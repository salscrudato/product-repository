# Code Review Export

Generated: 2025-12-28T17:27:47.749Z

Total Files: 177

---

## Table of Contents

- [functions/index.js](#functions-index-js)
- [functions/src/api/ai.js](#functions-src-api-ai-js)
- [functions/src/api/autoDraftCoverageFields.js](#functions-src-api-autodraftcoveragefields-js)
- [functions/src/api/coverageAssistant.js](#functions-src-api-coverageassistant-js)
- [functions/src/api/dataIntegrity.js](#functions-src-api-dataintegrity-js)
- [functions/src/api/pricing.js](#functions-src-api-pricing-js)
- [functions/src/api/productCreationAgent.js](#functions-src-api-productcreationagent-js)
- [functions/src/middleware/auth.js](#functions-src-middleware-auth-js)
- [functions/src/middleware/errorHandler.js](#functions-src-middleware-errorhandler-js)
- [functions/src/middleware/rateLimit.js](#functions-src-middleware-ratelimit-js)
- [functions/src/middleware/validation.js](#functions-src-middleware-validation-js)
- [functions/src/migrations/schemaV3.js](#functions-src-migrations-schemav3-js)
- [functions/src/services/dataIntegrity.js](#functions-src-services-dataintegrity-js)
- [functions/src/services/openai.js](#functions-src-services-openai-js)
- [functions/src/services/pdf.js](#functions-src-services-pdf-js)
- [functions/src/triggers/productIntegrity.js](#functions-src-triggers-productintegrity-js)
- [functions/src/utils/logger.js](#functions-src-utils-logger-js)
- [src/App.tsx](#src-app-tsx)
- [src/components/AIBuilder.tsx](#src-components-aibuilder-tsx)
- [src/components/Builder.tsx](#src-components-builder-tsx)
- [src/components/ClaimsAnalysis.tsx](#src-components-claimsanalysis-tsx)
- [src/components/CoverageScreen.tsx](#src-components-coveragescreen-tsx)
- [src/components/CoverageStatesScreen.tsx](#src-components-coveragestatesscreen-tsx)
- [src/components/DataDictionary.tsx](#src-components-datadictionary-tsx)
- [src/components/DataDictionaryModal.tsx](#src-components-datadictionarymodal-tsx)
- [src/components/ErrorBoundary.tsx](#src-components-errorboundary-tsx)
- [src/components/FormsScreen.tsx](#src-components-formsscreen-tsx)
- [src/components/Home.tsx](#src-components-home-tsx)
- [src/components/Login.tsx](#src-components-login-tsx)
- [src/components/PackagesScreen.tsx](#src-components-packagesscreen-tsx)
- [src/components/PricingScreen.tsx](#src-components-pricingscreen-tsx)
- [src/components/ProductBuilder.tsx](#src-components-productbuilder-tsx)
- [src/components/ProductExplorer.tsx](#src-components-productexplorer-tsx)
- [src/components/ProductHub.tsx](#src-components-producthub-tsx)
- [src/components/RequireAuth.tsx](#src-components-requireauth-tsx)
- [src/components/RulesScreen.tsx](#src-components-rulesscreen-tsx)
- [src/components/StatesScreen.tsx](#src-components-statesscreen-tsx)
- [src/components/TableScreen.tsx](#src-components-tablescreen-tsx)
- [src/components/TaskManagement.tsx](#src-components-taskmanagement-tsx)
- [src/components/common/Badge.tsx](#src-components-common-badge-tsx)
- [src/components/common/CommandPalette.tsx](#src-components-common-commandpalette-tsx)
- [src/components/common/CoverageSnapshot.tsx](#src-components-common-coveragesnapshot-tsx)
- [src/components/common/DesignSystem.tsx](#src-components-common-designsystem-tsx)
- [src/components/common/ProgressBar.tsx](#src-components-common-progressbar-tsx)
- [src/components/common/Skeleton.tsx](#src-components-common-skeleton-tsx)
- [src/components/common/StatusAnnouncer.tsx](#src-components-common-statusannouncer-tsx)
- [src/components/common/Toast.tsx](#src-components-common-toast-tsx)
- [src/components/common/Typography.tsx](#src-components-common-typography-tsx)
- [src/components/common/index.ts](#src-components-common-index-ts)
- [src/components/inputs/CoinsuranceInput.tsx](#src-components-inputs-coinsuranceinput-tsx)
- [src/components/inputs/WaitingPeriodInput.tsx](#src-components-inputs-waitingperiodinput-tsx)
- [src/components/inputs/index.ts](#src-components-inputs-index-ts)
- [src/components/modals/DeductiblesModal.tsx](#src-components-modals-deductiblesmodal-tsx)
- [src/components/modals/LimitsModal.tsx](#src-components-modals-limitsmodal-tsx)
- [src/components/modals/index.ts](#src-components-modals-index-ts)
- [src/components/packages/PackageBuilder.tsx](#src-components-packages-packagebuilder-tsx)
- [src/components/packages/PackageCard.tsx](#src-components-packages-packagecard-tsx)
- [src/components/packages/index.ts](#src-components-packages-index-ts)
- [src/components/pricing/PremiumCalculator.tsx](#src-components-pricing-premiumcalculator-tsx)
- [src/components/pricing/RatingAlgorithmBuilder.tsx](#src-components-pricing-ratingalgorithmbuilder-tsx)
- [src/components/pricing/index.ts](#src-components-pricing-index-ts)
- [src/components/sections/ClaimsSection.tsx](#src-components-sections-claimssection-tsx)
- [src/components/sections/EndorsementMetadataSection.tsx](#src-components-sections-endorsementmetadatasection-tsx)
- [src/components/sections/UnderwritingSection.tsx](#src-components-sections-underwritingsection-tsx)
- [src/components/sections/index.ts](#src-components-sections-index-ts)
- [src/components/selectors/CoverageTriggerSelector.tsx](#src-components-selectors-coveragetriggerselector-tsx)
- [src/components/selectors/DeductibleTypeSelector.tsx](#src-components-selectors-deductibletypeselector-tsx)
- [src/components/selectors/DepreciationMethodSelector.tsx](#src-components-selectors-depreciationmethodselector-tsx)
- [src/components/selectors/LimitTypeSelector.tsx](#src-components-selectors-limittypeselector-tsx)
- [src/components/selectors/TerritorySelector.tsx](#src-components-selectors-territoryselector-tsx)
- [src/components/selectors/ValuationMethodSelector.tsx](#src-components-selectors-valuationmethodselector-tsx)
- [src/components/selectors/index.ts](#src-components-selectors-index-ts)
- [src/components/ui/Breadcrumb.tsx](#src-components-ui-breadcrumb-tsx)
- [src/components/ui/Button.tsx](#src-components-ui-button-tsx)
- [src/components/ui/Card.tsx](#src-components-ui-card-tsx)
- [src/components/ui/ConfirmationModal.tsx](#src-components-ui-confirmationmodal-tsx)
- [src/components/ui/ConnectionStatus.tsx](#src-components-ui-connectionstatus-tsx)
- [src/components/ui/EmptyState.tsx](#src-components-ui-emptystate-tsx)
- [src/components/ui/EnhancedChatMessage.tsx](#src-components-ui-enhancedchatmessage-tsx)
- [src/components/ui/EnhancedHeader.tsx](#src-components-ui-enhancedheader-tsx)
- [src/components/ui/EnhancedSummary.tsx](#src-components-ui-enhancedsummary-tsx)
- [src/components/ui/Icon.tsx](#src-components-ui-icon-tsx)
- [src/components/ui/Input.tsx](#src-components-ui-input-tsx)
- [src/components/ui/Layout.tsx](#src-components-ui-layout-tsx)
- [src/components/ui/LoadingSpinner.tsx](#src-components-ui-loadingspinner-tsx)
- [src/components/ui/Navigation.tsx](#src-components-ui-navigation-tsx)
- [src/components/ui/NotificationBadge.tsx](#src-components-ui-notificationbadge-tsx)
- [src/components/ui/PageContainer.tsx](#src-components-ui-pagecontainer-tsx)
- [src/components/ui/ProductCard.tsx](#src-components-ui-productcard-tsx)
- [src/components/ui/ProductContextBar.tsx](#src-components-ui-productcontextbar-tsx)
- [src/components/ui/ProductQuickActionsBar.tsx](#src-components-ui-productquickactionsbar-tsx)
- [src/components/ui/QuickActionMenu.tsx](#src-components-ui-quickactionmenu-tsx)
- [src/components/ui/RouteProgress.tsx](#src-components-ui-routeprogress-tsx)
- [src/components/ui/Select.tsx](#src-components-ui-select-tsx)
- [src/components/ui/StatusBadge.tsx](#src-components-ui-statusbadge-tsx)
- [src/components/ui/Table.tsx](#src-components-ui-table-tsx)
- [src/components/ui/Tooltip.tsx](#src-components-ui-tooltip-tsx)
- [src/components/ui/UnifiedAIResponse.tsx](#src-components-ui-unifiedairesponse-tsx)
- [src/components/ui/VirtualizedGrid.tsx](#src-components-ui-virtualizedgrid-tsx)
- [src/components/ui/index.ts](#src-components-ui-index-ts)
- [src/components/wizard/AIAssistedField.tsx](#src-components-wizard-aiassistedfield-tsx)
- [src/components/wizard/AIFieldIndicator.tsx](#src-components-wizard-aifieldindicator-tsx)
- [src/components/wizard/AIInsightsCard.tsx](#src-components-wizard-aiinsightscard-tsx)
- [src/components/wizard/AIReviewSummary.tsx](#src-components-wizard-aireviewsummary-tsx)
- [src/components/wizard/AISuggestionsSidebar.tsx](#src-components-wizard-aisuggestionssidebar-tsx)
- [src/components/wizard/CompletionCelebration.tsx](#src-components-wizard-completioncelebration-tsx)
- [src/components/wizard/CoverageCopilotWizard.tsx](#src-components-wizard-coveragecopilotwizard-tsx)
- [src/components/wizard/FormsStep.tsx](#src-components-wizard-formsstep-tsx)
- [src/components/wizard/PremiumAnimations.tsx](#src-components-wizard-premiumanimations-tsx)
- [src/components/wizard/SmartCoverageNameInput.tsx](#src-components-wizard-smartcoveragenameinput-tsx)
- [src/components/wizard/WizardFooter.tsx](#src-components-wizard-wizardfooter-tsx)
- [src/components/wizard/WizardProgress.tsx](#src-components-wizard-wizardprogress-tsx)
- [src/components/wizard/index.ts](#src-components-wizard-index-ts)
- [src/config/aiConfig.ts](#src-config-aiconfig-ts)
- [src/config/constants.ts](#src-config-constants-ts)
- [src/config/env.ts](#src-config-env-ts)
- [src/config/pricingEnums.ts](#src-config-pricingenums-ts)
- [src/config/rulesEnums.ts](#src-config-rulesenums-ts)
- [src/context/ProductContext.tsx](#src-context-productcontext-tsx)
- [src/data/coverageDatabase.ts](#src-data-coveragedatabase-ts)
- [src/firebase.ts](#src-firebase-ts)
- [src/hooks/index.ts](#src-hooks-index-ts)
- [src/hooks/useAdvancedMemo.ts](#src-hooks-useadvancedmemo-ts)
- [src/hooks/useAutoDraftCoverage.ts](#src-hooks-useautodraftcoverage-ts)
- [src/hooks/useCoverageData.ts](#src-hooks-usecoveragedata-ts)
- [src/hooks/useCoverageDraft.ts](#src-hooks-usecoveragedraft-ts)
- [src/hooks/useCoverageFormCounts.ts](#src-hooks-usecoverageformcounts-ts)
- [src/hooks/useCoveragePackages.ts](#src-hooks-usecoveragepackages-ts)
- [src/hooks/useCoverages.ts](#src-hooks-usecoverages-ts)
- [src/hooks/useFirebaseConnection.ts](#src-hooks-usefirebaseconnection-ts)
- [src/hooks/useForms.ts](#src-hooks-useforms-ts)
- [src/hooks/useProduct.ts](#src-hooks-useproduct-ts)
- [src/hooks/useProducts.ts](#src-hooks-useproducts-ts)
- [src/index.tsx](#src-index-tsx)
- [src/pages/FormsMapper.tsx](#src-pages-formsmapper-tsx)
- [src/pages/PricingBuilder.tsx](#src-pages-pricingbuilder-tsx)
- [src/pages/Product360.tsx](#src-pages-product360-tsx)
- [src/pages/QuoteSandbox.tsx](#src-pages-quotesandbox-tsx)
- [src/services/advancedRAGService.ts](#src-services-advancedragservice-ts)
- [src/services/aiPromptOptimizer.ts](#src-services-aipromptoptimizer-ts)
- [src/services/auditService.ts](#src-services-auditservice-ts)
- [src/services/cacheService.ts](#src-services-cacheservice-ts)
- [src/services/claimsAnalysisService.ts](#src-services-claimsanalysisservice-ts)
- [src/services/coverageSearch.ts](#src-services-coveragesearch-ts)
- [src/services/dataDictionaryService.ts](#src-services-datadictionaryservice-ts)
- [src/services/firebaseConnectionMonitor.ts](#src-services-firebaseconnectionmonitor-ts)
- [src/services/firebaseOptimized.ts](#src-services-firebaseoptimized-ts)
- [src/services/index.ts](#src-services-index-ts)
- [src/services/product360ReadModel.ts](#src-services-product360readmodel-ts)
- [src/services/responseFormatter.ts](#src-services-responseformatter-ts)
- [src/services/validationService.ts](#src-services-validationservice-ts)
- [src/styled.d.ts](#src-styled-d-ts)
- [src/styles/GlobalStyle.ts](#src-styles-globalstyle-ts)
- [src/styles/animations.ts](#src-styles-animations-ts)
- [src/styles/copilotAnimations.ts](#src-styles-copilotanimations-ts)
- [src/styles/theme.ts](#src-styles-theme-ts)
- [src/types/index.ts](#src-types-index-ts)
- [src/types/pricing.ts](#src-types-pricing-ts)
- [src/utils/aiTimeout.ts](#src-utils-aitimeout-ts)
- [src/utils/bundleOptimization.tsx](#src-utils-bundleoptimization-tsx)
- [src/utils/core/index.ts](#src-utils-core-index-ts)
- [src/utils/data/index.ts](#src-utils-data-index-ts)
- [src/utils/firestoreHelpers.ts](#src-utils-firestorehelpers-ts)
- [src/utils/format.ts](#src-utils-format-ts)
- [src/utils/index.ts](#src-utils-index-ts)
- [src/utils/logger.ts](#src-utils-logger-ts)
- [src/utils/markdownParser.tsx](#src-utils-markdownparser-tsx)
- [src/utils/markdownSanitizer.ts](#src-utils-markdownsanitizer-ts)
- [src/utils/parallelProcessor.ts](#src-utils-parallelprocessor-ts)
- [src/utils/pdfChunking.ts](#src-utils-pdfchunking-ts)
- [src/utils/performance.ts](#src-utils-performance-ts)
- [src/utils/performanceMonitor.ts](#src-utils-performancemonitor-ts)
- [src/utils/productClone.ts](#src-utils-productclone-ts)
- [src/utils/stateGuards.ts](#src-utils-stateguards-ts)
- [src/utils/storage.ts](#src-utils-storage-ts)
- [src/utils/ui/index.ts](#src-utils-ui-index-ts)
- [src/vite-env.d.ts](#src-vite-env-d-ts)

---

## functions/index.js

**Path:** `functions/index.js`

```javascript
/**
 * Firebase Cloud Functions - Main Entry Point
 * OPTIMIZED: Cost-effective, fast AI operations
 */

const functions = require('firebase-functions');
const { onCall } = require('firebase-functions/v2/https');
const { defineSecret } = require('firebase-functions/params');
const admin = require('firebase-admin');
const axios = require('axios');
const crypto = require('crypto');

// Define the secret
const openaiKey = defineSecret('OPENAI_KEY');

// Initialize Firebase Admin
admin.initializeApp();
const db = admin.firestore();

// ============================================================================
// COST-EFFECTIVE CONFIG - 100% COMPLETENESS GUARANTEED
// ============================================================================

const AI_CONFIG = {
  // Model pricing (per 1K tokens) - All using gpt-4o-mini for cost savings
  models: {
    fast: { name: 'gpt-4o-mini', inputCost: 0.00015, outputCost: 0.0006 },
    quality: { name: 'gpt-4o-mini', inputCost: 0.00015, outputCost: 0.0006 }
  },

  // Task-specific settings - FULL COMPLETENESS with generous limits
  tasks: {
    summary: { model: 'gpt-4o-mini', maxTokens: 4000, timeout: 90000 },  // 90s, 4K tokens
    chat: { model: 'gpt-4o-mini', maxTokens: 2000, timeout: 60000 },     // 60s, 2K tokens
    claims: { model: 'gpt-4o-mini', maxTokens: 3000, timeout: 90000 }    // 90s, 3K tokens
  },

  // Input limits - NO truncation for summaries, generous for others
  maxInputChars: {
    summary: 200000,  // ~50K tokens - full document support
    chat: 50000,      // ~12.5K tokens - generous context
    claims: 100000    // ~25K tokens - full claim details
  }
};

// In-memory cache for responses (persists across warm function invocations)
const responseCache = new Map();
const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

/**
 * Generate cache key
 */
const getCacheKey = (type, content, prompt) => {
  const hash = crypto.createHash('md5')
    .update(type + content.substring(0, 1000) + (prompt || ''))
    .digest('hex');
  return hash;
};

/**
 * Get cached response
 */
const getFromCache = (key) => {
  const cached = responseCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  responseCache.delete(key);
  return null;
};

/**
 * Store in cache
 */
const setCache = (key, data) => {
  // Limit cache size
  if (responseCache.size > 50) {
    const firstKey = responseCache.keys().next().value;
    responseCache.delete(firstKey);
  }
  responseCache.set(key, { data, timestamp: Date.now() });
};

/**
 * Smart text truncation - preserves completeness, only truncates if absolutely necessary
 */
const smartTruncate = (text, maxChars) => {
  // Return full text if within limits (should almost always be the case now)
  if (!text || text.length <= maxChars) return text;

  // For very large documents, try to preserve structure
  const truncated = text.substring(0, maxChars);
  const lastSection = truncated.lastIndexOf('\n\n');
  if (lastSection > maxChars * 0.9) {
    return truncated.substring(0, lastSection);
  }
  return truncated;
};

/**
 * Compress system prompt - remove unnecessary words
 */
const compressPrompt = (prompt) => {
  if (!prompt) return prompt;
  return prompt
    .replace(/\s+/g, ' ')
    .replace(/please /gi, '')
    .replace(/could you /gi, '')
    .replace(/I would like you to /gi, '')
    .trim();
};

// Import modular API functions
const aiAPI = require('./src/api/ai');
const productCreationAgentAPI = require('./src/api/productCreationAgent');






// ============================================================================
// OpenAI Proxy Functions - Cost-Effective with 100% Completeness
// ============================================================================

/**
 * Generate product summary from PDF text
 * COMPLETE: Full document processing, generous token limits, cost-effective model
 */
exports.generateProductSummary = onCall({ secrets: [openaiKey] }, async (request) => {
  const startTime = Date.now();

  try {
    const { pdfText, systemPrompt } = request.data;
    const config = AI_CONFIG.tasks.summary;

    // Validation
    if (!pdfText || typeof pdfText !== 'string' || !pdfText.trim()) {
      throw new functions.https.HttpsError('invalid-argument', 'PDF text is required');
    }

    // Check cache first
    const cacheKey = getCacheKey('summary', pdfText, systemPrompt);
    const cached = getFromCache(cacheKey);
    if (cached) {
      console.log(`âœ… Cache hit - ${Date.now() - startTime}ms`);
      return { ...cached, fromCache: true };
    }

    const apiKey = openaiKey.value()?.trim();
    if (!apiKey) {
      throw new functions.https.HttpsError('internal', 'OpenAI API key not configured');
    }

    // Process full document - only truncate if extremely large
    const processedText = smartTruncate(pdfText, AI_CONFIG.maxInputChars.summary);
    // Use provided prompt or comprehensive default
    const effectivePrompt = systemPrompt || 'You are an expert insurance analyst. Analyze the provided insurance product document and create a comprehensive, complete summary including ALL coverages, exclusions, conditions, and limits. Do not omit any coverage details.';

    console.log(`ðŸ“Š Processing: ${pdfText.length} chars, timeout: ${config.timeout}ms`);

    const response = await axios.post('https://api.openai.com/v1/chat/completions', {
      model: config.model,
      messages: [
        { role: 'system', content: effectivePrompt },
        { role: 'user', content: processedText }
      ],
      max_tokens: config.maxTokens,
      temperature: 0.2
    }, {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      timeout: config.timeout
    });

    const result = {
      success: true,
      content: response.data.choices[0].message.content,
      usage: response.data.usage,
      model: config.model,
      latencyMs: Date.now() - startTime
    };

    // Cache the response
    setCache(cacheKey, result);

    console.log(`âœ… Summary complete - ${result.latencyMs}ms, ${response.data.usage?.total_tokens} tokens`);
    return result;

  } catch (error) {
    console.error('Product summary error:', error.response?.data || error.message);
    throw new functions.https.HttpsError('internal', error.response?.data?.error?.message || error.message);
  }
});

/**
 * Generate chat response
 * COMPLETE: Full context support, generous token limits, cost-effective model
 */
exports.generateChatResponse = onCall({ secrets: [openaiKey] }, async (request) => {
  const startTime = Date.now();

  try {
    const { messages, maxTokens, temperature = 0.7 } = request.data;
    const config = AI_CONFIG.tasks.chat;

    if (!messages || !Array.isArray(messages)) {
      throw new functions.https.HttpsError('invalid-argument', 'Messages array is required');
    }

    // Use gpt-4o-mini for cost savings, but allow full token output
    const effectiveMaxTokens = maxTokens || config.maxTokens;

    // Check cache for identical conversations
    const conversationKey = getCacheKey('chat', JSON.stringify(messages), '');
    const cached = getFromCache(conversationKey);
    if (cached) {
      console.log(`âœ… Chat cache hit - ${Date.now() - startTime}ms`);
      return { ...cached, fromCache: true };
    }

    const apiKey = openaiKey.value()?.trim();
    if (!apiKey) {
      throw new functions.https.HttpsError('internal', 'OpenAI API key not configured');
    }

    // Process messages - allow generous context
    const processedMessages = messages.map(msg => ({
      ...msg,
      content: typeof msg.content === 'string'
        ? smartTruncate(msg.content, AI_CONFIG.maxInputChars.chat)
        : msg.content
    }));

    const response = await axios.post('https://api.openai.com/v1/chat/completions', {
      model: config.model,
      messages: processedMessages,
      max_tokens: effectiveMaxTokens,
      temperature
    }, {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      timeout: config.timeout
    });

    const result = {
      success: true,
      content: response.data.choices[0].message.content,
      usage: response.data.usage,
      model: config.model,
      latencyMs: Date.now() - startTime
    };

    // Cache for repeated questions
    setCache(conversationKey, result);

    console.log(`âœ… Chat response - ${result.latencyMs}ms, ${response.data.usage?.total_tokens} tokens`);
    return result;

  } catch (error) {
    console.error('Chat response error:', error.response?.data || error.message);
    throw new functions.https.HttpsError('internal', error.response?.data?.error?.message || error.message);
  }
});

/**
 * Claims analysis
 * COMPLETE: Full claim context, comprehensive analysis, cost-effective model
 */
exports.analyzeClaim = onCall({ secrets: [openaiKey] }, async (request) => {
  const startTime = Date.now();

  try {
    const { messages, temperature = 0.2 } = request.data;
    const config = AI_CONFIG.tasks.claims;

    if (!messages || !Array.isArray(messages)) {
      throw new functions.https.HttpsError('invalid-argument', 'Messages array is required');
    }

    // Check cache
    const cacheKey = getCacheKey('claims', JSON.stringify(messages), '');
    const cached = getFromCache(cacheKey);
    if (cached) {
      console.log(`âœ… Claims cache hit - ${Date.now() - startTime}ms`);
      return { ...cached, fromCache: true };
    }

    const apiKey = openaiKey.value()?.trim();
    if (!apiKey) {
      throw new functions.https.HttpsError('internal', 'OpenAI API key not configured');
    }

    // Process messages with generous limits
    const processedMessages = messages.map(msg => ({
      ...msg,
      content: typeof msg.content === 'string'
        ? smartTruncate(msg.content, AI_CONFIG.maxInputChars.claims)
        : msg.content
    }));

    const response = await axios.post('https://api.openai.com/v1/chat/completions', {
      model: config.model,
      messages: processedMessages,
      max_tokens: config.maxTokens,
      temperature
    }, {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      timeout: config.timeout
    });

    const result = {
      success: true,
      content: response.data.choices[0].message.content,
      usage: response.data.usage,
      model: config.model,
      latencyMs: Date.now() - startTime
    };

    // Cache the result
    setCache(cacheKey, result);

    console.log(`âœ… Claims analysis - ${result.latencyMs}ms, ${response.data.usage?.total_tokens} tokens`);
    return result;

  } catch (error) {
    console.error('Claims analysis error:', error.response?.data || error.message);
    throw new functions.https.HttpsError('internal', error.response?.data?.error?.message || error.message);
  }
});

// ============================================================================
// MODERNIZED API EXPORTS
// ============================================================================

// AI-powered features (using new modular architecture)
exports.generateProductSummaryV2 = aiAPI.generateProductSummary;
exports.generateChatResponseV2 = aiAPI.generateChatResponse;
exports.analyzeClaimV2 = aiAPI.analyzeClaim;

// Pricing Engine
const pricingAPI = require('./src/api/pricing');
exports.rateCoverage = pricingAPI.rateCoverage;
exports.ratePackage = pricingAPI.ratePackage;

// Data Integrity (extended)
const dataIntegrityAPI = require('./src/api/dataIntegrity');
exports.migrateToSchemaV3 = dataIntegrityAPI.migrateToSchemaV3;
exports.recalculateProductStats = dataIntegrityAPI.recalculateProductStats;
exports.recalculateCoverageStats = dataIntegrityAPI.recalculateCoverageStats;

// Product Integrity Triggers
const productIntegrityTriggers = require('./src/triggers/productIntegrity');
exports.onCoverageChange = productIntegrityTriggers.onCoverageChange;
exports.onCoverageDelete = productIntegrityTriggers.onCoverageDelete;
exports.onLimitChange = productIntegrityTriggers.onLimitChange;
exports.onLimitDelete = productIntegrityTriggers.onLimitDelete;
exports.onDeductibleChange = productIntegrityTriggers.onDeductibleChange;
exports.onDeductibleDelete = productIntegrityTriggers.onDeductibleDelete;
exports.onFormCoverageChange = productIntegrityTriggers.onFormCoverageChange;
exports.onFormCoverageDelete = productIntegrityTriggers.onFormCoverageDelete;

// Product Creation Agent
exports.createProductFromPDF = productCreationAgentAPI.createProductFromPDF;

// Coverage Assistant (AI Copilot)
const coverageAssistantAPI = require('./src/api/coverageAssistant');
exports.coverageAssistant = coverageAssistantAPI.coverageAssistant;

// Auto-Draft Coverage Fields (lightweight AI for wizard steps)
const autoDraftAPI = require('./src/api/autoDraftCoverageFields');
exports.autoDraftCoverageFields = autoDraftAPI.autoDraftCoverageFields;

// Coverage Name Suggestions (AI-powered autocomplete)
exports.suggestCoverageNames = aiAPI.suggestCoverageNames;
```

---

## functions/src/api/ai.js

**Path:** `functions/src/api/ai.js`

```javascript
/**
 * AI API Functions
 * Cloud Functions for AI-powered features
 */

const functions = require('firebase-functions');
const { onCall, HttpsError } = require('firebase-functions/v2/https');
const { requireAuth } = require('../middleware/auth');
const { validateAIRequest } = require('../middleware/validation');
const { withErrorHandling } = require('../middleware/errorHandler');
const { rateLimitAI } = require('../middleware/rateLimit');
const { logger } = require('../utils/logger');
const openaiService = require('../services/openai');
const pdfService = require('../services/pdf');

/**
 * Generate product summary from PDF
 * Accepts PDF URL, base64, or pre-extracted text
 */
const generateProductSummary = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    // Authentication and rate limiting
    requireAuth(context);
    rateLimitAI(context);

    const { pdfUrl, pdfBase64, pdfText, systemPrompt } = data;

    logger.info('Product summary generation requested', {
      userId: context.auth.uid,
      hasUrl: !!pdfUrl,
      hasBase64: !!pdfBase64,
      hasText: !!pdfText
    });

    let extractedText = pdfText;

    // Extract text from PDF if URL or base64 provided
    if (pdfUrl) {
      extractedText = await pdfService.extractTextFromUrl(pdfUrl);
    } else if (pdfBase64) {
      extractedText = await pdfService.extractTextFromBase64(pdfBase64);
    }

    if (!extractedText) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Must provide pdfUrl, pdfBase64, or pdfText'
      );
    }

    // Validate and truncate text
    validateAIRequest({ pdfText: extractedText, systemPrompt });
    const truncatedText = pdfService.truncateText(extractedText, 100000);

    // Generate summary using OpenAI
    const result = await openaiService.generateProductSummary(
      truncatedText,
      systemPrompt
    );

    logger.info('Product summary generated successfully', {
      userId: context.auth.uid,
      tokensUsed: result.usage?.total_tokens
    });

    return result;
  }, 'generateProductSummary')
);

/**
 * Generate chat response
 */
const generateChatResponse = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    // Authentication and rate limiting
    requireAuth(context);
    rateLimitAI(context);

    const { messages, systemPrompt, model, maxTokens, temperature } = data;

    // Validation
    validateAIRequest({ messages });

    logger.info('Chat response requested', {
      userId: context.auth.uid,
      messageCount: messages.length,
      model: model || 'default',
      maxTokens: maxTokens || 'default'
    });

    // Generate response using OpenAI with custom parameters
    const result = await openaiService.generateChatResponse(
      messages,
      systemPrompt,
      {
        model,
        maxTokens,
        temperature
      }
    );

    logger.info('Chat response generated successfully', {
      userId: context.auth.uid,
      tokensUsed: result.usage?.total_tokens,
      model: result.model
    });

    return result;
  }, 'generateChatResponse')
);

/**
 * Analyze insurance claim
 */
const analyzeClaim = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    // Authentication and rate limiting
    requireAuth(context);
    rateLimitAI(context);

    const { claimText, systemPrompt } = data;

    // Validation
    if (!claimText || typeof claimText !== 'string') {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'claimText is required and must be a string'
      );
    }

    logger.info('Claim analysis requested', {
      userId: context.auth.uid,
      textLength: claimText.length
    });

    // Analyze claim using OpenAI
    const result = await openaiService.analyzeClaim(
      claimText,
      systemPrompt
    );

    logger.info('Claim analysis completed successfully', {
      userId: context.auth.uid,
      tokensUsed: result.usage?.total_tokens
    });

    return result;
  }, 'analyzeClaim')
);

/**
 * Suggest coverage names based on partial input
 * Uses AI to dynamically generate relevant P&C insurance coverage suggestions
 *
 * Using v2 onCall for proper Firebase Auth integration
 */
const suggestCoverageNames = onCall(
  {
    // Enable CORS and require authentication
    cors: true,
    // Secrets for OpenAI
    secrets: ['OPENAI_API_KEY'],
  },
  async (request) => {
    // v2 uses request.auth instead of context.auth
    if (!request.auth) {
      throw new HttpsError(
        'unauthenticated',
        'User must be authenticated to perform this action'
      );
    }

    const { query, lineOfBusiness = 'property', existingNames = [] } = request.data;

    if (!query || query.length < 2) {
      return { suggestions: [] };
    }

    logger.info('Coverage name suggestion requested', {
      userId: request.auth.uid,
      query,
      lineOfBusiness
    });

    // Build a focused prompt for coverage name suggestions
    const systemPrompt = `You are an expert P&C insurance product specialist. Generate relevant insurance coverage name suggestions based on the user's partial input.

Line of Business: ${lineOfBusiness}
${existingNames.length > 0 ? `Existing coverages (avoid duplicates): ${existingNames.join(', ')}` : ''}

Rules:
1. Return only standard P&C insurance coverage names
2. Suggestions should complete or relate to the user's input
3. Be specific and professional (e.g., "Building & Structures Coverage" not just "Building")
4. Include common variations and related coverages
5. Return 5-8 suggestions, most relevant first
6. Format: Return ONLY a JSON array of strings, no explanations`;

    const messages = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: `Suggest coverage names matching: "${query}"` }
    ];

    try {
      const result = await openaiService.generateChatResponse(
        messages,
        'gpt-4o-mini', // Use fast, cheap model for suggestions
        100, // Low max tokens
        0.3 // Low temperature for consistent results
      );

      // Parse the response
      let suggestions = [];
      try {
        const content = result.content || result.choices?.[0]?.message?.content || '[]';
        // Clean up the response - sometimes GPT adds markdown
        const cleaned = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        suggestions = JSON.parse(cleaned);

        // Filter out any that match existing names
        suggestions = suggestions.filter(
          s => !existingNames.some(e => e.toLowerCase() === s.toLowerCase())
        );
      } catch (parseError) {
        logger.warn('Failed to parse AI suggestions', { error: parseError.message, content: result.content });
        suggestions = [];
      }

      logger.info('Coverage name suggestions generated', {
        userId: request.auth.uid,
        count: suggestions.length,
        tokensUsed: result.usage?.total_tokens
      });

      return { suggestions };
    } catch (error) {
      logger.error('Coverage suggestion failed', { error: error.message });
      throw new HttpsError('internal', 'Failed to generate suggestions');
    }
  }
);

module.exports = {
  generateProductSummary,
  generateChatResponse,
  analyzeClaim,
  suggestCoverageNames
};

```

---

## functions/src/api/autoDraftCoverageFields.js

**Path:** `functions/src/api/autoDraftCoverageFields.js`

```javascript
/**
 * autoDraftCoverageFields - Lightweight AI endpoint for auto-drafting coverage fields
 *
 * Uses GPT-4o-mini for fast, cost-efficient field generation with strict JSON response.
 * All outputs follow strict JSON schemas matching the Coverage TypeScript interface.
 */

const { onCall } = require('firebase-functions/v2/https');
const { defineSecret } = require('firebase-functions/params');
const functions = require('firebase-functions');
const { logger } = require('firebase-functions');
const openaiService = require('../services/openai');

const openaiKey = defineSecret('OPENAI_API_KEY');

// Step-specific field mappings matching Coverage interface
const STEP_FIELDS = {
  triggers: ['coverageTrigger', 'waitingPeriod', 'waitingPeriodUnit', 'allowRetroactiveDate', 'extendedReportingPeriod'],
  valuation: ['valuationMethod', 'coinsurance', 'coinsuranceMinimum', 'hasCoinsurancePenalty', 'depreciationMethod'],
  underwriting: ['eligibilityCriteria', 'prohibitedClasses', 'requiresUnderwriterApproval'],
  claims: ['claimsReportingPeriod', 'proofOfLossDeadline', 'hasSubrogationRights', 'hasSalvageRights'],
  forms: [] // Forms are linked, not generated
};

// JSON schemas for strict type validation
const JSON_SCHEMAS = {
  triggers: {
    type: 'object',
    properties: {
      coverageTrigger: { type: 'string', enum: ['occurrence', 'claimsMade', 'hybrid'] },
      waitingPeriod: { type: 'number', minimum: 0 },
      waitingPeriodUnit: { type: 'string', enum: ['days', 'months'] },
      allowRetroactiveDate: { type: 'boolean' },
      extendedReportingPeriod: { type: 'number', minimum: 0 }
    },
    required: ['coverageTrigger'],
    additionalProperties: false
  },
  valuation: {
    type: 'object',
    properties: {
      valuationMethod: { type: 'string', enum: ['ACV', 'RC', 'agreedValue', 'marketValue', 'functionalRC', 'statedAmount'] },
      coinsurance: { type: 'number', enum: [80, 90, 100] },
      coinsuranceMinimum: { type: 'number', minimum: 0, maximum: 100 },
      hasCoinsurancePenalty: { type: 'boolean' },
      depreciationMethod: { type: 'string', enum: ['straightLine', 'decliningBalance', 'ageOfItem'] }
    },
    required: ['valuationMethod'],
    additionalProperties: false
  },
  underwriting: {
    type: 'object',
    properties: {
      eligibilityCriteria: { type: 'array', items: { type: 'string' } },
      prohibitedClasses: { type: 'array', items: { type: 'string' } },
      requiresUnderwriterApproval: { type: 'boolean' }
    },
    required: [],
    additionalProperties: false
  },
  claims: {
    type: 'object',
    properties: {
      claimsReportingPeriod: { type: 'number', minimum: 0 },
      proofOfLossDeadline: { type: 'number', minimum: 0 },
      hasSubrogationRights: { type: 'boolean' },
      hasSalvageRights: { type: 'boolean' }
    },
    required: [],
    additionalProperties: false
  }
};

// Strict JSON schema prompt for each step
const getStepPrompt = (stepId, coverageName, coverageCode, currentDraft) => {
  const baseContext = `You are configuring a P&C insurance coverage named "${coverageName}" (Code: ${coverageCode || 'TBD'}).

Current draft state:
${JSON.stringify(currentDraft, null, 2)}

Based on the coverage name and type, generate appropriate values for the ${stepId} step.
Use industry-standard defaults appropriate for this specific coverage type.`;

  const prompts = {
    triggers: `${baseContext}

Generate trigger-related fields. Consider:
- "occurrence" trigger: Coverage applies when the loss OCCURS during the policy period (most property coverages)
- "claimsMade" trigger: Coverage applies when the claim is MADE during the policy period (professional liability, D&O)
- "hybrid" trigger: Both occurrence and claims-made elements
- Waiting periods: Common for specific perils (e.g., flood, equipment breakdown)
- Extended reporting periods: Important for claims-made policies

Return ONLY valid JSON matching this exact TypeScript interface:
{
  "coverageTrigger": "occurrence" | "claimsMade" | "hybrid",
  "waitingPeriod": number (0 if none, otherwise days like 14, 30, 60, 72 for weather perils),
  "waitingPeriodUnit": "days" | "months",
  "allowRetroactiveDate": boolean (true for claims-made policies),
  "extendedReportingPeriod": number (months, 0 if not applicable, 12-60 for claims-made)
}`,

    valuation: `${baseContext}

Generate valuation-related fields. Consider:
- ACV (Actual Cash Value): Replacement cost minus depreciation
- RC (Replacement Cost): Full replacement without depreciation deduction
- agreedValue: Pre-agreed value, common for fine art, collectibles
- marketValue: Current market value, used for certain property types
- functionalRC: Cost to replace with similar function, not identical
- statedAmount: Amount stated by insured (usually classic cars)

Coinsurance: 80% is standard, 90-100% for lower premiums
Depreciation: straightLine is most common

Return ONLY valid JSON matching this exact TypeScript interface:
{
  "valuationMethod": "ACV" | "RC" | "agreedValue" | "marketValue" | "functionalRC" | "statedAmount",
  "coinsurance": 80 | 90 | 100,
  "coinsuranceMinimum": number (typically 80),
  "hasCoinsurancePenalty": boolean (true if coinsurance penalty applies),
  "depreciationMethod": "straightLine" | "decliningBalance" | "ageOfItem"
}`,

    underwriting: `${baseContext}

Generate underwriting-related fields appropriate for this coverage type.
Consider:
- Eligibility criteria: Specific requirements to qualify
- Prohibited classes: Business types or risks that cannot be insured
- Underwriter approval: Required for complex or high-value risks

Return ONLY valid JSON matching this exact TypeScript interface:
{
  "eligibilityCriteria": ["criterion1", "criterion2", ...],
  "prohibitedClasses": ["class1", "class2", ...] or [],
  "requiresUnderwriterApproval": boolean
}`,

    claims: `${baseContext}

Generate claims-related fields. Consider:
- Claims reporting periods: 30-90 days typical
- Proof of loss deadlines: 60-90 days common
- Subrogation: Right to recover from responsible party
- Salvage: Right to damaged property

Return ONLY valid JSON matching this exact TypeScript interface:
{
  "claimsReportingPeriod": number (days, typically 30, 60, or 90),
  "proofOfLossDeadline": number (days, typically 60 or 90),
  "hasSubrogationRights": boolean (usually true for property),
  "hasSalvageRights": boolean (usually true for property)
}`
  };

  return prompts[stepId] || null;
};

/**
 * Validate fields against the step's JSON schema
 */
const validateAndSanitizeFields = (stepId, fields) => {
  const schema = JSON_SCHEMAS[stepId];
  if (!schema) return fields;

  const sanitized = {};
  const allowedFields = STEP_FIELDS[stepId] || [];

  // Only include fields that are in the allowed list for this step
  for (const key of allowedFields) {
    if (fields.hasOwnProperty(key)) {
      const value = fields[key];
      const propSchema = schema.properties[key];

      if (!propSchema) continue;

      // Type validation
      if (propSchema.type === 'string' && typeof value === 'string') {
        if (propSchema.enum && !propSchema.enum.includes(value)) continue;
        sanitized[key] = value;
      } else if (propSchema.type === 'number' && typeof value === 'number') {
        if (propSchema.enum && !propSchema.enum.includes(value)) continue;
        if (propSchema.minimum !== undefined && value < propSchema.minimum) continue;
        if (propSchema.maximum !== undefined && value > propSchema.maximum) continue;
        sanitized[key] = value;
      } else if (propSchema.type === 'boolean' && typeof value === 'boolean') {
        sanitized[key] = value;
      } else if (propSchema.type === 'array' && Array.isArray(value)) {
        sanitized[key] = value.filter(item => typeof item === 'string');
      }
    }
  }

  return sanitized;
};

/**
 * Auto-draft coverage fields for a specific wizard step
 */
const autoDraftCoverageFields = onCall(
  { secrets: [openaiKey], timeoutSeconds: 30, memory: '256MiB' },
  async (request) => {
    if (!request.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    const { productId, stepId, coverageName, coverageCode, currentDraft = {} } = request.data;

    if (!productId) {
      throw new functions.https.HttpsError('invalid-argument', 'productId is required');
    }
    if (!stepId) {
      throw new functions.https.HttpsError('invalid-argument', 'stepId is required');
    }
    if (!coverageName) {
      throw new functions.https.HttpsError('invalid-argument', 'coverageName is required');
    }

    // Skip if step doesn't have generatable fields
    if (!STEP_FIELDS[stepId] || STEP_FIELDS[stepId].length === 0) {
      return { fields: {}, confidence: 0, suggestions: [] };
    }

    logger.info('Auto-drafting coverage fields', {
      userId: request.auth.uid,
      productId,
      stepId,
      coverageName
    });

    try {
      openaiService.initializeWithKey(openaiKey.value());

      const systemPrompt = `You are a P&C insurance product configuration expert.
You generate accurate, industry-standard default values for coverage fields based on the coverage name and type.

CRITICAL REQUIREMENTS:
1. Return ONLY valid JSON - no explanations, no markdown, no extra text
2. Use values that match the exact TypeScript types specified
3. Be consistent with P&C insurance industry standards
4. Consider the specific coverage type when choosing defaults

For liability coverages (e.g., General Liability, Professional Liability, D&O):
- Use "claimsMade" or "hybrid" triggers
- Include extended reporting periods (12-60 months)
- Allow retroactive dates

For property coverages (e.g., Building, Contents, Equipment):
- Use "occurrence" trigger
- Waiting periods only for specific perils (flood, earthquake)
- No extended reporting period needed`;

      const userPrompt = getStepPrompt(stepId, coverageName, coverageCode, currentDraft);

      if (!userPrompt) {
        return { fields: {}, confidence: 0, suggestions: [] };
      }

      const response = await openaiService.chatCompletion({
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        model: 'gpt-4o-mini',
        maxTokens: 500,
        temperature: 0.2  // Lower temperature for more consistent outputs
      });

      // Parse JSON response
      let rawFields = {};
      try {
        const content = response.content.trim();
        // Remove any markdown code blocks if present
        const jsonStr = content.replace(/```json?\n?/g, '').replace(/```/g, '').trim();
        rawFields = JSON.parse(jsonStr);
      } catch (parseErr) {
        logger.warn('Failed to parse AI response as JSON', {
          content: response.content,
          error: parseErr.message
        });
        return { fields: {}, confidence: 0, suggestions: ['AI response was not valid JSON'] };
      }

      // Validate and sanitize fields against schema
      const fields = validateAndSanitizeFields(stepId, rawFields);

      logger.info('Auto-draft completed', {
        stepId,
        rawFieldCount: Object.keys(rawFields).length,
        validatedFieldCount: Object.keys(fields).length,
        estimatedCost: response.estimatedCost
      });

      return {
        fields,
        confidence: Object.keys(fields).length > 0 ? 0.85 : 0,
        suggestions: []
      };

    } catch (err) {
      logger.error('Auto-draft error', { error: err.message, stepId, coverageName });
      throw new functions.https.HttpsError('internal', 'Failed to generate field suggestions');
    }
  }
);

module.exports = { autoDraftCoverageFields };

```

---

## functions/src/api/coverageAssistant.js

**Path:** `functions/src/api/coverageAssistant.js`

```javascript
/**
 * Coverage Assistant API
 * AI-powered coverage copilot for multi-turn coverage creation
 */

const functions = require('firebase-functions');
const { onCall } = require('firebase-functions/v2/https');
const { defineSecret } = require('firebase-functions/params');
const axios = require('axios');
const { logger } = require('../utils/logger');

// Define the secret
const openaiKey = defineSecret('OPENAI_KEY');

// Valid coverage fields for validation
const VALID_COVERAGE_FIELDS = [
  'name', 'coverageCode', 'description', 'type', 'isOptional', 'coverageKind',
  'scopeOfCoverage', 'perilsCovered', 'exclusions', 'insurableObjects', 'excludedObjects',
  'premiumBasis', 'ratePerUnit', 'minimumPremium', 'premium',
  'coinsurancePercentage', 'hasCoinsurancePenalty', 'insuredParticipation', 'coinsuranceWaiver',
  'coverageTrigger', 'waitingPeriod', 'waitingPeriodUnit', 'allowRetroactiveDate',
  'valuationMethod', 'depreciationMethod', 'agreedValueAmount',
  'territoryType', 'states', 'availabilityStates', 'excludedTerritories', 'includedTerritories',
  'modifiesCoverageId', 'endorsementType', 'supersedes',
  'requiresUnderwriterApproval', 'eligibilityCriteria', 'prohibitedClasses',
  'requiredCoverages', 'incompatibleCoverages', 'requiredCoverageIds', 'incompatibleCoverageIds',
  'claimsReportingPeriod', 'proofOfLossDeadline', 'hasSubrogationRights', 'hasSalvageRights',
  'coverageCategory', 'lineOfBusiness', 'parentCoverageId'
];

const REQUIRED_FOR_PUBLISH = ['name', 'coverageCode', 'productId'];

const COVERAGE_ASSISTANT_PROMPT = `You are an expert P&C insurance product manager assistant.

Responsibilities:
1. Extract structured coverage data from user messages
2. Ask only minimum necessary follow-up questions
3. Suggest sensible defaults based on industry standards
4. Return structured JSON responses

Coverage Types (coverageKind): coverage, endorsement, exclusion, notice, condition
Valuation methods: ACV, RC, agreedValue, marketValue
Triggers: occurrence, claimsMade, hybrid
Common coinsurance: 80%, 90%, 100%

Respond with JSON:
{
  "assistant_message": "Your response",
  "patch": { /* Fields to update */ },
  "questions": [{ "id": "q1", "text": "Question", "fieldHints": ["field"] }],
  "missing_required_for_publish": ["field1"],
  "warnings": []
}`;

function calculateSimilarity(text1, text2) {
  if (!text1 || !text2) return 0;
  const normalize = (s) => s.toLowerCase().replace(/[^a-z0-9]/g, ' ').split(/\s+/).filter(Boolean);
  const words1 = new Set(normalize(text1));
  const words2 = new Set(normalize(text2));
  const intersection = new Set([...words1].filter(x => words2.has(x)));
  const union = new Set([...words1, ...words2]);
  return intersection.size / union.size;
}

async function findSimilarCoverages(draft, existingCoverages = []) {
  const matches = [];
  const draftText = `${draft.name || ''} ${draft.description || ''} ${draft.coverageCode || ''}`;
  for (const coverage of existingCoverages) {
    if (coverage.id === draft.id) continue;
    const covText = `${coverage.name || ''} ${coverage.description || ''} ${coverage.coverageCode || ''}`;
    const similarity = calculateSimilarity(draftText, covText);
    if (similarity > 0.3) {
      matches.push({
        coverageId: coverage.id,
        name: coverage.name,
        coverageCode: coverage.coverageCode,
        similarity: Math.round(similarity * 100),
        why: 'Similar content'
      });
    }
  }
  return matches.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
}

function sanitizePatch(patch) {
  if (!patch || typeof patch !== 'object') return {};
  const sanitized = {};
  for (const [key, value] of Object.entries(patch)) {
    if (!VALID_COVERAGE_FIELDS.includes(key)) continue;
    if (value === null || value === undefined) continue;
    if (key === 'coinsurancePercentage' && typeof value === 'string') {
      sanitized[key] = parseInt(value, 10);
    } else if (['hasSubrogationRights', 'hasCoinsurancePenalty', 'isOptional'].includes(key)) {
      sanitized[key] = Boolean(value);
    } else {
      sanitized[key] = value;
    }
  }
  return sanitized;
}

function getMissingRequiredFields(draft) {
  return REQUIRED_FOR_PUBLISH.filter(field => {
    const value = draft[field];
    return !value || (typeof value === 'string' && value.trim().length === 0);
  });
}

/**
 * Coverage Assistant - Multi-turn AI copilot for coverage creation
 */
const coverageAssistant = onCall(
  { secrets: [openaiKey], timeoutSeconds: 60, memory: '512MiB' },
  async (request) => {
    if (!request.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    const { productId, userMessage, conversationHistory = [], currentDraft = {}, existingCoverages = [] } = request.data;

    if (!productId) {
      throw new functions.https.HttpsError('invalid-argument', 'productId is required');
    }
    if (!userMessage || typeof userMessage !== 'string') {
      throw new functions.https.HttpsError('invalid-argument', 'userMessage is required');
    }

    logger.info('Coverage assistant request', { userId: request.auth.uid, productId });

    try {
      const messages = [
        { role: 'system', content: COVERAGE_ASSISTANT_PROMPT },
        { role: 'system', content: `Current draft:\n${JSON.stringify(currentDraft, null, 2)}` }
      ];
      for (const msg of conversationHistory.slice(-10)) {
        messages.push({ role: msg.role === 'user' ? 'user' : 'assistant', content: msg.content });
      }
      messages.push({ role: 'user', content: userMessage });

      const response = await axios.post(
        'https://api.openai.com/v1/chat/completions',
        { model: 'gpt-4o-mini', messages, temperature: 0.3, max_tokens: 2000, response_format: { type: 'json_object' } },
        { headers: { 'Authorization': `Bearer ${openaiKey.value()}`, 'Content-Type': 'application/json' } }
      );

      const aiContent = response.data.choices[0]?.message?.content;
      if (!aiContent) throw new Error('No response from AI');

      let aiResponse;
      try {
        aiResponse = JSON.parse(aiContent);
      } catch {
        throw new functions.https.HttpsError('internal', 'AI returned invalid JSON');
      }

      const sanitizedPatch = sanitizePatch(aiResponse.patch);
      const mergedDraft = { ...currentDraft, ...sanitizedPatch };
      const nearMatches = await findSimilarCoverages(mergedDraft, existingCoverages);
      const missingRequired = getMissingRequiredFields(mergedDraft);

      const result = {
        assistant_message: aiResponse.assistant_message || 'I processed your request.',
        patch: sanitizedPatch,
        questions: Array.isArray(aiResponse.questions) ? aiResponse.questions : [],
        missing_required_for_publish: missingRequired,
        near_matches: nearMatches,
        warnings: aiResponse.warnings || []
      };

      if (nearMatches.length > 0 && nearMatches[0].similarity > 70) {
        result.warnings.push(`Similar coverage found: "${nearMatches[0].name}" (${nearMatches[0].similarity}% match)`);
      }

      logger.info('Coverage assistant response', { userId: request.auth.uid, patchFields: Object.keys(sanitizedPatch) });
      return result;

    } catch (error) {
      logger.error('Coverage assistant error', { error: error.message });
      if (error instanceof functions.https.HttpsError) throw error;
      throw new functions.https.HttpsError('internal', error.message || 'Failed to process request');
    }
  }
);

module.exports = { coverageAssistant };

```

---

## functions/src/api/dataIntegrity.js

**Path:** `functions/src/api/dataIntegrity.js`

```javascript
/**
 * Data Integrity API
 * Cloud Functions for data integrity, referential integrity, and cascade operations
 */

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const { requireAuth, requireAdmin } = require('../middleware/auth');
const { withErrorHandling } = require('../middleware/errorHandler');
const { logger } = require('../utils/logger');
const dataIntegrityService = require('../services/dataIntegrity');
const { migrateSchemaV3 } = require('../migrations/schemaV3');

const db = admin.firestore();

/**
 * Validate coverage referential integrity
 * Checks if all referenced entities exist
 */
const validateCoverageIntegrity = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    requireAdmin(context);

    const { productId, coverageId } = data;

    if (!productId || !coverageId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId and coverageId are required'
      );
    }

    logger.info('Validating coverage integrity', {
      userId: context.auth.uid,
      productId,
      coverageId
    });

    const result = await dataIntegrityService.validateCoverageIntegrity(
      productId,
      coverageId
    );

    return result;
  })
);

/**
 * Cascade delete coverage and all related entities
 * WARNING: This is a destructive operation
 */
const cascadeDeleteCoverage = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    requireAdmin(context);

    const { productId, coverageId } = data;

    if (!productId || !coverageId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId and coverageId are required'
      );
    }

    logger.warn('Cascade delete initiated', {
      userId: context.auth.uid,
      productId,
      coverageId
    });

    const result = await dataIntegrityService.cascadeDeleteCoverage(
      productId,
      coverageId
    );

    logger.info('Cascade delete completed', {
      userId: context.auth.uid,
      productId,
      coverageId,
      result
    });

    return result;
  })
);

/**
 * Detect orphaned records in a product
 * Finds entities with missing references
 */
const detectOrphanedRecords = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    requireAdmin(context);

    const { productId } = data;

    if (!productId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId is required'
      );
    }

    logger.info('Detecting orphaned records', {
      userId: context.auth.uid,
      productId
    });

    const orphans = await dataIntegrityService.detectOrphanedRecords(productId);

    return orphans;
  })
);

/**
 * Validate product data consistency
 * Checks for data inconsistencies and mismatches
 */
const validateProductConsistency = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    requireAdmin(context);

    const { productId } = data;

    if (!productId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId is required'
      );
    }

    logger.info('Validating product consistency', {
      userId: context.auth.uid,
      productId
    });

    const result = await dataIntegrityService.validateProductConsistency(productId);

    return result;
  })
);

/**
 * Run comprehensive data integrity check
 * Performs all validation and detection operations
 */
const runComprehensiveCheck = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    requireAdmin(context);

    const { productId } = data;

    if (!productId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId is required'
      );
    }

    logger.info('Running comprehensive data integrity check', {
      userId: context.auth.uid,
      productId
    });

    const results = {
      consistency: await dataIntegrityService.validateProductConsistency(productId),
      orphans: await dataIntegrityService.detectOrphanedRecords(productId),
      timestamp: new Date().toISOString()
    };

    return results;
  })
);

/**
 * Migrate schema to V3
 * Normalizes coverage fields and backfills denormalized counters
 */
const migrateToSchemaV3 = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    requireAdmin(context);

    logger.info('Starting schema V3 migration', {
      userId: context.auth.uid
    });

    const results = await migrateSchemaV3();
    return results;
  })
);

/**
 * Recalculate product statistics
 * Recomputes coverageCount, packageCount, formCount, ruleCount
 */
const recalculateProductStats = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    requireAdmin(context);

    const { productId } = data;
    if (!productId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId is required'
      );
    }

    logger.info('Recalculating product stats', {
      userId: context.auth.uid,
      productId
    });

    const productRef = db.collection('products').doc(productId);

    // Count coverages
    const coveragesSnap = await db.collection(`products/${productId}/coverages`).get();
    const coverageCount = coveragesSnap.size;

    // Count packages
    const packagesSnap = await db.collection(`products/${productId}/packages`).get();
    const packageCount = packagesSnap.size;

    // Count forms via formCoverages
    const formsSnap = await db
      .collectionGroup('formCoverages')
      .where('productId', '==', productId)
      .get();
    const formIds = new Set(formsSnap.docs.map(doc => doc.data().formId));
    const formCount = formIds.size;

    // Count rules
    const rulesSnap = await db
      .collection('rules')
      .where('productId', '==', productId)
      .get();
    const ruleCount = rulesSnap.size;

    await productRef.update({
      coverageCount,
      packageCount,
      formCount,
      ruleCount,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    return { coverageCount, packageCount, formCount, ruleCount };
  })
);

/**
 * Recalculate coverage statistics
 * Recomputes limitCount, deductibleCount, subCoverageCount, formMappingCount
 */
const recalculateCoverageStats = functions.https.onCall(
  withErrorHandling(async (data, context) => {
    requireAdmin(context);

    const { productId, coverageId } = data;
    if (!productId || !coverageId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId and coverageId are required'
      );
    }

    logger.info('Recalculating coverage stats', {
      userId: context.auth.uid,
      productId,
      coverageId
    });

    const coverageRef = db.collection(`products/${productId}/coverages`).doc(coverageId);

    // Count limits
    const limitsSnap = await db
      .collection(`products/${productId}/coverages/${coverageId}/limits`)
      .get();
    const limitCount = limitsSnap.size;

    // Count deductibles
    const deductiblesSnap = await db
      .collection(`products/${productId}/coverages/${coverageId}/deductibles`)
      .get();
    const deductibleCount = deductiblesSnap.size;

    // Count sub-coverages
    const subCoveragesSnap = await db
      .collection(`products/${productId}/coverages`)
      .where('parentCoverageId', '==', coverageId)
      .get();
    const subCoverageCount = subCoveragesSnap.size;

    // Count form mappings
    const formMappingsSnap = await db
      .collectionGroup('formCoverages')
      .where('productId', '==', productId)
      .where('coverageId', '==', coverageId)
      .get();
    const formMappingCount = formMappingsSnap.size;

    await coverageRef.update({
      limitCount,
      deductibleCount,
      subCoverageCount,
      formMappingCount,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    return { limitCount, deductibleCount, subCoverageCount, formMappingCount };
  })
);

module.exports = {
  validateCoverageIntegrity,
  cascadeDeleteCoverage,
  detectOrphanedRecords,
  validateProductConsistency,
  runComprehensiveCheck,
  migrateToSchemaV3,
  recalculateProductStats,
  recalculateCoverageStats
};

```

---

## functions/src/api/pricing.js

**Path:** `functions/src/api/pricing.js`

```javascript
/**
 * Pricing Engine API
 * Cloud Functions for deterministic, auditable pricing calculations
 */

const functions = require('firebase-functions');
const { onCall } = require('firebase-functions/v2/https');
const admin = require('firebase-admin');
const { requireAuth } = require('../middleware/auth');
const { withErrorHandling } = require('../middleware/errorHandler');
const { logger } = require('../utils/logger');

const db = admin.firestore();

/**
 * Rate a coverage based on inputs and pricing steps
 * Returns premium breakdown by step
 */
const rateCoverage = onCall(
  withErrorHandling(async (request) => {
    const { productId, coverageId, inputs } = request.data;

    if (!productId || !coverageId || !inputs) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId, coverageId, and inputs are required'
      );
    }

    logger.info('Rating coverage', {
      userId: request.auth?.uid || 'anonymous',
      productId,
      coverageId
    });

    try {
      // Fetch pricing steps for this coverage
      const stepsSnap = await db
        .collection(`products/${productId}/pricingSteps`)
        .where('scope', 'in', ['product', 'coverage'])
        .where('isActive', '==', true)
        .orderBy('order', 'asc')
        .get();

      const steps = stepsSnap.docs
        .map(doc => ({ id: doc.id, ...doc.data() }))
        .filter(step => step.scope === 'product' || step.targetId === coverageId);

      const stepBreakdown = {};
      let subtotal = 0;

      // Execute each step
      for (const step of steps) {
        let stepAmount = 0;

        // Execute rules in this step
        for (const ruleRef of step.rules || []) {
          const ruleDoc = await db.collection('rules').doc(ruleRef.ruleId).get();
          if (!ruleDoc.exists) continue;

          const rule = ruleDoc.data();
          if (!rule.isActive) continue;

          // Evaluate rule conditions
          if (evaluateConditions(rule.conditions || [], inputs)) {
            const ruleAmount = calculateRuleAmount(rule, inputs);
            stepAmount += ruleAmount;
          }
        }

        stepBreakdown[step.id] = stepAmount;
        subtotal += stepAmount;
      }

      return {
        stepBreakdown,
        subtotal,
        total: subtotal,
        metadata: {
          calculatedAt: new Date().toISOString(),
          productId,
          coverageId,
          stepsExecuted: steps.length
        }
      };
    } catch (error) {
      logger.error('Rating calculation failed', {
        productId,
        coverageId,
        error: error.message
      });
      throw error;
    }
  })
);

/**
 * Rate a package (bundle of coverages)
 */
const ratePackage = onCall(
  withErrorHandling(async (request) => {
    const { productId, packageId, inputs } = request.data;

    if (!productId || !packageId || !inputs) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'productId, packageId, and inputs are required'
      );
    }

    logger.info('Rating package', {
      userId: request.auth?.uid || 'anonymous',
      productId,
      packageId
    });

    try {
      // Fetch package
      const pkgDoc = await db
        .collection(`products/${productId}/packages`)
        .doc(packageId)
        .get();

      if (!pkgDoc.exists) {
        throw new functions.https.HttpsError('not-found', 'Package not found');
      }

      const pkg = pkgDoc.data();
      const coverageIds = pkg.coverageIds || [];

      // Rate each coverage
      const coveragePremiums = {};
      let total = 0;

      for (const covId of coverageIds) {
        // Call rateCoverage for each coverage
        const result = await rateCoverage({ data: { productId, coverageId: covId, inputs } });
        coveragePremiums[covId] = result.total;
        total += result.total;
      }

      // Apply package discount
      const discount = pkg.discountPercentage || 0;
      const discountAmount = total * (discount / 100);
      const finalTotal = total - discountAmount;

      return {
        coverages: coveragePremiums,
        subtotal: total,
        discount: discountAmount,
        discountPercentage: discount,
        total: finalTotal,
        metadata: {
          calculatedAt: new Date().toISOString(),
          productId,
          packageId,
          coverageCount: coverageIds.length
        }
      };
    } catch (error) {
      logger.error('Package rating failed', {
        productId,
        packageId,
        error: error.message
      });
      throw error;
    }
  })
);

/**
 * Evaluate pricing conditions against inputs
 */
function evaluateConditions(conditions, inputs) {
  if (!conditions || conditions.length === 0) return true;

  for (const condition of conditions) {
    if (!evaluateCondition(condition, inputs)) {
      return false;
    }
  }
  return true;
}

/**
 * Evaluate a single condition
 */
function evaluateCondition(condition, inputs) {
  const value = inputs[condition.field];
  if (value === undefined) return false;

  switch (condition.operator) {
    case 'equals':
      return value === condition.value;
    case 'greaterThan':
      return value > condition.value;
    case 'lessThan':
      return value < condition.value;
    case 'contains':
      return String(value).includes(String(condition.value));
    case 'between':
      return value >= condition.value[0] && value <= condition.value[1];
    default:
      return false;
  }
}

/**
 * Calculate amount for a rule
 */
function calculateRuleAmount(rule, inputs) {
  let amount = rule.value || 0;

  if (rule.valueType === 'percentage') {
    // For percentage, we'd need base amount from inputs
    // This is simplified; real implementation would be more complex
    amount = amount / 100;
  }

  return amount;
}

module.exports = {
  rateCoverage,
  ratePackage
};

```

---

## functions/src/api/productCreationAgent.js

**Path:** `functions/src/api/productCreationAgent.js`

```javascript
/**
 * Product Creation Agent API
 * Autonomous workflow for creating insurance products from PDF coverage forms
 */

const admin = require('firebase-admin');
const { onCall } = require('firebase-functions/v2/https');
const { defineSecret } = require('firebase-functions/params');
const axios = require('axios');
const pdfParse = require('pdf-parse');

const db = admin.firestore();
const openaiKey = defineSecret('OPENAI_KEY');

/**
 * Get the system prompt for autonomous product creation
 */
function getAutonomousProductCreationPrompt() {
  return `You are an expert insurance product architect. Your task is to analyze PDF coverage forms and create comprehensive insurance products.

When analyzing a PDF, extract:
1. Product name and code
2. All coverages with their details (limits, deductibles, scope)
3. Coverage relationships and hierarchies
4. Form associations
5. Pricing structure if available

Return a JSON object with this structure:
{
  "productName": "string",
  "productCode": "string",
  "productType": "string",
  "description": "string",
  "coverages": [
    {
      "name": "string",
      "code": "string",
      "type": "string",
      "scopeOfCoverage": "string",
      "limits": "string",
      "deductible": "string"
    }
  ],
  "forms": ["form names"],
  "metadata": {
    "effectiveDate": "string",
    "expirationDate": "string",
    "jurisdiction": "string"
  }
}`;
}

/**
 * Create finalized product in Firestore
 */
async function createFinalizedProduct(productData, userId) {
  try {
    const productsRef = db.collection('products');
    
    // Create product document
    const productDoc = await productsRef.add({
      name: productData.productName,
      code: productData.productCode,
      type: productData.productType,
      description: productData.description,
      createdAt: new Date(),
      createdBy: userId || 'anonymous',
      status: 'active',
      metadata: productData.metadata || {}
    });

    // Create coverages
    if (productData.coverages && Array.isArray(productData.coverages)) {
      const coveragesRef = productDoc.collection('coverages');
      for (const coverage of productData.coverages) {
        await coveragesRef.add({
          name: coverage.name,
          coverageName: coverage.name,
          code: coverage.code,
          coverageCode: coverage.code,
          type: coverage.type,
          coverageType: coverage.type,
          scopeOfCoverage: coverage.scopeOfCoverage,
          limits: coverage.limits,
          deductible: coverage.deductible,
          createdAt: new Date()
        });
      }
    }

    return {
      success: true,
      productId: productDoc.id,
      message: `Product "${productData.productName}" created successfully`
    };
  } catch (error) {
    console.error('Error creating finalized product:', error);
    throw error;
  }
}

/**
 * Create product from PDF using AI analysis
 */
exports.createProductFromPDF = onCall({ secrets: [openaiKey] }, async (request) => {
  try {
    const { storagePath } = request.data;
    const userId = request.auth?.uid || 'anonymous';

    if (!storagePath) {
      throw new Error('storagePath is required');
    }

    console.log('Creating product from PDF:', { storagePath, userId });

    // Download PDF from Firebase Storage
    const bucket = admin.storage().bucket();
    const file = bucket.file(storagePath);
    const [buffer] = await file.download();

    // Extract text from PDF
    const pdfData = await pdfParse(buffer);
    const pdfText = pdfData.text;

    if (!pdfText || pdfText.trim().length === 0) {
      throw new Error('No text extracted from PDF');
    }

    console.log('PDF text extracted:', { length: pdfText.length });

    // Call OpenAI to analyze PDF and extract product structure
    const response = await axios.post(
      'https://api.openai.com/v1/chat/completions',
      {
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: getAutonomousProductCreationPrompt()
          },
          {
            role: 'user',
            content: `Analyze this insurance coverage form and extract the product structure:\n\n${pdfText}`
          }
        ],
        temperature: 0.7,
        max_tokens: 2000
      },
      {
        headers: {
          'Authorization': `Bearer ${openaiKey.value()}`,
          'Content-Type': 'application/json'
        }
      }
    );

    const aiResponse = response.data.choices[0].message.content;
    console.log('AI response received:', { length: aiResponse.length });

    // Parse AI response
    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Could not parse AI response as JSON');
    }

    const productData = JSON.parse(jsonMatch[0]);
    console.log('Product data parsed:', { productName: productData.productName });

    // Create product in Firestore
    const result = await createFinalizedProduct(productData, userId);

    return {
      success: true,
      data: result
    };
  } catch (error) {
    console.error('Error in createProductFromPDF:', error);
    return {
      success: false,
      error: error.message
    };
  }
});

```

---

## functions/src/middleware/auth.js

**Path:** `functions/src/middleware/auth.js`

```javascript
/**
 * Authentication Middleware
 * Validates user authentication and authorization
 */

const { https } = require('firebase-functions');

/**
 * Middleware to require authentication
 * @param {Object} context - Firebase Functions context
 * @throws {https.HttpsError} If user is not authenticated
 */
const requireAuth = (context) => {
  if (!context.auth) {
    throw new https.HttpsError(
      'unauthenticated',
      'User must be authenticated to perform this action'
    );
  }
  return context.auth;
};

/**
 * Middleware to require specific role
 * @param {Object} context - Firebase Functions context
 * @param {string[]} allowedRoles - Array of allowed roles
 * @throws {https.HttpsError} If user doesn't have required role
 */
const requireRole = (context, allowedRoles) => {
  const auth = requireAuth(context);
  
  const userRole = auth.token.role || 'user';
  
  if (!allowedRoles.includes(userRole)) {
    throw new https.HttpsError(
      'permission-denied',
      `User role '${userRole}' is not authorized. Required: ${allowedRoles.join(', ')}`
    );
  }
  
  return auth;
};

/**
 * Middleware to check if user is admin
 * @param {Object} context - Firebase Functions context
 * @throws {https.HttpsError} If user is not admin
 */
const requireAdmin = (context) => {
  return requireRole(context, ['admin']);
};

/**
 * Get user ID from context
 * @param {Object} context - Firebase Functions context
 * @returns {string} User ID
 */
const getUserId = (context) => {
  const auth = requireAuth(context);
  return auth.uid;
};

module.exports = {
  requireAuth,
  requireRole,
  requireAdmin,
  getUserId
};

```

---

## functions/src/middleware/errorHandler.js

**Path:** `functions/src/middleware/errorHandler.js`

```javascript
/**
 * Error Handling Middleware
 * Centralized error handling and logging
 */

const { https } = require('firebase-functions');
const { logger } = require('../utils/logger');

/**
 * Handle and format errors
 * @param {Error} error - Error object
 * @param {string} context - Context where error occurred
 * @returns {https.HttpsError} Formatted error
 */
const handleError = (error, context = 'unknown') => {
  // Log the error
  logger.error(`Error in ${context}:`, {
    message: error.message,
    stack: error.stack,
    code: error.code
  });

  // If it's already an HttpsError, return it
  if (error instanceof https.HttpsError) {
    return error;
  }

  // Handle specific error types
  if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {
    return new https.HttpsError(
      'unavailable',
      'External service temporarily unavailable. Please try again later.'
    );
  }

  if (error.response) {
    // Axios error with response
    const status = error.response.status;
    
    if (status === 401 || status === 403) {
      return new https.HttpsError(
        'permission-denied',
        'Authentication failed with external service'
      );
    }
    
    if (status === 429) {
      return new https.HttpsError(
        'resource-exhausted',
        'Rate limit exceeded. Please try again later.'
      );
    }
    
    if (status >= 500) {
      return new https.HttpsError(
        'unavailable',
        'External service error. Please try again later.'
      );
    }
  }

  // Default to internal error
  return new https.HttpsError(
    'internal',
    process.env.NODE_ENV === 'development' 
      ? error.message 
      : 'An internal error occurred. Please try again later.'
  );
};

/**
 * Wrap async function with error handling
 * @param {Function} fn - Async function to wrap
 * @param {string} context - Context name for logging
 * @returns {Function} Wrapped function
 */
const withErrorHandling = (fn, context) => {
  return async (data, contextObj) => {
    try {
      return await fn(data, contextObj);
    } catch (error) {
      throw handleError(error, context);
    }
  };
};

module.exports = {
  handleError,
  withErrorHandling
};

```

---

## functions/src/middleware/rateLimit.js

**Path:** `functions/src/middleware/rateLimit.js`

```javascript
/**
 * Rate Limiting Middleware
 * Prevents abuse by limiting request rates
 */

const { https } = require('firebase-functions');
const admin = require('firebase-admin');

// In-memory rate limit store (for simple implementation)
// In production, use Redis or Firestore for distributed rate limiting
const rateLimitStore = new Map();

/**
 * Clean up old entries from rate limit store
 */
const cleanupRateLimitStore = () => {
  const now = Date.now();
  const oneHourAgo = now - 3600000;
  
  for (const [key, data] of rateLimitStore.entries()) {
    if (data.resetTime < oneHourAgo) {
      rateLimitStore.delete(key);
    }
  }
};

// Clean up every 10 minutes
setInterval(cleanupRateLimitStore, 600000);

/**
 * Rate limit middleware
 * @param {Object} context - Firebase Functions context
 * @param {Object} options - Rate limit options
 * @param {number} options.maxRequests - Maximum requests allowed
 * @param {number} options.windowMs - Time window in milliseconds
 * @throws {https.HttpsError} If rate limit exceeded
 */
const rateLimit = (context, options = {}) => {
  const { maxRequests = 100, windowMs = 3600000 } = options; // Default: 100 requests per hour
  
  // Get user identifier
  const userId = context.auth?.uid || context.rawRequest?.ip || 'anonymous';
  const key = `${userId}:${context.rawRequest?.url || 'unknown'}`;
  
  const now = Date.now();
  const data = rateLimitStore.get(key);
  
  if (!data || now > data.resetTime) {
    // First request or window expired
    rateLimitStore.set(key, {
      count: 1,
      resetTime: now + windowMs
    });
    return;
  }
  
  if (data.count >= maxRequests) {
    const resetIn = Math.ceil((data.resetTime - now) / 1000);
    throw new https.HttpsError(
      'resource-exhausted',
      `Rate limit exceeded. Try again in ${resetIn} seconds.`
    );
  }
  
  data.count++;
  rateLimitStore.set(key, data);
};

/**
 * Rate limit for AI requests (more restrictive)
 * @param {Object} context - Firebase Functions context
 */
const rateLimitAI = (context) => {
  return rateLimit(context, {
    maxRequests: 20, // 20 requests per hour for AI
    windowMs: 3600000
  });
};

/**
 * Rate limit for data operations
 * @param {Object} context - Firebase Functions context
 */
const rateLimitData = (context) => {
  return rateLimit(context, {
    maxRequests: 1000, // 1000 requests per hour for data operations
    windowMs: 3600000
  });
};

module.exports = {
  rateLimit,
  rateLimitAI,
  rateLimitData
};

```

---

## functions/src/middleware/validation.js

**Path:** `functions/src/middleware/validation.js`

```javascript
/**
 * Validation Middleware
 * Validates request data against schemas
 */

const { https } = require('firebase-functions');

/**
 * Validate required fields in data
 * @param {Object} data - Request data
 * @param {string[]} requiredFields - Array of required field names
 * @throws {https.HttpsError} If required fields are missing
 */
const validateRequired = (data, requiredFields) => {
  const missing = requiredFields.filter(field => !data[field]);
  
  if (missing.length > 0) {
    throw new https.HttpsError(
      'invalid-argument',
      `Missing required fields: ${missing.join(', ')}`
    );
  }
};

/**
 * Validate string field
 * @param {*} value - Value to validate
 * @param {string} fieldName - Field name for error messages
 * @param {Object} options - Validation options
 * @throws {https.HttpsError} If validation fails
 */
const validateString = (value, fieldName, options = {}) => {
  if (typeof value !== 'string') {
    throw new https.HttpsError(
      'invalid-argument',
      `${fieldName} must be a string`
    );
  }
  
  if (options.minLength && value.length < options.minLength) {
    throw new https.HttpsError(
      'invalid-argument',
      `${fieldName} must be at least ${options.minLength} characters`
    );
  }
  
  if (options.maxLength && value.length > options.maxLength) {
    throw new https.HttpsError(
      'invalid-argument',
      `${fieldName} must be at most ${options.maxLength} characters`
    );
  }
  
  if (options.pattern && !options.pattern.test(value)) {
    throw new https.HttpsError(
      'invalid-argument',
      `${fieldName} format is invalid`
    );
  }
};

/**
 * Validate array field
 * @param {*} value - Value to validate
 * @param {string} fieldName - Field name for error messages
 * @param {Object} options - Validation options
 * @throws {https.HttpsError} If validation fails
 */
const validateArray = (value, fieldName, options = {}) => {
  if (!Array.isArray(value)) {
    throw new https.HttpsError(
      'invalid-argument',
      `${fieldName} must be an array`
    );
  }
  
  if (options.minLength && value.length < options.minLength) {
    throw new https.HttpsError(
      'invalid-argument',
      `${fieldName} must have at least ${options.minLength} items`
    );
  }
  
  if (options.maxLength && value.length > options.maxLength) {
    throw new https.HttpsError(
      'invalid-argument',
      `${fieldName} must have at most ${options.maxLength} items`
    );
  }
};

/**
 * Validate product data
 * @param {Object} data - Product data to validate
 * @throws {https.HttpsError} If validation fails
 */
const validateProductData = (data) => {
  validateRequired(data, ['name', 'formNumber', 'effectiveDate']);
  validateString(data.name, 'name', { minLength: 1, maxLength: 200 });
  validateString(data.formNumber, 'formNumber', { minLength: 1, maxLength: 50 });
  validateString(data.effectiveDate, 'effectiveDate', { minLength: 1, maxLength: 20 });
  
  if (data.productCode) {
    validateString(data.productCode, 'productCode', { maxLength: 50 });
  }
};

/**
 * Validate coverage data
 * @param {Object} data - Coverage data to validate
 * @throws {https.HttpsError} If validation fails
 */
const validateCoverageData = (data) => {
  validateRequired(data, ['coverageName']);
  validateString(data.coverageName, 'coverageName', { minLength: 1, maxLength: 200 });
  
  if (data.scopeOfCoverage) {
    validateString(data.scopeOfCoverage, 'scopeOfCoverage', { maxLength: 5000 });
  }
  
  if (data.limits) {
    validateString(data.limits, 'limits', { maxLength: 1000 });
  }
};

/**
 * Validate AI request data
 * @param {Object} data - AI request data to validate
 * @throws {https.HttpsError} If validation fails
 */
const validateAIRequest = (data) => {
  if (data.messages) {
    validateArray(data.messages, 'messages', { minLength: 1, maxLength: 50 });
  }
  
  if (data.pdfText) {
    validateString(data.pdfText, 'pdfText', { minLength: 1, maxLength: 500000 });
  }
  
  if (data.model) {
    validateString(data.model, 'model', { maxLength: 50 });
  }
};

module.exports = {
  validateRequired,
  validateString,
  validateArray,
  validateProductData,
  validateCoverageData,
  validateAIRequest
};

```

---

## functions/src/migrations/schemaV3.js

**Path:** `functions/src/migrations/schemaV3.js`

```javascript
/**
 * Schema Migration V3
 * Normalizes coverage fields and backfills denormalized counters
 */

const admin = require('firebase-admin');
const { logger } = require('../utils/logger');

const db = admin.firestore();

/**
 * Migrate schema to V3
 * - Normalize coverage fields (coverageName â†’ name)
 * - Ensure productId and timestamps on all coverages
 * - Backfill counters: limitCount, deductibleCount, subCoverageCount, formMappingCount
 */
async function migrateSchemaV3() {
  const results = {
    productsProcessed: 0,
    coveragesProcessed: 0,
    coveragesUpdated: 0,
    errors: []
  };

  try {
    // Get all products
    const productsSnap = await db.collection('products').get();

    for (const productDoc of productsSnap.docs) {
      const productId = productDoc.id;
      results.productsProcessed++;

      try {
        // Get all coverages for this product
        const coveragesSnap = await db
          .collection(`products/${productId}/coverages`)
          .get();

        for (const coverageDoc of coveragesSnap.docs) {
          const coverageId = coverageDoc.id;
          const coverageData = coverageDoc.data();
          const updates = {};
          let needsUpdate = false;

          // Normalize coverageName â†’ name
          if (coverageData.coverageName && !coverageData.name) {
            updates.name = coverageData.coverageName;
            needsUpdate = true;
          }

          // Ensure productId
          if (!coverageData.productId) {
            updates.productId = productId;
            needsUpdate = true;
          }

          // Ensure timestamps
          if (!coverageData.createdAt) {
            updates.createdAt = admin.firestore.FieldValue.serverTimestamp();
            needsUpdate = true;
          }
          if (!coverageData.updatedAt) {
            updates.updatedAt = admin.firestore.FieldValue.serverTimestamp();
            needsUpdate = true;
          }

          // Backfill counters
          if (coverageData.limitCount === undefined) {
            const limitsSnap = await db
              .collection(`products/${productId}/coverages/${coverageId}/limits`)
              .get();
            updates.limitCount = limitsSnap.size;
            needsUpdate = true;
          }

          if (coverageData.deductibleCount === undefined) {
            const deductiblesSnap = await db
              .collection(`products/${productId}/coverages/${coverageId}/deductibles`)
              .get();
            updates.deductibleCount = deductiblesSnap.size;
            needsUpdate = true;
          }

          if (coverageData.subCoverageCount === undefined) {
            const subCoveragesSnap = await db
              .collection(`products/${productId}/coverages`)
              .where('parentCoverageId', '==', coverageId)
              .get();
            updates.subCoverageCount = subCoveragesSnap.size;
            needsUpdate = true;
          }

          if (coverageData.formMappingCount === undefined) {
            const formMappingsSnap = await db
              .collectionGroup('formCoverages')
              .where('productId', '==', productId)
              .where('coverageId', '==', coverageId)
              .get();
            updates.formMappingCount = formMappingsSnap.size;
            needsUpdate = true;
          }

          // Apply updates
          if (needsUpdate) {
            await db
              .collection(`products/${productId}/coverages`)
              .doc(coverageId)
              .update(updates);
            results.coveragesUpdated++;
          }

          results.coveragesProcessed++;
        }
      } catch (error) {
        results.errors.push({
          productId,
          error: error.message
        });
        logger.error('Migration error for product', { productId }, error);
      }
    }

    logger.info('Schema V3 migration completed', results);
    return results;
  } catch (error) {
    logger.error('Schema V3 migration failed', {}, error);
    throw error;
  }
}

module.exports = {
  migrateSchemaV3
};

```

---

## functions/src/services/dataIntegrity.js

**Path:** `functions/src/services/dataIntegrity.js`

```javascript
/**
 * Data Integrity Service
 * Handles referential integrity, cascade delete, orphan detection, and data validation
 */

const admin = require('firebase-admin');
const { logger } = require('../utils/logger');

const db = admin.firestore();

/**
 * Validate referential integrity for a coverage
 * Ensures all referenced entities exist
 */
async function validateCoverageIntegrity(productId, coverageId) {
  const errors = [];
  const warnings = [];

  try {
    const coverageRef = db.collection('products').doc(productId)
      .collection('coverages').doc(coverageId);
    const coverageSnap = await coverageRef.get();

    if (!coverageSnap.exists) {
      errors.push(`Coverage ${coverageId} does not exist`);
      return { isValid: false, errors, warnings };
    }

    const coverage = coverageSnap.data();

    // Check parent coverage exists (if sub-coverage)
    if (coverage.parentCoverageId) {
      const parentSnap = await db.collection('products').doc(productId)
        .collection('coverages').doc(coverage.parentCoverageId).get();
      if (!parentSnap.exists) {
        errors.push(`Parent coverage ${coverage.parentCoverageId} does not exist`);
      }
    }

    // Check all referenced forms exist
    if (coverage.formIds && Array.isArray(coverage.formIds)) {
      for (const formId of coverage.formIds) {
        const formSnap = await db.collection('forms').doc(formId).get();
        if (!formSnap.exists) {
          warnings.push(`Form ${formId} referenced but does not exist`);
        }
      }
    }

    // Check required coverages exist
    if (coverage.requiredCoverages && Array.isArray(coverage.requiredCoverages)) {
      for (const reqCoverageId of coverage.requiredCoverages) {
        const reqSnap = await db.collection('products').doc(productId)
          .collection('coverages').doc(reqCoverageId).get();
        if (!reqSnap.exists) {
          warnings.push(`Required coverage ${reqCoverageId} does not exist`);
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  } catch (error) {
    logger.error('Error validating coverage integrity:', error);
    throw error;
  }
}

/**
 * Cascade delete coverage and all related entities
 */
async function cascadeDeleteCoverage(productId, coverageId) {
  const batch = db.batch();
  const deletedEntities = {
    coverage: 0,
    limits: 0,
    deductibles: 0,
    formMappings: 0,
    rules: 0,
    subCoverages: 0
  };

  try {
    // Delete coverage limits
    const limitsSnap = await db.collection('products').doc(productId)
      .collection('coverages').doc(coverageId)
      .collection('limits').get();
    limitsSnap.docs.forEach(doc => {
      batch.delete(doc.ref);
      deletedEntities.limits++;
    });

    // Delete coverage deductibles
    const deductiblesSnap = await db.collection('products').doc(productId)
      .collection('coverages').doc(coverageId)
      .collection('deductibles').get();
    deductiblesSnap.docs.forEach(doc => {
      batch.delete(doc.ref);
      deletedEntities.deductibles++;
    });

    // Delete form-coverage mappings
    const mappingsSnap = await db.collection('formCoverages')
      .where('coverageId', '==', coverageId)
      .where('productId', '==', productId).get();
    mappingsSnap.docs.forEach(doc => {
      batch.delete(doc.ref);
      deletedEntities.formMappings++;
    });

    // Delete rules for this coverage
    const rulesSnap = await db.collection('rules')
      .where('productId', '==', productId)
      .where('targetId', '==', coverageId).get();
    rulesSnap.docs.forEach(doc => {
      batch.delete(doc.ref);
      deletedEntities.rules++;
    });

    // Delete sub-coverages
    const subCoveragesSnap = await db.collection('products').doc(productId)
      .collection('coverages')
      .where('parentCoverageId', '==', coverageId).get();
    subCoveragesSnap.docs.forEach(doc => {
      batch.delete(doc.ref);
      deletedEntities.subCoverages++;
    });

    // Delete the coverage itself
    batch.delete(db.collection('products').doc(productId)
      .collection('coverages').doc(coverageId));
    deletedEntities.coverage++;

    await batch.commit();

    logger.info('Cascade delete completed', {
      productId,
      coverageId,
      deletedEntities
    });

    return deletedEntities;
  } catch (error) {
    logger.error('Error in cascade delete:', error);
    throw error;
  }
}

/**
 * Detect orphaned records (entities with missing references)
 */
async function detectOrphanedRecords(productId) {
  const orphans = {
    formCoverages: [],
    rules: [],
    pricingRules: []
  };

  try {
    // Check form-coverage mappings
    const mappingsSnap = await db.collection('formCoverages')
      .where('productId', '==', productId).get();

    for (const doc of mappingsSnap.docs) {
      const mapping = doc.data();
      const coverageSnap = await db.collection('products').doc(productId)
        .collection('coverages').doc(mapping.coverageId).get();
      if (!coverageSnap.exists) {
        orphans.formCoverages.push({
          id: doc.id,
          coverageId: mapping.coverageId,
          formId: mapping.formId
        });
      }
    }

    // Check rules
    const rulesSnap = await db.collection('rules')
      .where('productId', '==', productId).get();

    for (const doc of rulesSnap.docs) {
      const rule = doc.data();
      if (rule.targetId) {
        const targetSnap = await db.collection('products').doc(productId)
          .collection('coverages').doc(rule.targetId).get();
        if (!targetSnap.exists) {
          orphans.rules.push({
            id: doc.id,
            targetId: rule.targetId,
            ruleType: rule.ruleType
          });
        }
      }
    }

    logger.info('Orphan detection completed', {
      productId,
      orphanCounts: {
        formCoverages: orphans.formCoverages.length,
        rules: orphans.rules.length
      }
    });

    return orphans;
  } catch (error) {
    logger.error('Error detecting orphans:', error);
    throw error;
  }
}

/**
 * Validate product data consistency
 */
async function validateProductConsistency(productId) {
  const issues = [];

  try {
    const productSnap = await db.collection('products').doc(productId).get();
    if (!productSnap.exists) {
      return { isConsistent: false, issues: ['Product does not exist'] };
    }

    // Check all coverages have valid product reference
    const coveragesSnap = await db.collection('products').doc(productId)
      .collection('coverages').get();

    for (const doc of coveragesSnap.docs) {
      const coverage = doc.data();
      if (coverage.productId !== productId) {
        issues.push(`Coverage ${doc.id} has mismatched productId`);
      }
    }

    // Check all rules reference valid product
    const rulesSnap = await db.collection('rules')
      .where('productId', '==', productId).get();

    for (const doc of rulesSnap.docs) {
      const rule = doc.data();
      if (!rule.productId) {
        issues.push(`Rule ${doc.id} missing productId`);
      }
    }

    return {
      isConsistent: issues.length === 0,
      issues
    };
  } catch (error) {
    logger.error('Error validating product consistency:', error);
    throw error;
  }
}

module.exports = {
  validateCoverageIntegrity,
  cascadeDeleteCoverage,
  detectOrphanedRecords,
  validateProductConsistency
};

```

---

## functions/src/services/openai.js

**Path:** `functions/src/services/openai.js`

```javascript
/**
 * OpenAI Service
 * Centralized service for all OpenAI API interactions
 *
 * OPTIMIZED VERSION - Enhanced Performance & Reliability:
 * - Response caching with TTL to reduce API calls
 * - Exponential backoff retry logic for transient failures
 * - Intelligent timeout handling based on request size
 * - Request deduplication to prevent duplicate calls
 * - Cost tracking and token budget management
 * - Model-specific optimizations
 */

const axios = require('axios');
const crypto = require('crypto');
const { logger } = require('../utils/logger');

// ============================================================================
// Configuration
// ============================================================================

const CONFIG = {
  // Cache settings
  cacheTTL: 3600000, // 1 hour
  maxCacheSize: 100,

  // Retry settings
  maxRetries: 3,
  initialRetryDelay: 1000, // 1 second
  maxRetryDelay: 10000, // 10 seconds

  // Timeout settings (ms)
  baseTimeout: 30000, // 30 seconds base
  timeoutPerToken: 50, // Additional ms per expected token
  maxTimeout: 120000, // 2 minutes max

  // Model configurations - all using gpt-4o-mini for cost efficiency
  models: {
    'gpt-4o-mini': { costPer1kInput: 0.00015, costPer1kOutput: 0.0006, maxTokens: 16384 }
  },
  // Default model for all operations
  defaultModel: 'gpt-4o-mini'
};

// ============================================================================
// Cache Management
// ============================================================================

const responseCache = new Map();
const pendingRequests = new Map(); // For request deduplication

/**
 * Generate cache key from request parameters
 */
const generateCacheKey = (messages, model, temperature) => {
  const key = JSON.stringify({ messages, model, temperature });
  return crypto.createHash('sha256').update(key).digest('hex');
};

/**
 * Get cached response if available and not expired
 */
const getCachedResponse = (cacheKey) => {
  const cached = responseCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CONFIG.cacheTTL) {
    logger.debug('Cache hit for OpenAI response', { cacheKey: cacheKey.substring(0, 8) });
    return cached.response;
  }
  if (cached) {
    responseCache.delete(cacheKey);
  }
  return null;
};

/**
 * Store response in cache with size management
 */
const setCachedResponse = (cacheKey, response) => {
  // Evict oldest entry if cache is full
  if (responseCache.size >= CONFIG.maxCacheSize) {
    const firstKey = responseCache.keys().next().value;
    responseCache.delete(firstKey);
  }
  responseCache.set(cacheKey, {
    response,
    timestamp: Date.now()
  });
};

/**
 * Calculate dynamic timeout based on expected response size
 */
const calculateTimeout = (maxTokens) => {
  const dynamicTimeout = CONFIG.baseTimeout + (maxTokens * CONFIG.timeoutPerToken);
  return Math.min(dynamicTimeout, CONFIG.maxTimeout);
};

/**
 * Sleep utility for retry delays
 */
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Calculate exponential backoff delay
 */
const getBackoffDelay = (attempt) => {
  const delay = CONFIG.initialRetryDelay * Math.pow(2, attempt);
  // Add jitter to prevent thundering herd
  const jitter = Math.random() * 0.3 * delay;
  return Math.min(delay + jitter, CONFIG.maxRetryDelay);
};

/**
 * Check if error is retryable
 */
const isRetryableError = (error) => {
  if (!error.response) {
    // Network errors are retryable
    return true;
  }
  const status = error.response.status;
  // Retry on rate limits (429) and server errors (5xx)
  return status === 429 || status >= 500;
};

/**
 * Get OpenAI API key from environment
 * Checks both OPENAI_API_KEY (for v2 functions secrets) and OPENAI_KEY (legacy)
 */
const getOpenAIKey = () => {
  const key = process.env.OPENAI_API_KEY || process.env.OPENAI_KEY;
  if (key) {
    const trimmedKey = key.trim();
    if (!trimmedKey) {
      throw new Error('OpenAI API key is empty after trimming.');
    }
    return trimmedKey;
  }
  throw new Error('OpenAI API key not configured. Set OPENAI_API_KEY environment variable.');
};

/**
 * Estimate input tokens (rough approximation)
 */
const estimateInputTokens = (messages) => {
  const text = messages.map(m => m.content || '').join(' ');
  return Math.ceil(text.length / 4);
};

/**
 * Call OpenAI Chat Completion API with retry logic
 * OPTIMIZED: Dynamic timeout, exponential backoff, request deduplication
 *
 * @param {Object} options - Request options
 * @param {Array} options.messages - Array of message objects
 * @param {string} options.model - Model to use (default: gpt-4o-mini)
 * @param {number} options.maxTokens - Maximum tokens to generate
 * @param {number} options.temperature - Temperature for randomness
 * @param {number} options.timeout - Request timeout in milliseconds (auto-calculated if not provided)
 * @param {boolean} options.useCache - Enable response caching (default: true)
 * @param {boolean} options.deduplicate - Enable request deduplication (default: true)
 * @returns {Promise<Object>} OpenAI response
 */
const chatCompletion = async (options = {}) => {
  const {
    messages,
    model = 'gpt-4o-mini',
    maxTokens = 2000,
    temperature = 0.2,
    timeout,
    useCache = true,
    deduplicate = true
  } = options;

  const startTime = Date.now();
  const cacheKey = generateCacheKey(messages, model, temperature);

  // Calculate dynamic timeout based on expected response size
  const effectiveTimeout = timeout || calculateTimeout(maxTokens);

  // Check cache first
  if (useCache) {
    const cachedResponse = getCachedResponse(cacheKey);
    if (cachedResponse) {
      logger.info('OpenAI response from cache', {
        model,
        duration: `${Date.now() - startTime}ms`,
        cacheKey: cacheKey.substring(0, 8)
      });
      return { ...cachedResponse, fromCache: true };
    }
  }

  // Request deduplication - if same request is in flight, wait for it
  if (deduplicate && pendingRequests.has(cacheKey)) {
    logger.debug('Waiting for duplicate request', { cacheKey: cacheKey.substring(0, 8) });
    return pendingRequests.get(cacheKey);
  }

  // Create the request promise
  const requestPromise = executeWithRetry(messages, model, maxTokens, temperature, effectiveTimeout, cacheKey, useCache, startTime);

  // Store for deduplication
  if (deduplicate) {
    pendingRequests.set(cacheKey, requestPromise);
    requestPromise.finally(() => pendingRequests.delete(cacheKey));
  }

  return requestPromise;
};

/**
 * Execute API call with retry logic
 */
const executeWithRetry = async (messages, model, maxTokens, temperature, timeout, cacheKey, useCache, startTime) => {
  const apiKey = getOpenAIKey();
  let lastError = null;

  for (let attempt = 0; attempt <= CONFIG.maxRetries; attempt++) {
    try {
      if (attempt > 0) {
        const delay = getBackoffDelay(attempt - 1);
        logger.debug(`Retry attempt ${attempt}/${CONFIG.maxRetries} after ${delay}ms`);
        await sleep(delay);
      }

      logger.debug('Calling OpenAI API', {
        model,
        messageCount: messages.length,
        maxTokens,
        attempt: attempt + 1,
        timeout
      });

      const response = await axios.post(
        'https://api.openai.com/v1/chat/completions',
        {
          model,
          messages,
          max_tokens: maxTokens,
          temperature
        },
        {
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          timeout
        }
      );

      const duration = Date.now() - startTime;
      const inputTokens = estimateInputTokens(messages);
      const outputTokens = response.data.usage?.completion_tokens || 0;
      const modelConfig = CONFIG.models[model] || CONFIG.models['gpt-4o-mini'];
      const estimatedCost = (inputTokens / 1000 * modelConfig.costPer1kInput) +
                           (outputTokens / 1000 * modelConfig.costPer1kOutput);

      const result = {
        success: true,
        content: response.data.choices[0].message.content,
        usage: response.data.usage,
        model: response.data.model,
        fromCache: false,
        estimatedCost: estimatedCost.toFixed(6),
        retryCount: attempt
      };

      // Cache successful response
      if (useCache) {
        setCachedResponse(cacheKey, result);
      }

      logger.info('OpenAI API call successful', {
        model,
        duration: `${duration}ms`,
        tokensUsed: response.data.usage?.total_tokens || 0,
        estimatedCost: `$${estimatedCost.toFixed(6)}`,
        retries: attempt
      });

      return result;
    } catch (error) {
      lastError = error;

      // Don't retry non-retryable errors
      if (!isRetryableError(error)) {
        break;
      }

      // Don't retry if we've exhausted attempts
      if (attempt >= CONFIG.maxRetries) {
        break;
      }

      logger.warn('OpenAI API call failed, will retry', {
        attempt: attempt + 1,
        error: error.message,
        status: error.response?.status
      });
    }
  }

  // All retries exhausted
  const duration = Date.now() - startTime;
  logger.error('OpenAI API call failed after retries', {
    duration: `${duration}ms`,
    error: lastError.message,
    status: lastError.response?.status,
    retries: CONFIG.maxRetries
  });

  // Re-throw with more context
  if (lastError.response) {
    const status = lastError.response.status;
    const message = lastError.response.data?.error?.message || lastError.message;

    if (status === 401) {
      throw new Error('OpenAI API authentication failed. Check API key.');
    } else if (status === 429) {
      throw new Error('OpenAI API rate limit exceeded. Please try again later.');
    } else if (status >= 500) {
      throw new Error('OpenAI API service error. Please try again later.');
    } else {
      throw new Error(`OpenAI API error: ${message}`);
    }
  }

  throw lastError;
};

/**
 * Generate product summary from PDF text
 * @param {string} pdfText - Extracted PDF text
 * @param {string} systemPrompt - System prompt for AI
 * @returns {Promise<Object>} Summary response
 */
const generateProductSummary = async (pdfText, systemPrompt) => {
  const messages = [
    {
      role: 'system',
      content: systemPrompt || 'You are an expert insurance analyst. Analyze the provided insurance product document and create a comprehensive summary.'
    },
    {
      role: 'user',
      content: pdfText
    }
  ];

  return chatCompletion({
    messages,
    maxTokens: 2000,
    temperature: 0.2
  });
};

/**
 * Generate chat response
 * @param {Array} messages - Chat message history
 * @param {string} systemPrompt - System prompt for AI
 * @param {Object} options - Additional options (model, maxTokens, temperature)
 * @returns {Promise<Object>} Chat response
 */
const generateChatResponse = async (messages, systemPrompt, options = {}) => {
  // System prompt is already included in messages from frontend
  // Only add if not present
  const hasSystemPrompt = messages.some(msg => msg.role === 'system');

  const fullMessages = hasSystemPrompt ? messages : [
    {
      role: 'system',
      content: systemPrompt || 'You are a helpful insurance product assistant.'
    },
    ...messages
  ];

  return chatCompletion({
    messages: fullMessages,
    model: options.model || 'gpt-4o-mini',
    maxTokens: options.maxTokens || 1500,
    temperature: options.temperature !== undefined ? options.temperature : 0.7
  });
};

/**
 * Analyze insurance claim
 * @param {string} claimText - Claim description
 * @param {string} systemPrompt - System prompt for AI
 * @returns {Promise<Object>} Analysis response
 */
const analyzeClaim = async (claimText, systemPrompt) => {
  const messages = [
    {
      role: 'system',
      content: systemPrompt || 'You are an expert insurance claims analyst.'
    },
    {
      role: 'user',
      content: claimText
    }
  ];

  return chatCompletion({
    messages,
    maxTokens: 2000,
    temperature: 0.3
  });
};

module.exports = {
  chatCompletion,
  generateProductSummary,
  generateChatResponse,
  analyzeClaim
};

```

---

## functions/src/services/pdf.js

**Path:** `functions/src/services/pdf.js`

```javascript
/**
 * PDF Processing Service
 * Handles PDF text extraction on the backend
 */

const pdfParseModule = require('pdf-parse');
// pdf-parse v2.3.10 exports PDFParse class
const PDFParse = pdfParseModule.PDFParse;
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { logger } = require('../utils/logger');

/**
 * Extract text from PDF buffer
 * @param {Buffer} pdfBuffer - PDF file buffer
 * @returns {Promise<string>} Extracted text
 */
const extractTextFromBuffer = async (pdfBuffer) => {
  let tempFilePath = null;
  try {
    logger.debug('Extracting text from PDF buffer', {
      bufferSize: pdfBuffer.length
    });

    // pdf-parse v2.3.10 requires file:// URL, so write buffer to temp file
    const tempDir = os.tmpdir();
    tempFilePath = path.join(tempDir, `pdf-${Date.now()}-${Math.random().toString(36).substring(7)}.pdf`);

    logger.debug('Writing PDF buffer to temp file', { tempFilePath });
    fs.writeFileSync(tempFilePath, pdfBuffer);

    // Create parser with file:// URL
    const fileUrl = `file://${tempFilePath}`;
    const parser = new PDFParse({ url: fileUrl });
    const result = await parser.getText();

    logger.info('PDF text extraction successful', {
      textLength: result.text ? result.text.length : 0,
      textPreview: result.text ? result.text.substring(0, 100) : 'empty'
    });

    return result.text || '';
  } catch (error) {
    logger.error('PDF text extraction failed', {
      error: error.message
    });
    throw new Error(`Failed to extract text from PDF: ${error.message}`);
  } finally {
    // Clean up temp file
    if (tempFilePath && fs.existsSync(tempFilePath)) {
      try {
        fs.unlinkSync(tempFilePath);
        logger.debug('Cleaned up temp PDF file', { tempFilePath });
      } catch (cleanupError) {
        logger.warn('Failed to clean up temp PDF file', {
          tempFilePath,
          error: cleanupError.message
        });
      }
    }
  }
};

/**
 * Download PDF from URL and extract text
 * @param {string} url - PDF file URL
 * @returns {Promise<string>} Extracted text
 */
const extractTextFromUrl = async (url) => {
  try {
    logger.debug('Downloading PDF from URL', { url });

    const response = await axios.get(url, {
      responseType: 'arraybuffer',
      timeout: 30000,
      maxContentLength: 50 * 1024 * 1024 // 50MB max
    });

    const buffer = Buffer.from(response.data);
    return extractTextFromBuffer(buffer);
  } catch (error) {
    logger.error('PDF download failed', {
      url,
      error: error.message
    });
    throw new Error(`Failed to download PDF: ${error.message}`);
  }
};

/**
 * Extract text from base64 encoded PDF
 * @param {string} base64Data - Base64 encoded PDF data
 * @returns {Promise<string>} Extracted text
 */
const extractTextFromBase64 = async (base64Data) => {
  try {
    // Remove data URL prefix if present
    const base64String = base64Data.replace(/^data:application\/pdf;base64,/, '');
    
    logger.debug('Extracting text from base64 PDF', {
      dataLength: base64String.length
    });

    const buffer = Buffer.from(base64String, 'base64');
    return extractTextFromBuffer(buffer);
  } catch (error) {
    logger.error('Base64 PDF extraction failed', {
      error: error.message
    });
    throw new Error(`Failed to extract text from base64 PDF: ${error.message}`);
  }
};

/**
 * Truncate text to maximum length
 * @param {string} text - Text to truncate
 * @param {number} maxWords - Maximum number of words
 * @returns {string} Truncated text
 */
const truncateText = (text, maxWords = 100000) => {
  const words = text.split(/\s+/);
  if (words.length <= maxWords) {
    return text;
  }
  
  logger.info('Truncating text', {
    originalWords: words.length,
    maxWords
  });
  
  return words.slice(0, maxWords).join(' ');
};

module.exports = {
  extractTextFromBuffer,
  extractTextFromUrl,
  extractTextFromBase64,
  truncateText
};

```

---

## functions/src/triggers/productIntegrity.js

**Path:** `functions/src/triggers/productIntegrity.js`

```javascript
/**
 * Product Integrity Triggers
 * Firestore triggers to maintain denormalized counters and referential integrity
 *
 * Optimizations:
 * - Batch operations to reduce write costs
 * - Debounced stats recalculation
 * - Efficient query patterns
 * - Comprehensive error handling
 */

const functions = require('firebase-functions');
const { onDocumentCreated, onDocumentDeleted, onDocumentUpdated } = require('firebase-functions/v2/firestore');
const admin = require('firebase-admin');
const { logger } = require('../utils/logger');

const db = admin.firestore();

/**
 * Optimized: Debounce map to prevent redundant recalculations
 */
const debounceTimers = new Map();
const DEBOUNCE_DELAY = 1000; // 1 second

/**
 * Optimized: Debounce stats recalculation
 */
const debounceRecalculation = (key, fn) => {
  if (debounceTimers.has(key)) {
    clearTimeout(debounceTimers.get(key));
  }
  const timer = setTimeout(() => {
    fn();
    debounceTimers.delete(key);
  }, DEBOUNCE_DELAY);
  debounceTimers.set(key, timer);
};

/**
 * Trigger: When a coverage is created/updated/deleted, update product stats
 */
const onCoverageChange = onDocumentCreated(
  'products/{productId}/coverages/{coverageId}',
  async (event) => {
    const { productId } = event.params;
    await recalculateProductStats(productId);
  }
);

const onCoverageDelete = onDocumentDeleted(
  'products/{productId}/coverages/{coverageId}',
  async (event) => {
    const { productId } = event.params;
    await recalculateProductStats(productId);
  }
);

/**
 * Trigger: When a limit is created/deleted, update coverage stats
 */
const onLimitChange = onDocumentCreated(
  'products/{productId}/coverages/{coverageId}/limits/{limitId}',
  async (event) => {
    const { productId, coverageId } = event.params;
    await recalculateCoverageStats(productId, coverageId);
  }
);

const onLimitDelete = onDocumentDeleted(
  'products/{productId}/coverages/{coverageId}/limits/{limitId}',
  async (event) => {
    const { productId, coverageId } = event.params;
    await recalculateCoverageStats(productId, coverageId);
  }
);

/**
 * Trigger: When a deductible is created/deleted, update coverage stats
 */
const onDeductibleChange = onDocumentCreated(
  'products/{productId}/coverages/{coverageId}/deductibles/{deductibleId}',
  async (event) => {
    const { productId, coverageId } = event.params;
    await recalculateCoverageStats(productId, coverageId);
  }
);

const onDeductibleDelete = onDocumentDeleted(
  'products/{productId}/coverages/{coverageId}/deductibles/{deductibleId}',
  async (event) => {
    const { productId, coverageId } = event.params;
    await recalculateCoverageStats(productId, coverageId);
  }
);

/**
 * Trigger: When a form-coverage mapping is created/deleted, update stats
 */
const onFormCoverageChange = onDocumentCreated(
  'formCoverages/{mappingId}',
  async (event) => {
    const mapping = event.data.data();
    if (mapping.productId && mapping.coverageId) {
      await recalculateCoverageStats(mapping.productId, mapping.coverageId);
      await recalculateProductStats(mapping.productId);
    }
  }
);

const onFormCoverageDelete = onDocumentDeleted(
  'formCoverages/{mappingId}',
  async (event) => {
    const mapping = event.data.data();
    if (mapping.productId && mapping.coverageId) {
      await recalculateCoverageStats(mapping.productId, mapping.coverageId);
      await recalculateProductStats(mapping.productId);
    }
  }
);

/**
 * Optimized: Recalculate product statistics with batch operations
 */
async function recalculateProductStats(productId) {
  try {
    const productRef = db.collection('products').doc(productId);

    // Optimized: Parallel queries to reduce latency
    const [coveragesSnap, packagesSnap, formsSnap, rulesSnap] = await Promise.all([
      db.collection(`products/${productId}/coverages`).get(),
      db.collection(`products/${productId}/packages`).get(),
      db.collectionGroup('formCoverages').where('productId', '==', productId).get(),
      db.collection('rules').where('productId', '==', productId).get()
    ]);

    const coverageCount = coveragesSnap.size;
    const packageCount = packagesSnap.size;
    const formIds = new Set(formsSnap.docs.map(doc => doc.data().formId));
    const formCount = formIds.size;
    const ruleCount = rulesSnap.size;

    // Update product
    await productRef.update({
      coverageCount,
      packageCount,
      formCount,
      ruleCount,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    logger.info('Product stats recalculated', {
      productId,
      coverageCount,
      packageCount,
      formCount,
      ruleCount
    });
  } catch (error) {
    logger.error('Failed to recalculate product stats', { productId }, error);
  }
}

/**
 * Optimized: Recalculate coverage statistics with parallel queries
 */
async function recalculateCoverageStats(productId, coverageId) {
  try {
    const coverageRef = db.collection(`products/${productId}/coverages`).doc(coverageId);

    // Optimized: Parallel queries for limits and deductibles
    const [limitsSnap, deductiblesSnap] = await Promise.all([
      db.collection(`products/${productId}/coverages/${coverageId}/limits`).get(),
      db.collection(`products/${productId}/coverages/${coverageId}/deductibles`).get()
    ]);

    const limitCount = limitsSnap.size;
    const deductibleCount = deductiblesSnap.size;

    // Count sub-coverages
    const subCoveragesSnap = await db
      .collection(`products/${productId}/coverages`)
      .where('parentCoverageId', '==', coverageId)
      .get();
    const subCoverageCount = subCoveragesSnap.size;

    // Count form mappings
    const formMappingsSnap = await db
      .collectionGroup('formCoverages')
      .where('productId', '==', productId)
      .where('coverageId', '==', coverageId)
      .get();
    const formMappingCount = formMappingsSnap.size;

    // Update coverage
    await coverageRef.update({
      limitCount,
      deductibleCount,
      subCoverageCount,
      formMappingCount,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    logger.info('Coverage stats recalculated', {
      productId,
      coverageId,
      limitCount,
      deductibleCount,
      subCoverageCount,
      formMappingCount
    });
  } catch (error) {
    logger.error('Failed to recalculate coverage stats', { productId, coverageId }, error);
  }
}

module.exports = {
  onCoverageChange,
  onCoverageDelete,
  onLimitChange,
  onLimitDelete,
  onDeductibleChange,
  onDeductibleDelete,
  onFormCoverageChange,
  onFormCoverageDelete,
  recalculateProductStats,
  recalculateCoverageStats
};

```

---

## functions/src/utils/logger.js

**Path:** `functions/src/utils/logger.js`

```javascript
/**
 * Logging Utility
 * Centralized logging with structured output
 */

const functions = require('firebase-functions');

const LOG_LEVELS = {
  DEBUG: 'debug',
  INFO: 'info',
  WARN: 'warn',
  ERROR: 'error'
};

/**
 * Logger class for structured logging
 */
class Logger {
  constructor() {
    this.isDevelopment = process.env.NODE_ENV === 'development';
  }

  /**
   * Format log message with metadata
   * @param {string} level - Log level
   * @param {string} message - Log message
   * @param {Object} metadata - Additional metadata
   * @returns {Object} Formatted log object
   */
  formatLog(level, message, metadata = {}) {
    return {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...metadata
    };
  }

  /**
   * Log debug message
   * @param {string} message - Log message
   * @param {Object} metadata - Additional metadata
   */
  debug(message, metadata = {}) {
    if (this.isDevelopment) {
      const log = this.formatLog(LOG_LEVELS.DEBUG, message, metadata);
      console.log(JSON.stringify(log));
    }
  }

  /**
   * Log info message
   * @param {string} message - Log message
   * @param {Object} metadata - Additional metadata
   */
  info(message, metadata = {}) {
    const log = this.formatLog(LOG_LEVELS.INFO, message, metadata);
    functions.logger.info(log);
  }

  /**
   * Log warning message
   * @param {string} message - Log message
   * @param {Object} metadata - Additional metadata
   */
  warn(message, metadata = {}) {
    const log = this.formatLog(LOG_LEVELS.WARN, message, metadata);
    functions.logger.warn(log);
  }

  /**
   * Log error message
   * @param {string} message - Log message
   * @param {Object} metadata - Additional metadata
   */
  error(message, metadata = {}) {
    const log = this.formatLog(LOG_LEVELS.ERROR, message, metadata);
    functions.logger.error(log);
  }

}

// Export singleton instance
const logger = new Logger();

module.exports = {
  logger,
  LOG_LEVELS
};

```

---

## src/App.tsx

**Path:** `src/App.tsx`

```tsx
import React, { Suspense, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider } from 'styled-components';
import styled from 'styled-components';
import { GlobalStyle } from './styles/GlobalStyle';
import { theme } from './styles/theme';
import ErrorBoundary from './components/ErrorBoundary';
import { initBundleOptimizations, createOptimizedLazyComponent } from './utils/bundleOptimization';
import { ConnectionStatus } from './components/ui/ConnectionStatus';
import { PageLoadingSpinner } from './components/ui/LoadingSpinner';
import { ToastProvider } from './components/common/Toast';
import { StatusAnnouncerProvider } from './components/common/StatusAnnouncer';
import { RouteProgressProvider } from './components/ui/RouteProgress';

// Skip to content link for accessibility
const SkipLink = styled.a`
  position: absolute;
  top: -40px;
  left: 16px;
  padding: 8px 16px;
  background: ${({ theme }) => theme.colours.primary};
  color: white;
  border-radius: 8px;
  font-weight: 600;
  font-size: 14px;
  z-index: 10001;
  text-decoration: none;
  transition: top 0.2s ease;

  &:focus {
    top: 16px;
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.4);
  }
`;

import logger, { LOG_CATEGORIES } from './utils/logger';
import env from './config/env';



/* public */
import Login from './components/Login';

/* protected - Core components loaded immediately */
import Home from './components/Home';
import RequireAuth from './components/RequireAuth';

// Loading component for lazy-loaded routes - using proper PageLoadingSpinner
const LoadingSpinner: React.FC = () => <PageLoadingSpinner label="Loading..." />;

// ProductHub is lazy-loaded to avoid import conflict with bundleOptimization preloading
const ProductHub = createOptimizedLazyComponent(
  () => import('./components/ProductHub'),
  { chunkName: 'ProductHub', fallback: <LoadingSpinner /> }
);

/* protected - Heavy components lazy loaded with optimization */
const DataDictionary = createOptimizedLazyComponent(
  () => import('./components/DataDictionary'),
  { chunkName: 'DataDictionary', fallback: <LoadingSpinner /> }
);
const CoverageScreen = createOptimizedLazyComponent(
  () => import('./components/CoverageScreen'),
  { chunkName: 'CoverageScreen', fallback: <LoadingSpinner /> }
);
const PricingScreen = createOptimizedLazyComponent(
  () => import('./components/PricingScreen'),
  { chunkName: 'PricingScreen', fallback: <LoadingSpinner /> }
);
const TableScreen = createOptimizedLazyComponent(
  () => import('./components/TableScreen'),
  { chunkName: 'TableScreen', fallback: <LoadingSpinner /> }
);
const FormsScreen = createOptimizedLazyComponent(
  () => import('./components/FormsScreen'),
  { chunkName: 'FormsScreen', fallback: <LoadingSpinner /> }
);
const StatesScreen = createOptimizedLazyComponent(
  () => import('./components/StatesScreen'),
  { chunkName: 'StatesScreen', fallback: <LoadingSpinner /> }
);
const RulesScreen = createOptimizedLazyComponent(
  () => import('./components/RulesScreen'),
  { chunkName: 'RulesScreen', fallback: <LoadingSpinner /> }
);
const CoverageStatesScreen = createOptimizedLazyComponent(
  () => import('./components/CoverageStatesScreen'),
  { chunkName: 'CoverageStatesScreen', fallback: <LoadingSpinner /> }
);
const PackagesScreen = createOptimizedLazyComponent(
  () => import('./components/PackagesScreen'),
  { chunkName: 'PackagesScreen', fallback: <LoadingSpinner /> }
);
const ProductExplorer = createOptimizedLazyComponent(
  () => import('./components/ProductExplorer'),
  { chunkName: 'ProductExplorer', fallback: <LoadingSpinner /> }
);
const ProductBuilder = createOptimizedLazyComponent(
  () => import('./components/ProductBuilder'),
  { chunkName: 'ProductBuilder', fallback: <LoadingSpinner /> }
);
const AIBuilder = createOptimizedLazyComponent(
  () => import('./components/AIBuilder'),
  { chunkName: 'AIBuilder', fallback: <LoadingSpinner /> }
);
const Builder = createOptimizedLazyComponent(
  () => import('./components/Builder'),
  { chunkName: 'Builder', fallback: <LoadingSpinner /> }
);
const ClaimsAnalysis = createOptimizedLazyComponent(
  () => import('./components/ClaimsAnalysis'),
  { chunkName: 'ClaimsAnalysis', fallback: <LoadingSpinner /> }
);
const TaskManagement = createOptimizedLazyComponent(
  () => import('./components/TaskManagement'),
  { chunkName: 'TaskManagement', fallback: <LoadingSpinner /> }
);
const Product360 = createOptimizedLazyComponent(
  () => import('./pages/Product360'),
  { chunkName: 'Product360', fallback: <LoadingSpinner /> }
);
const FormsMapper = createOptimizedLazyComponent(
  () => import('./pages/FormsMapper'),
  { chunkName: 'FormsMapper', fallback: <LoadingSpinner /> }
);
const PricingBuilder = createOptimizedLazyComponent(
  () => import('./pages/PricingBuilder'),
  { chunkName: 'PricingBuilder', fallback: <LoadingSpinner /> }
);
const QuoteSandbox = createOptimizedLazyComponent(
  () => import('./pages/QuoteSandbox'),
  { chunkName: 'QuoteSandbox', fallback: <LoadingSpinner /> }
);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HistoryWrapper â€“ provides floating toggle + Version sidebar
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HistoryWrapper: React.FC = () => {
  return (
    <>
      {/* Primary route tree */}
      <Routes>
        {/* public */}
        <Route path="/login" element={<Login />} />

        {/* protected */}
        <Route
          path="/"
          element={
            <RequireAuth>
              <Home />
            </RequireAuth>
          }
        />
        <Route
          path="/products"
          element={
            <RequireAuth>
              <ProductHub />
            </RequireAuth>
          }
        />
        <Route
          path="/coverage/:productId/*"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <CoverageScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/coverage-states/:productId/:coverageId"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <CoverageStatesScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/forms/:productId/*"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <FormsScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/pricing/:productId"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <PricingScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/states/:productId"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <StatesScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/table/:productId/:stepId"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <TableScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/rules"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <RulesScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/rules/:productId"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <RulesScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/rules/:productId/:coverageId"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <RulesScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/product-explorer"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <ProductExplorer />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/product-builder"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <ProductBuilder />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/ai-builder"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <AIBuilder />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/builder"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <Builder />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/claims-analysis"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <ClaimsAnalysis />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/data-dictionary"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <DataDictionary />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/tasks"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <TaskManagement />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/products/:productId/packages"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <PackagesScreen />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/products/:productId/overview"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <Product360 />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/products/:productId/forms-mapper"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <FormsMapper />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/products/:productId/pricing"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <PricingBuilder />
              </Suspense>
            </RequireAuth>
          }
        />
        <Route
          path="/quote-sandbox/:productId"
          element={
            <RequireAuth>
              <Suspense fallback={<LoadingSpinner />}>
                <QuoteSandbox />
              </Suspense>
            </RequireAuth>
          }
        />

        {/* catch-all */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </>
  );
};

// Track initialization to prevent duplicate logs in StrictMode
let appInitialized = false;

const App: React.FC = () => {
  // Optimized: Initialize bundle optimizations and performance monitoring
  useEffect(() => {
    if (appInitialized) return;
    appInitialized = true;

    try {
      initBundleOptimizations();
      // Single consolidated log for app initialization
      console.log(`ðŸš€ App initialized (${env.NODE_ENV})`);
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'App initialization failed', {
        environment: env.NODE_ENV
      }, error as Error);
    }
  }, []);

  return (
    <ErrorBoundary>
      <ThemeProvider theme={theme}>
        <GlobalStyle />
        <SkipLink href="#main-content">Skip to main content</SkipLink>
        <StatusAnnouncerProvider>
          <ToastProvider>
            <RouteProgressProvider>
              <ConnectionStatus />
              <Router>
                <HistoryWrapper />
              </Router>
            </RouteProgressProvider>
          </ToastProvider>
        </StatusAnnouncerProvider>
      </ThemeProvider>
    </ErrorBoundary>
  );
};

export default App;

```

---

## src/components/AIBuilder.tsx

**Path:** `src/components/AIBuilder.tsx`

```tsx
import { useState, useEffect } from 'react';
import { collection, collectionGroup, getDocs } from 'firebase/firestore';
import { db, functions } from '@/firebase';
import { httpsCallable } from 'firebase/functions';
import styled from 'styled-components';
import {
  SparklesIcon,
  LightBulbIcon,
  CpuChipIcon,
  PaperAirplaneIcon
} from '@heroicons/react/24/solid';
import MainNavigation from '@components/ui/Navigation';
import EnhancedHeader from '@components/ui/EnhancedHeader';
import { WrenchScrewdriverIcon } from '@heroicons/react/24/solid';
import MarkdownRenderer from '@utils/markdownParser';
import { sanitizeMarkdownWithLimit } from '@utils/markdownSanitizer';
import { withTimeout, DEFAULT_AI_RETRY_OPTIONS } from '@utils/aiTimeout';
import { AI_MODELS, AI_PARAMETERS } from '@config/aiConfig';

/* ---------- Styled Components ---------- */
const Page = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
  display: flex;
  flex-direction: column;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 300px;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #06b6d4 100%);
    opacity: 0.08;
    z-index: 0;
  }
`;

const MainContent = styled.main`
  flex: 1;
  padding: 32px 32px 80px;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
  position: relative;
  z-index: 1;

  @media (max-width: 768px) {
    padding: 24px 20px 60px;
  }
`;

const AIBuilderContainer = styled.div`
  width: 100%;
  max-width: 1000px;
  margin: 0 auto;
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: blur(24px);
  border: 1px solid rgba(226, 232, 240, 0.4);
  border-radius: 20px;
  box-shadow: 0 12px 48px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 16px 64px rgba(99, 102, 241, 0.12);
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

const ChatHeader = styled.div`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  padding: 20px 24px;
  display: flex;
  align-items: center;
  gap: 12px;
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    animation: shimmer 3s infinite;
  }

  @keyframes shimmer {
    0% { left: -100%; }
    100% { left: 100%; }
  }
`;

const ChatTitle = styled.h3`
  margin: 0;
  font-size: 18px;
  font-weight: 700;
  letter-spacing: -0.01em;
  display: flex;
  align-items: center;
  gap: 8px;
`;

const ChatMessages = styled.div`
  height: 400px;
  overflow-y: auto;
  padding: 24px;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);

  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: rgba(226, 232, 240, 0.3);
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.3);
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background: rgba(99, 102, 241, 0.5);
  }
`;

interface ChatMessageProps {
  isUser: boolean;
}

const ChatMessage = styled.div<ChatMessageProps>`
  margin-bottom: 16px;
  display: flex;
  justify-content: ${props => props.isUser ? 'flex-end' : 'flex-start'};
  animation: fadeInUp 0.3s ease;

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
`;

const MessageBubble = styled.div<ChatMessageProps>`
  max-width: 80%;
  padding: 16px 20px;
  border-radius: ${props => props.isUser ? '20px 20px 4px 20px' : '20px 20px 20px 4px'};
  background: ${props => props.isUser
    ? 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)'
    : '#ffffff'};
  color: ${props => props.isUser ? '#ffffff' : '#374151'};
  border: ${props => props.isUser ? 'none' : '1px solid rgba(226, 232, 240, 0.6)'};
  font-size: 14px;
  line-height: 1.6;
  box-shadow: ${props => props.isUser
    ? '0 4px 16px rgba(99, 102, 241, 0.25)'
    : '0 2px 8px rgba(0, 0, 0, 0.08)'};
`;

const ChatInputContainer = styled.div`
  padding: 20px 24px;
  background: #ffffff;
  border-top: 1px solid rgba(226, 232, 240, 0.6);
  display: flex;
  gap: 12px;
  align-items: flex-end;
`;

const ChatInput = styled.textarea`
  flex: 1;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 12px;
  padding: 12px 16px;
  font-size: 14px;
  font-family: inherit;
  resize: none;
  min-height: 44px;
  max-height: 120px;
  background: rgba(248, 250, 252, 0.8);
  transition: all 0.3s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    background: #ffffff;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;

const SendButton = styled.button`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 12px;
  padding: 12px 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.3s ease;
  min-height: 44px;

  &:hover:not(:disabled) {
    background: linear-gradient(135deg, #5b5bf6 0%, #7c3aed 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const WelcomeMessage = styled.div`
  text-align: center;
  padding: 40px 20px;
  color: #6b7280;
  background: #ffffff;
  border-radius: 16px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  margin-bottom: 16px;
`;

const SuggestionChips = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 16px;
  justify-content: center;
`;

const SuggestionChip = styled.button`
  background: rgba(99, 102, 241, 0.1);
  color: #6366f1;
  border: 1px solid rgba(99, 102, 241, 0.2);
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.2);
    border-color: rgba(99, 102, 241, 0.4);
  }
`;

const AI_SYSTEM_PROMPT = `You are an expert AI Product Builder for insurance products. Help users create new products by analyzing existing products, coverages, and forms.

Your capabilities:
1. Product Analysis - Understand existing products and their structures
2. Intelligent Recommendations - Suggest optimal coverage combinations
3. Form Association - Recommend relevant forms for coverages
4. Product Structure - Help build complete product structures
5. Market Intelligence - Provide insights on product positioning

When users describe what they want to build:
- Ask clarifying questions
- Analyze existing products for patterns
- Suggest coverage combinations
- Recommend appropriate forms
- Help with naming and categorization
- Provide step-by-step guidance

Always be conversational, helpful, and professional. Use markdown formatting.`;

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
}

interface ContextData {
  products: Record<string, string>;
  coverages: Array<{ id: string; [key: string]: unknown }>;
  forms: Array<{ id: string; [key: string]: unknown }>;
}

const AIBuilder = () => {
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [chatInput, setChatInput] = useState('');
  const [chatLoading, setChatLoading] = useState(false);
  const [aiSuggestions, setAiSuggestions] = useState<string[]>([]);
  const [contextData, setContextData] = useState<ContextData | null>(null);

  // Fetch data on mount
  useEffect(() => {
    const fetchData = async () => {
      try {
        const productsSnap = await getDocs(collection(db, 'products'));
        const productMap: Record<string, string> = {};
        productsSnap.docs.forEach(doc => {
          const data = doc.data();
          // Only include non-archived products
          if (!data.archived) {
            productMap[doc.id] = data.name;
          }
        });

        const coveragesSnap = await getDocs(collectionGroup(db, 'coverages'));
        const coverageList = coveragesSnap.docs
          .map(doc => ({
            id: doc.id,
            ...doc.data(),
            productId: doc.ref.parent.parent?.id || '',
          }))
          // Filter out coverages from archived products
          .filter(coverage => productMap[coverage.productId]);

        const formsSnap = await getDocs(collection(db, 'forms'));
        const formList = formsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        setContextData({
          products: productMap,
          coverages: coverageList,
          forms: formList
        });

        setAiSuggestions([
          "Create a homeowners product similar to HO3 but for condos",
          "Build a commercial property product for small businesses",
          "Design an umbrella policy with high liability limits",
          "Create a renters insurance product for millennials",
          "Build a cyber liability product for tech companies"
        ]);
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };
    fetchData();
  }, []);

  const handleChatMessage = async () => {
    if (!chatInput.trim() || chatLoading || !contextData) return;

    const userMessage = chatInput.trim();
    setChatInput('');
    setChatLoading(true);

    const newUserMessage: ChatMessage = { role: 'user', content: userMessage };
    setChatMessages(prev => [...prev, newUserMessage]);

    try {
      // Build context string from available data
      const contextString = `Available Products: ${Object.keys(contextData.products).length}
Available Coverages: ${contextData.coverages.length}
Available Forms: ${contextData.forms.length}`;

      const generateChat = httpsCallable(functions, 'generateChatResponse');

      // Use timeout to prevent hanging requests
      const result = await withTimeout(
        generateChat({
          messages: [
            { role: 'system', content: AI_SYSTEM_PROMPT },
            { role: 'system', content: `Database context:\n${contextString}` },
            ...chatMessages,
            newUserMessage
          ],
          model: AI_MODELS.PRODUCT_BUILDER,
          maxTokens: AI_PARAMETERS.PRODUCT_BUILDER.max_tokens,
          temperature: AI_PARAMETERS.PRODUCT_BUILDER.temperature
        }) as Promise<any>,
        DEFAULT_AI_RETRY_OPTIONS.timeoutMs,
        'AI chat response'
      );

      const data = result.data as { success: boolean; content?: string };
      if (!data.success) {
        throw new Error('Failed to generate chat response');
      }

      // Sanitize markdown response to prevent XSS
      const aiResponse = sanitizeMarkdownWithLimit(data.content?.trim() || '', 5000);
      if (aiResponse) {
        setChatMessages(prev => [...prev, { role: 'assistant', content: aiResponse }]);
      }
    } catch (error) {
      console.error('Error in AI chat:', error);
      setChatMessages(prev => [...prev, {
        role: 'assistant',
        content: 'I apologize, but I encountered an error. Please try again.'
      }]);
    } finally {
      setChatLoading(false);
    }
  };

  const handleSuggestionClick = (suggestion: string) => {
    setChatInput(suggestion);
  };

  const handleChatKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleChatMessage();
    }
  };

  return (
    <Page>
      <MainNavigation />
      <MainContent>
        <EnhancedHeader
          title="AI Product Builder"
          subtitle="Describe your product vision and I'll help you build it intelligently"
          icon={WrenchScrewdriverIcon}
        />

        <AIBuilderContainer>
          <ChatHeader>
            <ChatTitle>
              <CpuChipIcon width={20} height={20} />
              AI Product Assistant
              <SparklesIcon width={16} height={16} style={{ marginLeft: 'auto', opacity: 0.8 }} />
            </ChatTitle>
          </ChatHeader>

          <ChatMessages>
            {chatMessages.length === 0 ? (
              <WelcomeMessage>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', marginBottom: '16px' }}>
                  <LightBulbIcon width={24} height={24} style={{ color: '#6366f1' }} />
                  <h4 style={{ margin: 0, color: '#374151' }}>Welcome to AI Product Builder</h4>
                </div>
                <p style={{ margin: '0 0 16px 0', color: '#6b7280', lineHeight: '1.6' }}>
                  I'm your intelligent assistant for building insurance products. I can analyze your existing products and help you create the perfect new one.
                </p>
                <p style={{ margin: 0, color: '#6b7280', fontSize: '14px' }}>
                  Try asking me something like "Create a condo insurance product" or click a suggestion below:
                </p>
                <SuggestionChips>
                  {aiSuggestions.map((suggestion, index) => (
                    <SuggestionChip
                      key={index}
                      onClick={() => handleSuggestionClick(suggestion)}
                    >
                      {suggestion}
                    </SuggestionChip>
                  ))}
                </SuggestionChips>
              </WelcomeMessage>
            ) : (
              chatMessages.map((message, index) => (
                <ChatMessage key={index} isUser={message.role === 'user'}>
                  <MessageBubble isUser={message.role === 'user'}>
                    {message.role === 'user' ? (
                      message.content
                    ) : (
                      <MarkdownRenderer>{message.content}</MarkdownRenderer>
                    )}
                  </MessageBubble>
                </ChatMessage>
              ))
            )}

            {chatLoading && (
              <ChatMessage isUser={false}>
                <MessageBubble isUser={false}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <div style={{
                      width: '16px',
                      height: '16px',
                      border: '2px solid #e5e7eb',
                      borderTop: '2px solid #6366f1',
                      borderRadius: '50%',
                      animation: 'spin 1s linear infinite'
                    }} />
                    Analyzing your request...
                  </div>
                </MessageBubble>
              </ChatMessage>
            )}
          </ChatMessages>

          <ChatInputContainer>
            <ChatInput
              placeholder="Describe the product you want to build..."
              value={chatInput}
              onChange={(e) => setChatInput(e.target.value)}
              onKeyDown={handleChatKeyDown}
              rows={1}
            />
            <SendButton
              onClick={handleChatMessage}
              disabled={!chatInput.trim() || chatLoading}
            >
              <PaperAirplaneIcon />
              Send
            </SendButton>
          </ChatInputContainer>
        </AIBuilderContainer>
      </MainContent>
    </Page>
  );
};

export default AIBuilder;

```

---

## src/components/Builder.tsx

**Path:** `src/components/Builder.tsx`

```tsx
import { useState, useEffect } from 'react';
import { collection, collectionGroup, getDocs, addDoc, updateDoc, doc, writeBatch, serverTimestamp, query, where, getDoc } from 'firebase/firestore';
import { db, storage } from '@/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import styled from 'styled-components';
import {
  WrenchScrewdriverIcon,
  MagnifyingGlassIcon
} from '@heroicons/react/24/solid';
import { useNavigate } from 'react-router-dom';
import MainNavigation from '@components/ui/Navigation';
import EnhancedHeader from '@components/ui/EnhancedHeader';
import ConfirmationModal from '@components/ui/ConfirmationModal';

/* ---------- Type Definitions ---------- */
interface CoverageItem {
  id: string;
  name?: string;
  coverageName?: string;
  coverageCode?: string;
  category?: string;
  productId: string;
  parentCoverageId?: string | null;
  scopeOfCoverage?: string;
  states?: string[];
}

interface CoverageDetails {
  subCoverages: Array<{ id: string; [key: string]: unknown }>;
  limits: Array<{ id: string; [key: string]: unknown }>;
  deductibles: Array<{ id: string; [key: string]: unknown }>;
  linkedFormIds: string[];
}

interface SelectedCoveragesMap {
  [coverageId: string]: CoverageItem;
}

interface CoverageDetailsMap {
  [coverageId: string]: CoverageDetails;
}

interface ProductsMap {
  [productId: string]: string;
}

/* ---------- Styled Components (reused from ProductBuilder) ---------- */
const Page = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
  display: flex;
  flex-direction: column;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 300px;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #06b6d4 100%);
    opacity: 0.08;
    z-index: 0;
  }
`;

const MainContent = styled.main`
  flex: 1;
  padding: 32px 32px 80px;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
  position: relative;
  z-index: 1;

  @media (max-width: 768px) {
    padding: 24px 20px 60px;
  }
`;

const ProductBuilderGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 24px;
  margin-bottom: 40px;
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;

  @media (max-width: 1200px) {
    grid-template-columns: 1fr;
    & > *:last-child {
      grid-column: 1 / -1;
    }
  }

  @media (max-width: 1024px) {
    grid-template-columns: 1fr;
    gap: 20px;
  }
`;

const CoverageBrowserContainer = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

const CoverageBrowserHeader = styled.div`
  padding: 24px 24px 16px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
`;

const SearchFilterContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 16px;
`;

const SearchInput = styled.input`
  width: 100%;
  padding: 12px 16px 12px 40px;
  font-size: 14px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(20px);
  transition: all 0.3s ease;
  position: relative;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;

const SearchIconWrapper = styled.div`
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: #94a3b8;
  pointer-events: none;
`;

const FilterRow = styled.div`
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
`;

const FilterSelect = styled.select`
  padding: 8px 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 8px;
  background: white;
  font-size: 13px;
  color: #374151;
  cursor: pointer;
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
  }
`;

const CoverageCardsGrid = styled.div`
  padding: 16px;
  max-height: 600px;
  overflow-y: auto;
  display: grid;
  gap: 12px;

  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: rgba(226, 232, 240, 0.3);
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.3);
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background: rgba(99, 102, 241, 0.5);
  }
`;

const CoverageCard = styled.div<{ $selected?: boolean }>`
  padding: 16px;
  border: 1px solid ${props => props.$selected ? '#6366f1' : 'rgba(226, 232, 240, 0.6)'};
  border-radius: 12px;
  background: ${props => props.$selected ? 'rgba(99, 102, 241, 0.05)' : 'white'};
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;

  &:hover {
    border-color: #6366f1;
    background: rgba(99, 102, 241, 0.02);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  ${props => props.$selected && `
    box-shadow: 0 4px 16px rgba(99, 102, 241, 0.2);
  `}
`;

const CoverageCardHeader = styled.div`
  display: flex;
  justify-content: between;
  align-items: flex-start;
  margin-bottom: 8px;
`;

const CoverageCardTitle = styled.h4`
  margin: 0;
  font-size: 14px;
  font-weight: 600;
  color: #374151;
  line-height: 1.3;
  flex: 1;
`;

const CoverageCardBadge = styled.span`
  padding: 2px 8px;
  background: rgba(99, 102, 241, 0.1);
  color: #6366f1;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 500;
  margin-left: 8px;
`;

const CoverageCardMeta = styled.div`
  font-size: 12px;
  color: #6b7280;
  margin-bottom: 8px;
`;

const CoverageCardActions = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 12px;
`;

const FormCount = styled.span`
  font-size: 11px;
  color: #6b7280;
  background: rgba(107, 114, 128, 0.1);
  padding: 2px 6px;
  border-radius: 8px;
`;

const SelectButton = styled.button<{ $selected?: boolean }>`
  padding: 4px 12px;
  background: ${props => props.$selected ? '#6366f1' : 'transparent'};
  color: ${props => props.$selected ? 'white' : '#6366f1'};
  border: 1px solid #6366f1;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: ${props => props.$selected ? '#4f46e5' : 'rgba(99, 102, 241, 0.1)'};
  }
`;

const ProductBuilderPanel = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

const ProductBuilderHeader = styled.div`
  padding: 24px 24px 16px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
`;

const ProductBuilderContent = styled.div`
  padding: 24px;
`;

const SectionTitle = styled.h2`
  font-size: 1.5rem;
  font-weight: 600;
  background: linear-gradient(135deg, #1e293b 0%, #475569 50%, #64748b 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin: 0 0 24px 0;
  letter-spacing: -0.01em;
`;

const SelectedCoveragesContainer = styled.div`
  margin-bottom: 24px;
`;

const SelectedCoveragesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 300px;
  overflow-y: auto;
  padding: 12px;
  background: rgba(248, 250, 252, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);
`;

const SelectedCoverageItem = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background: white;
  border-radius: 8px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  transition: all 0.2s ease;

  &:hover {
    border-color: rgba(99, 102, 241, 0.3);
    background: rgba(99, 102, 241, 0.02);
  }
`;

const SelectedCoverageInfo = styled.div`
  flex: 1;
`;

const SelectedCoverageName = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 4px;
`;

const SelectedCoverageDetails = styled.div`
  font-size: 11px;
  color: #6b7280;
  display: flex;
  gap: 12px;
`;

const RemoveCoverageButton = styled.button`
  padding: 4px 8px;
  background: rgba(239, 68, 68, 0.1);
  border: none;
  color: #ef4444;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s ease;
  font-size: 12px;
  font-weight: 500;

  &:hover {
    background: rgba(239, 68, 68, 0.2);
  }
`;

const CoverageDetailsPanel = styled.div`
  background: rgba(248, 250, 252, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  padding: 16px;
  margin-top: 16px;
`;

const DetailRow = styled.div`
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  font-size: 13px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.4);

  &:last-child {
    border-bottom: none;
  }
`;

const DetailLabel = styled.span`
  font-weight: 600;
  color: #374151;
`;

const DetailValue = styled.span`
  color: #6b7280;
`;

const FormGroup = styled.div`
  margin-bottom: 16px;
`;

const FormLabel = styled.label`
  display: block;
  font-size: 13px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 6px;
`;

const FormInput = styled.input`
  width: 100%;
  padding: 10px 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 8px;
  font-size: 13px;
  background: white;
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;

const FileInput = styled.input`
  display: none;
`;

const FileInputLabel = styled.label`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 16px;
  border: 2px dashed rgba(99, 102, 241, 0.3);
  border-radius: 8px;
  background: rgba(99, 102, 241, 0.02);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 13px;
  color: #6366f1;
  font-weight: 500;

  &:hover {
    border-color: rgba(99, 102, 241, 0.5);
    background: rgba(99, 102, 241, 0.05);
  }
`;

const CreateButton = styled.button`
  width: 100%;
  padding: 12px 16px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;

  &:hover:not(:disabled) {
    background: linear-gradient(135deg, #5b5bf6 0%, #7c3aed 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

const Builder = () => {
  const [coverages, setCoverages] = useState<CoverageItem[]>([]);
  const [products, setProducts] = useState<ProductsMap>({});
  const [selectedCoverages, setSelectedCoverages] = useState<SelectedCoveragesMap>({});
  const [coverageDetails, setCoverageDetails] = useState<CoverageDetailsMap>({});
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedProductFilter, setSelectedProductFilter] = useState('');
  const [selectedCategoryFilter, setSelectedCategoryFilter] = useState('');

  // Product creation state
  const [newProductName, setNewProductName] = useState('');
  const [formNumber, setFormNumber] = useState('');
  const [productCode, setProductCode] = useState('');
  const [effectiveDate, setEffectiveDate] = useState('');
  const [file, setFile] = useState<File | null>(null);
  const [isCreating, setIsCreating] = useState(false);
  const [showConfirmation, setShowConfirmation] = useState(false);

  const navigate = useNavigate();

  // Fetch data on mount
  useEffect(() => {
    const fetchData = async () => {
      try {
        const productsSnap = await getDocs(collection(db, 'products'));
        const productMap: ProductsMap = {};
        productsSnap.docs.forEach(docSnap => {
          const data = docSnap.data();
          // Only include non-archived products
          if (!data.archived) {
            productMap[docSnap.id] = data.name;
          }
        });
        setProducts(productMap);

        const coveragesSnap = await getDocs(collectionGroup(db, 'coverages'));
        const coverageList: CoverageItem[] = coveragesSnap.docs
          .map(docSnap => ({
            id: docSnap.id,
            ...docSnap.data(),
            productId: docSnap.ref.parent.parent?.id || '',
          } as CoverageItem))
          // Filter out coverages from archived products
          .filter(coverage => productMap[coverage.productId]);
        setCoverages(coverageList);
      } catch (error) {
        console.error('Error fetching data:', error);
        alert('Failed to load data. Please try again.');
      }
    };
    fetchData();
  }, []);

  // Fetch coverage details including sub-coverages, limits, deductibles, and forms
  const fetchCoverageDetails = async (coverageId: string, productId: string) => {
    try {
      // Get sub-coverages
      const subCoveragesSnap = await getDocs(
        query(
          collection(db, `products/${productId}/coverages`),
          where('parentCoverageId', '==', coverageId)
        )
      );
      const subCoverages = subCoveragesSnap.docs.map(docSnap => ({
        id: docSnap.id,
        ...docSnap.data()
      }));

      // Get limits
      const limitsSnap = await getDocs(
        collection(db, `products/${productId}/coverages/${coverageId}/limits`)
      );
      const limits = limitsSnap.docs.map(docSnap => ({
        id: docSnap.id,
        ...docSnap.data()
      }));

      // Get deductibles
      const deductiblesSnap = await getDocs(
        collection(db, `products/${productId}/coverages/${coverageId}/deductibles`)
      );
      const deductibles = deductiblesSnap.docs.map(docSnap => ({
        id: docSnap.id,
        ...docSnap.data()
      }));

      // Get linked forms
      const formsSnap = await getDocs(
        query(
          collection(db, 'formCoverages'),
          where('coverageId', '==', coverageId),
          where('productId', '==', productId)
        )
      );
      const linkedFormIds = formsSnap.docs.map(docSnap => docSnap.data().formId);

      setCoverageDetails(prev => ({
        ...prev,
        [coverageId]: {
          subCoverages,
          limits,
          deductibles,
          linkedFormIds
        }
      }));
    } catch (error) {
      console.error('Error fetching coverage details:', error);
    }
  };

  const filteredCoverages = coverages.filter(c => {
    const matchesSearch = !searchTerm ||
      (c.name || '').toLowerCase().includes(searchTerm.toLowerCase()) ||
      (c.coverageCode || '').toLowerCase().includes(searchTerm.toLowerCase());

    const matchesProduct = !selectedProductFilter || c.productId === selectedProductFilter;
    const matchesCategory = !selectedCategoryFilter || c.category === selectedCategoryFilter;

    return matchesSearch && matchesProduct && matchesCategory;
  });

  const uniqueProducts = [...new Set(coverages.map(c => c.productId))].map(pid => ({
    id: pid,
    name: products[pid] || 'Unknown'
  }));

  const uniqueCategories = [...new Set(coverages.map(c => c.category).filter(Boolean))] as string[];

  const handleSmartCoverageSelect = async (coverage: CoverageItem) => {
    setSelectedCoverages(prev => {
      const newSelected = { ...prev };
      if (newSelected[coverage.id]) {
        delete newSelected[coverage.id];
        // Clean up details when deselecting
        setCoverageDetails(prevDetails => {
          const newDetails = { ...prevDetails };
          delete newDetails[coverage.id];
          return newDetails;
        });
      } else {
        newSelected[coverage.id] = coverage;
        // Fetch coverage details when selecting
        fetchCoverageDetails(coverage.id, coverage.productId);
      }
      return newSelected;
    });
  };

  const handleRemoveCoverage = (coverageId: string) => {
    setSelectedCoverages(prev => {
      const newSelected = { ...prev };
      delete newSelected[coverageId];
      return newSelected;
    });
    setCoverageDetails(prev => {
      const newDetails = { ...prev };
      delete newDetails[coverageId];
      return newDetails;
    });
  };

  // Create product with form auto-add
  const handleCreateProduct = async () => {
    if (!newProductName || !formNumber || !effectiveDate || Object.keys(selectedCoverages).length === 0) {
      alert('Please fill in all required fields and select at least one coverage.');
      return;
    }

    // Validate 4-digit year
    if (!/^\d{4}$/.test(effectiveDate)) {
      alert('Please enter a valid 4-digit year (e.g., 2024).');
      return;
    }

    setShowConfirmation(true);
  };

  const handleConfirmCreateProduct = async () => {
    setIsCreating(true);
    try {
      let formDownloadUrl = '';
      let formFilePath = '';

      // Upload form file if provided
      if (file) {
        const storageRef = ref(storage, `forms/${Date.now()}_${file.name}`);
        await uploadBytes(storageRef, file);
        formDownloadUrl = await getDownloadURL(storageRef);
        formFilePath = storageRef.fullPath;
      }

      // Create new product
      const productRef = await addDoc(collection(db, 'products'), {
        name: newProductName,
        formNumber,
        productCode: productCode || '',
        effectiveDate,
        createdAt: serverTimestamp(),
      });
      const newProductId = productRef.id;

      // Create coverages for new product (with sub-coverages, limits, and deductibles)
      const newCoverageIds: { [key: string]: string } = {};

      // Helper function to recursively clone a coverage and all its related data
      const cloneCoverage = async (sourceCoverageId: string, sourceProductId: string, targetProductId: string, parentCoverageId: string | null = null): Promise<string | null> => {
        // Get source coverage data
        const sourceCoverageRef = doc(db, `products/${sourceProductId}/coverages`, sourceCoverageId);
        const sourceCoverageSnap = await getDoc(sourceCoverageRef);
        if (!sourceCoverageSnap.exists()) return null;

        const sourceCoverageData = sourceCoverageSnap.data();

        // Create new coverage
        const newCoverageRef = await addDoc(
          collection(db, `products/${targetProductId}/coverages`),
          {
            name: sourceCoverageData.name || 'Unnamed Coverage',
            coverageCode: sourceCoverageData.coverageCode || '',
            coverageName: sourceCoverageData.coverageName || '',
            scopeOfCoverage: sourceCoverageData.scopeOfCoverage || '',
            category: sourceCoverageData.category || 'Base Coverage',
            parentCoverageId: parentCoverageId,
            createdAt: serverTimestamp(),
          }
        );
        const newCoverageId = newCoverageRef.id;

        // Clone limits
        const limitsSnap = await getDocs(collection(db, `products/${sourceProductId}/coverages/${sourceCoverageId}/limits`));
        if (limitsSnap.docs.length > 0) {
          const batch = writeBatch(db);
          limitsSnap.docs.forEach(limitDoc => {
            const limitRef = doc(collection(db, `products/${targetProductId}/coverages/${newCoverageId}/limits`));
            batch.set(limitRef, limitDoc.data());
          });
          await batch.commit();
        }

        // Clone deductibles
        const deductiblesSnap = await getDocs(collection(db, `products/${sourceProductId}/coverages/${sourceCoverageId}/deductibles`));
        if (deductiblesSnap.docs.length > 0) {
          const batch = writeBatch(db);
          deductiblesSnap.docs.forEach(deductibleDoc => {
            const deductibleRef = doc(collection(db, `products/${targetProductId}/coverages/${newCoverageId}/deductibles`));
            batch.set(deductibleRef, deductibleDoc.data());
          });
          await batch.commit();
        }

        // Clone states
        if (sourceCoverageData.states && sourceCoverageData.states.length > 0) {
          await updateDoc(doc(db, `products/${targetProductId}/coverages`, newCoverageId), {
            states: sourceCoverageData.states
          });
        }

        // Clone sub-coverages recursively
        const subCoveragesSnap = await getDocs(
          query(
            collection(db, `products/${sourceProductId}/coverages`),
            where('parentCoverageId', '==', sourceCoverageId)
          )
        );
        for (const subCoverageDoc of subCoveragesSnap.docs) {
          await cloneCoverage(subCoverageDoc.id, sourceProductId, targetProductId, newCoverageId);
        }

        return newCoverageId;
      };

      // Clone all selected coverages
      for (const coverageId in selectedCoverages) {
        const coverage = selectedCoverages[coverageId];
        if (coverage) {
          const newCoverageId = await cloneCoverage(coverageId, coverage.productId, newProductId);
          if (newCoverageId) {
            newCoverageIds[coverageId] = newCoverageId;
          }
        }
      }

      // Clone pricing steps from source product
      const sourceProductId = Object.values(selectedCoverages)[0]?.productId;
      if (sourceProductId) {
        const pricingSnap = await getDocs(collection(db, `products/${sourceProductId}/steps`));
        if (pricingSnap.docs.length > 0) {
          const batch = writeBatch(db);
          pricingSnap.docs.forEach(pricingDoc => {
            const pricingRef = doc(collection(db, `products/${newProductId}/steps`));
            batch.set(pricingRef, pricingDoc.data());
          });
          await batch.commit();
        }
      }

      // Clone rules from source product
      if (sourceProductId) {
        const rulesSnap = await getDocs(
          query(collection(db, 'rules'), where('productId', '==', sourceProductId))
        );
        if (rulesSnap.docs.length > 0) {
          const batch = writeBatch(db);
          rulesSnap.docs.forEach(ruleDoc => {
            const ruleData = ruleDoc.data();
            const ruleRef = doc(collection(db, 'rules'));
            batch.set(ruleRef, {
              ...ruleData,
              productId: newProductId,
              createdAt: serverTimestamp()
            });
          });
          await batch.commit();
        }
      }

      // âœ… AUTO-ADD FORM: If form was uploaded, create form document and link to coverages
      if (file && formDownloadUrl) {
        const newFormRef = await addDoc(collection(db, 'forms'), {
          formName: file.name.replace(/\.[^/.]+$/, ''), // Remove file extension
          formNumber: formNumber,
          effectiveDate: effectiveDate,
          type: 'Custom',
          category: 'Product Form',
          productId: newProductId,
          downloadUrl: formDownloadUrl,
          filePath: formFilePath,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          isActive: true,
          edition: new Date().toLocaleDateString('en-US', { month: '2-digit', year: '2-digit' })
        });
        const newFormId = newFormRef.id;

        // Create form-coverage links for all selected coverages
        const batch = writeBatch(db);
        const newCoverageIdsList = Object.values(newCoverageIds);

        for (let i = 0; i < newCoverageIdsList.length; i++) {
          const newCoverageId = newCoverageIdsList[i];
          const mappingRef = doc(collection(db, 'formCoverages'));
          batch.set(mappingRef, {
            formId: newFormId,
            coverageId: newCoverageId,
            productId: newProductId,
            isPrimary: i === 0, // First coverage is primary
            displayOrder: i,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()
          });
        }
        await batch.commit();

        console.log(`âœ… Form auto-added: ${newFormId} linked to ${newCoverageIdsList.length} coverages`);
      }

      // Navigate to product hub with the new product ID
      navigate(`/product-hub?productId=${newProductId}`, { replace: true });
      // Force a small delay to ensure navigation completes
      setTimeout(() => {
        window.location.reload();
      }, 500);
      setShowConfirmation(false);
    } catch (error) {
      console.error('Error creating product:', error);
      alert('Failed to create product. Please try again.');
      setShowConfirmation(false);
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <Page>
      <MainNavigation />
      <MainContent>
        <EnhancedHeader
          title="Product Builder"
          subtitle="Select coverages and build your insurance product"
          icon={WrenchScrewdriverIcon}
        />

        <ProductBuilderGrid>
          <CoverageBrowserContainer>
            <CoverageBrowserHeader>
              <SectionTitle style={{ margin: '0 0 16px 0' }}>Coverage Library</SectionTitle>
              <SearchFilterContainer>
                <div style={{ position: 'relative' }}>
                  <SearchInput
                    placeholder="Search coverages by name, code, or scope..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                  <SearchIconWrapper>
                    <MagnifyingGlassIcon width={16} height={16} />
                  </SearchIconWrapper>
                </div>
                <FilterRow>
                  <FilterSelect
                    value={selectedProductFilter}
                    onChange={(e) => setSelectedProductFilter(e.target.value)}
                  >
                    <option value="">All Products</option>
                    {uniqueProducts.map(product => (
                      <option key={product.id} value={product.id}>
                        {product.name}
                      </option>
                    ))}
                  </FilterSelect>
                  <FilterSelect
                    value={selectedCategoryFilter}
                    onChange={(e) => setSelectedCategoryFilter(e.target.value)}
                  >
                    <option value="">All Categories</option>
                    {uniqueCategories.map(category => (
                      <option key={category} value={category}>
                        {category}
                      </option>
                    ))}
                  </FilterSelect>
                </FilterRow>
              </SearchFilterContainer>
            </CoverageBrowserHeader>

            <CoverageCardsGrid>
              {filteredCoverages.map(coverage => {
                const isSelected = !!selectedCoverages[coverage.id];
                return (
                  <CoverageCard
                    key={coverage.id}
                    $selected={isSelected}
                    onClick={() => handleSmartCoverageSelect(coverage)}
                  >
                    <CoverageCardHeader>
                      <CoverageCardTitle>
                        {coverage.name || coverage.coverageName || 'Unnamed Coverage'}
                      </CoverageCardTitle>
                      {coverage.category && (
                        <CoverageCardBadge>{coverage.category}</CoverageCardBadge>
                      )}
                    </CoverageCardHeader>

                    <CoverageCardMeta>
                      <div>Product: {products[coverage.productId] || 'Unknown'}</div>
                      {coverage.coverageCode && <div>Code: {coverage.coverageCode}</div>}
                    </CoverageCardMeta>

                    <CoverageCardActions>
                      <FormCount>0 forms</FormCount>
                      <SelectButton $selected={isSelected}>
                        {isSelected ? 'Selected' : 'Select'}
                      </SelectButton>
                    </CoverageCardActions>
                  </CoverageCard>
                );
              })}
            </CoverageCardsGrid>
          </CoverageBrowserContainer>

          <ProductBuilderPanel>
            <ProductBuilderHeader>
              <SectionTitle style={{ margin: '0 0 8px 0' }}>Product Builder</SectionTitle>
              <div style={{ fontSize: '13px', color: '#6b7280' }}>
                {Object.keys(selectedCoverages).length} coverages selected
              </div>
            </ProductBuilderHeader>

            <ProductBuilderContent>
              {Object.keys(selectedCoverages).length === 0 ? (
                <p style={{ color: '#6b7280', fontSize: '14px' }}>
                  Select coverages from the library to get started building your product.
                </p>
              ) : (
                <>
                  <h4 style={{ margin: '0 0 16px 0', fontSize: '13px', fontWeight: '600', color: '#374151' }}>
                    Product Details
                  </h4>
                  <FormGroup>
                    <FormLabel>Product Name *</FormLabel>
                    <FormInput
                      type="text"
                      placeholder="e.g., Homeowners Insurance"
                      value={newProductName}
                      onChange={(e) => setNewProductName(e.target.value)}
                    />
                  </FormGroup>

                  <FormGroup>
                    <FormLabel>Form Number *</FormLabel>
                    <FormInput
                      type="text"
                      placeholder="e.g., HO-001"
                      value={formNumber}
                      onChange={(e) => setFormNumber(e.target.value)}
                    />
                  </FormGroup>

                  <FormGroup>
                    <FormLabel>Product Code</FormLabel>
                    <FormInput
                      type="text"
                      placeholder="e.g., HO"
                      value={productCode}
                      onChange={(e) => setProductCode(e.target.value)}
                    />
                  </FormGroup>

                  <FormGroup>
                    <FormLabel>Year *</FormLabel>
                    <FormInput
                      type="text"
                      placeholder="e.g., 2024"
                      maxLength={4}
                      value={effectiveDate}
                      onChange={(e) => {
                        const value = e.target.value.replace(/\D/g, '').slice(0, 4);
                        setEffectiveDate(value);
                      }}
                    />
                  </FormGroup>

                  <FormGroup>
                    <FormLabel>Upload Form (PDF)</FormLabel>
                    <FileInput
                      id="form-file"
                      type="file"
                      accept=".pdf"
                      onChange={(e) => setFile(e.target.files?.[0] || null)}
                    />
                    <FileInputLabel htmlFor="form-file">
                      {file ? `âœ“ ${file.name}` : 'ðŸ“„ Click to upload PDF form'}
                    </FileInputLabel>
                  </FormGroup>

                  <CreateButton
                    onClick={handleCreateProduct}
                    disabled={isCreating || !newProductName || !formNumber || !effectiveDate}
                  >
                    {isCreating ? 'Creating...' : 'Create Product'}
                  </CreateButton>

                  <SelectedCoveragesContainer style={{ marginTop: '24px' }}>
                  <h4 style={{ margin: '0 0 12px 0', fontSize: '13px', fontWeight: '600', color: '#374151' }}>
                    Selected Coverages
                  </h4>
                  <SelectedCoveragesList>
                    {Object.entries(selectedCoverages).map(([covId, coverage]) => {
                      const details = coverageDetails[covId];
                      return (
                        <SelectedCoverageItem key={covId}>
                          <SelectedCoverageInfo>
                            <SelectedCoverageName>
                              {coverage.name || coverage.coverageName || 'Unnamed'}
                            </SelectedCoverageName>
                            <SelectedCoverageDetails>
                              {details && (
                                <>
                                  <span>{details.subCoverages?.length || 0} sub-coverages</span>
                                  <span>{details.limits?.length || 0} limits</span>
                                  <span>{details.deductibles?.length || 0} deductibles</span>
                                  <span>{details.linkedFormIds?.length || 0} forms</span>
                                </>
                              )}
                            </SelectedCoverageDetails>
                          </SelectedCoverageInfo>
                          <RemoveCoverageButton onClick={() => handleRemoveCoverage(covId)}>
                            Remove
                          </RemoveCoverageButton>
                        </SelectedCoverageItem>
                      );
                    })}
                  </SelectedCoveragesList>

                  {Object.keys(selectedCoverages).length > 0 && Object.values(coverageDetails).some(d => d) && (
                    <CoverageDetailsPanel>
                      <h4 style={{ margin: '0 0 12px 0', fontSize: '13px', fontWeight: '600', color: '#374151' }}>
                        Coverage Details
                      </h4>
                      {Object.entries(selectedCoverages).map(([covId, coverage]) => {
                        const details = coverageDetails[covId];
                        if (!details) return null;
                        return (
                          <div key={covId} style={{ marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid rgba(226, 232, 240, 0.6)' }}>
                            <DetailRow>
                              <DetailLabel>{coverage.name || 'Coverage'}</DetailLabel>
                              <DetailValue>{coverage.coverageCode || 'N/A'}</DetailValue>
                            </DetailRow>
                            <DetailRow>
                              <DetailLabel>Sub-Coverages</DetailLabel>
                              <DetailValue>{details.subCoverages?.length || 0}</DetailValue>
                            </DetailRow>
                            <DetailRow>
                              <DetailLabel>Limits</DetailLabel>
                              <DetailValue>{details.limits?.length || 0}</DetailValue>
                            </DetailRow>
                            <DetailRow>
                              <DetailLabel>Deductibles</DetailLabel>
                              <DetailValue>{details.deductibles?.length || 0}</DetailValue>
                            </DetailRow>
                            <DetailRow>
                              <DetailLabel>Linked Forms</DetailLabel>
                              <DetailValue>{details.linkedFormIds?.length || 0}</DetailValue>
                            </DetailRow>
                          </div>
                        );
                      })}
                    </CoverageDetailsPanel>
                  )}
                  </SelectedCoveragesContainer>
                </>
              )}
            </ProductBuilderContent>
          </ProductBuilderPanel>
        </ProductBuilderGrid>

        {/* Create Product Confirmation Modal */}
        <ConfirmationModal
          isOpen={showConfirmation}
          title="Create Product"
          message={`Create product "${newProductName}" with ${Object.keys(selectedCoverages).length} coverage(s)? All related data including sub-coverages, limits, deductibles, pricing, and rules will be cloned.`}
          confirmText="Create"
          cancelText="Cancel"
          isDangerous={false}
          isLoading={isCreating}
          onConfirm={handleConfirmCreateProduct}
          onCancel={() => setShowConfirmation(false)}
        />
      </MainContent>
    </Page>
  );
};

export default Builder;

```

---

## src/components/ClaimsAnalysis.tsx

**Path:** `src/components/ClaimsAnalysis.tsx`

```tsx
import React, { useState, useEffect, useRef } from 'react';
import { db } from '@/firebase';
import { collection, getDocs } from 'firebase/firestore';
import {
  DocumentTextIcon,
  ChatBubbleLeftRightIcon,
  MagnifyingGlassIcon,
  PaperAirplaneIcon
} from '@heroicons/react/24/solid';
import styled, { keyframes } from 'styled-components';
import MainNavigation from './ui/Navigation';
import { Button } from './ui/Button';
import { TextInput } from './ui/Input';
import { UnifiedAIResponse } from './ui/UnifiedAIResponse';
import EnhancedHeader from './ui/EnhancedHeader';
import { PageContainer, PageContent } from './ui/PageContainer';
import { Breadcrumb } from './ui/Breadcrumb';
import { processFormsForAnalysis } from '@utils/pdfChunking';
import { analyzeClaimWithChunking } from '../services/claimsAnalysisService';
import logger, { LOG_CATEGORIES } from '../utils/logger';
import LoadingSpinner from './ui/LoadingSpinner';
import { EmptyState } from './ui/EmptyState';

/* ---------- Type Definitions ---------- */
interface MessageErrorBoundaryProps {
  children: React.ReactNode;
}

interface MessageErrorBoundaryState {
  hasError: boolean;
}

interface ClaimsErrorBoundaryProps {
  children: React.ReactNode;
}

interface ClaimsErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

interface FormItem {
  id: string;
  formName?: string;
  formNumber?: string;
  category?: string;
  downloadUrl?: string;
  [key: string]: unknown;
}

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

// Error boundary component for message content
class MessageErrorBoundary extends React.Component<MessageErrorBoundaryProps, MessageErrorBoundaryState> {
  constructor(props: MessageErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(_error: Error): MessageErrorBoundaryState {
    return { hasError: true };
  }

  override componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    logger.error(LOG_CATEGORIES.ERROR, 'Message rendering error', { errorInfo }, error);
  }

  override render(): React.ReactNode {
    if (this.state.hasError) {
      return (
        <div style={{
          padding: '16px',
          background: '#fee2e2',
          border: '1px solid #fecaca',
          borderRadius: '8px',
          color: '#dc2626'
        }}>
          <strong>Error displaying message</strong>
          <p style={{ margin: '8px 0 0 0', fontSize: '14px' }}>
            There was an error rendering this message. The content may contain invalid formatting.
          </p>
        </div>
      );
    }

    return this.props.children;
  }
}

// Top-level error boundary for the entire component
class ClaimsAnalysisErrorBoundary extends React.Component<ClaimsErrorBoundaryProps, ClaimsErrorBoundaryState> {
  constructor(props: ClaimsErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ClaimsErrorBoundaryState {
    return { hasError: true, error };
  }

  override componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    logger.error(LOG_CATEGORIES.ERROR, 'Claims Analysis component error', { errorInfo }, error);
  }

  override render(): React.ReactNode {
    if (this.state.hasError) {
      return (
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          background: 'linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%)'
        }}>
          <div style={{
            maxWidth: '500px',
            padding: '32px',
            background: 'white',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
            textAlign: 'center'
          }}>
            <h2 style={{ color: '#dc2626', marginBottom: '16px' }}>Claims Analysis Error</h2>
            <p style={{ color: '#64748b', marginBottom: '24px' }}>
              Something went wrong while loading the Claims Analysis page. Please try refreshing the page.
            </p>
            <button
              onClick={() => window.location.reload()}
              style={{
                background: '#6366f1',
                color: 'white',
                border: 'none',
                padding: '12px 24px',
                borderRadius: '8px',
                cursor: 'pointer'
              }}
            >
              Refresh Page
            </button>
            {this.state.error && (
              <details style={{ marginTop: '16px', textAlign: 'left' }}>
                <summary style={{ cursor: 'pointer', color: '#64748b' }}>Error Details</summary>
                <pre style={{
                  background: '#f8fafc',
                  padding: '12px',
                  borderRadius: '4px',
                  fontSize: '12px',
                  overflow: 'auto',
                  marginTop: '8px'
                }}>
                  {this.state.error.toString()}
                </pre>
              </details>
            )}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

/* ---------- Animations ---------- */
const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
`;

const slideIn = keyframes`
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
`;

/* ---------- Claims Stats Dashboard ---------- */
const ClaimsStatsDashboard = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
  animation: ${slideIn} 0.4s ease-out;
`;

const ClaimsStatCard = styled.div<{ $color?: string }>`
  background: white;
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: ${({ $color }) => $color || 'linear-gradient(90deg, #6366f1, #8b5cf6)'};
  }

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
    border-color: transparent;
  }
`;

const ClaimsStatValue = styled.div`
  font-size: 28px;
  font-weight: 700;
  color: #1e293b;
  margin-bottom: 4px;
  letter-spacing: -0.02em;
`;

const ClaimsStatLabel = styled.div`
  font-size: 13px;
  font-weight: 500;
  color: #64748b;
  display: flex;
  align-items: center;
  gap: 6px;

  svg {
    width: 14px;
    height: 14px;
    opacity: 0.7;
  }
`;

/* ---------- Styled Components ---------- */
const ContentGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 32px;
  height: calc(100vh - 200px);

  @media (max-width: 1024px) {
    grid-template-columns: 1fr;
    height: auto;
    gap: 24px;
  }
`;

const Panel = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  display: flex;
  flex-direction: column;
  overflow: hidden;
`;

const PanelHeader = styled.div`
  padding: 24px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.05), rgba(139, 92, 246, 0.05));
`;

const PanelTitle = styled.h2`
  font-size: 20px;
  font-weight: 600;
  color: #1e293b;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 12px;

  svg {
    width: 24px;
    height: 24px;
    color: #6366f1;
  }
`;

const PanelContent = styled.div`
  flex: 1;
  padding: 24px;
  overflow-y: auto;
`;

/* ---------- Forms Selection Panel ---------- */
const SearchContainer = styled.div`
  position: relative;
  margin-bottom: 20px;
`;

const SearchInput = styled(TextInput)`
  width: 100%;
  padding: 12px 20px 12px 48px;
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  background: rgba(255, 255, 255, 0.9);

  &:focus {
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const SearchIcon = styled(MagnifyingGlassIcon)`
  position: absolute;
  left: 16px;
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  color: #6366f1;
  pointer-events: none;
`;

const FormsList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: 400px;
  overflow-y: auto;
`;

const FormItemStyled = styled.div<{ $selected?: boolean }>`
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  border: 2px solid ${props => props.$selected ? '#6366f1' : 'rgba(226, 232, 240, 0.6)'};
  border-radius: 12px;
  background: ${props => props.$selected ? 'rgba(99, 102, 241, 0.05)' : 'rgba(255, 255, 255, 0.8)'};
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: #6366f1;
    background: rgba(99, 102, 241, 0.05);
    transform: translateY(-1px);
  }
`;

const FormRadio = styled.div<{ $checked?: boolean }>`
  width: 20px;
  height: 20px;
  border: 2px solid ${props => props.$checked ? '#6366f1' : '#d1d5db'};
  border-radius: 50%;
  background: ${props => props.$checked ? '#6366f1' : 'transparent'};
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  position: relative;

  &::after {
    content: '';
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: white;
    opacity: ${props => props.$checked ? 1 : 0};
    transition: opacity 0.2s ease;
  }
`;

const FormInfo = styled.div`
  flex: 1;
`;

const FormName = styled.div`
  font-weight: 600;
  color: #1e293b;
  font-size: 14px;
  margin-bottom: 4px;
`;

const FormMeta = styled.div`
  font-size: 12px;
  color: #64748b;
`;

const SelectedCount = styled.div`
  margin-top: 16px;
  padding: 12px;
  background: rgba(99, 102, 241, 0.1);
  border-radius: 8px;
  font-size: 14px;
  color: #6366f1;
  font-weight: 500;
  text-align: center;
`;

/* ---------- Chat Panel ---------- */
const ChatContainer = styled.div`
  display: flex;
  flex-direction: column;
  height: 100%;
`;

const MessagesArea = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 0 4px;
  margin-bottom: 20px;
`;

const Message = styled.div`
  margin-bottom: 20px;
  animation: ${fadeIn} 0.3s ease;
`;

const MessageHeader = styled.div<{ $isUser?: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 12px;
  font-weight: 600;
  color: ${props => props.$isUser ? '#6366f1' : '#059669'};
  text-transform: uppercase;
  letter-spacing: 0.05em;
`;

const MessageContent = styled.div<{ $isUser?: boolean }>`
  background: ${props => props.$isUser ? 'linear-gradient(135deg, #6366f1, #8b5cf6)' : 'rgba(248, 250, 252, 0.8)'};
  color: ${props => props.$isUser ? 'white' : '#1e293b'};
  padding: 20px 24px;
  border-radius: 16px;
  font-size: 14px;
  line-height: 1.7;
  border: ${props => props.$isUser ? 'none' : '1px solid rgba(226, 232, 240, 0.6)'};
  max-height: 70vh;
  overflow-y: auto;

  /* Markdown-style formatting */
  h1, h2 {
    margin: 20px 0 12px 0;
    font-weight: 700;
    font-size: 18px;
    color: ${props => props.$isUser ? 'white' : '#1e293b'};
    border-bottom: 2px solid ${props => props.$isUser ? 'rgba(255,255,255,0.3)' : 'rgba(99, 102, 241, 0.2)'};
    padding-bottom: 8px;
  }

  h3 {
    margin: 16px 0 8px 0;
    font-weight: 600;
    font-size: 16px;
    color: ${props => props.$isUser ? 'rgba(255,255,255,0.95)' : '#475569'};
  }

  h4 {
    margin: 12px 0 6px 0;
    font-weight: 600;
    font-size: 14px;
    color: ${props => props.$isUser ? 'rgba(255,255,255,0.9)' : '#64748b'};
  }

  p {
    margin: 12px 0;
    line-height: 1.7;
  }

  ul, ol {
    margin: 12px 0;
    padding-left: 24px;
  }

  li {
    margin: 8px 0;
    line-height: 1.6;
  }

  strong {
    font-weight: 700;
    color: ${props => props.$isUser ? 'white' : '#1e293b'};
  }

  /* Code and emphasis */
  code {
    background: ${props => props.$isUser ? 'rgba(255,255,255,0.2)' : 'rgba(99, 102, 241, 0.1)'};
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    font-size: 13px;
  }

  /* Sections with better spacing */
  & > *:first-child {
    margin-top: 0;
  }

  & > *:last-child {
    margin-bottom: 0;
  }

  /* Coverage determination styling */
  h2:first-child {
    background: ${props => props.$isUser ? 'rgba(255,255,255,0.2)' : 'linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(16, 185, 129, 0.1))'};
    color: ${props => props.$isUser ? 'white' : '#059669'};
    padding: 12px 16px;
    border-radius: 8px;
    border: none;
    margin: 0 0 20px 0;
    font-size: 16px;
    text-align: center;
  }
`;

const InputArea = styled.div`
  display: flex;
  gap: 12px;
  align-items: flex-end;
`;

const ChatInput = styled.textarea`
  flex: 1;
  min-height: 44px;
  max-height: 120px;
  padding: 12px 16px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.9);
  font-size: 14px;
  font-family: inherit;
  resize: none;
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;

const SendButton = styled(Button)`
  min-width: 44px;
  height: 44px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

// LoadingSpinner and EmptyState now imported from ui components

const InlineLoadingSpinner = styled.div`
  border: 3px solid rgba(99, 102, 241, 0.1);
  border-top: 3px solid #6366f1;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  animation: ${spin} 1s linear infinite;
`;



function ClaimsAnalysisComponent() {
  const [forms, setForms] = useState<FormItem[]>([]);
  const [filteredForms, setFilteredForms] = useState<FormItem[]>([]);
  const [selectedForm, setSelectedForm] = useState<FormItem | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [loading, setLoading] = useState(true);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Load forms on component mount
  useEffect(() => {
    try {
      loadForms();
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Error in loadForms useEffect', {}, error instanceof Error ? error : undefined);
    }
  }, []);

  // Filter forms based on search query
  useEffect(() => {
    try {
      if (!Array.isArray(forms)) {
        logger.warn(LOG_CATEGORIES.DATA, 'Forms is not an array', { forms });
        setFilteredForms([]);
        return;
      }

      if (!searchQuery.trim()) {
        setFilteredForms(forms);
      } else {
        const query = searchQuery.toLowerCase();
        const filtered = forms.filter((form: FormItem) => {
          if (!form || typeof form !== 'object') return false;
          return (
            (form.formName || '').toLowerCase().includes(query) ||
            (form.formNumber || '').toLowerCase().includes(query) ||
            (form.category || '').toLowerCase().includes(query)
          );
        });
        setFilteredForms(filtered);
      }
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Error in filter useEffect', {}, error instanceof Error ? error : undefined);
      setFilteredForms([]);
    }
  }, [forms, searchQuery]);

  // Auto-scroll to bottom of messages
  useEffect(() => {
    try {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Error in scroll useEffect', {}, error instanceof Error ? error : undefined);
    }
  }, [messages]);

  const loadForms = async () => {
    try {
      logger.info(LOG_CATEGORIES.DATA, 'Loading forms from Firestore...');
      setLoading(true);

      // Add timeout to prevent hanging
      const formsSnapshot = await Promise.race([
        getDocs(collection(db, 'forms')),
        new Promise<never>((_, reject) =>
          setTimeout(() => reject(new Error('Firestore timeout')), 10000)
        )
      ]);

      const formsData: FormItem[] = formsSnapshot.docs.map(docSnap => {
        const data = docSnap.data();
        return {
          id: docSnap.id,
          formName: data.formName || '',
          formNumber: data.formNumber || '',
          category: data.category || '',
          downloadUrl: data.downloadUrl || '',
          filePath: data.filePath || '',
          ...data
        };
      });

      // âœ… FILTER: Only show forms with PDF uploaded (have downloadUrl or filePath)
      const formsWithPDF = formsData.filter(form =>
        form.downloadUrl || form.filePath
      );

      logger.info(LOG_CATEGORIES.DATA, `Loaded ${formsWithPDF.length} forms with PDF (out of ${formsData.length} total)`);
      setForms(formsWithPDF);
      setFilteredForms(formsWithPDF);
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Error loading forms', {}, error instanceof Error ? error : undefined);
      // Set empty arrays to prevent undefined errors
      setForms([]);
      setFilteredForms([]);
    } finally {
      setLoading(false);
    }
  };

  const selectForm = (form: FormItem) => {
    setSelectedForm(prev => {
      // If clicking the same form, deselect it
      if (prev && prev.id === form.id) {
        return null;
      }
      // Otherwise, select the new form
      return form;
    });
  };

  const handleSendMessage = async () => {
    if (!inputValue.trim() || !selectedForm || isAnalyzing) return;

    const userMessage = inputValue.trim();
    setInputValue('');
    setIsAnalyzing(true);

    // Add user message to chat
    const newUserMessage: ChatMessage = {
      role: 'user' as const,
      content: userMessage,
      timestamp: new Date()
    };

    try {
      setMessages(prev => [...prev, newUserMessage]);
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Error adding user message', {}, error instanceof Error ? error : undefined);
      setIsAnalyzing(false);
      return;
    }

    try {
      // Validate selected form
      if (!selectedForm) {
        throw new Error('No form selected for analysis');
      }

      // Process selected form with timeout
      logger.info(LOG_CATEGORIES.AI, 'Processing form for analysis...');
      const formChunks = await Promise.race([
        processFormsForAnalysis([selectedForm]),
        new Promise<never>((_, reject) =>
          setTimeout(() => reject(new Error('Form processing timeout')), 90000)
        )
      ]);

      if (!formChunks || formChunks.length === 0) {
        throw new Error('No content could be extracted from the selected form');
      }

      logger.info(LOG_CATEGORIES.AI, `Processed ${formChunks.length} form chunks`);

      // Get conversation history (excluding current message)
      const conversationHistory: Array<{ role: string; content: string }> = messages.map(msg => ({
        role: msg.role as string,
        content: msg.content || ''
      })).filter(msg => msg.content.trim());

      // Analyze claim with timeout
      logger.info(LOG_CATEGORIES.AI, 'Analyzing claim...');
      const analysis = await Promise.race([
        analyzeClaimWithChunking(userMessage, formChunks, conversationHistory),
        new Promise<never>((_, reject) =>
          setTimeout(() => reject(new Error('Analysis timeout')), 120000)
        )
      ]);

      if (!analysis || typeof analysis !== 'string') {
        throw new Error('Invalid analysis response received');
      }

      logger.info(LOG_CATEGORIES.AI, 'Analysis completed successfully');

      // Add AI response to chat
      const aiMessage: ChatMessage = {
        role: 'assistant' as const,
        content: analysis,
        timestamp: new Date()
      };
      setMessages(prev => [...prev, aiMessage]);

    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Error analyzing claim', {}, error instanceof Error ? error : undefined);

      // Create a safe error message
      const errorMessage: ChatMessage = {
        role: 'assistant' as const,
        content: `I apologize, but I encountered an error while analyzing your claim: ${error instanceof Error ? error.message : 'Unknown error'}. Please try again or contact support if the issue persists.`,
        timestamp: new Date()
      };

      try {
        setMessages(prev => [...prev, errorMessage]);
      } catch (setError) {
        logger.error(LOG_CATEGORIES.ERROR, 'Error setting error message', {}, setError instanceof Error ? setError : undefined);
      }
    } finally {
      setIsAnalyzing(false);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  if (loading) {
    return (
      <PageContainer withOverlay={true}>
        <MainNavigation />
        <PageContent>
          <LoadingSpinner type="circular" size="40px" />
        </PageContent>
      </PageContainer>
    );
  }

  return (
    <PageContainer withOverlay={true}>
      <MainNavigation />
      <PageContent>
        <Breadcrumb
          items={[
            { label: 'Home', path: '/' },
            { label: 'Claims Analysis' }
          ]}
        />

        <EnhancedHeader
          title="Claims Analysis"
          subtitle="AI-powered claim coverage determination with form analysis"
          icon={ChatBubbleLeftRightIcon}
        />

        {/* Claims Stats Dashboard */}
        <ClaimsStatsDashboard>
          <ClaimsStatCard $color="linear-gradient(90deg, #6366f1, #8b5cf6)">
            <ClaimsStatValue>{forms.length}</ClaimsStatValue>
            <ClaimsStatLabel>
              <DocumentTextIcon />
              Available Forms
            </ClaimsStatLabel>
          </ClaimsStatCard>
          <ClaimsStatCard $color="linear-gradient(90deg, #10b981, #059669)">
            <ClaimsStatValue>{forms.filter(f => f.downloadUrl).length}</ClaimsStatValue>
            <ClaimsStatLabel>
              <DocumentTextIcon />
              With PDFs
            </ClaimsStatLabel>
          </ClaimsStatCard>
          <ClaimsStatCard $color="linear-gradient(90deg, #f59e0b, #d97706)">
            <ClaimsStatValue>{messages.filter(m => m.role === 'user').length}</ClaimsStatValue>
            <ClaimsStatLabel>
              <ChatBubbleLeftRightIcon />
              Questions Asked
            </ClaimsStatLabel>
          </ClaimsStatCard>
          <ClaimsStatCard $color="linear-gradient(90deg, #06b6d4, #0891b2)">
            <ClaimsStatValue>{messages.filter(m => m.role === 'assistant').length}</ClaimsStatValue>
            <ClaimsStatLabel>
              <ChatBubbleLeftRightIcon />
              Analyses Provided
            </ClaimsStatLabel>
          </ClaimsStatCard>
        </ClaimsStatsDashboard>

        <ContentGrid>
          {/* Forms Selection Panel */}
          <Panel>
            <PanelHeader>
              <PanelTitle>
                <DocumentTextIcon />
                Select Form for Analysis
              </PanelTitle>
            </PanelHeader>
            <PanelContent>
              <SearchContainer>
                <SearchIcon />
                <SearchInput
                  placeholder="Search forms by name, number, or category..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </SearchContainer>

              <FormsList>
                {Array.isArray(filteredForms) && filteredForms.map(form => {
                  if (!form || !form.id) return null;
                  const isSelected = !!(selectedForm && selectedForm.id === form.id);
                  return (
                    <FormItemStyled
                      key={form.id}
                      $selected={isSelected}
                      onClick={() => selectForm(form)}
                    >
                      <FormRadio $checked={isSelected} />
                      <FormInfo>
                        <FormName>
                          {form.formName || form.formNumber || 'Unnamed Form'}
                        </FormName>
                        <FormMeta>
                          {form.formNumber && `${form.formNumber} â€¢ `}
                          {form.category || 'Unknown Category'}
                        </FormMeta>
                      </FormInfo>
                    </FormItemStyled>
                  );
                })}
              </FormsList>

              {selectedForm && (
                <SelectedCount>
                  {selectedForm.formName || selectedForm.formNumber || 'Form'} selected for analysis
                </SelectedCount>
              )}
            </PanelContent>
          </Panel>

          {/* Chat Panel */}
          <Panel>
            <PanelHeader>
              <PanelTitle>
                <ChatBubbleLeftRightIcon />
                Claims Analysis Chat
              </PanelTitle>
            </PanelHeader>
            <PanelContent>
              <ChatContainer>
                <MessagesArea>
                  {messages.length === 0 ? (
                    <EmptyState
                      icon={<ChatBubbleLeftRightIcon style={{ width: '48px', height: '48px' }} />}
                      title="Ready to Analyze Claims"
                      description="Select a form and describe a claim scenario to get started."
                      variant="compact"
                    />
                  ) : (
                    Array.isArray(messages) && messages.map((message, index) => {
                      if (!message || typeof message !== 'object') return null;
                      const isUserMessage = message.role === 'user';
                      return (
                        <Message key={index}>
                          <MessageHeader $isUser={isUserMessage}>
                            {isUserMessage ? 'You' : 'Claims Analyst AI'}
                          </MessageHeader>
                          <MessageErrorBoundary>
                            <MessageContent $isUser={isUserMessage}>
                              {isUserMessage ? (
                                <div style={{ whiteSpace: 'pre-wrap' }}>
                                  {message.content || ''}
                                </div>
                              ) : (
                                <UnifiedAIResponse content={message.content || ''} />
                              )}
                            </MessageContent>
                          </MessageErrorBoundary>
                        </Message>
                      );
                    })
                  )}
                  {isAnalyzing && (
                    <Message>
                      <MessageHeader $isUser={false}>Claims Analyst AI</MessageHeader>
                      <MessageContent $isUser={false}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                          <InlineLoadingSpinner />
                          Analyzing claim against selected form...
                        </div>
                      </MessageContent>
                    </Message>
                  )}
                  <div ref={messagesEndRef} />
                </MessagesArea>

                <InputArea>
                  <ChatInput
                    placeholder={
                      !selectedForm
                        ? "Please select a form first..."
                        : "Describe a claim scenario for analysis..."
                    }
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={handleKeyDown}
                    disabled={!selectedForm || isAnalyzing}
                  />
                  <SendButton
                    onClick={handleSendMessage}
                    disabled={!inputValue.trim() || !selectedForm || isAnalyzing}
                  >
                    {isAnalyzing ? <InlineLoadingSpinner /> : <PaperAirplaneIcon />}
                  </SendButton>
                </InputArea>
              </ChatContainer>
            </PanelContent>
          </Panel>
        </ContentGrid>
      </PageContent>
    </PageContainer>
  );
}

// Export with error boundary wrapper
export default function ClaimsAnalysis() {
  return (
    <ClaimsAnalysisErrorBoundary>
      <ClaimsAnalysisComponent />
    </ClaimsAnalysisErrorBoundary>
  );
}
```

---

## src/components/CoverageScreen.tsx

**Path:** `src/components/CoverageScreen.tsx`

```tsx
// src/components/CoverageScreen.tsx
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useParams, useLocation, useNavigate, Link as RouterLink } from 'react-router-dom';
import {
  collection,
  getDocs,
  addDoc,
  deleteDoc,
  doc,
  updateDoc,
  getDoc,
  query,
  where,
  writeBatch,
  serverTimestamp
} from 'firebase/firestore';
import { ref, getDownloadURL } from 'firebase/storage';
import { db, storage } from '@/firebase';
import useCoverages from '@hooks/useCoverages';
import { useCoverageFormCounts } from '@hooks/useCoverageFormCounts';

import { Button } from '../components/ui/Button';
import { TextInput } from '../components/ui/Input';
import MainNavigation from '../components/ui/Navigation';
import { PageContainer, PageContent } from '../components/ui/PageContainer';
import EnhancedHeader from '../components/ui/EnhancedHeader';

import { LimitsModal } from '../components/modals/LimitsModal';
import { DeductiblesModal } from '../components/modals/DeductiblesModal';
import { CoverageCopilotWizard } from '../components/wizard/CoverageCopilotWizard';

import styled, { keyframes } from 'styled-components';
import {
  Overlay,
  Modal,
  ModalHeader,
  ModalTitle,
  CloseBtn
} from '../components/ui/Table';
import { StatsDashboard } from '../components/common/DesignSystem';
import {
  PencilIcon,
  PlusIcon,
  TrashIcon,
  XMarkIcon,
  ShieldCheckIcon,
  ChevronRightIcon,
  MapIcon,
  Cog6ToothIcon,
  ChartBarIcon,
  ScaleIcon,
  ClipboardDocumentCheckIcon,
  BanknotesIcon,
  SparklesIcon,
  MagnifyingGlassIcon
} from '@heroicons/react/24/solid';

/* ---------- styled components ---------- */

// Animations for micro-interactions
const fadeInUp = keyframes`
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
`;

const scaleIn = keyframes`
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
`;

const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

// Coverage Grid - 2-column layout for coverage cards
const CoverageGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
  margin-bottom: 120px;
  width: 100%;

  & > * {
    animation: ${fadeInUp} 0.5s ease-out backwards;
  }

  & > *:nth-child(1) { animation-delay: 0.05s; }
  & > *:nth-child(2) { animation-delay: 0.1s; }
  & > *:nth-child(3) { animation-delay: 0.15s; }
  & > *:nth-child(4) { animation-delay: 0.2s; }
  & > *:nth-child(5) { animation-delay: 0.25s; }
  & > *:nth-child(6) { animation-delay: 0.3s; }
  & > *:nth-child(7) { animation-delay: 0.35s; }
  & > *:nth-child(8) { animation-delay: 0.4s; }

  @media (max-width: 1024px) {
    grid-template-columns: 1fr;
    gap: 12px;
  }
`;

// Coverage Group - Contains parent and its sub-coverages
const CoverageGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 8px;
`;

// Sub-coverage Container with professional visual connector
const SubCoverageContainer = styled.div<{ $isExpanded: boolean }>`
  position: relative;
  margin-left: 24px;
  display: grid;
  grid-template-columns: 1fr;
  gap: 12px;
  padding-left: 24px;

  &::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 2px;
    background: linear-gradient(180deg, #e2e8f0 0%, #cbd5e1 50%, #e2e8f0 100%);
    border-radius: 1px;
  }

  & > * {
    position: relative;
  }

  & > *::before {
    content: '';
    position: absolute;
    left: -24px;
    top: 50%;
    transform: translateY(-50%);
    width: 16px;
    height: 1px;
    background: #e2e8f0;
  }

  ${({ $isExpanded }) => $isExpanded ? `
    opacity: 1;
    transform: translateY(0);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  ` : `
    opacity: 0;
    transform: translateY(-10px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    pointer-events: none;
    position: absolute;
    z-index: -1;
  `}

  @media (max-width: 768px) {
    margin-left: 16px;
  }
`;

// Command Bar - Apple-inspired search + actions bar (matching ProductHub)
const CommandBar = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 32px;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.85);
  backdrop-filter: blur(20px) saturate(180%);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.6);
  box-shadow:
    0 1px 3px rgba(0, 0, 0, 0.04),
    0 4px 12px rgba(0, 0, 0, 0.03),
    inset 0 1px 0 rgba(255, 255, 255, 0.8);
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    padding: 1px;
    background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0.2) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    pointer-events: none;
  }
`;

const CommandBarLeft = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const CommandBarCenter = styled.div`
  flex: 1;
  display: flex;
  justify-content: center;
  max-width: 640px;
  min-width: 320px;
`;

const CommandBarRight = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const SearchWrapper = styled.div`
  width: 100%;
  position: relative;
  display: flex;
  align-items: center;
`;

const SearchInputStyled = styled.input`
  width: 100%;
  padding: 12px 16px 12px 44px;
  background: rgba(0, 0, 0, 0.03);
  border: 1px solid rgba(0, 0, 0, 0.06);
  border-radius: 12px;
  font-size: 14px;
  font-weight: 450;
  color: #1a1a1a;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  letter-spacing: -0.01em;

  &::placeholder {
    color: #8e8e93;
    font-weight: 400;
  }

  &:hover {
    background: rgba(0, 0, 0, 0.04);
    border-color: rgba(0, 0, 0, 0.08);
  }

  &:focus {
    outline: none;
    background: #ffffff;
    border-color: rgba(99, 102, 241, 0.5);
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.12);
  }
`;

const SearchIconWrapper = styled.div`
  position: absolute;
  left: 14px;
  top: 50%;
  transform: translateY(-50%);
  color: #8e8e93;
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;

  svg {
    width: 18px;
    height: 18px;
  }
`;

const ToolbarButton = styled.button<{ $active?: boolean }>`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 10px 16px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 10px;
  background: ${({ $active }) => $active ? 'rgba(99, 102, 241, 0.1)' : 'white'};
  color: ${({ $active }) => $active ? '#6366f1' : '#475569'};
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  svg {
    width: 16px;
    height: 16px;
  }

  &:hover {
    background: rgba(99, 102, 241, 0.08);
    border-color: rgba(99, 102, 241, 0.3);
    color: #6366f1;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

const ToolbarLabel = styled.span`
  font-size: 13px;
  color: #64748b;
  font-weight: 500;
`;

const CopilotButton = styled.button`
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 12px 24px;
  font-size: 14px;
  font-weight: 600;
  color: #ffffff;
  background: linear-gradient(135deg, #2563eb 0%, #7c3aed 50%, #8b5cf6 100%);
  background-size: 200% 100%;
  border: none;
  border-radius: 50px;
  box-shadow: 0 8px 24px rgba(124, 58, 237, 0.35), 0 3px 6px rgba(0, 0, 0, 0.08);
  cursor: pointer;
  transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(20px);
  letter-spacing: 0.01em;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    inset: -2px;
    background: linear-gradient(135deg, #2563eb, #7c3aed, #8b5cf6);
    border-radius: 52px;
    z-index: -1;
    opacity: 0;
    transition: opacity 0.3s ease;
    filter: blur(10px);
  }

  &:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 12px 32px rgba(124, 58, 237, 0.45), 0 6px 12px rgba(0, 0, 0, 0.12);
    background-position: 100% 0;

    &::before {
      opacity: 0.6;
    }
  }

  &:active {
    transform: translateY(-1px) scale(1.01);
  }

  svg {
    width: 18px;
    height: 18px;
    transition: transform 0.3s ease;
  }

  &:hover svg {
    transform: rotate(15deg) scale(1.1);
  }
`;

// Parent Coverage Card - Compact card for parent coverages
const ParentCoverageCard = styled.div`
  background: white;
  border-radius: 14px;
  padding: 16px;
  border: 1px solid rgba(226, 232, 240, 0.9);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.04), 0 1px 4px rgba(0, 0, 0, 0.02);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #6366f1, #8b5cf6, #06b6d4);
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 20px 40px rgba(99, 102, 241, 0.12), 0 8px 16px rgba(0, 0, 0, 0.06);
    border-color: rgba(99, 102, 241, 0.4);

    &::before {
      opacity: 1;
    }
  }

  &:focus-within {
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
  }
`;

// Coverage Card - Compact design for sub-coverages
const CoverageCard = styled.div<{ $isSubCoverage?: boolean; $delay?: number }>`
  background: white;
  border-radius: 12px;
  padding: 14px;
  border: 1px solid rgba(226, 232, 240, 0.9);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  animation: ${scaleIn} 0.35s ease-out backwards;
  animation-delay: ${({ $delay }) => ($delay || 0) * 0.05}s;

  &:hover {
    transform: translateY(-3px) scale(1.01);
    box-shadow: 0 12px 28px rgba(99, 102, 241, 0.1), 0 4px 12px rgba(0, 0, 0, 0.05);
    border-color: rgba(99, 102, 241, 0.35);
  }

  ${({ $isSubCoverage }) => $isSubCoverage && `
    background: linear-gradient(135deg, rgba(248, 250, 252, 0.9) 0%, rgba(241, 245, 249, 0.9) 100%);
    border-left: 4px solid #6366f1;

    &::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(180deg, #6366f1 0%, #8b5cf6 100%);
    }
  `}
`;

const CardHeader = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 14px;
`;

const CardHeaderRow = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
`;

const CardTitleGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
`;

const CardTitle = styled.h3`
  font-size: 18px;
  font-weight: 700;
  color: #1e293b;
  margin: 0;
  line-height: 1.3;
  letter-spacing: -0.025em;
`;

const CardCode = styled.span`
  font-size: 12px;
  font-weight: 600;
  color: #6366f1;
  background: rgba(99, 102, 241, 0.1);
  padding: 4px 10px;
  border-radius: 6px;
  border: 1px solid rgba(99, 102, 241, 0.2);
  letter-spacing: 0.025em;
  white-space: nowrap;
`;

const CardActions = styled.div`
  display: flex;
  gap: 8px;
  flex-shrink: 0;
`;



const IconButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border: none;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.8);
  color: #64748b;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(255, 255, 255, 0.2);

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
  }

  &.danger:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
  }
`;

// Coverage Type Badge - Shows if coverage is optional, required, or endorsement
const CoverageTypeBadge = styled.span<{ $isOptional?: boolean }>`
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 3px 8px;
  border-radius: 12px;
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.03em;
  margin-left: 8px;

  ${({ $isOptional }) => $isOptional ? `
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.08) 100%);
    color: #6366f1;
    border: 1px solid rgba(99, 102, 241, 0.2);
  ` : `
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.08) 100%);
    color: #059669;
    border: 1px solid rgba(16, 185, 129, 0.2);
  `}
`;

const CardMetrics = styled.div`
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
`;

const MetricItem = styled.div<{ $hasValue?: boolean }>`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  background: linear-gradient(135deg, rgba(248, 250, 252, 0.9) 0%, rgba(241, 245, 249, 0.9) 100%);
  backdrop-filter: blur(8px);
  border-radius: 8px;
  font-size: 12px;
  color: #475569;
  cursor: pointer;
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  border: 1px solid rgba(226, 232, 240, 0.6);
  font-weight: 500;
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 3px;
    height: 100%;
    background: ${({ $hasValue }) => $hasValue ? 'linear-gradient(180deg, #10b981, #059669)' : 'transparent'};
    transition: all 0.25s ease;
  }

  &:hover {
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%);
    color: #6366f1;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.12);
    border-color: rgba(99, 102, 241, 0.3);

    svg {
      color: #6366f1;
    }
  }

  &:active {
    transform: translateY(0);
  }

  svg {
    width: 16px;
    height: 16px;
    color: #64748b;
    transition: all 0.25s ease;
    flex-shrink: 0;
  }
`;

const MetricLabel = styled.span`
  white-space: nowrap;
`;

const MetricBadge = styled.span<{ $variant?: 'default' | 'success' | 'warning' }>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 22px;
  height: 22px;
  padding: 0 6px;
  font-size: 11px;
  font-weight: 700;
  border-radius: 11px;

  ${({ $variant }) => {
    switch ($variant) {
      case 'success':
        return `
          background: rgba(16, 185, 129, 0.15);
          color: #059669;
        `;
      case 'warning':
        return `
          background: rgba(245, 158, 11, 0.15);
          color: #d97706;
        `;
      default:
        return `
          background: rgba(100, 116, 139, 0.1);
          color: #64748b;
        `;
    }
  }}
`;

const ExpandButton = styled.button<{ $expanded?: boolean }>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border: none;
  border-radius: 8px;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
  color: #6366f1;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  border: 1.5px solid rgba(99, 102, 241, 0.2);
  flex-shrink: 0;

  svg {
    width: 16px;
    height: 16px;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ${({ $expanded }) => $expanded && 'transform: rotate(90deg);'}
  }

  &:hover {
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
    transform: scale(1.08);
    box-shadow: 0 6px 16px rgba(99, 102, 241, 0.25);
  }

  &:active {
    transform: scale(0.98);
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }
`;

// P&C Attributes Display - Shows key coverage configuration at a glance
const CoverageAttributesRow = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 10px 16px;
  background: linear-gradient(135deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.6) 100%);
  border-top: 1px solid rgba(226, 232, 240, 0.5);
  border-radius: 0 0 12px 12px;
`;

const AttributeChip = styled.div<{ $variant?: 'trigger' | 'valuation' | 'coinsurance' | 'territory' | 'default' }>`
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 4px 10px;
  border-radius: 16px;
  font-size: 11px;
  font-weight: 500;
  transition: all 0.2s ease;

  ${({ $variant }) => {
    switch ($variant) {
      case 'trigger':
        return `
          background: linear-gradient(135deg, rgba(99, 102, 241, 0.12) 0%, rgba(139, 92, 246, 0.1) 100%);
          color: #6366f1;
          border: 1px solid rgba(99, 102, 241, 0.2);
        `;
      case 'valuation':
        return `
          background: linear-gradient(135deg, rgba(16, 185, 129, 0.12) 0%, rgba(5, 150, 105, 0.1) 100%);
          color: #059669;
          border: 1px solid rgba(16, 185, 129, 0.2);
        `;
      case 'coinsurance':
        return `
          background: linear-gradient(135deg, rgba(245, 158, 11, 0.12) 0%, rgba(217, 119, 6, 0.1) 100%);
          color: #d97706;
          border: 1px solid rgba(245, 158, 11, 0.2);
        `;
      case 'territory':
        return `
          background: linear-gradient(135deg, rgba(59, 130, 246, 0.12) 0%, rgba(37, 99, 235, 0.1) 100%);
          color: #2563eb;
          border: 1px solid rgba(59, 130, 246, 0.2);
        `;
      default:
        return `
          background: rgba(107, 114, 128, 0.08);
          color: #6b7280;
          border: 1px solid rgba(107, 114, 128, 0.15);
        `;
    }
  }}

  svg {
    width: 12px;
    height: 12px;
  }

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  }
`;

const AttributeLabel = styled.span`
  font-weight: 600;
  opacity: 0.8;
`;

const AttributeValue = styled.span`
  font-weight: 500;
`;

const WideModal = styled(Modal)`
  max-width: 1000px;
  width: 95%;
  border-radius: 24px;
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.2);
`;

// Empty State - Enhanced with illustration and better CTAs
const EmptyState = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 80px 40px;
  background: linear-gradient(135deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.6) 100%);
  border-radius: 24px;
  border: 2px dashed rgba(203, 213, 225, 0.6);
  animation: ${fadeInUp} 0.5s ease-out;
`;

const EmptyStateIcon = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 80px;
  height: 80px;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
  border-radius: 24px;
  margin-bottom: 24px;

  svg {
    width: 40px;
    height: 40px;
    color: #6366f1;
  }
`;

const EmptyStateTitle = styled.h3`
  font-size: 22px;
  font-weight: 700;
  color: #1e293b;
  margin: 0 0 12px 0;
  letter-spacing: -0.02em;
`;

const EmptyStateText = styled.p`
  font-size: 15px;
  color: #64748b;
  margin: 0 0 28px 0;
  max-width: 400px;
  line-height: 1.6;
`;

const EmptyStateButton = styled.button`
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 14px 24px;
  font-size: 14px;
  font-weight: 600;
  color: white;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(99, 102, 241, 0.4);
  }

  svg {
    width: 18px;
    height: 18px;
  }
`;

// Skeleton Loading State
const SkeletonCard = styled.div`
  background: white;
  border-radius: 16px;
  padding: 24px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  animation: ${pulse} 1.5s ease-in-out infinite;
`;

const SkeletonLine = styled.div<{ $width?: string; $height?: string }>`
  background: linear-gradient(90deg, #f1f5f9 0%, #e2e8f0 50%, #f1f5f9 100%);
  background-size: 200% 100%;
  animation: ${shimmer} 1.5s ease-in-out infinite;
  border-radius: 6px;
  height: ${({ $height }) => $height || '16px'};
  width: ${({ $width }) => $width || '100%'};
  margin-bottom: 12px;
`;

// Actions container for modal buttons
const Actions = styled.div`
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 24px;
`;

// Enhanced form linking styles
const FormLinkContainer = styled.div`
  max-height: 360px;
  overflow-y: auto;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 12px;
  padding: 8px;
  margin-bottom: 16px;
  background: rgba(248, 250, 252, 0.5);
`;

const FormLinkItem = styled.label`
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: 4px;

  &:hover {
    background: rgba(99, 102, 241, 0.05);
  }

  &:last-child {
    margin-bottom: 0;
  }
`;

const FormCheckbox = styled.input`
  width: 18px;
  height: 18px;
  accent-color: #6366f1;
  cursor: pointer;
`;

const FormLabel = styled.span`
  flex: 1;
  font-size: 14px;
  font-weight: 500;
  color: #374151;
`;

const FormLinkActions = styled.div`
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
`;



/* ---------- main component ---------- */
export default function CoverageScreen() {
  const { productId } = useParams();
  const location = useLocation();
  const navigate = useNavigate();

  // nested path => parentCoverageId
  const segs = location.pathname.split('/').filter(Boolean);
  const parentCoverageId = segs.length > 2 ? segs[segs.length - 1] : null;

  /* --- realtime coverages hook --- */
  const {
    coverages,
    loading: coveragesLoading,
    error: coveragesError,
    reload: reloadCoverages
  } = useCoverages(productId);

  /* --- form counts from junction table --- */
  const formCounts = useCoverageFormCounts(
    productId,
    coverages.map(c => c.id)
  );

  /* --- derived sub-counts & filtering --- */
  const coveragesWithSub = useMemo(() => {
    const counts = {};
    const parentMap = {};

    // Build parent map and count children
    coverages.forEach(c => {
      if (c.parentCoverageId) {
        counts[c.parentCoverageId] = (counts[c.parentCoverageId] || 0) + 1;
        // Find parent coverage for name lookup
        const parent = coverages.find(p => p.id === c.parentCoverageId);
        if (parent) {
          parentMap[c.id] = {
            id: parent.id,
            name: parent.name,
            coverageCode: parent.coverageCode
          };
        }
      }
    });

    return coverages.map(c => ({
      ...c,
      subCount: counts[c.id] || 0,
      parentInfo: parentMap[c.id] || null
    }));
  }, [coverages]);

  /* ---------------- UI/Meta state ---------------- */
  const [metaLoading, setMetaLoading] = useState(true);
  const [forms, setForms] = useState([]);
  const [rules, setRules] = useState([]);
  const [productName, setProductName] = useState('');
  const [parentCoverageName, setParentCoverageName] = useState('');

  const [rawSearch, setRawSearch] = useState('');
  const searchQuery = useDebounce(rawSearch, 250);

  // Filter state - typeFilter is used in filtering logic, setter reserved for future UI
  const [typeFilter, _setTypeFilter] = useState<'all' | 'required' | 'optional'>('all');
  void _setTypeFilter; // Suppress unused variable warning

  // Tree expand/collapse state
  const [expandedIds, setExpandedIds] = useState([]);
  const toggleExpand = id => {
    setExpandedIds(ids =>
      ids.includes(id) ? ids.filter(i => i !== id) : [...ids, id]
    );
  };

  // Sub-coverage add button state
  const [addingParentId, setAddingParentId] = useState(null);

  // Coverage Copilot wizard state
  const [copilotWizardOpen, setCopilotWizardOpen] = useState(false);
  const [editingCoverageForWizard, setEditingCoverageForWizard] = useState<any>(null);

  // Tree structure generation for proper parent-child rendering
  const treeStructure = useMemo(() => {
    const childrenMap = {};
    const parentCoverages = [];

    // Build children map and identify parent coverages
    coveragesWithSub.forEach(c => {
      if (c.parentCoverageId) {
        (childrenMap[c.parentCoverageId] = childrenMap[c.parentCoverageId] || []).push(c);
      } else {
        parentCoverages.push(c);
      }
    });

    // Sort children arrays
    Object.values(childrenMap).forEach(arr =>
      arr.sort((a, b) => (a.name || '').localeCompare(b.name || ''))
    );

    // Sort parent coverages
    parentCoverages.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

    return { parentCoverages, childrenMap };
  }, [coveragesWithSub]);

  // Filter coverages by search and type
  const filteredTreeStructure = useMemo(() => {
    const q = searchQuery.toLowerCase();
    const { parentCoverages, childrenMap } = treeStructure;
    const filteredParents: typeof parentCoverages = [];
    const filteredChildrenMap: typeof childrenMap = {};

    // Helper to check if coverage matches filters
    const matchesFilters = (coverage: typeof parentCoverages[0]) => {
      // Search filter
      const matchesSearch = !q ||
        (coverage.name || '').toLowerCase().includes(q) ||
        (coverage.coverageCode || '').toLowerCase().includes(q);

      // Type filter
      const matchesType = typeFilter === 'all' ||
        (typeFilter === 'required' && coverage.isOptional === false) ||
        (typeFilter === 'optional' && coverage.isOptional === true);

      return matchesSearch && matchesType;
    };

    parentCoverages.forEach(parent => {
      const parentMatches = matchesFilters(parent);
      const children = childrenMap[parent.id] || [];
      const matchingChildren = children.filter(matchesFilters);

      // Include parent if it matches or has matching children
      if (parentMatches || matchingChildren.length > 0) {
        filteredParents.push(parent);
        if (matchingChildren.length > 0) {
          filteredChildrenMap[parent.id] = matchingChildren;
        } else if (parentMatches && children.length > 0) {
          // When parent matches but no children match, still show all children
          filteredChildrenMap[parent.id] = children;
        }
      }
    });

    return { parentCoverages: filteredParents, childrenMap: filteredChildrenMap };
  }, [treeStructure, searchQuery, typeFilter]);

  // Get rule count for a specific coverage
  const getRuleCount = useCallback((coverageId: string) => {
    return rules.filter(rule =>
      rule.ruleType === 'Coverage' && rule.targetId === coverageId
    ).length;
  }, [rules]);

  // Format P&C-specific attributes for display
  const formatCoverageTrigger = (trigger?: string) => {
    const triggerLabels: Record<string, string> = {
      'occurrence': 'Occurrence',
      'claimsMade': 'Claims-Made',
      'hybrid': 'Hybrid'
    };
    return triggerLabels[trigger || ''] || null;
  };

  const formatValuationMethod = (method?: string) => {
    const methodLabels: Record<string, string> = {
      'ACV': 'Actual Cash Value',
      'RC': 'Replacement Cost',
      'agreedValue': 'Agreed Value',
      'marketValue': 'Market Value',
      'functionalRC': 'Functional RC',
      'statedAmount': 'Stated Amount'
    };
    return methodLabels[method || ''] || null;
  };

  const formatTerritoryType = (type?: string) => {
    const typeLabels: Record<string, string> = {
      'worldwide': 'Worldwide',
      'USA': 'USA Only',
      'stateSpecific': 'State-Specific',
      'custom': 'Custom Territory'
    };
    return typeLabels[type || ''] || null;
  };

  // Check if coverage has any P&C attributes configured
  const hasPCAttributes = (coverage: any) => {
    return coverage.coverageTrigger || coverage.valuationMethod ||
           coverage.coinsurancePercentage || coverage.territoryType ||
           coverage.waitingPeriod;
  };

  const [limitModalOpen, setLimitModalOpen] = useState(false);
  const [deductibleModalOpen, setDeductibleModalOpen] = useState(false);
  const [currentCoverage, setCurrentCoverage] = useState(null);

  const [linkFormsModalOpen, setLinkFormsModalOpen] = useState(false);
  const [selectedCoverageForForms, setSelectedCoverageForForms] = useState(null);
  const [linkFormIds, setLinkFormIds] = useState([]);
  const [formSearchQuery, setFormSearchQuery] = useState('');

  /* ---------- effect: load meta (forms + names + rules) ---------- */
  const loadMeta = useCallback(async () => {
    if (!productId) return;
    setMetaLoading(true);
    try {
      // forms - enrich with linked coverages from junction table
      const formsSnap = await getDocs(
        query(collection(db, 'forms'), where('productId', '==', productId))
      );

      // Fetch all form-coverage links for this product
      const linksSnap = await getDocs(
        query(collection(db, 'formCoverages'), where('productId', '==', productId))
      );
      const coveragesByForm = {};
      linksSnap.docs.forEach(doc => {
        const { formId, coverageId } = doc.data();
        if (!coveragesByForm[formId]) {
          coveragesByForm[formId] = [];
        }
        coveragesByForm[formId].push(coverageId);
      });

      const list = await Promise.all(
        formsSnap.docs.map(async d => {
          const data = d.data();
          let url = null;
          if (data.filePath) {
            try { url = await getDownloadURL(ref(storage, data.filePath)); } catch {}
          }
          return {
            ...data,
            id: d.id,
            downloadUrl: url,
            coverageIds: coveragesByForm[d.id] || []
          };
        })
      );
      setForms(list);

      // rules - fetch all rules for this product
      const rulesSnap = await getDocs(
        query(collection(db, 'rules'), where('productId', '==', productId))
      );
      const rulesList = rulesSnap.docs.map(d => ({ id: d.id, ...d.data() }));
      setRules(rulesList);

      // product / parent names
      const prodDoc = await getDoc(doc(db, 'products', productId));
      setProductName(prodDoc.exists() ? prodDoc.data().name : 'Unknown Product');

      if (parentCoverageId) {
        const parDoc = await getDoc(doc(db, `products/${productId}/coverages`, parentCoverageId));
        setParentCoverageName(parDoc.exists() ? parDoc.data().name : 'Unknown Coverage');
      } else {
        setParentCoverageName('');
      }
    } catch (err) {
      alert('Failed to load data: ' + err.message);
    } finally {
      setMetaLoading(false);
    }
  }, [productId, parentCoverageId]);

  useEffect(() => { loadMeta(); }, [loadMeta]);

  /* ---------- helpers ---------- */
  // Open Coverage Copilot wizard for editing
  const openEditModal = c => {
    setEditingCoverageForWizard(c);
    setCopilotWizardOpen(true);
  };

  // Open Coverage Copilot wizard for adding new coverage
  const openAddModal = (parentId = null) => {
    setEditingCoverageForWizard(parentId ? { parentCoverageId: parentId } : null);
    setCopilotWizardOpen(true);
  };

  /* ---------- Modal handlers ---------- */
  const openLimitModal = c => {
    setCurrentCoverage(c);
    setLimitModalOpen(true);
  };

  const openDeductibleModal = c => {
    setCurrentCoverage(c);
    setDeductibleModalOpen(true);
  };

  const openLinkFormsModal = async c => {
    setSelectedCoverageForForms(c);
    setFormSearchQuery('');

    // Fetch existing linked forms from junction table
    try {
      const linksSnap = await getDocs(
        query(
          collection(db, 'formCoverages'),
          where('coverageId', '==', c.id),
          where('productId', '==', productId)
        )
      );
      const linkedFormIds = linksSnap.docs.map(doc => doc.data().formId);
      setLinkFormIds(linkedFormIds);
    } catch (err) {
      console.error('Error fetching linked forms:', err);
      setLinkFormIds([]);
    }

    setLinkFormsModalOpen(true);
  };



  // Filter forms based on search query
  const filteredForms = useMemo(() => {
    if (!formSearchQuery.trim()) return forms;
    const query = formSearchQuery.toLowerCase();
    return forms.filter(f =>
      (f.formName && f.formName.toLowerCase().includes(query)) ||
      (f.formNumber && f.formNumber.toLowerCase().includes(query))
    );
  }, [forms, formSearchQuery]);

  const handleDelete = async id => {
    if (!window.confirm('Delete this coverage?')) return;
    try {
      await deleteDoc(doc(db, `products/${productId}/coverages`, id));
      await reloadCoverages();

    } catch (err) {
      alert('Delete failed: ' + err.message);
    }
  };

  const saveLinkedForms = async () => {
    if (!selectedCoverageForForms) return;
    try {
      const coverage = selectedCoverageForForms;
      const desired = new Set(linkFormIds);

      // Fetch existing links from junction table
      const existingSnap = await getDocs(
        query(
          collection(db, 'formCoverages'),
          where('coverageId', '==', coverage.id),
          where('productId', '==', productId)
        )
      );

      const batch = writeBatch(db);

      // Remove deselected links
      existingSnap.docs.forEach(d => {
        if (!desired.has(d.data().formId)) {
          batch.delete(d.ref);
        }
      });

      // Add new links
      const existingIds = new Set(existingSnap.docs.map(d => d.data().formId));
      desired.forEach(fid => {
        if (!existingIds.has(fid)) {
          // âœ… FIXED: Use addDoc pattern with batch instead of doc(collection(...))
          const linkRef = doc(collection(db, 'formCoverages'));
          batch.set(linkRef, {
            formId: fid,
            coverageId: coverage.id,
            productId,
            createdAt: serverTimestamp()
          });
        }
      });

      // âœ… REMOVED: No longer updating coverage.formIds array
      // The formCoverages junction table is the single source of truth

      await batch.commit();
      setLinkFormsModalOpen(false);
      await reloadCoverages();
    } catch (err) {
      console.error('Error saving linked forms:', err);
      alert('Failed to save linked forms: ' + (err.message || 'Unknown error'));
    }
  };

  /* ---------- render guards ---------- */
  if (coveragesLoading || metaLoading) {
    return (
      <PageContainer>
        <MainNavigation />
        <PageContent>
          <EnhancedHeader
            title="Loading Coverages..."
            subtitle="Please wait while we fetch your data"
            icon={ShieldCheckIcon}
            showBackButton
            onBackClick={() => navigate(-1)}
          />

          {/* Skeleton Loading */}
          <CoverageGrid>
            {[1, 2, 3].map(i => (
              <SkeletonCard key={i}>
                <SkeletonLine $width="50%" $height="20px" />
                <SkeletonLine $width="80%" $height="14px" />
                <SkeletonLine $width="100%" $height="40px" />
              </SkeletonCard>
            ))}
          </CoverageGrid>
        </PageContent>
      </PageContainer>
    );
  }

  if (coveragesError) {
    return (
      <PageContainer>
        <MainNavigation />
        <PageContent>
          <EmptyState>
            <EmptyStateIcon>
              <ShieldCheckIcon />
            </EmptyStateIcon>
            <EmptyStateTitle>Error Loading Coverages</EmptyStateTitle>
            <EmptyStateText>There was an error loading the coverage data. Please try refreshing the page.</EmptyStateText>
            <EmptyStateButton onClick={() => window.location.reload()}>
              Refresh Page
            </EmptyStateButton>
          </EmptyState>
        </PageContent>
      </PageContainer>
    );
  }

  /* ---------- UI ---------- */
  return (
    <PageContainer>
      <MainNavigation />
      <PageContent>
        <EnhancedHeader
          title={parentCoverageId ? `${parentCoverageName} Coverages` : `${productName} - Coverages`}
          subtitle={`Manage ${filteredTreeStructure.parentCoverages.length} coverage option${filteredTreeStructure.parentCoverages.length !== 1 ? 's' : ''}`}
          icon={ShieldCheckIcon}
          showBackButton
          onBackClick={() => navigate(-1)}
        />

        {/* Command Bar with Search and Add */}
        <CommandBar>
          <CommandBarLeft>
            <ToolbarLabel>
              {filteredTreeStructure.parentCoverages.length} coverage{filteredTreeStructure.parentCoverages.length !== 1 ? 's' : ''}
              {searchQuery && ` matching "${searchQuery}"`}
            </ToolbarLabel>
          </CommandBarLeft>

          <CommandBarCenter>
            <SearchWrapper>
              <SearchIconWrapper>
                <MagnifyingGlassIcon />
              </SearchIconWrapper>
              <SearchInputStyled
                type="text"
                placeholder="Search coverages by name or code..."
                value={rawSearch}
                onChange={(e) => setRawSearch(e.target.value)}
                aria-label="Search coverages"
              />
            </SearchWrapper>
          </CommandBarCenter>

          <CommandBarRight>
            <CopilotButton onClick={() => setCopilotWizardOpen(true)}>
              <SparklesIcon />
              Coverage Copilot
            </CopilotButton>
          </CommandBarRight>
        </CommandBar>

        {/* Coverages Display */}
        {filteredTreeStructure.parentCoverages.length > 0 ? (
          <CoverageGrid>
	            {filteredTreeStructure.parentCoverages.map((parent, index) => {
	              const isExpanded = expandedIds.includes(parent.id);

	              return (
                  <CoverageGroup key={parent.id} style={{ animationDelay: `${index * 0.05}s` }}>
                    {/* Parent Coverage */}
                      <ParentCoverageCard>
                        <CardHeader>
                          <CardHeaderRow>
                            <CardTitleGroup>
                              <CardTitle>{parent.name}</CardTitle>
                              {parent.isOptional !== undefined && (
                                <CoverageTypeBadge $isOptional={parent.isOptional}>
                                  {parent.isOptional ? 'Optional' : 'Required'}
                                </CoverageTypeBadge>
                              )}
                              <CardCode>{parent.coverageCode}</CardCode>
                              {parent.subCount > 0 && (
                                <ExpandButton
                                  $expanded={isExpanded}
                                  onClick={() => toggleExpand(parent.id)}
                                  aria-label={isExpanded ? 'Collapse sub-coverages' : 'Expand sub-coverages'}
                                >
                                  <ChevronRightIcon />
                                </ExpandButton>
                              )}
                              <IconButton onClick={() => openAddModal(parent.id)} title="Add sub-coverage">
                                <PlusIcon width={16} />
                              </IconButton>
                            </CardTitleGroup>
                            <CardActions>
                              <IconButton onClick={() => openEditModal(parent)} title="Edit coverage">
                                <PencilIcon width={16} />
                              </IconButton>
                              <IconButton className="danger" onClick={() => handleDelete(parent.id)} title="Delete coverage">
                                <TrashIcon width={16} />
                              </IconButton>
                            </CardActions>
                          </CardHeaderRow>
                        </CardHeader>

                        <CardMetrics>
                            <MetricItem
                              $hasValue={parent.limitsCount > 0}
                              onClick={() => openLimitModal(parent)}
                              title="Configure coverage limits"
                            >
                              <ChartBarIcon />
                              <MetricLabel>Limits</MetricLabel>
                              <MetricBadge $variant={parent.limitsCount > 0 ? 'success' : 'default'}>
                                {parent.limitsCount || 0}
                              </MetricBadge>
                            </MetricItem>
                            <MetricItem
                              $hasValue={parent.deductiblesCount > 0}
                              onClick={() => openDeductibleModal(parent)}
                              title="Configure deductible options"
                            >
                              <ScaleIcon />
                              <MetricLabel>Deductibles</MetricLabel>
                              <MetricBadge $variant={parent.deductiblesCount > 0 ? 'success' : 'default'}>
                                {parent.deductiblesCount || 0}
                              </MetricBadge>
                            </MetricItem>
                            <MetricItem
                              $hasValue={parent.states?.length > 0}
                              as={RouterLink}
                              to={`/coverage-states/${productId}/${parent.id}`}
                              title="Manage state availability"
                            >
                              <MapIcon />
                              <MetricLabel>States</MetricLabel>
                              <MetricBadge $variant={parent.states?.length > 0 ? 'success' : 'default'}>
                                {parent.states?.length || 0}
                              </MetricBadge>
                            </MetricItem>
                            <MetricItem
                              $hasValue={formCounts[parent.id] > 0}
                              onClick={() => openLinkFormsModal(parent)}
                              title="Link coverage forms and endorsements"
                            >
                              <ClipboardDocumentCheckIcon />
                              <MetricLabel>Forms</MetricLabel>
                              <MetricBadge $variant={formCounts[parent.id] > 0 ? 'success' : 'default'}>
                                {formCounts[parent.id] || 0}
                              </MetricBadge>
                            </MetricItem>
                            <MetricItem
                              onClick={() => navigate(`/pricing/${productId}?coverage=${encodeURIComponent(parent.name)}`)}
                              title="Configure pricing and rates"
                            >
                              <BanknotesIcon />
                              <MetricLabel>Pricing</MetricLabel>
                            </MetricItem>
                            <MetricItem
                              $hasValue={getRuleCount(parent.id) > 0}
                              onClick={() => navigate(`/rules/${productId}/${parent.id}`)}
                              title="Manage business rules"
                            >
                              <Cog6ToothIcon />
                              <MetricLabel>Rules</MetricLabel>
                              <MetricBadge $variant={getRuleCount(parent.id) > 0 ? 'success' : 'default'}>
                                {getRuleCount(parent.id)}
                              </MetricBadge>
                            </MetricItem>
                          </CardMetrics>

                        {/* P&C Attributes Row - Shows key coverage configuration */}
                        {hasPCAttributes(parent) && (
                          <CoverageAttributesRow>
                            {formatCoverageTrigger(parent.coverageTrigger) && (
                              <AttributeChip $variant="trigger" title="Coverage Trigger">
                                <AttributeLabel>Trigger:</AttributeLabel>
                                <AttributeValue>{formatCoverageTrigger(parent.coverageTrigger)}</AttributeValue>
                              </AttributeChip>
                            )}
                            {formatValuationMethod(parent.valuationMethod) && (
                              <AttributeChip $variant="valuation" title="Valuation Method">
                                <AttributeLabel>Valuation:</AttributeLabel>
                                <AttributeValue>{formatValuationMethod(parent.valuationMethod)}</AttributeValue>
                              </AttributeChip>
                            )}
                            {parent.coinsurancePercentage && (
                              <AttributeChip $variant="coinsurance" title="Coinsurance Requirement">
                                <AttributeLabel>Coinsurance:</AttributeLabel>
                                <AttributeValue>{parent.coinsurancePercentage}%</AttributeValue>
                              </AttributeChip>
                            )}
                            {formatTerritoryType(parent.territoryType) && (
                              <AttributeChip $variant="territory" title="Territory Coverage">
                                <AttributeLabel>Territory:</AttributeLabel>
                                <AttributeValue>{formatTerritoryType(parent.territoryType)}</AttributeValue>
                              </AttributeChip>
                            )}
                            {parent.waitingPeriod && (
                              <AttributeChip $variant="default" title="Waiting Period">
                                <AttributeLabel>Wait:</AttributeLabel>
                                <AttributeValue>{parent.waitingPeriod} {parent.waitingPeriodUnit || 'days'}</AttributeValue>
                              </AttributeChip>
                            )}
                          </CoverageAttributesRow>
                        )}
                      </ParentCoverageCard>
                    {/* Sub-Coverages */}
	                    {filteredTreeStructure.childrenMap[parent.id] && isExpanded && (
	                      <SubCoverageContainer $isExpanded={isExpanded}>
	                        {filteredTreeStructure.childrenMap[parent.id].map((child, childIndex) => (
	                            <CoverageCard key={child.id} $isSubCoverage $delay={childIndex}>
	                              <CardHeader>
	                                <CardHeaderRow>
	                                  <CardTitleGroup>
	                                    <CardTitle>{child.name}</CardTitle>
	                                    {child.isOptional !== undefined && (
	                                      <CoverageTypeBadge $isOptional={child.isOptional}>
	                                        {child.isOptional ? 'Optional' : 'Required'}
	                                      </CoverageTypeBadge>
	                                    )}
	                                    <CardCode>{child.coverageCode}</CardCode>
	                                  </CardTitleGroup>
	                                  <CardActions>
	                                    <IconButton onClick={() => openEditModal(child)} title="Edit coverage">
	                                      <PencilIcon width={16} />
	                                    </IconButton>
	                                    <IconButton className="danger" onClick={() => handleDelete(child.id)} title="Delete coverage">
	                                      <TrashIcon width={16} />
	                                    </IconButton>
	                                  </CardActions>
	                                </CardHeaderRow>
	                              </CardHeader>

                              <CardMetrics>
                                <MetricItem
                                  $hasValue={child.limitsCount > 0}
                                  onClick={() => openLimitModal(child)}
                                  title="Configure coverage limits"
                                >
                                  <ChartBarIcon />
                                  <MetricLabel>Limits</MetricLabel>
                                  <MetricBadge $variant={child.limitsCount > 0 ? 'success' : 'default'}>
                                    {child.limitsCount || 0}
                                  </MetricBadge>
                                </MetricItem>
                                <MetricItem
                                  $hasValue={child.deductiblesCount > 0}
                                  onClick={() => openDeductibleModal(child)}
                                  title="Configure deductible options"
                                >
                                  <ScaleIcon />
                                  <MetricLabel>Deductibles</MetricLabel>
                                  <MetricBadge $variant={child.deductiblesCount > 0 ? 'success' : 'default'}>
                                    {child.deductiblesCount || 0}
                                  </MetricBadge>
                                </MetricItem>
                                <MetricItem
                                  $hasValue={child.states?.length > 0}
                                  as={RouterLink}
                                  to={`/coverage-states/${productId}/${child.id}`}
                                  title="Manage state availability"
                                >
                                  <MapIcon />
                                  <MetricLabel>States</MetricLabel>
                                  <MetricBadge $variant={child.states?.length > 0 ? 'success' : 'default'}>
                                    {child.states?.length || 0}
                                  </MetricBadge>
                                </MetricItem>
                                <MetricItem
                                  $hasValue={formCounts[child.id] > 0}
                                  onClick={() => openLinkFormsModal(child)}
                                  title="Link coverage forms"
                                >
                                  <ClipboardDocumentCheckIcon />
                                  <MetricLabel>Forms</MetricLabel>
                                  <MetricBadge $variant={formCounts[child.id] > 0 ? 'success' : 'default'}>
                                    {formCounts[child.id] || 0}
                                  </MetricBadge>
                                </MetricItem>
                                <MetricItem
                                  onClick={() => navigate(`/pricing/${productId}?coverage=${encodeURIComponent(child.name)}`)}
                                  title="Configure pricing"
                                >
                                  <BanknotesIcon />
                                  <MetricLabel>Pricing</MetricLabel>
                                </MetricItem>
                                <MetricItem
                                  $hasValue={getRuleCount(child.id) > 0}
                                  onClick={() => navigate(`/rules/${productId}/${child.id}`)}
                                  title="Manage business rules"
                                >
                                  <Cog6ToothIcon />
                                  <MetricLabel>Rules</MetricLabel>
                                  <MetricBadge $variant={getRuleCount(child.id) > 0 ? 'success' : 'default'}>
                                    {getRuleCount(child.id)}
                                  </MetricBadge>
                                </MetricItem>
	                              </CardMetrics>

	                              {/* P&C Attributes Row for sub-coverages */}
	                              {hasPCAttributes(child) && (
	                                <CoverageAttributesRow>
	                                  {formatCoverageTrigger(child.coverageTrigger) && (
	                                    <AttributeChip $variant="trigger" title="Coverage Trigger">
	                                      <AttributeLabel>Trigger:</AttributeLabel>
	                                      <AttributeValue>{formatCoverageTrigger(child.coverageTrigger)}</AttributeValue>
	                                    </AttributeChip>
	                                  )}
	                                  {formatValuationMethod(child.valuationMethod) && (
	                                    <AttributeChip $variant="valuation" title="Valuation Method">
	                                      <AttributeLabel>Valuation:</AttributeLabel>
	                                      <AttributeValue>{formatValuationMethod(child.valuationMethod)}</AttributeValue>
	                                    </AttributeChip>
	                                  )}
	                                  {child.coinsurancePercentage && (
	                                    <AttributeChip $variant="coinsurance" title="Coinsurance Requirement">
	                                      <AttributeLabel>Coinsurance:</AttributeLabel>
	                                      <AttributeValue>{child.coinsurancePercentage}%</AttributeValue>
	                                    </AttributeChip>
	                                  )}
	                                  {formatTerritoryType(child.territoryType) && (
	                                    <AttributeChip $variant="territory" title="Territory Coverage">
	                                      <AttributeLabel>Territory:</AttributeLabel>
	                                      <AttributeValue>{formatTerritoryType(child.territoryType)}</AttributeValue>
	                                    </AttributeChip>
	                                  )}
	                                  {child.waitingPeriod && (
	                                    <AttributeChip $variant="default" title="Waiting Period">
	                                      <AttributeLabel>Wait:</AttributeLabel>
	                                      <AttributeValue>{child.waitingPeriod} {child.waitingPeriodUnit || 'days'}</AttributeValue>
	                                    </AttributeChip>
	                                  )}
	                                </CoverageAttributesRow>
	                              )}
                          </CoverageCard>
	                        ))}
                      </SubCoverageContainer>
                    )}
                  </CoverageGroup>
                );
              })}
            </CoverageGrid>
        ) : (
          <EmptyState>
            <EmptyStateIcon>
              <ShieldCheckIcon />
            </EmptyStateIcon>
            <EmptyStateTitle>
              {searchQuery ? 'No matching coverages' : 'No coverages yet'}
            </EmptyStateTitle>
            <EmptyStateText>
              {searchQuery
                ? 'Try adjusting your search terms or clear the search to see all coverages.'
                : 'Build your coverage structure by adding coverages with limits, deductibles, and state-specific configurations. Each coverage can include sub-coverages, linked forms, and business rules for comprehensive policy management.'}
            </EmptyStateText>
            {!searchQuery && (
              <EmptyStateButton onClick={() => setCopilotWizardOpen(true)}>
                <SparklesIcon />
                Launch Coverage Copilot
              </EmptyStateButton>
            )}
          </EmptyState>
        )}

      </PageContent>

      {/* ----- Limits Modal (Enhanced) ----- */}
      {limitModalOpen && currentCoverage && (
        <LimitsModal
          isOpen={limitModalOpen}
          onClose={() => setLimitModalOpen(false)}
          productId={productId}
          coverageId={currentCoverage.id}
          coverageName={currentCoverage.name}
          onSave={reloadCoverages}
        />
      )}

      {/* ----- Deductibles Modal (Enhanced) ----- */}
      {deductibleModalOpen && currentCoverage && (
        <DeductiblesModal
          isOpen={deductibleModalOpen}
          onClose={() => setDeductibleModalOpen(false)}
          productId={productId}
          coverageId={currentCoverage.id}
          coverageName={currentCoverage.name}
          onSave={reloadCoverages}
        />
      )}

      {/* Coverage Copilot Wizard - Used for both add and edit */}
      {copilotWizardOpen && productId && (
        <CoverageCopilotWizard
          isOpen={copilotWizardOpen}
          onClose={() => {
            setCopilotWizardOpen(false);
            setEditingCoverageForWizard(null);
          }}
          productId={productId}
          existingCoverage={editingCoverageForWizard}
          onSave={async () => {
            setCopilotWizardOpen(false);
            setEditingCoverageForWizard(null);
            await reloadCoverages();
          }}
        />
      )}

      {/* Link Forms Modal - Moved outside PageContent */}
      {linkFormsModalOpen && (
        <Overlay onClick={() => setLinkFormsModalOpen(false)}>
          <WideModal onClick={e => e.stopPropagation()}>
            <ModalHeader>
              <ModalTitle>Link Forms to {selectedCoverageForForms?.name}</ModalTitle>
              <CloseBtn onClick={() => setLinkFormsModalOpen(false)}>
                <XMarkIcon width={20} height={20}/>
              </CloseBtn>
            </ModalHeader>

            <TextInput
              placeholder="Search forms by name or number..."
              value={formSearchQuery || ''}
              onChange={e => setFormSearchQuery(e.target.value)}
              style={{
                marginBottom: '12px',
                border: '1px solid rgba(226, 232, 240, 0.6)',
                borderRadius: '8px',
                padding: '10px 12px',
                fontSize: '14px'
              }}
            />

            <FormLinkActions>
              <Button variant="ghost" onClick={() => setLinkFormIds(filteredForms.map(f => f.id))}>
                Select All ({filteredForms.length})
              </Button>
              <Button variant="ghost" onClick={() => setLinkFormIds([])}>
                Clear All
              </Button>
              <span style={{ fontSize: '14px', color: '#6b7280', marginLeft: 'auto' }}>
                {linkFormIds.length} selected
              </span>
            </FormLinkActions>

            <FormLinkContainer>
              {filteredForms.map(f => (
                <FormLinkItem key={f.id}>
                  <FormCheckbox
                    type="checkbox"
                    value={f.id}
                    checked={linkFormIds.includes(f.id)}
                    onChange={e => {
                      const val = e.target.value;
                      setLinkFormIds(ids =>
                        ids.includes(val) ? ids.filter(i => i !== val) : [...ids, val]
                      );
                    }}
                  />
                  <FormLabel>{f.formName || f.formNumber || 'Unnamed Form'}</FormLabel>
                </FormLinkItem>
              ))}
              {filteredForms.length === 0 && (
                <div style={{
                  textAlign: 'center',
                  padding: '32px',
                  color: '#6b7280',
                  fontStyle: 'italic'
                }}>
                  No forms found matching your search
                </div>
              )}
            </FormLinkContainer>

            <Actions>
              <Button onClick={saveLinkedForms}>Save Changes</Button>
              <Button variant="ghost" onClick={() => setLinkFormsModalOpen(false)}>Cancel</Button>
            </Actions>
          </WideModal>
        </Overlay>
      )}
    </PageContainer>
  );
}

/* ---------- simple debounce hook ---------- */
function useDebounce(value, ms=250){
  const [v,setV]=useState(value);
  useEffect(()=>{const id=setTimeout(()=>setV(value),ms);return ()=>clearTimeout(id);},[value,ms]);
  return v;
}

```

---

## src/components/CoverageStatesScreen.tsx

**Path:** `src/components/CoverageStatesScreen.tsx`

```tsx
import { useState, useEffect, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { doc, getDoc, updateDoc, serverTimestamp, collection, getDocs } from 'firebase/firestore';
import { db } from '@/firebase';
import { ComposableMap, Geographies, Geography } from 'react-simple-maps';
import styled, { keyframes } from 'styled-components';
import { Page, Container, PageHeader, Title } from '@components/ui/Layout';
import { Button } from '@components/ui/Button';
import { TextInput } from '@components/ui/Input';
import { CoverageSnapshot } from '@components/common/CoverageSnapshot';

const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;
const Spinner = styled.div`
  border: 4px solid #f3f3f3;
  border-top: 4px solid #6366f1;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: ${spin} 1s linear infinite;
  margin: 100px auto;
`;

// --- NEW UI BITS (match StatesScreen) -----------------------------
const HistoryButton = styled.button`
  position: fixed;
  bottom: 16px;
  right: 16px;
  width: 56px;
  height: 56px;
  border: none;
  border-radius: 50%;
  background: #374151;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  cursor: pointer;
  z-index: 1100;
  &:hover { background: #1f2937; }
`;

const Panel = styled.div`
  flex: 1 1 360px;
  background: #ffffff;
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  max-width: ${props => (props.collapsed ? '48px' : '420px')};
  transition: max-width 0.25s ease;
  overflow: hidden;
`;

const TogglePanelBtn = styled.button`
  position: absolute;
  top: 16px;
  right: -20px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: none;
  background: #7c3aed;
  color: #fff;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  &:hover { background:#5b21b6; }
`;

const Chip = styled.span`
  display:inline-flex;
  align-items:center;
  gap:4px;
  background:#f3f4f6;
  color:#374151;
  border-radius:16px;
  padding:4px 10px;
  font-size:14px;
  margin:4px;
`;

const ChipDelete = styled.button`
  background:none;
  border:none;
  color:#ef4444;
  cursor:pointer;
  line-height:1;
`;

const FloatingBar = styled.div`
  position:fixed;
  bottom:24px;
  right:96px;   /* leave room for history circle */
  display:flex;
  gap:12px;
  z-index:1200;
`;

export default function CoverageStatesScreen() {
  const { productId, coverageId } = useParams();
  const navigate = useNavigate();
  const [coverage, setCoverage] = useState(null);
  const [product, setProduct] = useState(null);
  const [parentCoverage, setParentCoverage] = useState(null);
  const [availableStates, setAvailableStates] = useState([]);
  const [selectedStates, setSelectedStates] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [newState, setNewState] = useState('');
  const [loading, setLoading] = useState(true);
  const [formsCount, setFormsCount] = useState(0);
  const [rulesCount, setRulesCount] = useState(0);

  const [panelCollapsed, setPanelCollapsed] = useState(false);
  const searchRef = useRef(null);
  const [debouncedQuery, setDebouncedQuery] = useState('');

  // keyboard shortcut `/` to jump to search
  useEffect(() => {
    const handler = e => {
      if (e.key === '/' && !e.target.matches('input, textarea, select')) {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);

  // debounce search
  useEffect(() => {
    const t = setTimeout(() => setSearchQuery(debouncedQuery), 250);
    return () => clearTimeout(t);
  }, [debouncedQuery]);

  const stateNameToCode = {
    "Alabama": "AL",
    "Alaska": "AK",
    "Arizona": "AZ",
    "Arkansas": "AR",
    "California": "CA",
    "Colorado": "CO",
    "Connecticut": "CT",
    "Delaware": "DE",
    "Florida": "FL",
    "Georgia": "GA",
    "Hawaii": "HI",
    "Idaho": "ID",
    "Illinois": "IL",
    "Indiana": "IN",
    "Iowa": "IA",
    "Kansas": "KS",
    "Kentucky": "KY",
    "Louisiana": "LA",
    "Maine": "ME",
    "Maryland": "MD",
    "Massachusetts": "MA",
    "Michigan": "MI",
    "Minnesota": "MN",
    "Mississippi": "MS",
    "Missouri": "MO",
    "Montana": "MT",
    "Nebraska": "NE",
    "Nevada": "NV",
    "New Hampshire": "NH",
    "New Jersey": "NJ",
    "New Mexico": "NM",
    "New York": "NY",
    "North Carolina": "NC",
    "North Dakota": "ND",
    "Ohio": "OH",
    "Oklahoma": "OK",
    "Oregon": "OR",
    "Pennsylvania": "PA",
    "Rhode Island": "RI",
    "South Carolina": "SC",
    "South Dakota": "SD",
    "Tennessee": "TN",
    "Texas": "TX",
    "Utah": "UT",
    "Vermont": "VT",
    "Virginia": "VA",
    "Washington": "WA",
    "West Virginia": "WV",
    "Wisconsin": "WI",
    "Wyoming": "WY",
  };

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        // Fetch coverage
        const coverageDoc = await getDoc(doc(db, `products/${productId}/coverages`, coverageId));
        if (!coverageDoc.exists()) throw new Error('Coverage not found');
        const coverageData = { id: coverageDoc.id, ...coverageDoc.data() };
        setCoverage(coverageData);
        setSelectedStates(coverageData.states || []);

        // Fetch product
        const productDoc = await getDoc(doc(db, 'products', productId));
        if (!productDoc.exists()) throw new Error('Product not found');
        const productData = productDoc.data();
        setProduct(productData);

        // Fetch parent coverage if exists
        if (coverageData.parentCoverageId) {
          const parentDoc = await getDoc(doc(db, `products/${productId}/coverages`, coverageData.parentCoverageId));
          if (parentDoc.exists()) {
            setParentCoverage({ id: parentDoc.id, ...parentDoc.data() });
            setAvailableStates(parentDoc.data().states || []);
          }
        } else {
          setAvailableStates(productData.availableStates || []);
        }

        // Fetch forms count
        const formsSnap = await getDocs(collection(db, `products/${productId}/coverages/${coverageId}/forms`));
        setFormsCount(formsSnap.size);

        // Fetch rules count
        const rulesSnap = await getDocs(collection(db, `products/${productId}/coverages/${coverageId}/rules`));
        setRulesCount(rulesSnap.size);
      } catch (error) {
        console.error('Error fetching data:', error);
        alert('Failed to load data.');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [productId, coverageId]);

  const handleAddState = () => {
    if (newState && availableStates.includes(newState) && !selectedStates.includes(newState)) {
      setSelectedStates([...selectedStates, newState]);
      setNewState('');
    }
  };

  const handleRemoveState = (state) => {
    setSelectedStates(selectedStates.filter(s => s !== state));
  };

  const handleSelectAll = () => {
    setSelectedStates([...availableStates]);
  };

  const handleClearAll = () => {
    setSelectedStates([]);
  };

  const handleSave = async () => {
    try {
      // Basic validation - ensure at least one state is selected
      if (selectedStates.length === 0) {
        alert('Please select at least one state.');
        return;
      }

      // Save the states
      await updateDoc(doc(db, `products/${productId}/coverages`, coverageId), {
        states: selectedStates,
        updatedAt: serverTimestamp(),
      });
      alert('States saved successfully!');
      navigate(-1);
    } catch (error) {
      console.error('Error saving states:', error);
      alert('Failed to save states.');
    }
  };

  if (loading) {
    return (
      <Page>
        <Container>
          <Spinner />
        </Container>
      </Page>
    );
  }

  if (!coverage || !product) return <div>Loading...</div>;

  const filteredStates = selectedStates.filter(state =>
    state.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <Page>
      <Container>
        <PageHeader>
          <Title>State Availability for {coverage.name}</Title>
          <Button variant="ghost" onClick={() => navigate(-1)}>Back</Button>
        </PageHeader>

        {/* Coverage Context Snapshot */}
        <div style={{ marginBottom: 24 }}>
          <CoverageSnapshot
            name={coverage.name}
            coverageCode={coverage.coverageCode}
            isOptional={coverage.isOptional}
            productName={product.name}
            parentCoverageName={parentCoverage?.name}
            statesCount={selectedStates.length}
            formsCount={formsCount}
            rulesCount={rulesCount}
            triggerLabel={coverage.coverageTrigger}
            valuationLabel={coverage.valuationMethod}
            territoryLabel={coverage.territory}
            coinsuranceLabel={coverage.coinsurance}
            waitingPeriodLabel={coverage.waitingPeriod}
          />
        </div>

        <div style={{ display:'flex', flexWrap:'wrap', gap:24 }}>
          {/* Map */}
          <div style={{ flex:'1 1 50%', background:'#fff', borderRadius:12, padding:20, boxShadow:'0 4px 12px rgba(0,0,0,0.1)' }}>
            <h2 style={{fontSize:24,fontWeight:600,marginBottom:16}}>US Map</h2>
            <ComposableMap
              projection="geoAlbersUsa"
              style={{ width: '100%', height: 'auto', margin: '0 auto' }}
            >
              <Geographies geography="https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json">
                {({ geographies }) =>
                  geographies
                    .filter(geo => stateNameToCode[geo.properties.name])
                    .map(geo => {
                      const stateCode = stateNameToCode[geo.properties.name];
                      const isAvailable = availableStates.includes(stateCode);
                      return (
                        <Geography
                          key={geo.rsmKey}
                          geography={geo}
                          onClick={() => {
                            if (!isAvailable) return;
                            if (selectedStates.includes(stateCode)) {
                              setSelectedStates(selectedStates.filter(s => s !== stateCode));
                            } else {
                              setSelectedStates([...selectedStates, stateCode]);
                            }
                          }}
                          style={{
                            default: {
                              fill: selectedStates.includes(stateCode) ? '#3B82F6' : isAvailable ? '#E5E7EB' : '#D1D5DB',
                              stroke: '#FFFFFF',
                              strokeWidth: 1,
                              outline: 'none',
                              cursor: isAvailable ? 'pointer' : 'default',
                            },
                            hover: {
                              fill: isAvailable ? (selectedStates.includes(stateCode) ? '#2563EB' : '#D1D5DB') : '#D1D5DB',
                              stroke: '#FFFFFF',
                              strokeWidth: 1,
                              outline: 'none',
                              cursor: isAvailable ? 'pointer' : 'default',
                            },
                            pressed: {
                              fill: isAvailable ? (selectedStates.includes(stateCode) ? '#1E40AF' : '#9CA3AF') : '#D1D5DB',
                              stroke: '#FFFFFF',
                              strokeWidth: 1,
                              outline: 'none',
                              cursor: isAvailable ? 'pointer' : 'default',
                            },
                          }}
                        />
                      );
                    })
                }
              </Geographies>
            </ComposableMap>
          </div>

          {/* CONTROL PANEL */}
          <Panel collapsed={panelCollapsed}>
            <TogglePanelBtn onClick={() => setPanelCollapsed(c=>!c)}>
              {panelCollapsed ? 'âŸ¨' : 'âŸ©'}
            </TogglePanelBtn>
            {!panelCollapsed && (
              <>
                <h2 style={{ fontSize:24, fontWeight:600, color:'#1F2937', marginBottom:16 }}>Applicable States</h2>
                <div style={{ display:'flex', gap:12, flexWrap:'wrap', marginBottom:16 }}>
                  <TextInput as="select" value={newState} onChange={e=>setNewState(e.target.value)}>
                    <option value="">Select State</option>
                    {availableStates.map(s=> <option key={s} value={s}>{s}</option>)}
                  </TextInput>
                  <Button primary onClick={handleAddState}>Add</Button>
                </div>
                <TextInput
                  ref={searchRef}
                  placeholder="Search States"
                  value={debouncedQuery}
                  onChange={e=>setDebouncedQuery(e.target.value)}
                  style={{ marginBottom:16 }}
                />
                {filteredStates.length > 0 ? (
                  <div style={{ maxHeight:260, overflowY:'auto' }}>
                    {filteredStates.map(state=>(
                      <Chip key={state}>
                        {state}
                        <ChipDelete onClick={()=>handleRemoveState(state)}>Ã—</ChipDelete>
                      </Chip>
                    ))}
                  </div>
                ) : (
                  <p style={{ textAlign:'center', fontSize:18, color:'#6B7280' }}>No States Selected</p>
                )}
              </>
            )}
          </Panel>
        </div>
        <FloatingBar>
          <Button ghost onClick={handleSelectAll}>Select&nbsp;All</Button>
          <Button ghost onClick={handleClearAll}>Clear&nbsp;All</Button>
          <Button success onClick={handleSave}>Save</Button>
        </FloatingBar>
        <HistoryButton aria-label="Back" onClick={()=>navigate(-1)}>
          â†©
        </HistoryButton>
      </Container>
    </Page>
  );
}
```

---

## src/components/DataDictionary.tsx

**Path:** `src/components/DataDictionary.tsx`

```tsx
import { useEffect, useState, useMemo } from 'react';
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  onSnapshot
} from 'firebase/firestore';
import { db } from '@/firebase';
import { Button } from '@components/ui/Button';
import { TextInput } from '@components/ui/Input';
import MainNavigation from './ui/Navigation';
import EnhancedHeader from './ui/EnhancedHeader';
import { PageContainer, PageContent } from './ui/PageContainer';
import { Breadcrumb } from './ui/Breadcrumb';
import {
  Squares2X2Icon,
  TableCellsIcon,
  PlusIcon,
  BookOpenIcon
} from '@heroicons/react/24/solid';
import styled from 'styled-components';

/* ---------- styled components ---------- */

// Action Bar
const ActionBar = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 32px;
  gap: 16px;

  @media (max-width: 768px) {
    flex-direction: column;
    gap: 12px;
  }
`;

const ActionGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
`;

// View Toggle
const ViewToggle = styled.div`
  display: flex;
  background: rgba(255, 255, 255, 0.9);
  border-radius: 12px;
  padding: 4px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
`;

const ViewToggleButton = styled.button.withConfig({
  shouldForwardProp: (prop) => !['active'].includes(prop),
})`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border: none;
  background: ${props => props.active ? 'rgba(99, 102, 241, 0.1)' : 'transparent'};
  color: ${props => props.active ? '#6366f1' : '#64748b'};
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: ${props => props.active ? 'rgba(99, 102, 241, 0.15)' : 'rgba(99, 102, 241, 0.05)'};
    color: #6366f1;
  }
`;

// Add Button
const AddButton = styled(Button)`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  font-size: 14px;
  background: rgba(99, 102, 241, 0.1);
  color: #6366f1;
  border: 1px solid rgba(99, 102, 241, 0.2);

  &:hover {
    background: rgba(99, 102, 241, 0.15);
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

// Table Container for table view
const TableContainer = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  padding: 24px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  margin-bottom: 60px;
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
`;

const THead = styled.thead`
  background: #f9fafb;
`;

const Tr = styled.tr`
  border-bottom: 1px solid #e5e7eb;

  &:hover {
    background: #f9fafb;
  }
`;

const Th = styled.th`
  padding: 16px 12px;
  text-align: ${({ align = 'left' }) => align};
  font-size: 14px;
  font-weight: 600;
  color: #374151;
  border-bottom: 2px solid #e5e7eb;
`;

const Td = styled.td`
  padding: 16px 12px;
  text-align: ${({ align = 'left' }) => align};
  font-size: 14px;
  color: #1f2937;
`;

// Cards Grid for card view
const CardsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 24px;
  margin-bottom: 60px;

  @media (max-width: 768px) {
    grid-template-columns: 1fr;
    gap: 16px;
  }
`;

// Data Dictionary Card
const DictCard = styled.div`
  background: white;
  border-radius: 12px;
  padding: 20px;
  border: 1px solid #e2e8f0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.2s ease;
  position: relative;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
    border-color: #6366f1;
  }
`;

const CardHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 16px;
`;

const CardTitle = styled.h3`
  font-size: 16px;
  font-weight: 600;
  color: #1f2937;
  margin: 0;
  flex: 1;
`;

const CategoryBadge = styled.span`
  display: inline-block;
  padding: 4px 8px;
  background: rgba(99, 102, 241, 0.1);
  color: #6366f1;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  margin-left: 12px;
`;

const CardContent = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const FieldGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 4px;
`;

const FieldLabel = styled.label`
  font-size: 12px;
  font-weight: 500;
  color: #6b7280;
  text-transform: uppercase;
  letter-spacing: 0.05em;
`;

const CategorySelect = styled(TextInput).attrs({ as: 'select' })`
  width: 100%;
  font-size: 14px;
  padding: 8px 12px;
`;

const CardActions = styled.div`
  display: flex;
  justify-content: flex-end;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid #f3f4f6;
`;

const DeleteButton = styled(Button)`
  padding: 6px 12px;
  font-size: 12px;
  background: rgba(220, 38, 38, 0.1);
  color: #dc2626;
  border: 1px solid rgba(220, 38, 38, 0.2);

  &:hover {
    background: rgba(220, 38, 38, 0.15);
    border-color: rgba(220, 38, 38, 0.3);
  }
`;

// Allowed categories for each entry
const CATEGORY_OPTIONS = [
  'Insured',
  'Product',
  'Pricing',
  'Rules',
  'Forms',
  'N/A'
];

export default function DataDictionary() {
  const [rows, setRows] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [viewMode, setViewMode] = useState('cards'); // 'cards' or 'table'

  // Subscribe to the 'dataDictionary' collection in Firestore
  useEffect(() => {
    const unsubscribe = onSnapshot(
      collection(db, 'dataDictionary'),
      snapshot => {
        const data = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
        setRows(data);
      },
      error => {
        console.error('Data Dictionary subscription error:', error);
      }
    );
    return unsubscribe;
  }, []);

  // Create a new blank row
  const handleAddRow = async () => {
    try {
      await addDoc(collection(db, 'dataDictionary'), {
        category: 'N/A',
        displayName: '',
        code: ''
      });
    } catch (err) {
      console.error('Failed to add Data Dictionary row:', err);
      alert('Unable to add row. Please try again.');
    }
  };

  // Update a single field in a row
  const handleUpdate = async (id, field, value) => {
    try {
      await updateDoc(doc(db, 'dataDictionary', id), { [field]: value });
    } catch (err) {
      console.error('Failed to update Data Dictionary row:', err);
      alert('Unable to save changes. Please retry.');
    }
  };

  // Delete a row after confirmation
  const handleDelete = async id => {
    if (!window.confirm('Delete this entry?')) return;
    try {
      await deleteDoc(doc(db, 'dataDictionary', id));
    } catch (err) {
      console.error('Failed to delete Data Dictionary row:', err);
      alert('Unable to delete. Please retry.');
    }
  };

  // Filter rows based on search query
  const filteredRows = useMemo(() => {
    if (!searchQuery.trim()) return rows;

    const query = searchQuery.toLowerCase();
    return rows.filter(row =>
      (row.displayName || '').toLowerCase().includes(query) ||
      (row.code || '').toLowerCase().includes(query) ||
      (row.category || '').toLowerCase().includes(query)
    );
  }, [rows, searchQuery]);

  return (
    <PageContainer withOverlay={true}>
      <MainNavigation />
      <PageContent>
        <Breadcrumb
          items={[
            { label: 'Home', path: '/' },
            { label: 'Data Dictionary' }
          ]}
        />

        <EnhancedHeader
          title="Data Dictionary"
          subtitle={`Manage and organize ${rows.length} data definitions and mappings`}
          icon={BookOpenIcon}
          searchProps={{
            placeholder: "Search by display name, code, or category...",
            value: searchQuery,
            onChange: (e) => setSearchQuery(e.target.value)
          }}
        />

        {/* Action Bar with View Toggle */}
        <ActionBar>
          <ActionGroup>
            <ViewToggle>
              <ViewToggleButton
                active={viewMode === 'cards'}
                onClick={() => setViewMode('cards')}
              >
                <Squares2X2Icon width={16} height={16} />
                Cards
              </ViewToggleButton>
              <ViewToggleButton
                active={viewMode === 'table'}
                onClick={() => setViewMode('table')}
              >
                <TableCellsIcon width={16} height={16} />
                Table
              </ViewToggleButton>
            </ViewToggle>
          </ActionGroup>
          <AddButton onClick={handleAddRow}>
            <PlusIcon width={16} height={16} />
            Add Entry
          </AddButton>
        </ActionBar>

        {/* Data Display */}
        {filteredRows.length ? (
          viewMode === 'cards' ? (
            <CardsGrid>
              {filteredRows.map(row => (
                <DictCard key={row.id}>
                  <CardHeader>
                    <CardTitle>
                      {row.displayName || 'Unnamed Entry'}
                    </CardTitle>
                    <CategoryBadge>{row.category || 'N/A'}</CategoryBadge>
                  </CardHeader>
                  <CardContent>
                    <FieldGroup>
                      <FieldLabel>Category</FieldLabel>
                      <CategorySelect
                        value={row.category || 'N/A'}
                        onChange={e => handleUpdate(row.id, 'category', e.target.value)}
                      >
                        {CATEGORY_OPTIONS.map(opt => (
                          <option key={opt} value={opt}>
                            {opt}
                          </option>
                        ))}
                      </CategorySelect>
                    </FieldGroup>
                    <FieldGroup>
                      <FieldLabel>Display Name</FieldLabel>
                      <TextInput
                        value={row.displayName}
                        onChange={e => handleUpdate(row.id, 'displayName', e.target.value)}
                        placeholder="Display Name"
                      />
                    </FieldGroup>
                    <FieldGroup>
                      <FieldLabel>IT Code</FieldLabel>
                      <TextInput
                        value={row.code}
                        onChange={e => handleUpdate(row.id, 'code', e.target.value)}
                        placeholder="IT Code"
                      />
                    </FieldGroup>
                  </CardContent>
                  <CardActions>
                    <DeleteButton onClick={() => handleDelete(row.id)}>
                      Delete
                    </DeleteButton>
                  </CardActions>
                </DictCard>
              ))}
            </CardsGrid>
          ) : (
            <TableContainer>
              <Table>
                <THead>
                  <Tr>
                    <Th>Category</Th>
                    <Th>Display Name</Th>
                    <Th>IT Code</Th>
                    <Th align="center" style={{ width: 150 }}>Actions</Th>
                  </Tr>
                </THead>
                <tbody>
                  {filteredRows.map(row => (
                    <Tr key={row.id}>
                      <Td>
                        <CategorySelect
                          value={row.category || 'N/A'}
                          onChange={e => handleUpdate(row.id, 'category', e.target.value)}
                        >
                          {CATEGORY_OPTIONS.map(opt => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </CategorySelect>
                      </Td>
                      <Td>
                        <TextInput
                          value={row.displayName}
                          onChange={e => handleUpdate(row.id, 'displayName', e.target.value)}
                          placeholder="Display Name"
                        />
                      </Td>
                      <Td>
                        <TextInput
                          value={row.code}
                          onChange={e => handleUpdate(row.id, 'code', e.target.value)}
                          placeholder="IT Code"
                        />
                      </Td>
                      <Td align="center">
                        <DeleteButton onClick={() => handleDelete(row.id)}>
                          Delete
                        </DeleteButton>
                      </Td>
                    </Tr>
                  ))}
                </tbody>
              </Table>
            </TableContainer>
          )
        ) : (
          <div style={{
            textAlign: 'center',
            padding: '60px 20px',
            color: '#6b7280',
            fontSize: '16px'
          }}>
            {searchQuery ? 'No entries match your search.' : 'No data dictionary entries yet.'}
          </div>
        )}
      </PageContent>
    </PageContainer>
  );
}
```

---

## src/components/DataDictionaryModal.tsx

**Path:** `src/components/DataDictionaryModal.tsx`

```tsx
// src/components/DataDictionaryModal.js

import { useEffect, useState } from 'react';
import PropTypes from 'prop-types';
// Firestore imports for real-time subscription and mutations
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  onSnapshot
} from 'firebase/firestore';
import { db } from '../firebase';
// Shared UI primitives
import {
  Table,
  THead,
  Tr,
  Th,
  Td,
  Overlay,
  Modal,
  ModalHeader,
  ModalTitle,
  CloseBtn
} from '../components/ui/Table';
import { Button } from '../components/ui/Button';
import { TextInput } from '../components/ui/Input';
import styled from 'styled-components';

const WideModal = styled(Modal)`
  max-width: 900px;
  width: 90%;
`;

// Allowed categories for each entry
const CATEGORY_OPTIONS = [
  'Insured',
  'Product',
  'Pricing',
  'Rules',
  'Forms',
  'N/A'
];

// A styled wrapper for the category <select>, matching TextInput look
const CategorySelect = styled(TextInput).attrs({ as: 'select' })`
  width: 100%;
`;

export default function DataDictionaryModal({ open, onClose }) {
  // Local state for rows fetched from Firestore
  const [rows, setRows] = useState([]);

  // Subscribe to the 'dataDictionary' collection in Firestore
  useEffect(() => {
    if (!open) return; // only subscribe when modal is open
    const unsubscribe = onSnapshot(
      collection(db, 'dataDictionary'),
      snapshot => {
        const data = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
        setRows(data);
      },
      error => {
        console.error('Data Dictionary subscription error:', error);
      }
    );
    return unsubscribe;
  }, [open]);

  // Create a new blank row
  const handleAddRow = async () => {
    try {
      await addDoc(collection(db, 'dataDictionary'), {
        category: 'N/A',
        displayName: '',
        code: ''
      });
      // onSnapshot will update local state automatically
    } catch (err) {
      console.error('Failed to add Data Dictionary row:', err);
      alert('Unable to add row. Please try again.');
    }
  };

  // Update a single field in a row
  const handleUpdate = async (id, field, value) => {
    try {
      await updateDoc(doc(db, 'dataDictionary', id), { [field]: value });
      // optimistic UI: local state will reflect Firestore update via onSnapshot
    } catch (err) {
      console.error('Failed to update Data Dictionary row:', err);
      alert('Unable to save changes. Please retry.');
    }
  };

  // Delete a row after confirmation
  const handleDelete = async id => {
    if (!window.confirm('Delete this entry?')) return;
    try {
      await deleteDoc(doc(db, 'dataDictionary', id));
    } catch (err) {
      console.error('Failed to delete Data Dictionary row:', err);
      alert('Unable to delete. Please retry.');
    }
  };

  // If not open, render nothing
  if (!open) return null;

  return (
    <Overlay onClick={onClose}>
      <WideModal onClick={e => e.stopPropagation()}>
        {/* Header with title and close button */}
        <ModalHeader>
          <ModalTitle>Data Dictionary</ModalTitle>
          <CloseBtn onClick={onClose}>âœ•</CloseBtn>
        </ModalHeader>

        {/* Data table */}
        <Table style={{ marginBottom: 24 }}>
          <THead>
            <Tr>
              <Th>Category</Th>
              <Th>Display Name</Th>
              <Th>IT Code</Th>
              <Th align="center" style={{ width: 150 }} />
            </Tr>
          </THead>
          <tbody>
            {rows.map(row => (
              <Tr key={row.id}>
                {/* Category dropdown */}
                <Td>
                  <CategorySelect
                    value={row.category || 'N/A'}
                    onChange={e => handleUpdate(row.id, 'category', e.target.value)}
                  >
                    {CATEGORY_OPTIONS.map(opt => (
                      <option key={opt} value={opt}>
                        {opt}
                      </option>
                    ))}
                  </CategorySelect>
                </Td>

                {/* Display Name input */}
                <Td>
                  <TextInput
                    value={row.displayName}
                    onChange={e => handleUpdate(row.id, 'displayName', e.target.value)}
                    placeholder="Display Name"
                  />
                </Td>

                {/* IT Code input */}
                <Td>
                  <TextInput
                    value={row.code}
                    onChange={e => handleUpdate(row.id, 'code', e.target.value)}
                    placeholder="IT Code"
                  />
                </Td>

                {/* Delete button */}
                <Td align="center">
                  <Button
                    variant="danger"
                    onClick={() => handleDelete(row.id)}
                    style={{ padding: '4px 8px' }}
                  >
                    Delete
                  </Button>
                </Td>
              </Tr>
            ))}
          </tbody>
        </Table>

        {/* Add Row action */}
        <Button onClick={handleAddRow}>Add Row</Button>
      </WideModal>
    </Overlay>
  );
}

DataDictionaryModal.propTypes = {
  /** Whether the modal is visible */
  open: PropTypes.bool.isRequired,
  /** Callback to close the modal */
  onClose: PropTypes.func.isRequired
};
```

---

## src/components/ErrorBoundary.tsx

**Path:** `src/components/ErrorBoundary.tsx`

```tsx
/**
 * ErrorBoundary Component
 *
 * Enhancements:
 * - Comprehensive error logging with context
 * - Accessibility features (ARIA labels, keyboard navigation)
 * - Development vs production error display
 * - Error recovery with retry mechanism
 */

import React from 'react';
import styled from 'styled-components';
import { ExclamationTriangleIcon, ArrowPathIcon } from '@heroicons/react/24/outline';
import logger, { LOG_CATEGORIES } from '@utils/logger';

const ErrorContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  padding: 40px 20px;
  text-align: center;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  margin: 20px;
`;

const ErrorIcon = styled.div`
  width: 80px;
  height: 80px;
  background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 24px;
  
  svg {
    width: 40px;
    height: 40px;
    color: #dc2626;
  }
`;

const ErrorTitle = styled.h2`
  font-size: 24px;
  font-weight: 600;
  color: #111827;
  margin: 0 0 12px 0;
`;

const ErrorMessage = styled.p`
  font-size: 16px;
  color: #6b7280;
  margin: 0 0 32px 0;
  max-width: 500px;
  line-height: 1.6;
`;

const ErrorDetails = styled.details`
  margin: 20px 0;
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
  max-width: 600px;
  text-align: left;
  
  summary {
    cursor: pointer;
    font-weight: 500;
    color: #374151;
    margin-bottom: 8px;
  }
  
  pre {
    font-size: 12px;
    color: #6b7280;
    white-space: pre-wrap;
    word-break: break-word;
    margin: 8px 0 0 0;
  }
`;

const RetryButton = styled.button`
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 12px 24px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
  }
  
  &:active {
    transform: translateY(0);
  }
  
  svg {
    width: 18px;
    height: 18px;
  }
`;

interface ErrorFallbackProps {
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
  resetError: () => void;
}

const ErrorFallback: React.FC<ErrorFallbackProps> = ({ error, errorInfo, resetError }) => {
  const isDevelopment = process.env.NODE_ENV === 'development';

  return (
    <ErrorContainer role="alert" aria-live="assertive">
      <ErrorIcon aria-hidden="true">
        <ExclamationTriangleIcon />
      </ErrorIcon>

      <ErrorTitle id="error-title">Something went wrong</ErrorTitle>

      <ErrorMessage aria-describedby="error-title">
        We encountered an unexpected error. This has been logged and our team will investigate.
        Please try refreshing the page or contact support if the problem persists.
      </ErrorMessage>

      {/* Optimized: Accessible retry button with keyboard support */}
      <RetryButton
        onClick={resetError}
        aria-label="Retry the operation"
        onKeyDown={(e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            resetError();
          }
        }}
      >
        <ArrowPathIcon />
        Try Again
      </RetryButton>

      {isDevelopment && error && (
        <ErrorDetails>
          <summary>Error Details (Development Only)</summary>
          <pre>
            <strong>Error:</strong> {error.toString()}
            {errorInfo && (
              <>
                <br /><br />
                <strong>Component Stack:</strong>
                {errorInfo.componentStack}
              </>
            )}
          </pre>
        </ErrorDetails>
      )}
    </ErrorContainer>
  );
};

interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: (error: Error | null, errorInfo: React.ErrorInfo | null, resetError: () => void) => React.ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(_error: Error): Partial<ErrorBoundaryState> {
    // Update state so the next render will show the fallback UI
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    // Optimized: Comprehensive error logging with context
    logger.error(LOG_CATEGORIES.ERROR, 'Error caught by ErrorBoundary', {
      errorMessage: error.message,
      errorStack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent
    }, error);

    this.setState({
      error,
      errorInfo
    });

    // In production, send to error reporting service
    if (process.env.NODE_ENV === 'production') {
      // Example: Sentry.captureException(error, { contexts: { react: errorInfo } });
      logger.warn(LOG_CATEGORIES.ERROR, 'Error in production - consider integrating error reporting service');
    }
  }

  resetError = (): void => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };

  render(): React.ReactNode {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback(this.state.error, this.state.errorInfo, this.resetError);
      }

      // Default fallback UI
      return (
        <ErrorFallback
          error={this.state.error}
          errorInfo={this.state.errorInfo}
          resetError={this.resetError}
        />
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
export { ErrorFallback };
```

---

## src/components/FormsScreen.tsx

**Path:** `src/components/FormsScreen.tsx`

```tsx
import { useState, useEffect, useMemo, useRef } from 'react';
import { useParams, useLocation } from 'react-router-dom';
import { db } from '@/firebase';
import {
  collection, getDocs, addDoc, deleteDoc, doc, updateDoc,
  query, where, getDoc, writeBatch, serverTimestamp
} from 'firebase/firestore';
import { uploadFormPdf, deleteFormPdf } from '@utils/storage';
import { getFormDisplayName } from '@utils/format';
import {
  TrashIcon, DocumentTextIcon, PlusIcon, XMarkIcon,
  LinkIcon, PencilIcon, MagnifyingGlassIcon,
  Squares2X2Icon
} from '@heroicons/react/24/solid';
import { CoverageSnapshot } from '@components/common/CoverageSnapshot';



import { Button } from '@components/ui/Button';
import { TextInput } from '@components/ui/Input';
import MainNavigation from '@components/ui/Navigation';
import { PageContainer, PageContent } from '@components/ui/PageContainer';
import EnhancedHeader from '@components/ui/EnhancedHeader';


import {
  Overlay, Modal, ModalHeader, ModalTitle, CloseBtn
} from '@components/ui/Table';

import styled, { keyframes } from 'styled-components';

/* ---------- styled helpers ---------- */
const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;
const Spinner = styled.div`
  border: 4px solid #f3f3f3;
  border-top: 4px solid #6366f1;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: ${spin} 1s linear infinite;
  margin: 100px auto;
`;

/* Gradient pillâ€‘button reused for â€œAdd Formâ€ */




/* highâ€‘z blurred backdrop */
const OverlayFixed = styled(Overlay)`
  position: fixed !important;
  inset: 0;
  background: rgba(17,24,39,0.55);
  backdrop-filter: blur(2px);
  z-index: 1400;
  display: flex;
  align-items: center;
  justify-content: center;
`;

/* ---------- Modern Styled Components ---------- */

// Filters Bar - Similar to pricing screen
const FiltersBar = styled.div`
  display: flex;
  gap: 24px;
  margin-bottom: 32px;
  padding: 20px 24px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(20px);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  align-items: end;
  position: relative;
  z-index: 10;

  @media (max-width: 768px) {
    flex-direction: column;
    gap: 16px;
    align-items: stretch;
  }
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex: 1;

  label {
    font-size: 14px;
    font-weight: 600;
    color: #374151;
    margin-bottom: 4px;
  }
`;

const FilterWrapper = styled.div`
  display: inline-flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  min-width: 200px;
  position: relative;
  z-index: 20;
`;



const AddButton = styled.button`
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 14px;
  font-size: 12px;
  font-weight: 600;
  color: #ffffff;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border: none;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(99, 102, 241, 0.25);
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 100;
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.2);

  &:hover {
    transform: translateX(-50%) translateY(-2px) scale(1.02);
    box-shadow: 0 8px 24px rgba(99, 102, 241, 0.35);
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
  }

  svg {
    width: 12px;
    height: 12px;
  }
`;

// Forms Grid - Single column layout like coverage screen
const FormsGrid = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-bottom: 120px;

  @media (max-width: 768px) {
    gap: 12px;
  }
`;

// Form Card - Full width design matching parent coverage cards
const FormCard = styled.div`
  background: white;
  border-radius: 12px;
  padding: 16px;
  border: 1px solid #e2e8f0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.2s ease;
  position: relative;
  width: 100%;
  z-index: 1;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
    border-color: #6366f1;
    z-index: 2;
  }
`;

const CardHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 14px;
  gap: 8px;
`;

// Container for title and tags
const TitleAndTagsContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 1;
  flex-wrap: wrap;
`;

const CardTitle = styled.h3`
  font-size: 18px;
  font-weight: 700;
  color: #1e293b;
  margin: 0;
  line-height: 1.3;
  letter-spacing: -0.025em;
`;

const CardCode = styled.span`
  font-size: 13px;
  font-weight: 600;
  color: #6366f1;
  background: rgba(99, 102, 241, 0.1);
  padding: 6px 12px;
  border-radius: 8px;
  margin-left: 16px;
  border: 1px solid rgba(99, 102, 241, 0.2);
  letter-spacing: 0.025em;
`;

const CardActions = styled.div`
  display: flex;
  gap: 8px;
  margin-left: 12px;
`;

const IconButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border: none;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.8);
  color: #64748b;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(255, 255, 255, 0.2);

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
  }

  &.danger:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
  }
`;

// Card Content
const CardContent = styled.div`
  margin-bottom: 12px;
`;

const CardCategory = styled.div.withConfig({
  shouldForwardProp: (prop) => !['category'].includes(prop),
})`
  display: inline-block;
  background: ${({ category }) => {
    switch (category) {
      case 'Base Coverage Form': return 'linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(99, 102, 241, 0.1) 100%)';
      case 'Endorsement': return 'linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(34, 197, 94, 0.1) 100%)';
      case 'Exclusion': return 'linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(251, 191, 36, 0.1) 100%)';
      default: return 'linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%)';
    }
  }};
  color: ${({ category }) => {
    switch (category) {
      case 'Base Coverage Form': return '#3b82f6';
      case 'Endorsement': return '#22c55e';
      case 'Exclusion': return '#f59e0b';
      default: return '#6366f1';
    }
  }};
  border: ${({ category }) => {
    switch (category) {
      case 'Base Coverage Form': return '1px solid rgba(59, 130, 246, 0.2)';
      case 'Endorsement': return '1px solid rgba(34, 197, 94, 0.2)';
      case 'Exclusion': return '1px solid rgba(245, 158, 11, 0.2)';
      default: return '1px solid rgba(99, 102, 241, 0.2)';
    }
  }};
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 10px;
  font-weight: 600;
  margin: 0;
  text-transform: uppercase;
  letter-spacing: 0.025em;
`;

const ExclusionsSection = styled.div`
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid #e5e7eb;
`;

const ExclusionsSectionTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #6b7280;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
`;

const ExclusionsList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 200px;
  overflow-y: auto;
`;

const ExclusionItem = styled.div`
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 8px 12px;
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  font-size: 13px;
`;

const ExclusionType = styled.span`
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  background: #fef3c7;
  color: #92400e;
  border: 1px solid #fbbf24;
  flex-shrink: 0;
`;

const ExclusionDetails = styled.div`
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
`;

const ExclusionName = styled.div`
  font-weight: 500;
  color: #111827;
`;

const ExclusionCoverage = styled.div`
  font-size: 12px;
  color: #6b7280;
  font-style: italic;
`;



const CardMetrics = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 12px;
  margin-top: 14px;
`;

const MetricItem = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  background: rgba(248, 250, 252, 0.8);
  backdrop-filter: blur(8px);
  border-radius: 10px;
  font-size: 13px;
  color: #64748b;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  border: 1px solid rgba(226, 232, 240, 0.5);
  font-weight: 500;

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(99, 102, 241, 0.15);
    border-color: rgba(99, 102, 241, 0.2);
  }

  svg {
    width: 16px;
    height: 16px;
    opacity: 0.8;
  }
`;



// Forms Stats Dashboard
const slideIn = keyframes`
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
`;

const FormsStatsDashboard = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
  animation: ${slideIn} 0.4s ease-out;
`;

const FormsStatCard = styled.div<{ $color?: string }>`
  background: white;
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: ${({ $color }) => $color || 'linear-gradient(90deg, #6366f1, #8b5cf6)'};
  }

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
    border-color: transparent;
  }
`;

const FormsStatValue = styled.div`
  font-size: 28px;
  font-weight: 700;
  color: #1e293b;
  margin-bottom: 4px;
  letter-spacing: -0.02em;
`;

const FormsStatLabel = styled.div`
  font-size: 13px;
  font-weight: 500;
  color: #64748b;
  display: flex;
  align-items: center;
  gap: 6px;

  svg {
    width: 14px;
    height: 14px;
    opacity: 0.7;
  }
`;

// Empty State
const EmptyState = styled.div`
  text-align: center;
  padding: 80px 20px;
  color: #64748b;
`;

const EmptyStateTitle = styled.h3`
  font-size: 24px;
  font-weight: 600;
  color: #475569;
  margin: 0 0 12px 0;
`;

const EmptyStateText = styled.p`
  font-size: 16px;
  color: #64748b;
  margin: 0 0 24px 0;
`;



/* ---------- component ---------- */
export default function FormsScreen() {
  const { productId } = useParams();
  const location = useLocation();
  const { coverageId } = location.state || {};


  /* data state */
  const [forms, setForms] = useState([]);
  const [products, setProducts] = useState([]);
  const [coverages, setCoverages] = useState([]);
  const [coverageExclusions, setCoverageExclusions] = useState({}); // Map of coverageId -> exclusions array

  /* coverage snapshot state - for when viewing forms for a specific coverage */
  const [selectedCoverageData, setSelectedCoverageData] = useState<any>(null);
  const [parentCoverageData, setParentCoverageData] = useState<any>(null);
  const [coverageRulesCount, setCoverageRulesCount] = useState(0);

  // --- filter/search state for modals
  const [coverageSearch, setCoverageSearch] = useState('');
  const [productSearch, setProductSearch] = useState('');

  /* search state (debounced) */
  const [rawSearch, setRawSearch] = useState('');
  const searchQuery = useDebounce(rawSearch, 250);
  const searchRef = useRef(null);

  /* filter state */
  const [selectedCoverage, setSelectedCoverage] = useState(null);
  const [selectedFilterStates, setSelectedFilterStates] = useState([]);

  /* ui state */
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  /* addâ€‘form modal */
  const [showModal, setShowModal] = useState(false);
  const [formName, setFormName] = useState('');
  const [formNumber, setFormNumber] = useState('');
  const [effectiveDate, setEffectiveDate] = useState('');
  const [type, setType] = useState('ISO');
  const [category, setCategory] = useState('Base Coverage Form');
  const [selectedProduct, setSelectedProduct] = useState(productId || '');
  const [selectedCoverages, setSelectedCoverages] = useState([]);
  const [selectedStates, setSelectedStates] = useState([]);
  const [file, setFile] = useState(null);

  /* linkâ€‘coverage modal */
  const [linkCoverageModalOpen, setLinkCoverageModalOpen] = useState(false);
  const [selectedForm, setSelectedForm] = useState(null);
  const [linkCoverageIds, setLinkCoverageIds] = useState([]);

  /* linkâ€‘product modal */
  const [linkProductModalOpen, setLinkProductModalOpen] = useState(false);
  const [linkProductIds, setLinkProductIds] = useState([]);

  /* states modal */
  const [statesModalOpen, setStatesModalOpen] = useState(false);
  const [selectedFormForStates, setSelectedFormForStates] = useState(null);
  const [formStates, setFormStates] = useState([]);

  /* version sidebar */
  const [editingId, setEditingId] = useState(null);
  const [changeSummary, setChangeSummary] = useState('');

  // Export/Import states







  /* ---------- computed values ---------- */
  const allStates = ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'];

  // Filter options for dropdowns
  const coverageOptions = [
    { value: null, label: 'All Coverages' },
    ...coverages.map(c => ({ value: c.name, label: c.name }))
  ].sort((a, b) => a.label.localeCompare(b.label));

  const stateOptions = [
    { value: null, label: 'All States' },
    ...allStates.map(state => ({ value: state, label: state }))
  ];

  /* ---------- sideâ€‘effects ---------- */

  /* `/` shortcut to focus */
  useEffect(() => {
    const handler = e => {
      if (e.key === '/' && !e.target.matches('input,textarea,select')) {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);

  /* fetch data */
  useEffect(() => {
    const fetchAll = async () => {
      setLoading(true);
      setError(null);
      try {
        /* products */
        const pSnap = await getDocs(collection(db, 'products'));
        const productList = pSnap.docs.map(d => ({ id: d.id, ...d.data() }));
        productList.sort((a, b) => a.name.localeCompare(b.name));
        setProducts(productList);

        /* coverages */
        let coverageList = [];
        if (productId) {
          const cSnap = await getDocs(collection(db, `products/${productId}/coverages`));
          coverageList = cSnap.docs.map(d => ({ id: d.id, ...d.data(), productId }));
        } else {
          for (const product of productList) {
            const cSnap = await getDocs(collection(db, `products/${product.id}/coverages`));
            coverageList = [
              ...coverageList,
              ...cSnap.docs.map(d => ({ id: d.id, ...d.data(), productId: product.id }))
            ];
          }
        }
        coverageList.sort((a, b) => a.name.localeCompare(b.name));
        setCoverages(coverageList);

        /* Load exclusions for each coverage */
        const exclusionsMap = {};
        for (const coverage of coverageList) {
          if (coverage.exclusions && coverage.exclusions.length > 0) {
            exclusionsMap[coverage.id] = coverage.exclusions;
          }
        }
        setCoverageExclusions(exclusionsMap);

        /* forms */
        const fSnap = await getDocs(collection(db, 'forms'));

        // Fetch all form-coverage links
        const linksSnap = await getDocs(collection(db, 'formCoverages'));
        const coveragesByForm = {};
        linksSnap.docs.forEach(doc => {
          const { formId, coverageId } = doc.data();
          if (!coveragesByForm[formId]) {
            coveragesByForm[formId] = [];
          }
          coveragesByForm[formId].push(coverageId);
        });

        const formList = await Promise.all(
          fSnap.docs.map(async d => {
            const data = d.data();
            let url = null;
            if (data.filePath) {
              try { url = await getDownloadURL(ref(storage, data.filePath)); } catch {}
            }
            return {
              ...data,
              id: d.id,
              downloadUrl: url,
              productIds: data.productIds || (data.productId ? [data.productId] : []),
              coverageIds: coveragesByForm[d.id] || []
            };
          })
        );
        setForms(formList);
      } catch (err) {
        console.error(err);
        setError('Failed to load data. Please try again.');
      } finally {
        setLoading(false);
      }
    };
    fetchAll();
  }, [productId]);

  /* Fetch coverage snapshot data when viewing forms for a specific coverage */
  useEffect(() => {
    const fetchCoverageSnapshot = async () => {
      if (!productId || !coverageId) {
        setSelectedCoverageData(null);
        setParentCoverageData(null);
        return;
      }

      try {
        // Fetch the coverage
        const coverageRef = doc(db, `products/${productId}/coverages`, coverageId);
        const coverageSnap = await getDoc(coverageRef);
        if (coverageSnap.exists()) {
          const coverageData = { id: coverageSnap.id, ...coverageSnap.data() };
          setSelectedCoverageData(coverageData);

          // Fetch parent coverage if exists
          if (coverageData.parentCoverageId) {
            const parentRef = doc(db, `products/${productId}/coverages`, coverageData.parentCoverageId);
            const parentSnap = await getDoc(parentRef);
            if (parentSnap.exists()) {
              setParentCoverageData({ id: parentSnap.id, ...parentSnap.data() });
            }
          }

          // Fetch rules count for this coverage
          const rulesSnap = await getDocs(collection(db, `products/${productId}/coverages/${coverageId}/rules`));
          setCoverageRulesCount(rulesSnap.size);
        }
      } catch (err) {
        console.error('Error fetching coverage snapshot data:', err);
      }
    };
    fetchCoverageSnapshot();
  }, [productId, coverageId]);

  /* maps */
  const productMap = useMemo(() =>
    Object.fromEntries(products.map(p => [p.id, p.name])), [products]);

  const coverageMap = useMemo(() =>
    Object.fromEntries(coverages.map(c => [c.id, c.name])), [coverages]);

  /* Get exclusions for a form based on its linked coverages */
  const getFormExclusions = useMemo(() => {
    const formExclusionsMap = {};
    forms.forEach(form => {
      const exclusions = [];
      if (form.coverageIds && form.coverageIds.length > 0) {
        form.coverageIds.forEach(covId => {
          if (coverageExclusions[covId]) {
            coverageExclusions[covId].forEach(exclusion => {
              exclusions.push({
                ...exclusion,
                coverageName: coverageMap[covId] || 'Unknown Coverage'
              });
            });
          }
        });
      }
      formExclusionsMap[form.id] = exclusions;
    });
    return formExclusionsMap;
  }, [forms, coverageExclusions, coverageMap]);

  /* filtered forms â€“ memoised */
  const filteredForms = useMemo(() => {
    return forms.filter(f => {
      const q = searchQuery.toLowerCase();
      const matchesSearch =
        (f.formName || '').toLowerCase().includes(q) ||
        f.formNumber.toLowerCase().includes(q) ||
        (f.category || '').toLowerCase().includes(q) ||
        (f.type || '').toLowerCase().includes(q);

      const matchesProduct = productId ? (f.productIds || []).includes(productId) : true;

      // Apply coverage filter
      const matchesCoverage = selectedCoverage ?
        f.coverageIds && f.coverageIds.some(covId => {
          const coverage = coverages.find(c => c.id === covId);
          return coverage && coverage.name === selectedCoverage;
        }) : true;

      // Apply states filter
      const matchesStates = selectedFilterStates.length > 0 ?
        f.states && selectedFilterStates.every(state => f.states.includes(state)) : true;

      return matchesSearch && matchesProduct && matchesCoverage && matchesStates;
    });
  }, [forms, searchQuery, productId, selectedCoverage, selectedFilterStates, coverages]);

  /* ---------- handlers (add, delete, link) ---------- */
  // open the modal preâ€‘filled for editing an existing form
  const openEditModal = formObj => {
    setFormName(formObj.formName || '');
    setFormNumber(formObj.formNumber);
    setEffectiveDate(formObj.effectiveDate);
    setType(formObj.type);
    setCategory(formObj.category);
    setSelectedProduct(formObj.productIds?.[0] || formObj.productId || '');
    setSelectedCoverages(formObj.coverageIds || []);
    setSelectedStates(formObj.states || []);
    setFile(null);            // user can (re)upload if desired
    setEditingId(formObj.id);
    setChangeSummary('');
    setShowModal(true);
  };
  const openLinkProductModal = form => {
    setSelectedForm(form);
    setLinkProductIds(form.productIds || (form.productId ? [form.productId] : []));
    setLinkProductModalOpen(true);
  };

  const handleLinkProducts = async () => {
    if (!selectedForm) return;
    try {
      const formId = selectedForm.id;
      await updateDoc(doc(db, 'forms', formId), {
        productIds: linkProductIds,
        /* keep legacy singleâ€‘ID field for older code paths */
        productId: linkProductIds[0] || null
      });
      setForms(fs => fs.map(f =>
        f.id === formId ? { ...f, productIds: linkProductIds } : f
      ));
      setLinkProductModalOpen(false);
      setSelectedForm(null);
      setLinkProductIds([]);
    } catch (err) {
      console.error(err);
      alert('Failed to link products.');
    }
  };
  const handleSaveForm = async () => {
    if (!formNumber || !effectiveDate || !selectedProduct) {
      alert('Form Number, Effective Date, and Product are required.');
      return;
    }
    if (editingId && changeSummary.trim().length < 10) {
      alert('Please provide a reason for the change (at least 10 characters).');
      return;
    }
    try {
      const basePayload = {
        formName: formName || null,
        formNumber,
        formEditionDate: effectiveDate,
        effectiveDate,
        type,
        category,
        productIds: selectedProduct ? [selectedProduct] : [],
        productId: selectedProduct,
        states: selectedStates
      };
      let filePath = null;
      let downloadUrl = null;
      if (file) {
        const uploadResult = await uploadFormPdf(file, selectedProduct);
        filePath = uploadResult.filePath;
        downloadUrl = uploadResult.downloadUrl;
      }
      const payload = {
        ...basePayload,
        ...(filePath && { filePath, downloadUrl })
      };
      let formId;
      if (editingId) {
        await updateDoc(doc(db, 'forms', editingId), payload);
        formId = editingId;
      } else {
        const docRef = await addDoc(collection(db, 'forms'), {
          ...payload,
          filePath,
          downloadUrl,
          createdAt: serverTimestamp()
        });
        formId = docRef.id;
      }

      // âœ… Link to coverages via junction table only (no array writes)
      const batch = writeBatch(db);

      // Delete old links for this form
      const existingLinksSnap = await getDocs(
        query(collection(db, 'formCoverages'), where('formId', '==', formId))
      );
      existingLinksSnap.docs.forEach(linkDoc => {
        batch.delete(linkDoc.ref);
      });

      // Add new links
      selectedCoverages.forEach(coverageId => {
        const newRef = doc(collection(db, 'formCoverages'));
        batch.set(newRef, {
          formId,
          coverageId,
          productId: selectedProduct,
          createdAt: serverTimestamp()
        });
      });

      await batch.commit();

      // reset ui
      setFormName('');
      setFormNumber('');
      setEffectiveDate('');
      setType('ISO');
      setCategory('Base Coverage Form');
      setSelectedProduct(productId || '');
      setSelectedCoverages([]);
      setSelectedStates([]);
      setFile(null);
      setEditingId(null);
      setChangeSummary('');
      setShowModal(false);

      // refresh forms list
      const snap = await getDocs(collection(db, 'forms'));
      const formList = snap.docs.map(d => ({
        ...d.data(),
        id: d.id
      }));
      setForms(formList);
    } catch (err) {
      console.error(err);
      alert('Failed to save form.');
    }
  };

  const handleDeleteForm = async id => {
    if (!window.confirm('Delete this form?')) return;
    try {
      const formDoc = forms.find(f => f.id === id);
      if (formDoc) {
        // Delete PDF file if it exists
        if (formDoc.filePath) {
          try {
            await deleteFormPdf(formDoc.filePath);
          } catch (err) {
            console.warn('Failed to delete PDF file:', err);
          }
        }

        // âœ… Delete junction table links only (no array writes to coverages)
        const linksSnap = await getDocs(
          query(collection(db, 'formCoverages'), where('formId', '==', id))
        );
        const batch = writeBatch(db);
        linksSnap.docs.forEach(linkDoc => {
          batch.delete(linkDoc.ref);
        });
        await batch.commit();
      }
      await deleteDoc(doc(db, 'forms', id));
      setForms(forms.filter(f => f.id !== id));
    } catch (err) {
      console.error(err);
      alert('Failed to delete form.');
    }
  };

  const openLinkCoverageModal = form => {
    setSelectedForm(form);
    setLinkCoverageIds(form.coverageIds || []);
    setLinkCoverageModalOpen(true);
  };

  const openStatesModal = form => {
    setSelectedFormForStates(form);
    setFormStates(form.states || []);
    setStatesModalOpen(true);
  };

  const handleLinkCoverage = async () => {
    if (!selectedForm) return;
    // map coverageId -> owning productId for quick lookâ€‘up
    const covIdToProductId = Object.fromEntries(coverages.map(c => [c.id, c.productId]));
    try {
      const formId = selectedForm.id;
      const batch = writeBatch(db);

      // Delete old links for this form
      const existingLinksSnap = await getDocs(
        query(collection(db, 'formCoverages'), where('formId', '==', formId))
      );
      existingLinksSnap.docs.forEach(linkDoc => {
        batch.delete(linkDoc.ref);
      });

      // Add new links (junction table only - single source of truth)
      linkCoverageIds.forEach(coverageId => {
        const owningProductId = covIdToProductId[coverageId];
        if (!owningProductId) return; // safety: skip if we can't resolve product
        const newRef = doc(collection(db, 'formCoverages'));
        batch.set(newRef, {
          formId,
          coverageId,
          productId: owningProductId,
          createdAt: serverTimestamp()
        });
      });

      await batch.commit();
      setLinkCoverageModalOpen(false);
      setSelectedForm(null);
      setLinkCoverageIds([]);
    } catch (err) {
      console.error(err);
      alert('Failed to link coverages to form.');
    }
  };

  const handleSaveStates = async () => {
    if (!selectedFormForStates) return;
    try {
      await updateDoc(doc(db, 'forms', selectedFormForStates.id), {
        states: formStates
      });
      setForms(fs => fs.map(f =>
        f.id === selectedFormForStates.id ? { ...f, states: formStates } : f
      ));
      setStatesModalOpen(false);
      setSelectedFormForStates(null);
      setFormStates([]);
    } catch (err) {
      console.error(err);
      alert('Failed to save states.');
    }
  };



  /* ---------- render ---------- */
  if (loading) {
    return (
      <PageContainer>
        <MainNavigation />
        <PageContent><Spinner /></PageContent>
      </PageContainer>
    );
  }
  if (error) {
    return (
      <PageContainer>
        <MainNavigation />
        <PageContent>{error}</PageContent>
      </PageContainer>
    );
  }

  const title =
    coverageId && coverageMap[coverageId]
      ? `Forms for ${coverageMap[coverageId]}`
      : productId && productMap[productId]
        ? `Forms for ${productMap[productId]}`
        : 'Forms';

  return (
    <PageContainer>
      <MainNavigation />
      <PageContent>
        <EnhancedHeader
          title={title}
          subtitle={`Manage ${filteredForms.length} form${filteredForms.length !== 1 ? 's' : ''}`}
          icon={DocumentTextIcon}
          showBackButton
          onBackClick={() => window.history.back()}
          searchProps={{
            placeholder: "Search forms by name, number, or category...",
            value: rawSearch,
            onChange: (e) => setRawSearch(e.target.value)
          }}
        />

        {/* Coverage Context Snapshot - show when viewing forms for a specific coverage */}
        {coverageId && selectedCoverageData && (
          <div style={{ marginBottom: 24 }}>
            <CoverageSnapshot
              name={selectedCoverageData.name}
              coverageCode={selectedCoverageData.coverageCode}
              isOptional={selectedCoverageData.isOptional}
              productName={productMap[productId]}
              parentCoverageName={parentCoverageData?.name}
              statesCount={(selectedCoverageData.states || []).length}
              formsCount={filteredForms.length}
              rulesCount={coverageRulesCount}
              triggerLabel={selectedCoverageData.coverageTrigger}
              valuationLabel={selectedCoverageData.valuationMethod}
              territoryLabel={selectedCoverageData.territory}
              coinsuranceLabel={selectedCoverageData.coinsurance}
              waitingPeriodLabel={selectedCoverageData.waitingPeriod}
            />
          </div>
        )}

        {/* Forms Stats Dashboard */}
        <FormsStatsDashboard>
          <FormsStatCard $color="linear-gradient(90deg, #6366f1, #8b5cf6)">
            <FormsStatValue>{forms.length}</FormsStatValue>
            <FormsStatLabel>
              <DocumentTextIcon />
              Total Forms
            </FormsStatLabel>
          </FormsStatCard>
          <FormsStatCard $color="linear-gradient(90deg, #3b82f6, #6366f1)">
            <FormsStatValue>{forms.filter(f => f.category === 'Base Coverage Form').length}</FormsStatValue>
            <FormsStatLabel>
              <DocumentTextIcon />
              Base Forms
            </FormsStatLabel>
          </FormsStatCard>
          <FormsStatCard $color="linear-gradient(90deg, #10b981, #059669)">
            <FormsStatValue>{forms.filter(f => f.category === 'Endorsement').length}</FormsStatValue>
            <FormsStatLabel>
              <PlusIcon />
              Endorsements
            </FormsStatLabel>
          </FormsStatCard>
          <FormsStatCard $color="linear-gradient(90deg, #f59e0b, #d97706)">
            <FormsStatValue>{forms.filter(f => f.category === 'Exclusion').length}</FormsStatValue>
            <FormsStatLabel>
              <XMarkIcon />
              Exclusions
            </FormsStatLabel>
          </FormsStatCard>
          <FormsStatCard $color="linear-gradient(90deg, #06b6d4, #0891b2)">
            <FormsStatValue>{forms.filter(f => f.downloadUrl).length}</FormsStatValue>
            <FormsStatLabel>
              <LinkIcon />
              With PDFs
            </FormsStatLabel>
          </FormsStatCard>
        </FormsStatsDashboard>

        {/* Filters Bar */}
        <FiltersBar>
          <FormGroup>
            <label>Select Coverage</label>
            <FilterWrapper>
              <FunnelIcon width={16} height={16} style={{ color: '#6B7280' }} />
              <TextInput
                as="select"
                value={selectedCoverage || ''}
                onChange={e => setSelectedCoverage(e.target.value || null)}
              >
                <option value="">All Coverages</option>
                {coverageOptions.map(o => (
                  <option key={o.value} value={o.value}>{o.label}</option>
                ))}
              </TextInput>
            </FilterWrapper>
          </FormGroup>

          <FormGroup>
            <label>Select States</label>
            <FilterWrapper>
              <MapIcon width={16} height={16} style={{ color: '#6B7280' }} />
              <TextInput
                as="select"
                multiple
                value={selectedFilterStates}
                onChange={e => setSelectedFilterStates(Array.from(e.target.selectedOptions, option => option.value))}
                style={{ minHeight: '100px' }}
              >
                {stateOptions.filter(o => o.value !== null).map(o => (
                  <option key={o.value} value={o.value}>{o.label}</option>
                ))}
              </TextInput>
            </FilterWrapper>
          </FormGroup>
        </FiltersBar>

        {/* Forms Display */}
        {filteredForms.length ? (
          <FormsGrid>
            {filteredForms.map(f => (
                <FormCard key={f.id}>
                  <CardHeader>
                    <TitleAndTagsContainer>
                      <CardTitle>
                        {f.downloadUrl ? (
                          <a
                            href={f.downloadUrl}
                            target="_blank"
                            rel="noopener noreferrer"
                            style={{ textDecoration: 'none', color: 'inherit' }}
                          >
                            {(f.formName || f.formNumber || 'Unnamed Form').toLowerCase().replace(/\b\w/g, c => c.toUpperCase())}
                          </a>
                        ) : (
                          <span>
                            {getFormDisplayName(f).toLowerCase().replace(/\b\w/g, c => c.toUpperCase())}
                          </span>
                        )}
                      </CardTitle>
                      <CardCategory category={f.category}>
                        {f.category}
                      </CardCategory>
                      <CardCode>{f.formNumber}</CardCode>
                    </TitleAndTagsContainer>
                    <CardActions>
                      <IconButton onClick={() => openEditModal(f)} title="Edit">
                        <PencilIcon width={16} height={16} />
                      </IconButton>
                      <IconButton className="danger" onClick={() => handleDeleteForm(f.id)} title="Delete">
                        <TrashIcon width={16} height={16} />
                      </IconButton>
                    </CardActions>
                  </CardHeader>

                  <CardContent>
                    <div style={{ display: 'flex', gap: '12px', marginBottom: '16px', fontSize: '14px', color: '#64748b' }}>
                      <span><strong>Type:</strong> {f.type}</span>
                      <span><strong>Edition:</strong> {f.effectiveDate || 'â€”'}</span>
                    </div>

                    <CardMetrics>
                      <MetricItem onClick={() => openLinkProductModal(f)}>
                        <Squares2X2Icon />
                        Products {f.productIds?.length ? `(${f.productIds.length})` : '(0)'}
                      </MetricItem>
                      <MetricItem onClick={() => openLinkCoverageModal(f)}>
                        <LinkIcon />
                        Coverages {f.coverageIds?.length ? `(${f.coverageIds.length})` : '(0)'}
                      </MetricItem>
                      <MetricItem onClick={() => openStatesModal(f)}>
                        <MapIcon />
                        States {f.states?.length ? `(${f.states.length})` : '(0)'}
                      </MetricItem>
                    </CardMetrics>

                    {/* Coverage Exclusions Section */}
                    {getFormExclusions[f.id] && getFormExclusions[f.id].length > 0 && (
                      <ExclusionsSection>
                        <ExclusionsSectionTitle>
                          Coverage Exclusions ({getFormExclusions[f.id].length})
                        </ExclusionsSectionTitle>
                        <ExclusionsList>
                          {getFormExclusions[f.id].map((exclusion, idx) => (
                            <ExclusionItem key={idx}>
                              <ExclusionType>{exclusion.type || 'general'}</ExclusionType>
                              <ExclusionDetails>
                                <ExclusionName>{exclusion.name}</ExclusionName>
                                <ExclusionCoverage>From: {exclusion.coverageName}</ExclusionCoverage>
                                {exclusion.description && (
                                  <div style={{ fontSize: '12px', color: '#6b7280', marginTop: '4px' }}>
                                    {exclusion.description}
                                  </div>
                                )}
                              </ExclusionDetails>
                            </ExclusionItem>
                          ))}
                        </ExclusionsList>
                      </ExclusionsSection>
                    )}
                  </CardContent>
                </FormCard>
              ))}
          </FormsGrid>
        ) : (
          <EmptyState>
            <EmptyStateTitle>No forms found</EmptyStateTitle>
            <EmptyStateText>
              {searchQuery ? 'Try adjusting your search terms' : 'Get started by adding your first form'}
            </EmptyStateText>
          </EmptyState>
        )}

        {/* Add Form Button */}
        <AddButton onClick={() => { setEditingId(null); setShowModal(true); }}>
          <PlusIcon width={14} height={14}/>
          Add Form
        </AddButton>

        {/* ---------- Add Form Modal ---------- */}
        {showModal && (
          <OverlayFixed>
            <Modal onClick={e => e.stopPropagation()}>
              <CloseBtn onClick={() => setShowModal(false)}>
                <XMarkIcon width={16} height={16} />
              </CloseBtn>
              <ModalTitle>{editingId ? 'Edit Form' : 'Add New Form'}</ModalTitle>
              {/* ---------- form fields ---------- */}
              <div style={{ display:'flex', flexWrap:'wrap', gap:16, marginBottom:16 }}>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Product*
                  </label>
                  <TextInput
                    as="select"
                    value={selectedProduct}
                    onChange={e => setSelectedProduct(e.target.value)}
                    disabled={!!productId}
                  >
                    <option value="">Select Product</option>
                    {products.map(p => (
                      <option key={p.id} value={p.id}>{p.name}</option>
                    ))}
                  </TextInput>
                </div>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Link Coverages (optional)
                  </label>
                  <div style={{ display: 'flex', gap: 8, marginBottom: 8 }}>
                    <Button variant="ghost" onClick={() => setSelectedCoverages(
                      coverages.filter(c => !productId || c.productId === (selectedProduct || productId)).map(c => c.id)
                    )}>Select All</Button>
                    <Button variant="ghost" onClick={() => setSelectedCoverages([])}>Clear All</Button>
                  </div>
                  <div style={{ maxHeight: 200, overflowY: 'auto', border: '1px solid #E5E7EB', borderRadius: 4, padding: 8 }}>
                    {(coverages.filter(c => !productId || c.productId === (selectedProduct || productId))).map(c => (
                      <label key={c.id} style={{ display: 'block', padding: 4 }}>
                        <input
                          type="checkbox"
                          value={c.id}
                          checked={selectedCoverages.includes(c.id)}
                          onChange={e => {
                            const val = e.target.value;
                            setSelectedCoverages(prev =>
                              prev.includes(val) ? prev.filter(x => x !== val) : [...prev, val]
                            );
                          }}
                        />{' '}
                        {c.name}
                      </label>
                    ))}
                  </div>
                </div>
              </div>

              <div style={{ display:'flex', flexWrap:'wrap', gap:16, marginBottom:16 }}>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Applicable States (optional)
                  </label>
                  <div style={{ display: 'flex', gap: 8, marginBottom: 8 }}>
                    <Button variant="ghost" onClick={() => setSelectedStates(['AL','AK','AZ','AR','CA','CO','CT','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY'])}>Select All</Button>
                    <Button variant="ghost" onClick={() => setSelectedStates([])}>Clear All</Button>
                  </div>
                  <div style={{ maxHeight: 200, overflowY: 'auto', border: '1px solid #E5E7EB', borderRadius: 4, padding: 8 }}>
                    {['AL','AK','AZ','AR','CA','CO','CT','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY'].map(state => (
                      <label key={state} style={{ display: 'block', padding: 4 }}>
                        <input
                          type="checkbox"
                          value={state}
                          checked={selectedStates.includes(state)}
                          onChange={e => {
                            const val = e.target.value;
                            setSelectedStates(prev =>
                              prev.includes(val) ? prev.filter(x => x !== val) : [...prev, val]
                            );
                          }}
                        />{' '}
                        {state}
                      </label>
                    ))}
                  </div>
                </div>
              </div>

              <div style={{ display:'flex', flexWrap:'wrap', gap:16, marginBottom:16 }}>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Form Name (optional)
                  </label>
                  <TextInput
                    placeholder="Form Name"
                    value={formName}
                    onChange={e => setFormName(e.target.value)}
                  />
                </div>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Form Number*
                  </label>
                  <TextInput
                    placeholder="Form Number"
                    value={formNumber}
                    onChange={e => setFormNumber(e.target.value)}
                  />
                </div>
              </div>

              <div style={{ display:'flex', flexWrap:'wrap', gap:16, marginBottom:16 }}>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Effective Date (MM/YY)*
                  </label>
                  <TextInput
                    placeholder="MM/YY"
                    value={effectiveDate}
                    onChange={e => {
                      let v = e.target.value.replace(/[^0-9]/g, '');
                      if (v.length > 4) v = v.slice(0, 4);
                      if (v.length > 2) v = v.slice(0, 2) + '/' + v.slice(2);
                      setEffectiveDate(v);
                    }}
                  />
                </div>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Type
                  </label>
                  <TextInput
                    as="select"
                    value={type}
                    onChange={e => setType(e.target.value)}
                  >
                    <option value="ISO">ISO</option>
                    <option value="Proprietary">Proprietary</option>
                    <option value="NAICS">NAICS</option>
                    <option value="Other">Other</option>
                  </TextInput>
                </div>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Category
                  </label>
                  <TextInput
                    as="select"
                    value={category}
                    onChange={e => setCategory(e.target.value)}
                  >
                    <option value="Base Coverage Form">Base Coverage Form</option>
                    <option value="Endorsement">Endorsement</option>
                    <option value="Exclusion">Exclusion</option>
                    <option value="Dec/Quote Letter">Dec/Quote Letter</option>
                    <option value="Notice">Notice</option>
                    <option value="Other">Other</option>
                  </TextInput>
                </div>
              </div>

              <div style={{ display:'flex', flexWrap:'wrap', gap:16, marginBottom:16 }}>
                <div style={{ flex:1, minWidth:140 }}>
                  <label style={{ display:'block', fontSize:14, fontWeight:500, color:'#1F2937', marginBottom:8 }}>
                    Upload PDF (optional)
                  </label>
                  <input
                    id="file-upload"
                    type="file"
                    accept=".pdf"
                    style={{ display:'none' }}
                    onChange={e => setFile(e.target.files[0])}
                  />
                  <label
                    htmlFor="file-upload"
                    style={{
                      width:'100%',
                      display:'flex',
                      alignItems:'center',
                      gap:8,
                      padding:12,
                      border:'1px dashed #D1D5DB',
                      borderRadius:8,
                      cursor:'pointer',
                      color:'#6B7280',
                      fontSize:14,
                      ...(file ? { color:'#1D4ED8', borderColor:'#1D4ED8' } : {})
                    }}
                  >
                    <DocumentTextIcon width={20} height={20} />
                    {file ? file.name : 'Upload PDF (optional)'}
                  </label>
                </div>
              </div>

              {editingId && (
                <textarea
                  rows="3"
                  placeholder="Reason for changes (required)"
                  value={changeSummary}
                  onChange={e => setChangeSummary(e.target.value)}
                  style={{ width:'100%', padding:10, borderRadius:6, border:'1px solid #e5e7eb', fontSize:14, marginBottom:16 }}
                />
              )}

              <Button onClick={handleSaveForm}>Save Form</Button>
            </Modal>
          </OverlayFixed>
        )}

        {/* Link Coverage Modal */}
        {linkCoverageModalOpen && (
          <OverlayFixed onClick={() => setLinkCoverageModalOpen(false)}>
            <Modal onClick={e => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>Link Form to Coverages</ModalTitle>
                <CloseBtn onClick={() => setLinkCoverageModalOpen(false)}>âœ•</CloseBtn>
              </ModalHeader>
              <p style={{ margin:'8px 0 12px' }}>
                Form:&nbsp;<strong>{getFormDisplayName(selectedForm || {})}</strong>
              </p>
              <div style={{ marginBottom: 8 }}>
                <TextInput
                  placeholder="Search coverages..."
                  value={coverageSearch}
                  onChange={e => setCoverageSearch(e.target.value)}
                />
              </div>
              <div style={{ display:'flex', gap:8, marginBottom:8 }}>
                <Button variant="ghost" onClick={() => setLinkCoverageIds(
                  coverages
                    .filter(c => (!productId || c.productId === selectedForm.productId))
                    .filter(c => c.name.toLowerCase().includes(coverageSearch.toLowerCase()))
                    .map(c => c.id)
                )}>Select All</Button>
                <Button variant="ghost" onClick={() => setLinkCoverageIds([])}>Clear All</Button>
              </div>
              <div style={{ maxHeight:220, overflowY:'auto', border:'1px solid #E5E7EB', borderRadius:4, padding:8 }}>
                {coverages
                  .filter(c => (!productId || c.productId === selectedForm.productId))
                  .filter(c => c.name.toLowerCase().includes(coverageSearch.toLowerCase()))
                  .sort((a, b) => a.name.localeCompare(b.name))
                  .map(c => (
                    <label key={c.id} style={{ display:'block', padding:4 }}>
                      <input
                        type="checkbox"
                        value={c.id}
                        checked={linkCoverageIds.includes(c.id)}
                        onChange={e => {
                          const val = e.target.value;
                          setLinkCoverageIds(prev =>
                            prev.includes(val) ? prev.filter(x => x !== val) : [...prev, val]
                          );
                        }}
                      />{' '}
                      {c.name}
                    </label>
                ))}
              </div>
              <div style={{ marginTop:16, display:'flex', gap:12 }}>
                <Button onClick={handleLinkCoverage}>Save</Button>
                <Button variant="ghost" onClick={() => setLinkCoverageModalOpen(false)}>Cancel</Button>
              </div>
            </Modal>
          </OverlayFixed>
        )}

        {/* Link Products Modal */}
        {linkProductModalOpen && (
          <OverlayFixed onClick={() => setLinkProductModalOpen(false)}>
            <Modal onClick={e => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>Link Form to Products</ModalTitle>
                <CloseBtn onClick={() => setLinkProductModalOpen(false)}>âœ•</CloseBtn>
              </ModalHeader>

              <p style={{ margin:'8px 0 12px' }}>
                Form:&nbsp;<strong>{getFormDisplayName(selectedForm || {})}</strong>
              </p>

              <div style={{ marginBottom: 8 }}>
                <TextInput
                  placeholder="Search products..."
                  value={productSearch}
                  onChange={e => setProductSearch(e.target.value)}
                />
              </div>

              <div style={{ display:'flex', gap:8, marginBottom:8 }}>
                <Button variant="ghost" onClick={() => setLinkProductIds(
                  products
                    .filter(p => p.name.toLowerCase().includes(productSearch.toLowerCase()))
                    .map(p => p.id)
                )}>Select All</Button>
                <Button variant="ghost" onClick={() => setLinkProductIds([])}>Clear All</Button>
              </div>

              <div style={{ maxHeight:220, overflowY:'auto', border:'1px solid #E5E7EB', borderRadius:4, padding:8 }}>
                {products
                  .filter(p => p.name.toLowerCase().includes(productSearch.toLowerCase()))
                  .sort((a, b) => a.name.localeCompare(b.name))
                  .map(p => (
                    <label key={p.id} style={{ display:'block', padding:4 }}>
                      <input
                        type="checkbox"
                        value={p.id}
                        checked={linkProductIds.includes(p.id)}
                        onChange={e => {
                          const val = e.target.value;
                          setLinkProductIds(prev =>
                            prev.includes(val) ? prev.filter(x => x !== val) : [...prev, val]
                          );
                        }}
                      />{' '}
                      {p.name}
                    </label>
                ))}
              </div>

              <div style={{ marginTop:16, display:'flex', gap:12 }}>
                <Button onClick={handleLinkProducts}>Save</Button>
                <Button variant="ghost" onClick={() => setLinkProductModalOpen(false)}>Cancel</Button>
              </div>
            </Modal>
          </OverlayFixed>
        )}

        {/* States Modal */}
        {statesModalOpen && (
          <OverlayFixed onClick={() => setStatesModalOpen(false)}>
            <Modal onClick={e => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>Manage States for {selectedFormForStates?.formName || selectedFormForStates?.formNumber}</ModalTitle>
                <CloseBtn onClick={() => setStatesModalOpen(false)}>âœ•</CloseBtn>
              </ModalHeader>

              <p style={{ margin:'8px 0 12px' }}>
                Form:&nbsp;<strong>{selectedFormForStates?.formName || selectedFormForStates?.formNumber}</strong>
              </p>

              <div style={{ display:'flex', gap:8, marginBottom:8 }}>
                <Button variant="ghost" onClick={() => setFormStates(['AL','AK','AZ','AR','CA','CO','CT','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY'])}>
                  Select All (50)
                </Button>
                <Button variant="ghost" onClick={() => setFormStates([])}>Clear All</Button>
                <span style={{ fontSize: '14px', color: '#6b7280', marginLeft: 'auto' }}>
                  {formStates.length} selected
                </span>
              </div>

              <div style={{ maxHeight:220, overflowY:'auto', border:'1px solid #E5E7EB', borderRadius:4, padding:8 }}>
                {['AL','AK','AZ','AR','CA','CO','CT','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY'].map(state => (
                  <label key={state} style={{ display:'block', padding:4 }}>
                    <input
                      type="checkbox"
                      value={state}
                      checked={formStates.includes(state)}
                      onChange={e => {
                        const val = e.target.value;
                        setFormStates(prev =>
                          prev.includes(val) ? prev.filter(x => x !== val) : [...prev, val]
                        );
                      }}
                    />{' '}
                    {state}
                  </label>
                ))}
              </div>

              <div style={{ marginTop:16, display:'flex', gap:12 }}>
                <Button onClick={handleSaveStates}>Save</Button>
                <Button variant="ghost" onClick={() => setStatesModalOpen(false)}>Cancel</Button>
              </div>
            </Modal>
          </OverlayFixed>
        )}

      </PageContent>
    </PageContainer>
  );
}

/* ---------- simple debounce hook ---------- */
function useDebounce(value, ms=250){
  const [v,setV]=useState(value);
  useEffect(()=>{const id=setTimeout(()=>setV(value),ms);return ()=>clearTimeout(id);},[value,ms]);
  return v;
}
```

---

## src/components/Home.tsx

**Path:** `src/components/Home.tsx`

```tsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import styled, { keyframes } from 'styled-components';
import {
  SparklesIcon,
  TrashIcon,
  ArrowUpIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  ClipboardDocumentIcon,
  CheckIcon
} from '@heroicons/react/24/solid';
import MainNavigation from './ui/Navigation';
import { EnhancedChatMessage } from './ui/EnhancedChatMessage';
import useProducts from '@hooks/useProducts';
import { useDeepMemo } from '@hooks/useAdvancedMemo';
import logger, { LOG_CATEGORIES } from '@utils/logger';
import { functions } from '@/firebase';
import { httpsCallable } from 'firebase/functions';
import { AI_MODELS, AI_PARAMETERS } from '../config/aiConfig';
import firebaseOptimized from '../services/firebaseOptimized';
import aiPromptOptimizer from '../services/aiPromptOptimizer';
import responseFormatter from '../services/responseFormatter';

// ============================================================================
// Animations
// ============================================================================

const fadeInUp = keyframes`
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

const slideInLeft = keyframes`
  from {
    opacity: 0;
    transform: translateX(-12px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
`;

const slideInRight = keyframes`
  from {
    opacity: 0;
    transform: translateX(12px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
`;

const pulseGlow = keyframes`
  0%, 100% {
    box-shadow: 0 0 16px rgba(99, 102, 241, 0.15);
  }
  50% {
    box-shadow: 0 0 28px rgba(99, 102, 241, 0.3);
  }
`;

const typingDots = keyframes`
  0%, 60%, 100% {
    transform: translateY(0);
    opacity: 0.3;
  }
  30% {
    transform: translateY(-5px);
    opacity: 1;
  }
`;



// Types for chat messages
interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  metadata?: {
    queryType?: string;
    confidence?: number;
    tokensUsed?: number;
    processingTime?: number;
    sources?: string[];
  };
}

// Query classification types
type QueryType =
  | 'product_analysis'
  | 'coverage_analysis'
  | 'pricing_analysis'
  | 'compliance_check'
  | 'task_management'
  | 'strategic_insight'
  | 'data_query'
  | 'general';

/* ---------- styled components ---------- */
const Page = styled.div`
  min-height: 100vh;
  background: ${({ theme }) => theme.isDarkMode
    ? 'linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%)'
    : 'linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%)'};
  display: flex;
  flex-direction: column;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 300px;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #06b6d4 100%);
    opacity: ${({ theme }) => theme.isDarkMode ? '0.05' : '0.08'};
    z-index: 0;
    pointer-events: none;
  }
`;

const MainContent = styled.main<{ $isEmpty: boolean }>`
  flex: 1;
  display: flex;
  flex-direction: column;
  max-width: 900px;
  margin: 0 auto;
  width: 100%;
  padding: 0;
  height: calc(100vh - 64px);
  position: relative;
  z-index: 1;

  /* Center content when empty */
  ${({ $isEmpty }) => $isEmpty && `
    justify-content: center;
    align-items: center;
  `}

  @media (max-width: 768px) {
    height: calc(100vh - 56px);
  }
`;

const ChatContainer = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 24px 16px;
  display: flex;
  flex-direction: column;
  gap: 0;

  /* Custom scrollbar - minimal */
  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: transparent;
  }

  &::-webkit-scrollbar-thumb {
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.15)'};
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.25)'};
  }

  @media (max-width: 768px) {
    padding: 16px;
    gap: 16px;
  }
`;

const EmptyState = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 48px 24px 32px;
  text-align: center;
  gap: 16px;
  width: 100%;
  max-width: 700px;

  svg {
    width: 64px;
    height: 64px;
    color: ${({ theme }) => theme.isDarkMode ? '#475569' : '#cbd5e1'};
    margin-bottom: 8px;
  }

  h2 {
    font-size: 24px;
    font-weight: 600;
    color: ${({ theme }) => theme.isDarkMode ? '#e2e8f0' : '#1e293b'};
    margin: 0;
  }

  p {
    font-size: 15px;
    color: ${({ theme }) => theme.isDarkMode ? '#94a3b8' : '#64748b'};
    margin: 0;
    max-width: 500px;
  }

  @media (max-width: 768px) {
    padding: 32px 16px 24px;

    svg {
      width: 48px;
      height: 48px;
    }

    h2 {
      font-size: 20px;
    }

    p {
      font-size: 14px;
    }
  }
`;

const CenteredContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 32px;
  width: 100%;
  max-width: 700px;
  padding: 0 24px;

  @media (max-width: 768px) {
    padding: 0 16px;
    gap: 24px;
  }
`;

const MessageGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-width: 800px;
  margin: 0 auto;
  width: 100%;
  animation: ${fadeInUp} 0.3s ease-out;
`;

const UserMessage = styled.div`
  display: flex;
  justify-content: flex-end;
  padding: 8px 0;
  animation: ${slideInRight} 0.25s ease-out;

  .content {
    background: ${({ theme }) => theme.isDarkMode ? '#3b82f6' : '#3b82f6'};
    color: #ffffff;
    padding: 12px 16px;
    border-radius: 20px;
    max-width: 75%;
    font-size: 15px;
    line-height: 1.6;
    word-wrap: break-word;
  }

  @media (max-width: 768px) {
    .content {
      max-width: 90%;
      font-size: 14px;
      padding: 10px 14px;
    }
  }
`;

const AssistantMessage = styled.div`
  display: flex;
  gap: 16px;
  align-items: flex-start;
  padding: 16px 0;
  animation: ${slideInLeft} 0.25s ease-out;

  .avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: ${({ theme }) => theme.isDarkMode
      ? 'linear-gradient(135deg, #6366f1, #8b5cf6)'
      : 'linear-gradient(135deg, #6366f1, #8b5cf6)'};
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    margin-top: 2px;

    svg {
      width: 14px;
      height: 14px;
      color: white;
    }
  }

  .content {
    flex: 1;
    min-width: 0;
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(30, 41, 59, 0.6)' : '#f8f9fa'};
    color: ${({ theme }) => theme.isDarkMode ? '#ececec' : '#1a1a1a'};
    padding: 16px 20px;
    border-radius: 4px 20px 20px 20px;
  }

  .message-actions {
    display: flex;
    gap: 4px;
    margin-top: 12px;
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  &:hover .message-actions {
    opacity: 1;
  }

  @media (max-width: 768px) {
    gap: 12px;

    .avatar {
      width: 24px;
      height: 24px;

      svg {
        width: 12px;
        height: 12px;
      }
    }

    .message-actions {
      opacity: 1;
    }
  }
`;

const ActionButton = styled.button<{ $active?: boolean }>`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  background: transparent;
  color: ${({ $active, theme }) =>
    $active
      ? '#10b981'
      : (theme.isDarkMode ? '#9b9b9b' : '#666666')};
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;

  svg {
    width: 14px;
    height: 14px;
  }

  &:hover {
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)'};
    color: ${({ $active, theme }) =>
      $active
        ? '#10b981'
        : (theme.isDarkMode ? '#e0e0e0' : '#1a1a1a')};
  }
`;

const InputContainer = styled.div<{ $isCentered: boolean }>`
  padding: 16px 24px;
  background: transparent;

  /* Center the input when no chat history */
  ${({ $isCentered }) => $isCentered && `
    width: 100%;
    max-width: 800px;
  `}

  @media (max-width: 768px) {
    padding: 12px 16px;
  }
`;

const InputWrapper = styled.div`
  max-width: 100%;
  margin: 0 auto;
  position: relative;
  display: flex;
  align-items: center;
`;

const InputField = styled.textarea`
  width: 100%;
  padding: 16px 56px 16px 20px;
  border: 1.5px solid ${({ theme }) => theme.isDarkMode ? '#334155' : 'rgba(226, 232, 240, 0.8)'};
  border-radius: 28px;
  font-size: 15px;
  font-family: inherit;
  resize: none;
  min-height: 56px;
  max-height: 200px;
  background: ${({ theme }) => theme.isDarkMode ? '#1e293b' : 'rgba(255, 255, 255, 0.98)'};
  color: ${({ theme }) => theme.isDarkMode ? '#e2e8f0' : '#1e293b'};
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  box-sizing: border-box;

  &:hover:not(:focus):not(:disabled) {
    border-color: ${({ theme }) => theme.isDarkMode ? '#475569' : '#cbd5e1'};
  }

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.12), 0 2px 8px rgba(0, 0, 0, 0.04);
  }

  &::placeholder {
    color: ${({ theme }) => theme.isDarkMode ? '#64748b' : '#94a3b8'};
    transition: color 0.2s ease;
  }

  &:focus::placeholder {
    color: ${({ theme }) => theme.isDarkMode ? '#475569' : '#cbd5e1'};
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  @media (max-width: 768px) {
    font-size: 14px;
    padding: 14px 52px 14px 18px;
    min-height: 52px;
    border-radius: 26px;
  }
`;

const SendButton = styled.button`
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border: none;
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
  box-shadow: 0 2px 8px rgba(99, 102, 241, 0.25);

  svg {
    width: 18px;
    height: 18px;
    stroke-width: 2.5;
  }

  &:hover:not(:disabled) {
    background: linear-gradient(135deg, #5b5bf6 0%, #7c3aed 100%);
    transform: translateY(-50%) scale(1.08);
    box-shadow: 0 4px 14px rgba(99, 102, 241, 0.4);
  }

  &:active:not(:disabled) {
    transform: translateY(-50%) scale(0.95);
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.2);
  }

  &:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: translateY(-50%);
    background: ${({ theme }) => theme.isDarkMode ? '#475569' : '#cbd5e1'};
    box-shadow: none;
  }

  @media (max-width: 768px) {
    width: 34px;
    height: 34px;
    right: 9px;

    svg {
      width: 16px;
      height: 16px;
    }
  }
`;

const ClearButton = styled.button`
  position: fixed;
  bottom: 100px;
  right: 24px;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: ${({ theme }) => theme.isDarkMode ? '#1e293b' : '#ffffff'};
  border: 1px solid ${({ theme }) => theme.isDarkMode ? '#334155' : '#e2e8f0'};
  color: ${({ theme }) => theme.isDarkMode ? '#e2e8f0' : '#64748b'};
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  z-index: 10;

  svg {
    width: 20px;
    height: 20px;
  }

  &:hover {
    background: ${({ theme }) => theme.isDarkMode ? '#334155' : '#f8fafc'};
    transform: scale(1.05);
  }

  @media (max-width: 768px) {
    bottom: 80px;
    right: 16px;
    width: 44px;
    height: 44px;

    svg {
      width: 18px;
      height: 18px;
    }
  }
`;


const SystemStatus = styled.div<{ $isReady: boolean }>`
  position: absolute;
  top: 16px;
  right: 24px;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border-radius: 8px;
  background: ${({ $isReady }) =>
    $isReady
      ? 'rgba(34, 197, 94, 0.1)'
      : 'rgba(249, 115, 22, 0.1)'};
  border: 1px solid ${({ $isReady }) =>
    $isReady ? 'rgba(34, 197, 94, 0.3)' : 'rgba(249, 115, 22, 0.3)'};
  font-size: 12px;
  font-weight: 600;
  color: ${({ $isReady }) => ($isReady ? '#22c55e' : '#f97316')};
  z-index: 5;

  svg {
    width: 14px;
    height: 14px;
  }

  @media (max-width: 768px) {
    top: 12px;
    right: 16px;
    font-size: 11px;
    padding: 6px 10px;
  }
`;

const LoadingIndicator = styled.div`
  display: flex;
  gap: 14px;
  align-items: flex-start;
  animation: ${fadeInUp} 0.3s ease-out;

  .avatar {
    width: 36px;
    height: 36px;
    border-radius: 12px;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    animation: ${pulseGlow} 2s infinite;

    svg {
      width: 18px;
      height: 18px;
      color: white;
    }
  }

  .typing-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.95)'};
    border: 1px solid ${({ theme }) => theme.isDarkMode ? '#334155' : '#e2e8f0'};
    border-radius: 4px 20px 20px 20px;
    padding: 16px 20px;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
  }

  .typing-text {
    font-size: 13px;
    color: ${({ theme }) => theme.isDarkMode ? '#94a3b8' : '#64748b'};
    font-weight: 500;
  }

  .dots {
    display: flex;
    gap: 6px;

    span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      animation: ${typingDots} 1.4s infinite ease-in-out;

      &:nth-child(1) {
        animation-delay: 0s;
      }

      &:nth-child(2) {
        animation-delay: 0.2s;
      }

      &:nth-child(3) {
        animation-delay: 0.4s;
      }
    }
  }

  @keyframes bounce {
    0%, 80%, 100% {
      transform: scale(0);
    }
    40% {
      transform: scale(1);
    }
  }
`;








/* ---------- component ---------- */
export default function Home() {
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  const [copiedMessageId, setCopiedMessageId] = useState<string | null>(null);
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // Data for context - comprehensive application data
  const { products, loading: productsLoading } = useProducts();
  const [coverages, setCoverages] = useState([]);
  const [forms, setForms] = useState([]);
  const [rules, setRules] = useState([]);
  const [pricingSteps, setPricingSteps] = useState([]);
  const [dataDictionary, setDataDictionary] = useState([]);
  const [formCoverages, setFormCoverages] = useState([]);
  const [tasks, setTasks] = useState([]);
  const [dataLoading, setDataLoading] = useState(true);

  // Copy message to clipboard
  const handleCopyMessage = useCallback(async (messageId: string, content: string) => {
    try {
      await navigator.clipboard.writeText(content);
      setCopiedMessageId(messageId);
      setTimeout(() => setCopiedMessageId(null), 2000);
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Failed to copy message', { error });
    }
  }, []);



  // Fetch comprehensive application data for enhanced AI context (optimized with caching)
  useEffect(() => {
    const fetchContextData = async () => {
      try {
        setDataLoading(true);

        // Use optimized Firebase service with caching
        // Note: Coverages are subcollections under products, so we use collectionGroup
        const [coverageList, formList, rulesList, pricingList, dictList, formCoverageList, taskList] = await Promise.all([
          firebaseOptimized.getCollectionGroup('coverages', { useCache: true }),
          firebaseOptimized.getCollection('forms', { useCache: true }),
          firebaseOptimized.getCollection('rules', { useCache: true }),
          firebaseOptimized.getCollection('pricingSteps', { useCache: true }),
          firebaseOptimized.getCollection('dataDictionary', { useCache: true }),
          firebaseOptimized.getCollection('formCoverages', { useCache: true }),
          firebaseOptimized.getCollection('tasks', { useCache: true })
        ]);

        setCoverages(coverageList || []);
        setForms(formList || []);
        setRules(rulesList || []);
        setPricingSteps(pricingList || []);
        setDataDictionary(dictList || []);
        setFormCoverages(formCoverageList || []);
        setTasks(taskList || []);

        // Log context data loading for debugging
        console.log('ðŸ“Š Context data loaded:', {
          coverages: coverageList?.length || 0,
          forms: formList?.length || 0,
          rules: rulesList?.length || 0,
          pricingSteps: pricingList?.length || 0,
          dataDictionary: dictList?.length || 0,
          formCoverages: formCoverageList?.length || 0,
          tasks: taskList?.length || 0
        });

      } catch (error) {
        logger.error(LOG_CATEGORIES.CACHE, 'Error fetching context data', { error });
      } finally {
        setDataLoading(false);
      }
    };

    fetchContextData();
  }, []);




  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (chatContainerRef.current) {
      const scrollToBottom = () => {
        chatContainerRef.current?.scrollTo({
          top: chatContainerRef.current.scrollHeight,
          behavior: 'smooth'
        });
      };
      // Small delay to ensure DOM is updated
      setTimeout(scrollToBottom, 100);
    }
  }, [chatHistory]);

  // Auto-resize textarea
  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.style.height = 'auto';
      inputRef.current.style.height = `${Math.min(inputRef.current.scrollHeight, 200)}px`;
    }
  }, [inputValue]);

  // Build comprehensive context summary for AI (optimized to avoid token limits)
  const contextSummary = useDeepMemo(() => {
    // Ensure all data arrays exist before processing
    const safeProducts = products || [];
    const safeCoverages = coverages || [];
    const safeForms = forms || [];
    const safeRules = rules || [];
    const safePricingSteps = pricingSteps || [];
    const safeDataDictionary = dataDictionary || [];
    const safeFormCoverages = formCoverages || [];
    const safeTasks = tasks || [];

    // Create a concise summary instead of full data dump
    const summary = {
      timestamp: new Date().toISOString(),
      systemOverview: {
        description: "Comprehensive P&C insurance product management platform",
        dataAvailable: "products, coverages, forms, pricing, rules, tasks, compliance data"
      },

      statistics: {
        products: {
          total: safeProducts.length,
          withForms: safeProducts.filter(p => p.formDownloadUrl).length,
          statesRepresented: [...new Set(safeProducts.flatMap(p => p.availableStates || []))].length,
          topProducts: safeProducts.slice(0, 5).map(p => ({
            name: p.name,
            code: p.productCode,
            states: (p.availableStates || []).length
          }))
        },
        coverages: {
          total: safeCoverages.length,
          subCoverages: safeCoverages.filter(c => c.parentCoverage).length,
          categories: [...new Set(safeCoverages.map(c => c.category).filter(Boolean))]
        },
        forms: {
          total: safeForms.length,
          categories: [...new Set(safeForms.map(f => f.category).filter(Boolean))],
          withDocuments: safeForms.filter(f => f.downloadUrl || f.filePath).length
        },
        rules: {
          total: safeRules.length,
          proprietary: safeRules.filter(r => r.proprietary).length
        },
        pricing: {
          totalSteps: safePricingSteps.length,
          stepTypes: [...new Set(safePricingSteps.map(s => s.stepType).filter(Boolean))]
        },
        tasks: {
          total: safeTasks.length,
          byPhase: {
            research: safeTasks.filter(t => t.phase === 'research').length,
            develop: safeTasks.filter(t => t.phase === 'develop').length,
            compliance: safeTasks.filter(t => t.phase === 'compliance').length,
            implementation: safeTasks.filter(t => t.phase === 'implementation').length
          },
          byPriority: {
            high: safeTasks.filter(t => t.priority === 'high').length,
            medium: safeTasks.filter(t => t.priority === 'medium').length,
            low: safeTasks.filter(t => t.priority === 'low').length
          },
          overdue: safeTasks.filter(t => t.dueDate && new Date(t.dueDate) < new Date()).length
        },
        dataDictionary: {
          total: safeDataDictionary.length
        },
        formCoverageMappings: {
          total: safeFormCoverages.length
        }
      },

      // Sample data for backward compatibility
      sampleData: {
        products: safeProducts.slice(0, 3).map(p => ({
          name: p.name,
          code: p.productCode,
          states: p.availableStates?.length || 0
        })),
        coverages: safeCoverages.slice(0, 3).map(c => ({
          name: c.coverageName,
          code: c.coverageCode,
          category: c.category
        })),
        tasks: safeTasks.slice(0, 3).map(t => ({
          title: t.title,
          phase: t.phase,
          priority: t.priority
        }))
      },

      // FULL DATA - Include all data for comprehensive AI context
      fullData: {
        products: safeProducts,
        coverages: safeCoverages,
        forms: safeForms,
        rules: safeRules,
        pricingSteps: safePricingSteps,
        dataDictionary: safeDataDictionary,
        formCoverages: safeFormCoverages,
        tasks: safeTasks
      }
    };

    return summary;
  }, [products, coverages, forms, rules, pricingSteps, dataDictionary, formCoverages, tasks]);

  // Use optimized query classification from service
  const classifyQuery = useCallback((query: string): QueryType => {
    return aiPromptOptimizer.classifyQuery(query);
  }, []);

  // Build optimized prompt using AI Prompt Optimizer service
  const buildEnhancedPrompt = useCallback((query: string, _queryType: QueryType) => {
    const optimizedPrompt = aiPromptOptimizer.buildOptimizedPrompt(query, contextSummary);
    return aiPromptOptimizer.formatForAPI(optimizedPrompt);
  }, [contextSummary]);

  const handleSendMessage = useCallback(async () => {
    const query = inputValue.trim();
    if (!query || isLoading || dataLoading) return;

    const startTime = Date.now();

    // Classify the query
    const queryType = classifyQuery(query);

    logger.logUserAction('Home chat query submitted', {
      queryLength: query.length,
      queryType,
      hasProducts: (products || []).length > 0,
      hasCoverages: (coverages || []).length > 0,
      hasForms: (forms || []).length > 0,
      hasRules: (rules || []).length > 0,
      timestamp: new Date().toISOString()
    });

    // Add user message to chat history
    const userMessage: ChatMessage = {
      id: `user-${Date.now()}`,
      role: 'user',
      content: query,
      timestamp: new Date(),
      metadata: {
        queryType
      }
    };
    setChatHistory(prev => [...prev, userMessage]);

    setInputValue(''); // Clear the input immediately
    setIsLoading(true);

    try {
      // Build enhanced, context-aware system prompt
      const systemPrompt = buildEnhancedPrompt(query, queryType);

      logger.logAIOperation('Home chat query', AI_MODELS.HOME_CHAT, query.substring(0, 100), '', 0);

      // Call Cloud Function (secure proxy to OpenAI)
      const generateChat = httpsCallable(functions, 'generateChatResponse');

      // Build conversation history for context (last 5 messages)
      const recentHistory = chatHistory.slice(-5).map(msg => ({
        role: msg.role,
        content: msg.content
      }));

      // Ensure we're sending a plain object with proper types
      const payload = {
        messages: [
          {
            role: 'system',
            content: String(systemPrompt)
          },
          ...recentHistory,
          { role: 'user', content: String(query) }
        ],
        model: String(AI_MODELS.HOME_CHAT),
        maxTokens: Number(AI_PARAMETERS.HOME_CHAT.max_tokens),
        temperature: Number(AI_PARAMETERS.HOME_CHAT.temperature)
      };

      console.log('ðŸš€ Calling generateChatResponse with:', {
        messagesCount: payload.messages.length,
        model: payload.model,
        maxTokens: payload.maxTokens,
        temperature: payload.temperature,
        contextSize: JSON.stringify(contextSummary).length
      });

      const result = await generateChat(payload);

      if (!result.data.success) {
        logger.error(LOG_CATEGORIES.AI, 'Cloud Function error', {
          model: AI_MODELS.HOME_CHAT,
          query: query.substring(0, 100)
        });
        throw new Error('Failed to generate chat response');
      }

      const aiResponse = result.data.content?.trim();
      const processingTime = Date.now() - startTime;

      logger.logAIOperation('Home chat response', AI_MODELS.HOME_CHAT, query.substring(0, 100), aiResponse?.substring(0, 100), processingTime);

      if (aiResponse) {
        // Format response for optimal display
        const formattedResponse = responseFormatter.formatWithMetadata(aiResponse, {
          queryType,
          tokensUsed: result.data.usage?.total_tokens,
          processingTime,
          confidence: 0.95,
          sources: ['products', 'coverages', 'forms', 'rules', 'tasks']
        });

        // Add AI response to chat history with enhanced metadata
        const assistantMessage: ChatMessage = {
          id: `assistant-${Date.now()}`,
          role: 'assistant',
          content: formattedResponse.content,
          timestamp: new Date(),
          metadata: {
            queryType,
            tokensUsed: result.data.usage?.total_tokens,
            processingTime,
            confidence: formattedResponse.metadata.confidence,
            sources: formattedResponse.metadata.sources,
            isStructured: formattedResponse.isStructured
          }
        };
        setChatHistory(prev => [...prev, assistantMessage]);
      } else {
        throw new Error('No response from AI');
      }
    } catch (error: any) {
      const duration = Date.now() - startTime;
      logger.error(LOG_CATEGORIES.AI, 'AI request failed', {
        query: query.substring(0, 100),
        duration,
        model: AI_MODELS.HOME_CHAT,
        errorType: error.name,
        errorMessage: error.message
      }, error);

      let errorMessage = 'Sorry, I encountered an error while processing your request. Please try again.';

      if (error.message.includes('429')) {
        errorMessage = 'I\'m currently experiencing high demand. Please wait a moment and try again.';
        logger.warn(LOG_CATEGORIES.AI, 'Rate limit hit for home chat', { query: query.substring(0, 100) });
      } else if (error.message.includes('401')) {
        errorMessage = 'Authentication error. Please check the API configuration.';
        logger.error(LOG_CATEGORIES.AI, 'Authentication error for home chat', { query: query.substring(0, 100) });
      } else if (error.message.includes('timeout')) {
        errorMessage = 'Request timed out. Please try a simpler question or try again later.';
        logger.warn(LOG_CATEGORIES.AI, 'Timeout error for home chat', { query: query.substring(0, 100), duration });
      }

      // Add error message to chat history
      const errorMsg: ChatMessage = {
        id: `error-${Date.now()}`,
        role: 'assistant',
        content: errorMessage,
        timestamp: new Date()
      };
      setChatHistory(prev => [...prev, errorMsg]);
    } finally {
      setIsLoading(false);
    }
  }, [inputValue, isLoading, dataLoading, products, coverages, forms, rules, contextSummary, chatHistory, classifyQuery, buildEnhancedPrompt]);

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleClearChat = () => {
    setChatHistory([]);
    setInputValue('');
  };

  // Compute loading state
  const isSystemReady = !dataLoading && !productsLoading;
  const isEmpty = chatHistory.length === 0;

  return (
    <Page>
      <MainNavigation />

      {/* System Status Indicator */}
      <SystemStatus $isReady={isSystemReady}>
        {isSystemReady ? (
          <>
            <CheckCircleIcon />
            <span>System Ready</span>
          </>
        ) : (
          <>
            <ExclamationTriangleIcon />
            <span>Loading...</span>
          </>
        )}
      </SystemStatus>

      <MainContent id="main-content" $isEmpty={isEmpty}>
        {isEmpty ? (
          /* Centered Empty State with Input */
          <CenteredContainer>
            <EmptyState>
              <SparklesIcon />
              <h2>Product Hub Assistant</h2>
              <p>
                Ask me anything about your insurance products, coverages, forms, pricing, rules, and tasks.
                I have access to all your data and can provide comprehensive insights.
              </p>
              {!isSystemReady && (
                <p style={{ fontSize: '13px', marginTop: '8px' }}>
                  Loading system data...
                </p>
              )}
            </EmptyState>

            {/* Centered Input */}
            <InputContainer $isCentered={true}>
              <InputWrapper>
                <InputField
                  ref={inputRef}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyDown={handleKeyDown}
                  placeholder={
                    isSystemReady
                      ? "Ask about products, coverages, pricing, compliance, or anything else..."
                      : "Loading system data..."
                  }
                  disabled={!isSystemReady || isLoading}
                  rows={1}
                />
                <SendButton
                  onClick={handleSendMessage}
                  disabled={!isSystemReady || isLoading || !inputValue.trim()}
                  title="Send message"
                >
                  <ArrowUpIcon />
                </SendButton>
              </InputWrapper>
            </InputContainer>
          </CenteredContainer>
        ) : (
          /* Chat Mode with Messages */
          <>
            <ChatContainer ref={chatContainerRef}>
              {chatHistory.map((message) => (
                <MessageGroup key={message.id}>
                  {message.role === 'user' ? (
                    <UserMessage>
                      <div className="content">{message.content}</div>
                    </UserMessage>
                  ) : (
                    <AssistantMessage>
                      <div className="avatar">
                        <SparklesIcon />
                      </div>
                      <div className="content">
                        <EnhancedChatMessage
                          content={message.content}
                          metadata={message.metadata}
                          showMetadata={false}
                        />
                        <div className="message-actions">
                          <ActionButton
                            onClick={() => handleCopyMessage(message.id, message.content)}
                            $active={copiedMessageId === message.id}
                            title={copiedMessageId === message.id ? 'Copied!' : 'Copy message'}
                          >
                            {copiedMessageId === message.id ? (
                              <CheckIcon />
                            ) : (
                              <ClipboardDocumentIcon />
                            )}
                          </ActionButton>
                        </div>
                      </div>
                    </AssistantMessage>
                  )}
                </MessageGroup>
              ))}

              {isLoading && (
                <LoadingIndicator>
                  <div className="avatar">
                    <SparklesIcon />
                  </div>
                  <div className="typing-container">
                    <div className="typing-text">Analyzing your request...</div>
                    <div className="dots">
                      <span></span>
                      <span></span>
                      <span></span>
                    </div>
                  </div>
                </LoadingIndicator>
              )}
            </ChatContainer>

            {/* Bottom Input Area */}
            <InputContainer $isCentered={false}>
              <InputWrapper>
                <InputField
                  ref={inputRef}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyDown={handleKeyDown}
                  placeholder={
                    isSystemReady
                      ? "Ask about products, coverages, pricing, compliance, or anything else..."
                      : "Loading system data..."
                  }
                  disabled={!isSystemReady || isLoading}
                  rows={1}
                />
                <SendButton
                  onClick={handleSendMessage}
                  disabled={!isSystemReady || isLoading || !inputValue.trim()}
                  title="Send message"
                >
                  <ArrowUpIcon />
                </SendButton>
              </InputWrapper>
            </InputContainer>

            {/* Clear Chat Button */}
            <ClearButton onClick={handleClearChat} title="Clear conversation">
              <TrashIcon />
            </ClearButton>
          </>
        )}
      </MainContent>


    </Page>
  );
}
```

---

## src/components/Login.tsx

**Path:** `src/components/Login.tsx`

```tsx
// src/components/Login.tsx
// Modern, clean, AI-inspired login page with subtle animations
import { useState, useCallback, useRef } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import styled, { keyframes, css } from 'styled-components';
import { CheckCircleIcon, ExclamationCircleIcon, SparklesIcon } from '@heroicons/react/24/solid';
import { getAuth, signInAnonymously } from 'firebase/auth';
import logger, { LOG_CATEGORIES } from '@utils/logger';

/* ============================== Animations =============================== */
const fadeInUp = keyframes`
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
`;

const pulse = keyframes`
  0%, 100% { opacity: 0.4; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(1.02); }
`;

const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

const spin = keyframes`
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
`;

const float = keyframes`
  0%, 100% { transform: translateY(100vh); opacity: 0; }
  10% { opacity: 0.6; }
  90% { opacity: 0.6; }
  100% { transform: translateY(-20px); opacity: 0; }
`;

const glow = keyframes`
  0%, 100% { box-shadow: 0 0 30px rgba(99, 102, 241, 0.15), 0 0 60px rgba(99, 102, 241, 0.05); }
  50% { box-shadow: 0 0 40px rgba(99, 102, 241, 0.25), 0 0 80px rgba(99, 102, 241, 0.1); }
`;

const gridPulse = keyframes`
  0%, 100% { opacity: 0.02; }
  50% { opacity: 0.05; }
`;

const orbFloat = keyframes`
  0%, 100% { transform: translate(0, 0); }
  33% { transform: translate(20px, -15px); }
  66% { transform: translate(-15px, 10px); }
`;

/* ============================== Layout =============================== */
const Page = styled.div`
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 24px;
  position: relative;
  overflow: hidden;
  background: #030712;

  @media (prefers-reduced-motion: reduce) {
    * { animation-duration: 0.01ms !important; }
  }
`;

/* Subtle grid background */
const GridBackground = styled.div`
  position: absolute;
  inset: 0;
  background-image:
    linear-gradient(rgba(99, 102, 241, 0.03) 1px, transparent 1px),
    linear-gradient(90deg, rgba(99, 102, 241, 0.03) 1px, transparent 1px);
  background-size: 80px 80px;
  animation: ${gridPulse} 8s ease-in-out infinite;
  pointer-events: none;
`;

/* Gradient orbs */
const GradientOrb = styled.div<{ $variant: 1 | 2 | 3 }>`
  position: absolute;
  border-radius: 50%;
  filter: blur(100px);
  pointer-events: none;
  
  ${({ $variant }) => $variant === 1 && css`
    width: 600px;
    height: 600px;
    top: -200px;
    right: -150px;
    background: radial-gradient(circle, rgba(99, 102, 241, 0.25) 0%, transparent 70%);
    animation: ${orbFloat} 20s ease-in-out infinite;
  `}
  
  ${({ $variant }) => $variant === 2 && css`
    width: 500px;
    height: 500px;
    bottom: -150px;
    left: -100px;
    background: radial-gradient(circle, rgba(168, 85, 247, 0.2) 0%, transparent 70%);
    animation: ${orbFloat} 25s ease-in-out infinite reverse;
  `}
  
  ${({ $variant }) => $variant === 3 && css`
    width: 400px;
    height: 400px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, rgba(14, 165, 233, 0.1) 0%, transparent 70%);
    animation: ${pulse} 6s ease-in-out infinite;
  `}
`;

/* Floating particles */
const ParticleContainer = styled.div`
  position: absolute;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
`;

const Particle = styled.div<{ $delay: number; $x: number; $duration: number }>`
  position: absolute;
  width: 3px;
  height: 3px;
  background: rgba(99, 102, 241, 0.5);
  border-radius: 50%;
  left: ${({ $x }) => $x}%;
  bottom: -10px;
  animation: ${float} ${({ $duration }) => $duration}s linear infinite;
  animation-delay: ${({ $delay }) => $delay}s;
`;

/* Card */
const Card = styled.div`
  position: relative;
  z-index: 10;
  width: 100%;
  max-width: 420px;
  padding: 56px 48px;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(24px);
  border: 1px solid rgba(99, 102, 241, 0.15);
  border-radius: 32px;
  animation: ${fadeInUp} 0.8s ease-out, ${glow} 6s ease-in-out infinite;
  animation-delay: 0s, 0.8s;

  &::before {
    content: '';
    position: absolute;
    inset: -1px;
    border-radius: 33px;
    padding: 1px;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.4), transparent 40%, transparent 60%, rgba(168, 85, 247, 0.4));
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
  }
`;

/* Logo */
const LogoContainer = styled.div`
  display: flex;
  justify-content: center;
  margin-bottom: 32px;
`;

const Logo = styled.div`
  width: 72px;
  height: 72px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(168, 85, 247, 0.2) 100%);
  border-radius: 20px;
  border: 1px solid rgba(99, 102, 241, 0.3);

  svg {
    width: 36px;
    height: 36px;
    color: #a5b4fc;
  }
`;

/* Typography */
const Title = styled.h1`
  font-size: 32px;
  font-weight: 600;
  color: #f8fafc;
  text-align: center;
  margin: 0 0 8px 0;
  letter-spacing: -0.02em;
`;

const Subtitle = styled.p`
  font-size: 16px;
  color: #94a3b8;
  text-align: center;
  margin: 0 0 40px 0;
`;

/* Button */
const Button = styled.button`
  width: 100%;
  padding: 16px 24px;
  font-size: 16px;
  font-weight: 500;
  color: #fff;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border: none;
  border-radius: 14px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;

  &:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(99, 102, 241, 0.4);
  }

  &:active:not(:disabled) {
    transform: translateY(0);
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    background-size: 200% 100%;
    animation: ${shimmer} 2s linear infinite;
    opacity: 0;
    transition: opacity 0.3s;
  }

  &:hover::before {
    opacity: 1;
  }
`;

/* Loading spinner */
const LoadingSpinner = styled.div`
  width: 20px;
  height: 20px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: #fff;
  border-radius: 50%;
  animation: ${spin} 0.8s linear infinite;
`;

/* Messages */
const Message = styled.div<{ $type: 'error' | 'success' }>`
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 14px 16px;
  margin-top: 20px;
  border-radius: 12px;
  font-size: 14px;
  animation: ${fadeInUp} 0.3s ease-out;

  ${({ $type }) => $type === 'error' && css`
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.2);
    color: #fca5a5;

    svg { color: #ef4444; }
  `}

  ${({ $type }) => $type === 'success' && css`
    background: rgba(34, 197, 94, 0.1);
    border: 1px solid rgba(34, 197, 94, 0.2);
    color: #86efac;

    svg { color: #22c55e; }
  `}
`;

/* Version badge */
const VersionBadge = styled.div`
  position: absolute;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  color: #475569;
  letter-spacing: 0.05em;
`;

/* ============================== Component =============================== */
const Login: React.FC = () => {
  const nav = useNavigate();
  const location = useLocation();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  // Get redirect path from location state
  const redirectTo = (location.state as { from?: string })?.from || '/';

  // Generate particles once
  const particles = useRef(
    Array.from({ length: 12 }, (_, i) => ({
      id: i,
      x: Math.random() * 100,
      delay: Math.random() * 10,
      duration: 15 + Math.random() * 10,
    }))
  ).current;

  const handleLaunch = useCallback(async () => {
    if (isLoading) return;

    setIsLoading(true);
    setError(null);
    const startTime = Date.now();

    logger.info(LOG_CATEGORIES.AUTH, 'Guest login initiated');

    try {
      const auth = getAuth();
      await signInAnonymously(auth);

      const duration = Date.now() - startTime;
      logger.info(LOG_CATEGORIES.AUTH, 'Guest login successful', { duration });

      setSuccess('Welcome! Launching platform...');

      setTimeout(() => {
        logger.logNavigation('/login', redirectTo, { reason: 'guest_login' });
        nav(redirectTo, { replace: true });
      }, 600);
    } catch (err) {
      const duration = Date.now() - startTime;
      logger.error(LOG_CATEGORIES.AUTH, 'Guest login failed', { duration }, err as Error);
      setError('Unable to start session. Please try again.');
    } finally {
      setIsLoading(false);
    }
  }, [nav, redirectTo, isLoading]);

  return (
    <Page>
      {/* Background elements */}
      <GridBackground aria-hidden="true" />
      <GradientOrb $variant={1} aria-hidden="true" />
      <GradientOrb $variant={2} aria-hidden="true" />
      <GradientOrb $variant={3} aria-hidden="true" />

      {/* Floating particles */}
      <ParticleContainer aria-hidden="true">
        {particles.map((p) => (
          <Particle key={p.id} $x={p.x} $delay={p.delay} $duration={p.duration} />
        ))}
      </ParticleContainer>

      {/* Main card */}
      <Card role="main" aria-labelledby="login-title">
        <LogoContainer>
          <Logo>
            <SparklesIcon />
          </Logo>
        </LogoContainer>

        <Title id="login-title">Welcome</Title>
        <Subtitle>AI-Powered Insurance Platform</Subtitle>

        <Button
          type="button"
          onClick={handleLaunch}
          disabled={isLoading}
          aria-busy={isLoading}
        >
          {isLoading ? (
            <>
              <LoadingSpinner aria-hidden="true" />
              Initializing...
            </>
          ) : (
            'Launch Platform'
          )}
        </Button>

        {error && (
          <Message $type="error" role="alert">
            <ExclamationCircleIcon width={18} />
            {error}
          </Message>
        )}

        {success && (
          <Message $type="success" role="status">
            <CheckCircleIcon width={18} />
            {success}
          </Message>
        )}

        <VersionBadge>Platform v2.0</VersionBadge>
      </Card>
    </Page>
  );
};

export default Login;
```

---

## src/components/PackagesScreen.tsx

**Path:** `src/components/PackagesScreen.tsx`

```tsx
import React, { useState, useEffect } from 'react';
import styled from 'styled-components';
import { useParams } from 'react-router-dom';
import { collection, getDocs } from 'firebase/firestore';
import { db } from '../firebase';
import { Coverage, CoveragePackage } from '../types';
import { useCoveragePackages, generatePackageRecommendations } from '../hooks/useCoveragePackages';
import { PackageCard } from './packages/PackageCard';
import { PackageBuilder } from './packages/PackageBuilder';
import { PlusIcon, SparklesIcon } from '@heroicons/react/24/outline';

const PackagesScreen: React.FC = () => {
  const { productId } = useParams<{ productId: string }>();
  const { packages, loading, createPackage, updatePackage, deletePackage } = useCoveragePackages(productId);
  
  const [coverages, setCoverages] = useState<Coverage[]>([]);
  const [loadingCoverages, setLoadingCoverages] = useState(true);
  const [showBuilder, setShowBuilder] = useState(false);
  const [editingPackage, setEditingPackage] = useState<CoveragePackage | null>(null);
  const [filterType, setFilterType] = useState<string>('all');
  const [showRecommendations] = useState(false);
  const [selectedCoverageIds] = useState<string[]>([]);

  // Load coverages
  useEffect(() => {
    if (!productId) return;

    const loadCoverages = async () => {
      try {
        const coveragesRef = collection(db, 'products', productId, 'coverages');
        const snapshot = await getDocs(coveragesRef);
        const coveragesList: Coverage[] = [];
        snapshot.forEach((doc) => {
          coveragesList.push({ id: doc.id, ...doc.data() } as Coverage);
        });
        setCoverages(coveragesList);
      } catch (err) {
        console.error('Error loading coverages:', err);
      } finally {
        setLoadingCoverages(false);
      }
    };

    loadCoverages();
  }, [productId]);

  const handleCreatePackage = async (packageData: Omit<CoveragePackage, 'id'>) => {
    await createPackage(packageData);
    setShowBuilder(false);
  };

  const handleUpdatePackage = async (packageData: Omit<CoveragePackage, 'id'>) => {
    if (!editingPackage) return;
    await updatePackage(editingPackage.id, packageData);
    setEditingPackage(null);
    setShowBuilder(false);
  };

  const handleDeletePackage = async (packageId: string) => {
    if (window.confirm('Are you sure you want to delete this package?')) {
      await deletePackage(packageId);
    }
  };

  const handleEditPackage = (pkg: CoveragePackage) => {
    setEditingPackage(pkg);
    setShowBuilder(true);
  };

  const filteredPackages = filterType === 'all' 
    ? packages 
    : packages.filter((pkg) => pkg.packageType === filterType);

  const recommendations = showRecommendations 
    ? generatePackageRecommendations(selectedCoverageIds, packages)
    : [];

  if (!productId) {
    return <ErrorMessage>No product selected</ErrorMessage>;
  }

  if (loading || loadingCoverages) {
    return <LoadingMessage>Loading packages...</LoadingMessage>;
  }

  if (showBuilder) {
    return (
      <Container>
        <PackageBuilder
          availableCoverages={coverages}
          initialData={editingPackage || undefined}
          onSave={editingPackage ? handleUpdatePackage : handleCreatePackage}
          onCancel={() => {
            setShowBuilder(false);
            setEditingPackage(null);
          }}
          productId={productId}
        />
      </Container>
    );
  }

  return (
    <Container>
      <Header>
        <HeaderLeft>
          <Title>Coverage Packages</Title>
          <Subtitle>Bundle coverages together with discounts and special pricing</Subtitle>
        </HeaderLeft>
        <HeaderRight>
          <CreateButton onClick={() => setShowBuilder(true)}>
            <PlusIcon width={20} height={20} />
            Create Package
          </CreateButton>
        </HeaderRight>
      </Header>

      <FilterBar>
        <FilterButton 
          $active={filterType === 'all'} 
          onClick={() => setFilterType('all')}
        >
          All Packages ({packages.length})
        </FilterButton>
        <FilterButton 
          $active={filterType === 'required'} 
          onClick={() => setFilterType('required')}
        >
          Required
        </FilterButton>
        <FilterButton 
          $active={filterType === 'recommended'} 
          onClick={() => setFilterType('recommended')}
        >
          Recommended
        </FilterButton>
        <FilterButton 
          $active={filterType === 'popular'} 
          onClick={() => setFilterType('popular')}
        >
          Popular
        </FilterButton>
        <FilterButton 
          $active={filterType === 'custom'} 
          onClick={() => setFilterType('custom')}
        >
          Custom
        </FilterButton>
      </FilterBar>

      {filteredPackages.length === 0 ? (
        <EmptyState>
          <EmptyStateIcon>ðŸ“¦</EmptyStateIcon>
          <EmptyStateTitle>No packages found</EmptyStateTitle>
          <EmptyStateText>
            {filterType === 'all' 
              ? 'Create your first coverage package to bundle coverages together'
              : `No ${filterType} packages available`
            }
          </EmptyStateText>
          {filterType === 'all' && (
            <CreateButton onClick={() => setShowBuilder(true)}>
              <PlusIcon width={20} height={20} />
              Create Package
            </CreateButton>
          )}
        </EmptyState>
      ) : (
        <PackagesGrid>
          {filteredPackages.map((pkg) => (
            <PackageCard
              key={pkg.id}
              package={pkg}
              coverages={coverages}
              onEdit={() => handleEditPackage(pkg)}
              onDelete={() => handleDeletePackage(pkg.id)}
            />
          ))}
        </PackagesGrid>
      )}

      {recommendations.length > 0 && (
        <RecommendationsSection>
          <RecommendationsHeader>
            <SparklesIcon width={24} height={24} />
            <RecommendationsTitle>Recommended Packages</RecommendationsTitle>
          </RecommendationsHeader>
          <PackagesGrid>
            {recommendations.slice(0, 3).map((pkg) => (
              <PackageCard
                key={pkg.id}
                package={pkg}
                coverages={coverages}
              />
            ))}
          </PackagesGrid>
        </RecommendationsSection>
      )}
    </Container>
  );
};

const Container = styled.div`
  padding: 32px;
  max-width: 1400px;
  margin: 0 auto;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 32px;
`;

const HeaderLeft = styled.div``;

const Title = styled.h1`
  font-size: 32px;
  font-weight: 700;
  color: #111827;
  margin: 0 0 8px 0;
`;

const Subtitle = styled.p`
  font-size: 16px;
  color: #6b7280;
  margin: 0;
`;

const HeaderRight = styled.div``;

const CreateButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 24px;
  background: #3b82f6;
  border: none;
  border-radius: 8px;
  color: white;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;

  &:hover {
    background: #2563eb;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  }

  svg {
    flex-shrink: 0;
  }
`;

const FilterBar = styled.div`
  display: flex;
  gap: 12px;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid #e5e7eb;
`;

const FilterButton = styled.button<{ $active: boolean }>`
  padding: 8px 16px;
  background: ${({ $active }) => $active ? '#3b82f6' : 'white'};
  border: 1px solid ${({ $active }) => $active ? '#3b82f6' : '#d1d5db'};
  border-radius: 6px;
  color: ${({ $active }) => $active ? 'white' : '#374151'};
  font-size: 14px;
  font-weight: ${({ $active }) => $active ? '600' : '500'};
  cursor: pointer;
  transition: all 0.2s;

  &:hover {
    background: ${({ $active }) => $active ? '#2563eb' : '#f9fafb'};
    border-color: ${({ $active }) => $active ? '#2563eb' : '#9ca3af'};
  }
`;

const PackagesGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 24px;
`;

const EmptyState = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 80px 24px;
  text-align: center;
`;

const EmptyStateIcon = styled.div`
  font-size: 64px;
  margin-bottom: 16px;
`;

const EmptyStateTitle = styled.h3`
  font-size: 20px;
  font-weight: 600;
  color: #111827;
  margin: 0 0 8px 0;
`;

const EmptyStateText = styled.p`
  font-size: 16px;
  color: #6b7280;
  margin: 0 0 24px 0;
  max-width: 400px;
`;

const LoadingMessage = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 80px 24px;
  font-size: 18px;
  color: #6b7280;
`;

const ErrorMessage = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 80px 24px;
  font-size: 18px;
  color: #dc2626;
`;

const RecommendationsSection = styled.div`
  margin-top: 48px;
  padding-top: 32px;
  border-top: 2px solid #e5e7eb;
`;

const RecommendationsHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 24px;

  svg {
    color: #f59e0b;
  }
`;

const RecommendationsTitle = styled.h2`
  font-size: 24px;
  font-weight: 600;
  color: #111827;
  margin: 0;
`;

export default PackagesScreen;

```

---

## src/components/PricingScreen.tsx

**Path:** `src/components/PricingScreen.tsx`

```tsx
import { useState, useEffect, useMemo, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { db } from '../firebase';
import { collection, getDocs, addDoc, deleteDoc, doc, getDoc, updateDoc } from 'firebase/firestore';
import {
  TrashIcon,
  PencilIcon,
  XMarkIcon,
  InformationCircleIcon,
  PlusIcon,
  MinusIcon,
  ChevronUpIcon,
  ChevronDownIcon,
  CurrencyDollarIcon,
} from '@heroicons/react/24/solid';
import { ArrowDownTrayIcon as DownloadIcon20, ArrowUpTrayIcon as UploadIcon20 } from '@heroicons/react/20/solid';

import { Button } from '../components/ui/Button';
import MainNavigation from '../components/ui/Navigation';
import { PageContainer, PageContent } from '../components/ui/PageContainer';
import EnhancedHeader from '../components/ui/EnhancedHeader';

import {
  Table,
  THead as TableHead,
  Tr as TableRow,
  Th as TableHeader,
  Td as TableCell,
  Modal as ModalBox,
  ModalHeader,
  ModalTitle,
  CloseBtn
} from '../components/ui/Table';
import styled, { keyframes } from 'styled-components';
import { TextInput } from '../components/ui/Input';
import RatingAlgorithmBuilder from './pricing/RatingAlgorithmBuilder';

/* ========== MODERN STYLED COMPONENTS ========== */

// Enhanced animations
const slideIn = keyframes`
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

// Ensures any button/link used inside table cells fills the cell width and centers its text
const CellButton = styled(Button)`
  width: 100%;
  justify-content: center;
`;

const FormGroup = styled.div`
  margin-bottom: 16px;
  label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: #1F2937;
    display: flex;
    align-items: center;
    gap: 4px;
  }
`;

const CoverageGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 8px;
  max-height: 200px;
  overflow-y: auto;
  padding: 8px;
  border: 1px solid #D1D5DB;
  border-radius: 8px;
  background: #F9FAFB;
`;

const StateGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
  gap: 8px;
  max-height: 200px;
  overflow-y: auto;
  padding: 8px;
  border: 1px solid #D1D5DB;
  border-radius: 8px;
  background: #F9FAFB;
`;

const OptionLabel = styled.label`
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 14px;
  color: #1F2937;
  input[type="checkbox"] {
    accent-color: #6B46C1;
  }
`;

const SelectAllContainer = styled.div`
  margin-bottom: 8px;
`;

// State filter options
const usStates = ['AL','AK','AZ','AR','CA','CO','CT','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY'];

// Main styled components
const MainContent = styled.div`
  max-width: 1400px;
  margin: 0 auto;
  padding: 32px 24px;
  position: relative;
  z-index: 1;
`;

const Card = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  padding: 28px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  margin-bottom: 32px;
  transition: all 0.3s ease;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
  }
`;

const FiltersBar = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 24px;
  align-items: flex-end;
  margin-bottom: 24px;
`;

const PriceBar = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 20px;
  font-weight: 700;
  color: #1F2937;
  margin-top: 24px;
`;

const PricingTable = styled(Table)`
  width: 100%;
  border-collapse: collapse;
  margin-top: 16px;
`;

const ActionsContainer = styled.div`
  display: flex;
  gap: 4px;
  align-items: center;
  justify-content: center;
  flex-wrap: nowrap;
  min-height: 40px; /* Ensure consistent height across rows */
`;

const OverlayFixed = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
`;

// Loading spinner
const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;
const Spinner = styled.div`
  border: 4px solid #f3f3f3;
  border-top: 4px solid #6366f1;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: ${spin} 1s linear infinite;
  margin: 100px auto;
`;

const Skeleton = styled.div`
  width: 100%;
  height: 20px;
  background: #E5E7EB;
  border-radius: 4px;
  animation: pulse 1.5s infinite;
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
  }
`;

const OperandGroup = styled.div`
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 32px;
`;

// Coverage Page style header components
const BackButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border: none;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.9);
  color: #64748b;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(12px);
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(99, 102, 241, 0.15);
    border-color: rgba(99, 102, 241, 0.2);
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

const TitleContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 1;
`;

const TitleIcon = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 8px;
  color: white;

  svg {
    width: 16px;
    height: 16px;
  }
`;

const CoveragePageHeaderSection = styled.div`
  display: flex;
  align-items: center;
  margin-bottom: 32px;
  gap: 16px;
`;

const CoveragePageTitle = styled.h1`
  font-size: 24px;
  font-weight: 700;
  background: linear-gradient(135deg, #1e293b 0%, #475569 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin: 0;
  letter-spacing: -0.025em;

  @media (max-width: 768px) {
    font-size: 20px;
  }
`;

// Editable value cell component
const EditableValueCell = styled.div`
  position: relative;

  input {
    width: 120px;
    padding: 4px 8px;
    border: 1px solid transparent;
    border-radius: 4px;
    background: transparent;
    text-align: center;
    font-size: 14px;

    &:hover {
      border-color: #e2e8f0;
      background: #f8fafc;
    }

    &:focus {
      outline: none;
      border-color: #6366f1;
      background: white;
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
    }
  }
`;

// Coverage Modal Styled Components (similar to forms modal)
const WideModal = styled(ModalBox)`
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
`;

const CoverageSearchInput = styled(TextInput)`
  margin-bottom: 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 8px;
  padding: 10px 12px;
  font-size: 14px;
`;

const CoverageLinkActions = styled.div`
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
`;

const CoverageLinkContainer = styled.div`
  max-height: 360px;
  overflow-y: auto;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 12px;
  padding: 8px;
  margin-bottom: 16px;
  background: rgba(248, 250, 252, 0.5);
`;

const CoverageLinkItem = styled.label`
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: 4px;

  &:hover {
    background: rgba(99, 102, 241, 0.05);
  }

  &:last-child {
    margin-bottom: 0;
  }
`;

const CoverageCheckbox = styled.input`
  width: 18px;
  height: 18px;
  accent-color: #6366f1;
  cursor: pointer;
`;

const CoverageLabel = styled.span`
  flex: 1;
  font-size: 14px;
  font-weight: 500;
  color: #374151;
`;

const Actions = styled.div`
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 16px;
`;

// Pricing Stats Dashboard
const PricingStatsDashboard = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
  animation: ${slideIn} 0.4s ease-out;
`;

const PricingStatCard = styled.div<{ $color?: string }>`
  background: white;
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: ${({ $color }) => $color || 'linear-gradient(90deg, #6366f1, #8b5cf6)'};
  }

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
    border-color: transparent;
  }
`;

const PricingStatValue = styled.div`
  font-size: 28px;
  font-weight: 700;
  color: #1e293b;
  margin-bottom: 4px;
  letter-spacing: -0.02em;
`;

const PricingStatLabel = styled.div`
  font-size: 13px;
  font-weight: 500;
  color: #64748b;
  display: flex;
  align-items: center;
  gap: 6px;

  svg {
    width: 14px;
    height: 14px;
    opacity: 0.7;
  }
`;

const PricingStatTrend = styled.span<{ $positive?: boolean }>`
  font-size: 11px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  margin-left: 8px;
  background: ${({ $positive }) => $positive ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)'};
  color: ${({ $positive }) => $positive ? '#059669' : '#dc2626'};
`;

// StepModal Component
function StepModal({ onClose, onSubmit, editingStep, coverages, dataCodes }) {
  const defaultStep = useMemo(() => ({
    stepType: 'factor',
    coverages: [],
    stepName: '',
    type: 'User Input',
    table: '',
    rounding: 'none',
    states: [],
    upstreamId: '',
    operand: '',
    value: 1
  }), []);

  const [stepData, setStepData] = useState(editingStep ? { ...editingStep } : { ...defaultStep });
  const [errors, setErrors] = useState({});
  const [comment, setComment] = useState('');

  useEffect(() => {
    setStepData(editingStep ? { ...editingStep } : { ...defaultStep });
    setErrors({});
    setComment('');
  }, [editingStep, defaultStep]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setStepData(prev => ({ ...prev, [name]: name === 'value' ? parseFloat(value) || 0 : value }));
    setErrors(prev => ({ ...prev, [name]: '' }));
  };

  const handleCoveragesChange = (coverage, checked) => {
    setStepData(prev => ({
      ...prev,
      coverages: checked
        ? [...prev.coverages, coverage]
        : prev.coverages.filter(c => c !== coverage)
    }));
  };

  const handleSelectAllCoverages = (checked) => {
    setStepData(prev => ({
      ...prev,
      coverages: checked ? coverages.map(c => c.name) : []
    }));
  };

  const handleStatesChange = (state, checked) => {
    setStepData(prev => ({
      ...prev,
      states: checked
        ? [...prev.states, state]
        : prev.states.filter(s => s !== state)
    }));
  };

  const handleSelectAllStates = (checked) => {
    setStepData(prev => ({
      ...prev,
      states: checked ? allStates : []
    }));
  };

  const validate = () => {
    const newErrors = {};
    if (stepData.stepType === 'factor') {
      if (!stepData.stepName) newErrors.stepName = 'Step Name is required';
      if (stepData.coverages.length === 0) newErrors.coverages = 'At least one coverage is required';
    } else if (!stepData.operand) {
      newErrors.operand = 'Operand is required';
    }
    if (editingStep && (!comment.trim() || comment.trim().length < 10)) {
      newErrors.comment = 'Reason must be at least 10 characters';
    }
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = () => {
    if (validate()) {
      onSubmit(stepData, comment);
    }
  };

  const allStates = ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'];

  return (
    <OverlayFixed onClick={onClose}>
      <ModalBox onClick={e => e.stopPropagation()}>
        <CloseBtn onClick={onClose} aria-label="Close modal"><XMarkIcon width={24} height={24} /></CloseBtn>
        <ModalHeader>
          <ModalTitle>{editingStep ? 'Edit Step' : 'Add Step'}</ModalTitle>
        </ModalHeader>
        {stepData.stepType === 'factor' ? (
          <>
            <FormGroup>
              <label>Coverages {errors.coverages && <span style={{ color: '#EF4444' }}>{errors.coverages}</span>}</label>
              <SelectAllContainer>
                <OptionLabel>
                  <input
                    type="checkbox"
                    checked={stepData.coverages.length === coverages.length}
                    onChange={e => handleSelectAllCoverages(e.target.checked)}
                  />
                  All
                </OptionLabel>
              </SelectAllContainer>
              <CoverageGrid>
                {coverages.map(c => (
                  <OptionLabel key={c.id}>
                    <input
                      type="checkbox"
                      checked={stepData.coverages.includes(c.name)}
                      onChange={e => handleCoveragesChange(c.name, e.target.checked)}
                      disabled={stepData.coverages.length === coverages.length && !stepData.coverages.includes(c.name)}
                    />
                    {c.name}
                  </OptionLabel>
                ))}
              </CoverageGrid>
            </FormGroup>
            <FormGroup>
              <label>Step Name {errors.stepName && <span style={{ color: '#EF4444' }}>{errors.stepName}</span>}</label>
              <TextInput name="stepName" value={stepData.stepName} onChange={handleChange} className={errors.stepName ? 'error' : ''} />
            </FormGroup>
            {editingStep && (
              <FormGroup>
                <label>Value</label>
                <TextInput type="number" name="value" value={stepData.value} onChange={handleChange} placeholder="Enter factor value" />
              </FormGroup>
            )}
            <FormGroup>
              <label>Type</label>
              <select name="type" value={stepData.type} onChange={handleChange} style={{ width: '100%', padding: 12, borderRadius: 8, border: '1px solid #D1D5DB' }}>
                <option value="User Input">User Input</option>
                <option value="Table">Table</option>
                <option value="Other">Other</option>
              </select>
            </FormGroup>
            <FormGroup>
              <label>Table Name (Optional)</label>
              <TextInput name="table" value={stepData.table} onChange={handleChange} />
            </FormGroup>
            <FormGroup>
              <label>Rounding</label>
              <select name="rounding" value={stepData.rounding} onChange={handleChange} style={{ width: '100%', padding: 12, borderRadius: 8, border: '1px solid #D1D5DB' }}>
                <option value="none">None</option>
                <option value="Whole Number">Whole Number</option>
                <option value="1 Decimal">1 Decimal</option>
                <option value="2 Decimals">2 Decimals</option>
                <option value="Other">Other</option>
              </select>
            </FormGroup>
            <FormGroup>
              <label>States <InformationCircleIcon style={{ width: '16px', color: '#6B7280' }} title="Select applicable states" /></label>
              <SelectAllContainer>
                <OptionLabel>
                  <input
                    type="checkbox"
                    checked={stepData.states.length === allStates.length}
                    onChange={e => handleSelectAllStates(e.target.checked)}
                  />
                  All
                </OptionLabel>
              </SelectAllContainer>
              <StateGrid>
                {allStates.map(state => (
                  <OptionLabel key={state}>
                    <input
                      type="checkbox"
                      checked={stepData.states.includes(state)}
                      onChange={e => handleStatesChange(state, e.target.checked)}
                      disabled={stepData.states.length === allStates.length && !stepData.states.includes(state)}
                    />
                    {state}
                  </OptionLabel>
                ))}
              </StateGrid>
            </FormGroup>
            <FormGroup>
              <label>UpstreamÂ ID</label>
              <select
                name="upstreamId"
                value={stepData.upstreamId}
                onChange={handleChange}
                style={{ width:'100%', padding:12, borderRadius:8, border:'1px solid #D1D5DB' }}
              >
                <option value="">Select IT Code</option>
                {dataCodes.map(code => (
                  <option key={code} value={code}>{code}</option>
                ))}
              </select>
            </FormGroup>
          </>
        ) : stepData.stepType === 'operand' ? (
          <>
            <FormGroup>
              <label>Coverages {errors.coverages && <span style={{ color: '#EF4444' }}>{errors.coverages}</span>}</label>
              <SelectAllContainer>
                <OptionLabel>
                  <input
                    type="checkbox"
                    checked={stepData.coverages.length === coverages.length}
                    onChange={e => handleSelectAllCoverages(e.target.checked)}
                  />
                  All
                </OptionLabel>
              </SelectAllContainer>
              <CoverageGrid>
                {coverages.map(c => (
                  <OptionLabel key={c.id}>
                    <input
                      type="checkbox"
                      checked={stepData.coverages.includes(c.name)}
                      onChange={e => handleCoveragesChange(c.name, e.target.checked)}
                      disabled={stepData.coverages.length === coverages.length && !stepData.coverages.includes(c.name)}
                    />
                    {c.name}
                  </OptionLabel>
                ))}
              </CoverageGrid>
            </FormGroup>
            <FormGroup>
              <label>Operand</label>
              <select
                name="operand"
                value={stepData.operand}
                onChange={handleChange}
                style={{ width: '100%', padding: 12, borderRadius: 8, border: '1px solid #D1D5DB' }}
              >
                <option value="+">+ (Addition)</option>
                <option value="-">- (Subtraction)</option>
                <option value="*">* (Multiplication)</option>
                <option value="/">/ (Division)</option>
                <option value="=">=  (Equals)</option>
              </select>
            </FormGroup>
            <FormGroup>
              <label>States <InformationCircleIcon style={{ width: '16px', color: '#6B7280' }} title="Select applicable states" /></label>
              <SelectAllContainer>
                <OptionLabel>
                  <input
                    type="checkbox"
                    checked={stepData.states.length === allStates.length}
                    onChange={e => handleSelectAllStates(e.target.checked)}
                  />
                  All
                </OptionLabel>
              </SelectAllContainer>
              <StateGrid>
                {allStates.map(state => (
                  <OptionLabel key={state}>
                    <input
                      type="checkbox"
                      checked={stepData.states.includes(state)}
                      onChange={e => handleStatesChange(state, e.target.checked)}
                      disabled={stepData.states.length === allStates.length && !stepData.states.includes(state)}
                    />
                    {state}
                  </OptionLabel>
                ))}
              </StateGrid>
            </FormGroup>
          </>
        ) : null}
        {editingStep && (
          <textarea
            rows="3"
            placeholder="Reason for changes (required)"
            value={comment}
            onChange={e => setComment(e.target.value)}
            style={{
              width: '100%',
              padding: 10,
              borderRadius: 6,
              border: '1px solid #e5e7eb',
              fontSize: 14,
              marginBottom: 12
            }}
          />
        )}
        {editingStep && errors.comment && <div style={{ color: '#EF4444', marginBottom: 8 }}>{errors.comment}</div>}
        <Button onClick={handleSubmit} aria-label={editingStep ? 'Update step' : 'Add step'} style={{ marginTop: 16 }}>
          {editingStep ? 'Update Step' : 'Add Step'}
        </Button>
      </ModalBox>
    </OverlayFixed>
  );
}

// Main PricingScreen Component
function PricingScreen() {
  const [loading, setLoading] = useState(true);
  const { productId } = useParams();
  const navigate = useNavigate();
  const [productName, setProductName] = useState('');
  const [coverages, setCoverages] = useState([]);
  const [steps, setSteps] = useState([]);
  // validCoverageCodes: coverageCode array for mapping/validation
  const validCoverageCodes = coverages.map(c => c.coverageCode);
  const [modalOpen, setModalOpen] = useState(false);
  const [editingStep, setEditingStep] = useState(null);
  const [comment, setComment] = useState('');
  const [price, setPrice] = useState('N/A');
  const [selectedCoverage, setSelectedCoverage] = useState(null);
  const [selectedStates, setSelectedStates] = useState([]);
  const [dataCodes, setDataCodes] = useState([]);
  // Step Details Modal state
  const [stepDetailsOpen, setStepDetailsOpen] = useState(false);
  const [detailsStep, setDetailsStep] = useState(null);

  // Handle URL query parameters for coverage filtering
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const coverageParam = urlParams.get('coverage');
    if (coverageParam) {
      setSelectedCoverage(coverageParam);
    }
  }, []);

  const fileInputRef = useRef(null);

  useEffect(() => {
    const fetchDictionary = async () => {
      try {
        const snapshot = await getDocs(collection(db, 'dataDictionary'));
        const codes = snapshot.docs.map(d => d.data().code).filter(Boolean).sort();
        setDataCodes(codes);
      } catch (err) {
        console.error('Unable to load dataâ€‘dictionary codes', err);
      }
    };
    fetchDictionary();
  }, []);

  const [covModalOpen, setCovModalOpen] = useState(false);

  const [selectedCoveragesForStep, setSelectedCoveragesForStep] = useState([]);
  const [currentEditingStep, setCurrentEditingStep] = useState(null);
  const [coverageSearchQuery, setCoverageSearchQuery] = useState('');

  // States modal state
  const [statesModalOpen, setStatesModalOpen] = useState(false);
  const [selectedStatesForStep, setSelectedStatesForStep] = useState([]);
  const [currentEditingStepForStates, setCurrentEditingStepForStates] = useState(null);
  const [stateSearchQuery, setStateSearchQuery] = useState('');

  const openCovModal = (step) => {
    setCurrentEditingStep(step);
    setSelectedCoveragesForStep(step.coverages || []);
    setCoverageSearchQuery('');
    setCovModalOpen(true);
  };

  const openStatesModal = (step) => {
    setCurrentEditingStepForStates(step);
    setSelectedStatesForStep(step.states || []);
    setStateSearchQuery('');
    setStatesModalOpen(true);
  };

  const allStates = useMemo(() => ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'], []);

  // Filter coverages based on search query
  const filteredCoverages = useMemo(() => {
    if (!coverageSearchQuery.trim()) return coverages;
    const query = coverageSearchQuery.toLowerCase();
    return coverages.filter(coverage =>
      coverage.name.toLowerCase().includes(query) ||
      coverage.coverageCode.toLowerCase().includes(query)
    );
  }, [coverages, coverageSearchQuery]);

  // Filter states based on search query
  const filteredStates = useMemo(() => {
    if (!stateSearchQuery.trim()) return allStates;
    const query = stateSearchQuery.toLowerCase();
    return allStates.filter(state =>
      state.toLowerCase().includes(query)
    );
  }, [allStates, stateSearchQuery]);

  // Save coverage changes
  const saveSelectedCoverages = async () => {
    if (!currentEditingStep) return;

    try {
      await updateDoc(
        doc(db, `products/${productId}/steps`, currentEditingStep.id),
        { coverages: selectedCoveragesForStep }
      );

      // Update local state
      setSteps(prevSteps =>
        prevSteps.map(step =>
          step.id === currentEditingStep.id
            ? { ...step, coverages: selectedCoveragesForStep }
            : step
        )
      );

      setCovModalOpen(false);
    } catch (err) {
      console.error('Failed to save coverage changes:', err);
      alert('Failed to save coverage changes: ' + err.message);
    }
  };

  // Save states changes
  const saveSelectedStates = async () => {
    if (!currentEditingStepForStates) return;

    try {
      await updateDoc(
        doc(db, `products/${productId}/steps`, currentEditingStepForStates.id),
        { states: selectedStatesForStep }
      );

      // Update local state
      setSteps(prevSteps =>
        prevSteps.map(step =>
          step.id === currentEditingStepForStates.id
            ? { ...step, states: selectedStatesForStep }
            : step
        )
      );

      setStatesModalOpen(false);
    } catch (err) {
      console.error('Failed to save states changes:', err);
      alert('Failed to save states changes: ' + err.message);
    }
  };

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const productDoc = await getDoc(doc(db, 'products', productId));
        if (productDoc.exists()) {
          setProductName(productDoc.data().name);
        } else {
          throw new Error("Product not found");
        }

        const coveragesSnapshot = await getDocs(collection(db, `products/${productId}/coverages`));
        const coverageList = coveragesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setCoverages(coverageList);

        const stepsSnapshot = await getDocs(collection(db, `products/${productId}/steps`));
        const stepList = stepsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        stepList.sort((a, b) => a.order - b.order);
        setSteps(stepList);
      } catch (error) {
        console.error("Error fetching data:", error);
        alert("Failed to load data. Please try again.");
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [productId]);

  // â€”â€” New: add operand row via buttons â€”â€”
  const addOperand = async (operandChar) => {
    try {
      const allCoverageNames = coverages.map(c => c.name);
      const docRef = await addDoc(collection(db, `products/${productId}/steps`), {
        stepType: 'operand',
        operand: operandChar,
        coverages: allCoverageNames, // Default to all coverages
        states: allStates, // Default to all states
        order: steps.length
      });

      setSteps(prev => [...prev, { id: docRef.id, stepType:'operand', operand:operandChar, coverages: allCoverageNames, states: allStates, order:steps.length }]
        .sort((a,b)=>a.order-b.order));
    } catch (err) {
      console.error('Error adding operand:', err);
      alert('Failed to add operand.');
    }
  };


  useEffect(() => {
    const calculatePricing = () => {
      let result = null;
      let currentOperand = null;

      steps.forEach(step => {
        if (step.stepType === 'factor') {
          const value = step.value || 0;
          if (result === null) {
            result = value;
          } else if (currentOperand) {
            if (currentOperand === '+') result += value;
            else if (currentOperand === '-') result -= value;
            else if (currentOperand === '*') result *= value;
            else if (currentOperand === '/') result = value !== 0 ? result / value : result;
          }
        } else if (step.stepType === 'operand') {
          currentOperand = step.operand;
        }
      });

      return result !== null ? result.toFixed(2) : 'N/A';
    };
    setPrice(calculatePricing());
  }, [steps]);

  const filteredSteps = useMemo(() => {
    return steps
      .filter(step =>
        (!selectedCoverage || (step.coverages && step.coverages.includes(selectedCoverage)))
      )
      .filter(step =>
        (selectedStates.length === 0
            || selectedStates.every(s => step.states && step.states.includes(s)))
      );
  }, [steps, selectedCoverage, selectedStates]);

  if (loading) {
    return (
      <PageContainer>
        <MainNavigation />
        <PageContent>
          <Spinner />
        </PageContent>
      </PageContainer>
    );
  }

  const handleModalSubmit = async (stepData, _comment) => {
    if (editingStep) {
      try {
        await updateDoc(doc(db, `products/${productId}/steps`, editingStep.id), stepData);
        // Log update
        const oldSnap = await getDoc(doc(db, `products/${productId}/steps`, editingStep.id));
        const oldData = oldSnap.exists() ? oldSnap.data() : {};
        const diff = {};
        Object.keys(stepData).forEach(key => {
          const before = oldData[key] ?? '';
          const after = stepData[key];
          if (JSON.stringify(before) !== JSON.stringify(after)) {
            diff[key] = { before, after };
          }
        });

        const updatedSteps = steps.map(s => s.id === editingStep.id ? { ...s, ...stepData } : s);
        updatedSteps.sort((a, b) => a.order - b.order);
        setSteps(updatedSteps);
      } catch (error) {
        console.error("Error updating step:", error);
        alert("Failed to update step. Please try again.");
      }
    } else {
      try {
        const docRef = await addDoc(collection(db, `products/${productId}/steps`), { ...stepData, order: steps.length });

        const updatedSteps = [...steps, { ...stepData, id: docRef.id, order: steps.length }];
        updatedSteps.sort((a, b) => a.order - b.order);
        setSteps(updatedSteps);
      } catch (error) {
        console.error("Error adding step:", error);
        alert("Failed to add step. Please try again.");
      }
    }
    setModalOpen(false);
  };

  const handleDeleteStep = async (stepId) => {
    if (window.confirm("Are you sure you want to delete this step?")) {
      try {
        await deleteDoc(doc(db, `products/${productId}/steps`, stepId));

        const updatedSteps = steps.filter(step => step.id !== stepId);
        updatedSteps.sort((a, b) => a.order - b.order);
        setSteps(updatedSteps);
      } catch (error) {
        console.error("Error deleting step:", error);
        alert("Failed to delete step. Please try again.");
      }
    }
  };

  const openAddModal = () => {
    setComment('');
    setEditingStep(null);
    setModalOpen(true);
  };

  const openEditModal = (step) => {
    setComment('');
    setEditingStep(step);
    setModalOpen(true);
  };

  const getStatesDisplay = (selectedStates) => {
    if (selectedStates.length === allStates.length) {
      return 'All';
    } else if (selectedStates.length > 1) {
      return 'Multiple';
    } else if (selectedStates.length === 1) {
      return selectedStates[0];
    } else {
      return 'All';
    }
  };

  const coverageOptions = [
    { value: null, label: 'All Coverages' },
    ...coverages.map(c => ({ value: c.name, label: c.name }))
  ].sort((a, b) => a.label.localeCompare(b.label));


  // ---------- XLSX helpers (Pricing) ----------
  const OPERANDS = ['+','-','*','/','='];
  const ALL_STATES = [...usStates];   // reuse list already declared

  // Enhanced pricing sheet with professional styling
  const makePricingSheet = (steps) => {
    // Add metadata header
    const currentDate = new Date().toLocaleDateString();
    const metadata = [
      ['Pricing Model Export Report'],
      [`Generated on: ${currentDate}`],
      [`Product: ${productName}`],
      [`Total Steps: ${steps.filter(s => s.stepType === 'factor').length}`],
      [''], // Empty row for spacing
      ['Coverage', 'Step Name', 'Table Name', 'Calculation', 'Rounding', 'Value', ...ALL_STATES]
    ];

    // flatten factor+operand so each factor row carries the FOLLOWING operand (Excel pattern)
    const rows = [];
    for (let i = 0; i < steps.length; i++) {
      const s = steps[i];
      if (s.stepType !== 'factor') continue;
      const next = steps[i + 1];
      const row = {
        Coverage: (s.coverages || []).join('; '),
        'Step Name': s.stepName || '',
        'Table Name': s.table || '',
        Calculation: (next && next.stepType === 'operand') ? next.operand : '',
        Rounding: s.rounding || 'None',
        Value: s.value ?? 0,
      };
      // mark states with Yes/No instead of X/blank
      ALL_STATES.forEach(st => {
        row[st] = (s.states || ALL_STATES).includes(st) ? 'Yes' : 'No';
      });
      rows.push(row);
    }

    const XLSX = require('xlsx');

    // Create worksheet with metadata
    const ws = XLSX.utils.aoa_to_sheet(metadata);

    // Add data rows if we have any
    if (rows.length > 0) {
      XLSX.utils.sheet_add_json(ws, rows, {
        origin: 'A7',
        skipHeader: false
      });
    }

    // Set column widths
    const colWidths = [
      { wch: 20 }, // Coverage
      { wch: 25 }, // Step Name
      { wch: 15 }, // Table Name
      { wch: 12 }, // Calculation
      { wch: 12 }, // Rounding
      { wch: 10 }, // Value
      ...ALL_STATES.map(() => ({ wch: 4 })) // State columns
    ];
    ws['!cols'] = colWidths;

    return ws;
  };

  // Convert sheet rows -> step objects array
  const sheetToStepObjects = (ws) =>{
    const XLSX = require('xlsx');
    const rows = XLSX.utils.sheet_to_json(ws,{defval:''});
    const out = [];
    rows.forEach((r)=>{
      // factor first
      const factor = {
        stepType:'factor',
        coverages: String(r['Coverage']).split(';').map(v=>v.trim()).filter(Boolean),
        stepName: r['Step Name'],
        table: r['Table Name'] || '',
        rounding: r['ROUNDING'] || 'none',
        value: parseFloat(String(r['Value']).replace(/[^0-9.-]/g,''))||0,
        states: ALL_STATES.filter(st=> String(r[st]).trim().toUpperCase()==='X')
      };
      out.push(factor);
      // operand after
      const op = String(r['CALCULATION']).trim();
      if (OPERANDS.includes(op)){
        out.push({ stepType:'operand', operand:op });
      }
    });
    return out;
  };


  const handleExportXLSX = async () =>{
    try{
      const XLSXmod = await import('xlsx');
      const XLSX = XLSXmod.default || XLSXmod;
      const fsMod = await import('file-saver');
      const saveAs = fsMod.saveAs || fsMod.default;
      const ws = makePricingSheet(steps);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb,ws,'Pricing');
      const buf = XLSX.write(wb,{bookType:'xlsx',type:'array'});
      saveAs(new Blob([buf],{type:'application/octet-stream'}),`pricing_${productName}.xlsx`);
    }catch(err){ alert('Export failed: '+err.message); }
  };

  const handleImportXLSX = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const XLSXmod = await import('xlsx');
      const XLSX = XLSXmod.default || XLSXmod;
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf);
      const ws = wb.Sheets[wb.SheetNames[0]];
      // Parse sheet into step objects
      const parsed = sheetToStepObjects(ws);

      // Map coverage names -> codes
      parsed.forEach(s => {
        if (s.stepType === 'factor') {
          s.coverages = s.coverages.map(name => {
            const cov = coverages.find(c => c.name === name);
            return cov ? cov.coverageCode : name;
          });
        }
      });

      // Validate coverage codes
      const invalidCov = parsed
        .filter(s => s.stepType === 'factor')
        .flatMap(s => s.coverages)
        .filter(code => !validCoverageCodes.includes(code));
      if (invalidCov.length) {
        alert('Invalid coverage codes: ' + [...new Set(invalidCov)].join(', '));
        e.target.value = '';
        return;
      }

      // Validate states
      const invalidStates = parsed
        .filter(s => s.stepType === 'factor')
        .flatMap(s => s.states || [])
        .filter(st => !ALL_STATES.includes(st));
      if (invalidStates.length) {
        alert('Invalid states: ' + [...new Set(invalidStates)].join(', '));
        e.target.value = '';
        return;
      }

      // Differential import: only add factor+operand pairs not already present
      let nextOrder = steps.length;
      const created = [];
      for (let i = 0; i < parsed.length; i++) {
        const row = parsed[i];
        if (row.stepType !== 'factor') continue;
        const operandRow = parsed[i+1] && parsed[i+1].stepType === 'operand' ? parsed[i+1] : null;
        // Check if a factor step with same coverage and stepName exists
        const exists = steps.some(s =>
          s.stepType === 'factor'
          && s.coverages.join(';') === row.coverages.join(';')
          && s.stepName === row.stepName
        );
        if (exists) continue;
        // Add factor
        const factorRef = await addDoc(
          collection(db, `products/${productId}/steps`),
          { ...row, order: nextOrder }
        );
        created.push({ id: factorRef.id, ...row, order: nextOrder });
        nextOrder++;
        // Add operand if present
        if (operandRow) {
          const allCoverageNames = coverages.map(c => c.name);
          const opRef = await addDoc(
            collection(db, `products/${productId}/steps`),
            { stepType: 'operand', operand: operandRow.operand, coverages: allCoverageNames, states: allStates, order: nextOrder }
          );
          created.push({ id: opRef.id, stepType: 'operand', operand: operandRow.operand, coverages: allCoverageNames, states: allStates, order: nextOrder });
          nextOrder++;
        }
      }

      // Update local state
      setSteps(prev => [...prev, ...created].sort((a, b) => a.order - b.order));
      alert('Import complete!');
    } catch (err) {
      console.error(err);
      alert('Import failed: ' + err.message);
    } finally {
      e.target.value = '';
    }
  };

// Table row styling
const FactorRow = styled(TableRow)`
  background-color: #F0F5FF;
  td {
    padding: 8px 12px;
  }
  &:hover {
    background: #E6EEFF;
  }
`;
const OperandRow = styled(TableRow)`
  background: #fff;
  border-top: 2px solid #E5E7EB;
  border-bottom: 2px solid #E5E7EB;
  td {
    padding: 0px 2px;
  }
  &:hover {
    background: rgba(228, 188, 255, 0.49);
  }
`;

// Center the operand perfectly in its column
const OperandStepCell = styled(TableCell)`
  padding: 0;
  vertical-align: middle;
  text-align: center;
`;

// Helper to render operand icon/glyph
function operandGlyph(op) {
  switch (op) {
    case '+':
      return <PlusIcon width={16} height={16} />;
    case '-':
      return <MinusIcon width={16} height={16} />;
    case '*':
      return <XMarkIcon width={16} height={16} />;
    case '/':
      return <span style={{ fontSize: 16, fontWeight: 700 }}>/</span>;
    case '=':
      return <span style={{ fontSize: 16, fontWeight: 700 }}>=</span>;
    default:
      return op;
  }
}

  const moveStep = async (id, idx, dir) => {
    const target = dir === 'up' ? idx - 1 : idx + 1;
    if (target < 0 || target >= steps.length) return;
    // Swap in local array
    const newSteps = [...steps];
    [newSteps[idx], newSteps[target]] = [newSteps[target], newSteps[idx]];
    // Persist new orders
    const stepA = newSteps[idx];
    const stepB = newSteps[target];
    await updateDoc(doc(db, `products/${productId}/steps`, stepA.id), { order: idx });
    await updateDoc(doc(db, `products/${productId}/steps`, stepB.id), { order: target });
    // Update UI
    setSteps(newSteps);
  };

  // Handle inline value editing
  const handleValueUpdate = async (stepId, newValue) => {
    try {
      const numericValue = parseFloat(newValue) || 0;
      await updateDoc(doc(db, `products/${productId}/steps`, stepId), { value: numericValue });

      const updatedSteps = steps.map(s =>
        s.id === stepId ? { ...s, value: numericValue } : s
      );
      setSteps(updatedSteps);
    } catch (error) {
      console.error("Error updating step value:", error);
      alert("Failed to update step value. Please try again.");
    }
  };

  const renderCalculationPreview = () => {
    if (loading) {
      return (
        <PricingTable>
          <TableHead>
            <TableRow>
              <TableHeader>Coverage</TableHeader>
              <TableHeader>Step Name</TableHeader>
              <TableHeader>States</TableHeader>
              <TableHeader>Value</TableHeader>
              <TableHeader style={{ width: 110 }}>Actions</TableHeader>
            </TableRow>
          </TableHead>
          <tbody>
            {Array(3).fill().map((_, i) => (
              <TableRow key={i}>
                <TableCell><Skeleton /></TableCell>
                <TableCell><Skeleton /></TableCell>
                <TableCell><Skeleton /></TableCell>
                <TableCell><Skeleton /></TableCell>
                <TableCell><Skeleton /></TableCell>
              </TableRow>
            ))}
          </tbody>
        </PricingTable>
      );
    }
    return (
      <PricingTable>
        <TableHead>
          <TableRow>
            <TableHeader style={{ textAlign: 'center' }}>Coverage</TableHeader>
            <TableHeader style={{ textAlign: 'center' }}>Step Name</TableHeader>
            <TableHeader style={{ textAlign: 'center' }}>States</TableHeader>
            <TableHeader style={{ textAlign: 'center' }}>Value</TableHeader>
            <TableHeader style={{ width: 110, textAlign: 'center' }}>Actions</TableHeader>
          </TableRow>
        </TableHead>
        <tbody>
          {filteredSteps.map((step, index) => (
            step.stepType === 'factor' ? (
              <FactorRow key={step.id}>
                <TableCell style={{ textAlign: 'center' }}>
                  <CellButton variant="ghost" onClick={() => openCovModal(step)}>
                    {step.coverages.length > 1
                      ? `Coverages (${step.coverages.length})`
                      : step.coverages[0] || 'All'
                    }
                  </CellButton>
                </TableCell>
                <TableCell style={{ textAlign: 'center' }}>
                  {step.table ? (
                    <CellButton
                      variant="ghost"
                      onClick={() => navigate(`/table/${productId}/${step.id}`)}
                    >
                      {step.stepName}
                    </CellButton>
                  ) : (
                    <span>{step.stepName}</span>
                  )}
                </TableCell>
                <TableCell style={{ textAlign: 'center' }}>
                  <CellButton
                    variant="ghost"
                    title="Select states for this step"
                    onClick={() => openStatesModal(step)}
                  >
                    {getStatesDisplay(step.states || [])}&nbsp;(
                    {(step.states && step.states.length) ? step.states.length : allStates.length}
                    )
                  </CellButton>
                </TableCell>
                <TableCell style={{ textAlign: 'center' }}>
                  <EditableValueCell>
                    <input
                      type="number"
                      defaultValue={step.value || 0}
                      onBlur={(e) => handleValueUpdate(step.id, e.target.value)}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          e.target.blur();
                        }
                      }}
                    />
                  </EditableValueCell>
                </TableCell>
                <TableCell style={{ textAlign: 'center' }}>
                  <ActionsContainer>
                    <Button variant="ghost" onClick={() => openEditModal(step)}>
                      <PencilIcon width={16} height={16}/>
                    </Button>
                    <Button variant="ghost" onClick={() => handleDeleteStep(step.id)} style={{ color: '#dc2626' }}>
                      <TrashIcon width={16} height={16}/>
                    </Button>
                    <Button variant="ghost" onClick={() => moveStep(step.id, index, 'up')}>
                      <ChevronUpIcon width={16} height={16}/>
                    </Button>
                    <Button variant="ghost" onClick={() => moveStep(step.id, index, 'down')}>
                      <ChevronDownIcon width={16} height={16}/>
                    </Button>
                  </ActionsContainer>
                </TableCell>
              </FactorRow>
            ) : (
              <OperandRow key={step.id}>
                {/* Coverage cell for operands */}
                <TableCell style={{ textAlign: 'center' }}>
                  <CellButton variant="ghost" onClick={() => openCovModal(step)}>
                    {step.coverages && step.coverages.length > 1
                      ? `Coverages (${step.coverages.length})`
                      : (step.coverages && step.coverages[0]) || 'All'
                    }
                  </CellButton>
                </TableCell>

                {/* Centred operand glyph inside the Stepâ€‘Name column */}
                <OperandStepCell>
                  {operandGlyph(step.operand)}
                </OperandStepCell>
                {/* States cell for operands */}
                <TableCell style={{ textAlign: 'center' }}>
                  <CellButton
                    variant="ghost"
                    title="Select states for this operand"
                    onClick={() => openStatesModal(step)}
                  >
                    {getStatesDisplay(step.states || [])}&nbsp;(
                    {(step.states && step.states.length) ? step.states.length : allStates.length}
                    )
                  </CellButton>
                </TableCell>
                {/* Empty Value column to preserve alignment */}
                <TableCell style={{ textAlign: 'center' }} />
                {/* Actions cell centered */}
                <TableCell style={{ textAlign: 'center' }}>
                  <ActionsContainer>
                    <Button variant="ghost" onClick={() => openEditModal(step)}>
                      <PencilIcon width={16} height={16} />
                    </Button>
                    <Button
                      variant="ghost"
                      onClick={() => handleDeleteStep(step.id)}
                      style={{ color: '#dc2626' }}
                    >
                      <TrashIcon width={16} height={16} />
                    </Button>
                    {/* Invisible spacer buttons to align with factor row actions */}
                    <Button variant="ghost" style={{ visibility: 'hidden' }}>
                      <ChevronUpIcon width={16} height={16}/>
                    </Button>
                    <Button variant="ghost" style={{ visibility: 'hidden' }}>
                      <ChevronDownIcon width={16} height={16}/>
                    </Button>
                  </ActionsContainer>
                </TableCell>
              </OperandRow>
            )
          ))}
        </tbody>
      </PricingTable>
    );
  };

  return (
    <PageContainer>
      <MainNavigation />
      <PageContent>
        <EnhancedHeader
          title={`${productName} - Pricing`}
          subtitle={`Manage pricing steps and calculations`}
          icon={CurrencyDollarIcon}
          showBackButton
          onBackClick={() => navigate(-1)}
        />

        {/* Rating Algorithm Builder */}
        <RatingAlgorithmBuilder
          steps={filteredSteps}
          coverages={coverages}
          onStepsChange={setSteps}
          onAddStep={openAddModal}
          onEditStep={(step) => openEditModal(step)}
          onDeleteStep={async (stepId) => {
            if (window.confirm("Are you sure you want to delete this step?")) {
              await handleDeleteStep(stepId);
            }
          }}
          onUpdateStepValue={handleValueUpdate}
          onReorderSteps={async (stepId, direction) => {
            const idx = steps.findIndex(s => s.id === stepId);
            if (idx !== -1) {
              await moveStep(stepId, idx, direction);
            }
          }}
          onAddOperand={addOperand}
          onOpenCoverageModal={openCovModal}
          onOpenStatesModal={openStatesModal}
          onOpenTable={(step) => navigate(`/table/${productId}/${step.id}`)}
          selectedCoverage={selectedCoverage}
          selectedStates={selectedStates}
          isLoading={loading}
        />
        {modalOpen && (
          <StepModal
            onClose={() => setModalOpen(false)}
            onSubmit={handleModalSubmit}
            editingStep={editingStep}
            steps={steps}
            coverages={coverages}
            dataCodes={dataCodes}
          />
        )}
        {covModalOpen && (
          <OverlayFixed onClick={() => setCovModalOpen(false)}>
            <WideModal onClick={e => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>Select Coverages for {currentEditingStep?.stepName}</ModalTitle>
                <CloseBtn onClick={() => setCovModalOpen(false)}>
                  <XMarkIcon width={20} height={20}/>
                </CloseBtn>
              </ModalHeader>

              <CoverageSearchInput
                placeholder="Search coverages by name or code..."
                value={coverageSearchQuery || ''}
                onChange={e => setCoverageSearchQuery(e.target.value)}
              />

              <CoverageLinkActions>
                <Button variant="ghost" onClick={() => setSelectedCoveragesForStep(filteredCoverages.map(c => c.name))}>
                  Select All ({filteredCoverages.length})
                </Button>
                <Button variant="ghost" onClick={() => setSelectedCoveragesForStep([])}>
                  Clear All
                </Button>
                <span style={{ fontSize: '14px', color: '#6b7280', marginLeft: 'auto' }}>
                  {selectedCoveragesForStep.length} selected
                </span>
              </CoverageLinkActions>

              <CoverageLinkContainer>
                {filteredCoverages.map(coverage => (
                  <CoverageLinkItem key={coverage.id}>
                    <CoverageCheckbox
                      type="checkbox"
                      value={coverage.name}
                      checked={selectedCoveragesForStep.includes(coverage.name)}
                      onChange={e => {
                        const coverageName = e.target.value;
                        setSelectedCoveragesForStep(selected =>
                          selected.includes(coverageName)
                            ? selected.filter(name => name !== coverageName)
                            : [...selected, coverageName]
                        );
                      }}
                    />
                    <CoverageLabel>{coverage.name}</CoverageLabel>
                  </CoverageLinkItem>
                ))}
                {filteredCoverages.length === 0 && (
                  <div style={{
                    textAlign: 'center',
                    padding: '32px',
                    color: '#6b7280',
                    fontStyle: 'italic'
                  }}>
                    No coverages found matching your search
                  </div>
                )}
              </CoverageLinkContainer>

              <Actions>
                <Button onClick={saveSelectedCoverages}>Save Changes</Button>
                <Button variant="ghost" onClick={() => setCovModalOpen(false)}>Cancel</Button>
              </Actions>
            </WideModal>
          </OverlayFixed>
        )}

        {/* States Selection Modal */}
        {statesModalOpen && (
          <OverlayFixed onClick={() => setStatesModalOpen(false)}>
            <WideModal onClick={e => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>Select States for {currentEditingStepForStates?.stepName}</ModalTitle>
                <CloseBtn onClick={() => setStatesModalOpen(false)}>
                  <XMarkIcon width={20} height={20}/>
                </CloseBtn>
              </ModalHeader>

              <CoverageSearchInput
                placeholder="Search states by abbreviation..."
                value={stateSearchQuery || ''}
                onChange={e => setStateSearchQuery(e.target.value)}
              />

              <CoverageLinkActions>
                <Button variant="ghost" onClick={() => setSelectedStatesForStep(filteredStates)}>
                  Select All ({filteredStates.length})
                </Button>
                <Button variant="ghost" onClick={() => setSelectedStatesForStep([])}>
                  Clear All
                </Button>
                <span style={{ fontSize: '14px', color: '#6b7280', marginLeft: 'auto' }}>
                  {selectedStatesForStep.length} selected
                </span>
              </CoverageLinkActions>

              <CoverageLinkContainer>
                {filteredStates.map(state => (
                  <CoverageLinkItem key={state}>
                    <CoverageCheckbox
                      type="checkbox"
                      value={state}
                      checked={selectedStatesForStep.includes(state)}
                      onChange={e => {
                        const stateName = e.target.value;
                        setSelectedStatesForStep(selected =>
                          selected.includes(stateName)
                            ? selected.filter(name => name !== stateName)
                            : [...selected, stateName]
                        );
                      }}
                    />
                    <CoverageLabel>{state}</CoverageLabel>
                  </CoverageLinkItem>
                ))}
                {filteredStates.length === 0 && (
                  <div style={{
                    textAlign: 'center',
                    padding: '32px',
                    color: '#6b7280',
                    fontStyle: 'italic'
                  }}>
                    No states found matching your search
                  </div>
                )}
              </CoverageLinkContainer>

              <Actions>
                <Button onClick={saveSelectedStates}>Save Changes</Button>
                <Button variant="ghost" onClick={() => setStatesModalOpen(false)}>Cancel</Button>
              </Actions>
            </WideModal>
          </OverlayFixed>
        )}

        {/* Step Details Modal */}
        {stepDetailsOpen && (
          <OverlayFixed onClick={() => setStepDetailsOpen(false)}>
            <ModalBox onClick={e => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>Step Details</ModalTitle>
                <CloseBtn onClick={() => setStepDetailsOpen(false)}>âœ•</CloseBtn>
              </ModalHeader>
              {detailsStep && (
                <>
                  <p><strong>Step&nbsp;Name:</strong> {detailsStep.stepName || '-'}</p>
                  <p><strong>Rounding:</strong> {detailsStep.rounding || '-'}</p>
                  <p><strong>States:</strong> {getStatesDisplay(detailsStep.states || [])}</p>
                  <p><strong>Upstream&nbsp;ID:</strong> {detailsStep.upstreamId || '-'}</p>
                </>
              )}
            </ModalBox>
          </OverlayFixed>
        )}

      </PageContent>
    </PageContainer>
  );
}

export default PricingScreen;
```

---

## src/components/ProductBuilder.tsx

**Path:** `src/components/ProductBuilder.tsx`

```tsx
import { useState, useEffect } from 'react';
import { collection, collectionGroup, getDocs, getDoc, addDoc, updateDoc, doc, query, where } from 'firebase/firestore';
import { db, storage, functions } from '@/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { httpsCallable } from 'firebase/functions';
import styled from 'styled-components';
import {
  XMarkIcon,
  PlusIcon,
  WrenchScrewdriverIcon,
  PaperAirplaneIcon,
  SparklesIcon,
  LightBulbIcon,
  CpuChipIcon,
  MagnifyingGlassIcon,
  DocumentDuplicateIcon
} from '@heroicons/react/24/solid';
import { useNavigate } from 'react-router-dom';
import MainNavigation from '@components/ui/Navigation';
import EnhancedHeader from '@components/ui/EnhancedHeader';
import MarkdownRenderer from '@utils/markdownParser';
import { cloneProduct } from '@utils/productClone';

/* ---------- Modern Styled Components ---------- */

// Global animations
const GlobalStyle = `
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
`;

// Page - Clean gradient background with overlay
const Page = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
  display: flex;
  flex-direction: column;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 300px;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #06b6d4 100%);
    opacity: 0.08;
    z-index: 0;
  }
`;

// Main Content - Modern layout
const MainContent = styled.main`
  flex: 1;
  padding: 32px 32px 80px;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
  position: relative;
  z-index: 1;

  @media (max-width: 768px) {
    padding: 24px 20px 60px;
  }
`;

// AI Chat Container - Revolutionary product builder interface
const AIBuilderContainer = styled.div`
  width: 100%;
  max-width: 1000px;
  margin: 0 auto 40px;
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: blur(24px);
  border: 1px solid rgba(226, 232, 240, 0.4);
  border-radius: 20px;
  box-shadow: 0 12px 48px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 16px 64px rgba(99, 102, 241, 0.12);
    border-color: rgba(99, 102, 241, 0.3);
  }

  @media (max-width: 768px) {
    max-width: 100%;
    margin-bottom: 32px;
  }
`;

const ChatHeader = styled.div`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  padding: 20px 24px;
  display: flex;
  align-items: center;
  gap: 12px;
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    animation: shimmer 3s infinite;
  }

  @keyframes shimmer {
    0% { left: -100%; }
    100% { left: 100%; }
  }
`;

const ChatTitle = styled.h3`
  margin: 0;
  font-size: 18px;
  font-weight: 700;
  letter-spacing: -0.01em;
  display: flex;
  align-items: center;
  gap: 8px;
`;

const ChatMessages = styled.div`
  height: 400px;
  overflow-y: auto;
  padding: 24px;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);

  /* Custom scrollbar */
  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: rgba(226, 232, 240, 0.3);
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.3);
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background: rgba(99, 102, 241, 0.5);
  }
`;

const ChatMessage = styled.div`
  margin-bottom: 16px;
  display: flex;
  justify-content: ${props => props.isUser ? 'flex-end' : 'flex-start'};
  animation: fadeInUp 0.3s ease;

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
`;

const MessageBubble = styled.div`
  max-width: 80%;
  padding: 16px 20px;
  border-radius: ${props => props.isUser ? '20px 20px 4px 20px' : '20px 20px 20px 4px'};
  background: ${props => props.isUser
    ? 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)'
    : '#ffffff'};
  color: ${props => props.isUser ? '#ffffff' : '#374151'};
  border: ${props => props.isUser ? 'none' : '1px solid rgba(226, 232, 240, 0.6)'};
  font-size: 14px;
  line-height: 1.6;
  box-shadow: ${props => props.isUser
    ? '0 4px 16px rgba(99, 102, 241, 0.25)'
    : '0 2px 8px rgba(0, 0, 0, 0.08)'};
  position: relative;

  ${props => !props.isUser && `
    &::before {
      content: '';
      position: absolute;
      top: 8px;
      left: -6px;
      width: 12px;
      height: 12px;
      background: #ffffff;
      border: 1px solid rgba(226, 232, 240, 0.6);
      border-right: none;
      border-bottom: none;
      transform: rotate(-45deg);
    }
  `}
`;

const ChatInputContainer = styled.div`
  padding: 20px 24px;
  background: #ffffff;
  border-top: 1px solid rgba(226, 232, 240, 0.6);
  display: flex;
  gap: 12px;
  align-items: flex-end;
`;

const ChatInput = styled.textarea`
  flex: 1;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 12px;
  padding: 12px 16px;
  font-size: 14px;
  font-family: inherit;
  resize: none;
  min-height: 44px;
  max-height: 120px;
  background: rgba(248, 250, 252, 0.8);
  transition: all 0.3s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    background: #ffffff;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;

const SendButton = styled.button`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 12px;
  padding: 12px 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.3s ease;
  min-height: 44px;

  &:hover:not(:disabled) {
    background: linear-gradient(135deg, #5b5bf6 0%, #7c3aed 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const WelcomeMessage = styled.div`
  text-align: center;
  padding: 40px 20px;
  color: #6b7280;
  background: #ffffff;
  border-radius: 16px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  margin-bottom: 16px;
`;

const SuggestionChips = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 16px;
  justify-content: center;
`;

const SuggestionChip = styled.button`
  background: rgba(99, 102, 241, 0.1);
  color: #6366f1;
  border: 1px solid rgba(99, 102, 241, 0.2);
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.15);
    border-color: rgba(99, 102, 241, 0.3);
    transform: translateY(-1px);
  }
`;

// Modern Product Builder Layout - Three column responsive grid
const ProductBuilderGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 400px 350px;
  gap: 24px;
  margin-bottom: 40px;
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;

  @media (max-width: 1400px) {
    grid-template-columns: 1fr 350px;
    & > *:last-child {
      grid-column: 1 / -1;
    }
  }

  @media (max-width: 1024px) {
    grid-template-columns: 1fr;
    gap: 20px;
  }
`;

// Coverage Browser Container
const CoverageBrowserContainer = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

// Coverage Browser Header
const CoverageBrowserHeader = styled.div`
  padding: 24px 24px 16px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
`;

// Search and Filter Controls
const SearchFilterContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 16px;
`;

const SearchInput = styled.input`
  width: 100%;
  padding: 12px 16px 12px 40px;
  font-size: 14px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(20px);
  transition: all 0.3s ease;
  position: relative;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;

const SearchIconWrapper = styled.div`
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: #94a3b8;
  pointer-events: none;
`;

const FilterRow = styled.div`
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
`;

const FilterSelect = styled.select`
  padding: 8px 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 8px;
  background: white;
  font-size: 13px;
  color: #374151;
  cursor: pointer;
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
  }
`;

// Coverage Cards Grid
const CoverageCardsGrid = styled.div`
  padding: 16px;
  max-height: 600px;
  overflow-y: auto;
  display: grid;
  gap: 12px;

  /* Custom scrollbar */
  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: rgba(226, 232, 240, 0.3);
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.3);
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background: rgba(99, 102, 241, 0.5);
  }
`;

// Individual Coverage Card
const CoverageCard = styled.div`
  padding: 16px;
  border: 1px solid ${props => props.selected ? '#6366f1' : 'rgba(226, 232, 240, 0.6)'};
  border-radius: 12px;
  background: ${props => props.selected ? 'rgba(99, 102, 241, 0.05)' : 'white'};
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;

  &:hover {
    border-color: #6366f1;
    background: rgba(99, 102, 241, 0.02);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  ${props => props.selected && `
    box-shadow: 0 4px 16px rgba(99, 102, 241, 0.2);
  `}
`;

const CoverageCardHeader = styled.div`
  display: flex;
  justify-content: between;
  align-items: flex-start;
  margin-bottom: 8px;
`;

const CoverageCardTitle = styled.h4`
  margin: 0;
  font-size: 14px;
  font-weight: 600;
  color: #374151;
  line-height: 1.3;
  flex: 1;
`;

const CoverageCardBadge = styled.span`
  padding: 2px 8px;
  background: rgba(99, 102, 241, 0.1);
  color: #6366f1;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 500;
  margin-left: 8px;
`;

const CoverageCardMeta = styled.div`
  font-size: 12px;
  color: #6b7280;
  margin-bottom: 8px;
`;

const CoverageCardActions = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 12px;
`;

const FormCount = styled.span`
  font-size: 11px;
  color: #6b7280;
  background: rgba(107, 114, 128, 0.1);
  padding: 2px 6px;
  border-radius: 8px;
`;

const SelectButton = styled.button`
  padding: 4px 12px;
  background: ${props => props.selected ? '#6366f1' : 'transparent'};
  color: ${props => props.selected ? 'white' : '#6366f1'};
  border: 1px solid #6366f1;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: ${props => props.selected ? '#4f46e5' : 'rgba(99, 102, 241, 0.1)'};
  }
`;

// Product Builder Panel
const ProductBuilderPanel = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

const ProductBuilderHeader = styled.div`
  padding: 24px 24px 16px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
`;

const ProductBuilderContent = styled.div`
  padding: 24px;
`;

// Selected Coverages Display
const SelectedCoveragesContainer = styled.div`
  margin-bottom: 24px;
`;

const SelectedCoveragesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 300px;
  overflow-y: auto;
  padding: 12px;
  background: rgba(248, 250, 252, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);

  &::-webkit-scrollbar {
    width: 4px;
  }

  &::-webkit-scrollbar-track {
    background: rgba(226, 232, 240, 0.3);
    border-radius: 2px;
  }

  &::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.3);
    border-radius: 2px;
  }
`;

const SelectedCoverageItem = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: white;
  border-radius: 8px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  transition: all 0.2s ease;

  &:hover {
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

const SelectedCoverageInfo = styled.div`
  flex: 1;
`;

const SelectedCoverageName = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 2px;
`;

const SelectedCoverageProduct = styled.div`
  font-size: 11px;
  color: #6b7280;
`;

const RemoveCoverageButton = styled.button`
  padding: 4px;
  background: none;
  border: none;
  color: #ef4444;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(239, 68, 68, 0.1);
  }
`;

// Product Details Form
const ProductDetailsForm = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 6px;
`;

const FormLabel = styled.label`
  font-size: 13px;
  font-weight: 600;
  color: #374151;
`;

const CompactFormInput = styled.input`
  padding: 10px 12px;
  font-size: 14px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.9);
  transition: all 0.3s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;

const FileUploadArea = styled.div`
  border: 2px dashed rgba(226, 232, 240, 0.8);
  border-radius: 12px;
  padding: 20px;
  text-align: center;
  background: rgba(248, 250, 252, 0.5);
  transition: all 0.3s ease;
  cursor: pointer;

  &:hover {
    border-color: rgba(99, 102, 241, 0.5);
    background: rgba(99, 102, 241, 0.02);
  }

  &.dragover {
    border-color: #6366f1;
    background: rgba(99, 102, 241, 0.05);
  }
`;

const FileUploadText = styled.div`
  font-size: 13px;
  color: #6b7280;
  margin-bottom: 8px;
`;

const FileUploadInput = styled.input`
  display: none;
`;

// Preview Panel
const PreviewPanel = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

const PreviewHeader = styled.div`
  padding: 20px 24px 16px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
`;

const PreviewContent = styled.div`
  padding: 20px;
  max-height: 500px;
  overflow-y: auto;

  &::-webkit-scrollbar {
    width: 4px;
  }

  &::-webkit-scrollbar-track {
    background: rgba(226, 232, 240, 0.3);
    border-radius: 2px;
  }

  &::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.3);
    border-radius: 2px;
  }
`;

const PreviewSection = styled.div`
  margin-bottom: 20px;
  padding: 16px;
  background: rgba(248, 250, 252, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);

  &:last-child {
    margin-bottom: 0;
  }
`;

const PreviewSectionTitle = styled.h4`
  margin: 0 0 12px 0;
  font-size: 14px;
  font-weight: 600;
  color: #374151;
`;

const PreviewItem = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 0;
  font-size: 13px;
  color: #6b7280;
  border-bottom: 1px solid rgba(226, 232, 240, 0.4);

  &:last-child {
    border-bottom: none;
  }
`;

const PreviewLabel = styled.span`
  font-weight: 500;
  color: #374151;
`;

const PreviewValue = styled.span`
  color: #6b7280;
`;

// Action Buttons
const ActionButtonsContainer = styled.div`
  display: flex;
  gap: 12px;
  margin-top: 24px;
`;

const PrimaryActionButton = styled.button`
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 20px;
  font-size: 14px;
  font-weight: 600;
  border: none;
  border-radius: 12px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);

  &:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(99, 102, 241, 0.4);
  }

  &:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }
`;

const SecondaryActionButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 20px;
  font-size: 14px;
  font-weight: 600;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 12px;
  background: white;
  color: #374151;
  cursor: pointer;
  transition: all 0.3s ease;

  &:hover {
    border-color: rgba(99, 102, 241, 0.3);
    background: rgba(99, 102, 241, 0.02);
  }
`;

// Section Title - Modern section headers
const SectionTitle = styled.h2`
  font-size: 1.5rem;
  font-weight: 600;
  background: linear-gradient(135deg, #1e293b 0%, #475569 50%, #64748b 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin: 0 0 24px 0;
  letter-spacing: -0.01em;
`;





// Modern Button
const ModernButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: 600;
  border: none;
  border-radius: 12px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);

  &:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(99, 102, 241, 0.4);
  }

  &:active:not(:disabled) {
    transform: translateY(-1px);
  }

  &:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }
`;



// Loading Container
const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  text-align: center;
`;

// Loading Spinner
const LoadingSpinner = styled.div`
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #6366f1;
  border-radius: 50%;
  animation: spin 1s linear infinite;

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
`;

// Modal Overlay
const ModalOverlay = styled.div`
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(8px);
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
`;

// Modal Container
const ModalContainer = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 24px;
  padding: 32px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
  max-width: 600px;
  width: 100%;
  max-height: 80vh;
  overflow-y: auto;
`;

// Modal Header
const ModalHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
`;

// Modal Title
const ModalTitle = styled.h3`
  font-size: 1.25rem;
  font-weight: 600;
  color: #1e293b;
  margin: 0;
`;

// Close Button
const CloseButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 8px;
  background: rgba(239, 68, 68, 0.1);
  color: #ef4444;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(239, 68, 68, 0.2);
    transform: scale(1.05);
  }
`;

// AI System Prompt for Product Builder
const AI_SYSTEM_PROMPT = `You are an expert AI Product Builder for insurance products. You help insurance product managers create new products by analyzing existing products, coverages, and forms in their database.

Your capabilities:
1. **Product Analysis**: Understand existing products, their coverages, forms, and relationships
2. **Intelligent Recommendations**: Suggest optimal coverage combinations based on product type and market needs
3. **Form Association**: Recommend relevant forms for selected coverages
4. **Product Structure**: Help build complete product structures with proper metadata
5. **Market Intelligence**: Provide insights on product positioning and competitive advantages

When users describe what they want to build, you should:
- Ask clarifying questions to understand their needs
- Analyze existing products for patterns and best practices
- Suggest coverage combinations that make business sense
- Recommend appropriate forms and documentation
- Help with product naming, coding, and categorization
- Provide step-by-step guidance through the product creation process

Always be conversational, helpful, and focus on creating products that will be successful in the insurance market.

Available data context will include:
- Existing products with their metadata
- All available coverages across products
- Forms and their associations
- Product relationships and hierarchies

Respond in a helpful, professional tone and use markdown formatting for better readability.`;

const ProductBuilder = () => {
  const [coverages, setCoverages] = useState([]);
  const [forms, setForms] = useState([]);
  const [products, setProducts] = useState({});
  const [selectedCoverages, setSelectedCoverages] = useState({});
  const [newProductName, setNewProductName] = useState('');
  const [formNumber, setFormNumber] = useState('');
  const [productCode, setProductCode] = useState('');
  const [effectiveDate, setEffectiveDate] = useState('');
  const [file, setFile] = useState(null);
  const [modalOpen, setModalOpen] = useState(false);
  const [modalItem] = useState(null);
  const [loading, setLoading] = useState(true);
  const [cloneLoading, setCloneLoading] = useState(false);
  const [cloneModalOpen, setCloneModalOpen] = useState(false);

  // New state for enhanced interface
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedProductFilter, setSelectedProductFilter] = useState('');
  const [selectedCategoryFilter, setSelectedCategoryFilter] = useState('');
  const [pricingSteps, setPricingSteps] = useState([]);
  const [rules, setRules] = useState([]);

  const [cloneTargetId, setCloneTargetId] = useState('');

  // AI Chat State
  const [chatMessages, setChatMessages] = useState([]);
  const [chatInput, setChatInput] = useState('');
  const [chatLoading, setChatLoading] = useState(false);
  const [aiSuggestions, setAiSuggestions] = useState([]);

  const navigate = useNavigate();

  // Fetch all coverages, forms, and products on mount
  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        // Fetch products
        const productsSnap = await getDocs(collection(db, 'products'));
        const productMap = {};
        productsSnap.docs.forEach(doc => {
          productMap[doc.id] = doc.data().name;
        });
        setProducts(productMap);

        // Fetch coverages across all products
        const coveragesSnap = await getDocs(collectionGroup(db, 'coverages'));
        const coverageList = coveragesSnap.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          productId: doc.ref.parent.parent.id,
        }));
        setCoverages(coverageList);

        // Fetch all forms
        const formsSnap = await getDocs(collection(db, 'forms'));
        const formList = formsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setForms(formList);

        // Fetch pricing steps across all products
        const stepsSnap = await getDocs(collectionGroup(db, 'steps'));
        const stepsList = stepsSnap.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          productId: doc.ref.parent.parent.id,
        }));
        setPricingSteps(stepsList);

        // Fetch rules
        const rulesSnap = await getDocs(collection(db, 'rules'));
        const rulesList = rulesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setRules(rulesList);
      } catch (error) {
        console.error('Error fetching data:', error);
        alert('Failed to load data. Please try again.');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  // Initialize AI suggestions based on existing data
  useEffect(() => {
    if (!loading && Object.keys(products).length > 0) {
      const suggestions = [
        "Create a homeowners product similar to HO3 but for condos",
        "Build a commercial property product for small businesses",
        "Design an umbrella policy with high liability limits",
        "Create a renters insurance product for millennials",
        "Build a cyber liability product for tech companies"
      ];
      setAiSuggestions(suggestions);
    }
  }, [loading, products]);

  // Prepare context data for AI
  const prepareAIContext = () => {
    const productSummary = Object.entries(products).map(([id, name]) => ({
      id,
      name,
      coverageCount: coverages.filter(c => c.productId === id).length
    }));

    const coverageSummary = coverages.map(c => ({
      name: c.coverageName,
      type: c.coverageType,
      scope: c.scopeOfCoverage,
      limits: c.limits,
      productId: c.productId
    }));

    const formSummary = forms.map(f => ({
      name: f.formName,
      number: f.formNumber,
      type: f.formType
    }));

    return {
      products: productSummary,
      coverages: coverageSummary,
      forms: formSummary,
      totalProducts: Object.keys(products).length,
      totalCoverages: coverages.length,
      totalForms: forms.length
    };
  };

  // Handle AI chat message
  const handleChatMessage = async () => {
    if (!chatInput.trim() || chatLoading) return;

    const userMessage = chatInput.trim();
    setChatInput('');
    setChatLoading(true);

    // Add user message to chat
    const newUserMessage = { role: 'user', content: userMessage };
    setChatMessages(prev => [...prev, newUserMessage]);

    try {
      const context = prepareAIContext();

      // Call Cloud Function (secure proxy to OpenAI)
      const generateChat = httpsCallable(functions, 'generateChatResponse');
      const result = await generateChat({
        messages: [
          { role: 'system', content: AI_SYSTEM_PROMPT },
          { role: 'system', content: `Current database context: ${JSON.stringify(context, null, 2)}` },
          ...chatMessages,
          newUserMessage
        ],
        model: 'gpt-4o-mini',
        maxTokens: 2000,
        temperature: 0.7
      });

      if (!result.data.success) {
        throw new Error('Failed to generate chat response');
      }

      const aiResponse = result.data.content?.trim();

      if (aiResponse) {
        const aiMessage = { role: 'assistant', content: aiResponse };
        setChatMessages(prev => [...prev, aiMessage]);

        // Parse AI response for product suggestions
        parseAIResponseForActions(aiResponse);
      } else {
        throw new Error('No response from AI');
      }

    } catch (error) {
      console.error('Error in AI chat:', error);
      const errorMessage = {
        role: 'assistant',
        content: 'I apologize, but I encountered an error. Please try again or contact support if the issue persists.'
      };
      setChatMessages(prev => [...prev, errorMessage]);
    } finally {
      setChatLoading(false);
    }
  };

  // Parse AI response for actionable suggestions
  const parseAIResponseForActions = (aiResponse) => {
    // Look for product suggestions in AI response
    const productNameMatch = aiResponse.match(/product name[:\s]*["']([^"']+)["']/i);
    const productCodeMatch = aiResponse.match(/product code[:\s]*["']([^"']+)["']/i);
    const formNumberMatch = aiResponse.match(/form number[:\s]*["']([^"']+)["']/i);

    if (productNameMatch) {
      setNewProductName(productNameMatch[1]);
    }
    if (productCodeMatch) {
      setProductCode(productCodeMatch[1]);
    }
    if (formNumberMatch) {
      setFormNumber(formNumberMatch[1]);
    }
  };

  // Handle suggestion chip click
  const handleSuggestionClick = (suggestion) => {
    setChatInput(suggestion);
  };

  // Handle Enter key in chat input
  const handleChatKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleChatMessage();
    }
  };




  // Handle modal submission for multiple associations
  const handleModalSubmit = (coverageId, formIds) => {
    setSelectedCoverages(prev => ({ ...prev, [coverageId]: formIds }));
    setModalOpen(false);
  };



  // Enhanced filtering for coverages
  const filteredCoverages = coverages.filter(coverage => {
    const matchesSearch = !searchTerm ||
      coverage.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      coverage.coverageCode?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      coverage.scopeOfCoverage?.toLowerCase().includes(searchTerm.toLowerCase());

    const matchesProduct = !selectedProductFilter || coverage.productId === selectedProductFilter;
    const matchesCategory = !selectedCategoryFilter || coverage.category === selectedCategoryFilter;

    return matchesSearch && matchesProduct && matchesCategory;
  });

  // Get unique product names for filter
  const uniqueProducts = [...new Set(coverages.map(c => c.productId))]
    .map(id => ({ id, name: products[id] }))
    .filter(p => p.name)
    .sort((a, b) => a.name.localeCompare(b.name));

  // Get unique categories for filter
  const uniqueCategories = [...new Set(coverages.map(c => c.category))]
    .filter(Boolean)
    .sort();

  // Helper to get associated forms for a coverage
  const getAssociatedForms = (coverageId) => {
    return forms.filter(f => f.coverageIds?.includes(coverageId));
  };

  // Helper to get pricing steps for selected coverages
  const getRelevantPricingSteps = () => {
    const selectedCoverageIds = Object.keys(selectedCoverages);
    return pricingSteps.filter(step =>
      step.coverages?.some(cov => selectedCoverageIds.includes(cov))
    );
  };

  // Helper to get relevant rules for selected coverages
  const getRelevantRules = () => {
    const selectedProductIds = [...new Set(
      Object.keys(selectedCoverages).map(covId =>
        coverages.find(c => c.id === covId)?.productId
      ).filter(Boolean)
    )];
    return rules.filter(rule => selectedProductIds.includes(rule.productId));
  };

  // Handle coverage selection with smart form association
  const handleSmartCoverageSelect = (coverage) => {
    const associatedForms = getAssociatedForms(coverage.id);

    if (selectedCoverages[coverage.id]) {
      // Deselect coverage
      const newSelected = { ...selectedCoverages };
      delete newSelected[coverage.id];
      setSelectedCoverages(newSelected);
    } else {
      // Auto-select coverage with its forms
      setSelectedCoverages(prev => ({
        ...prev,
        [coverage.id]: associatedForms.map(f => f.id)
      }));
    }
  };

  // Handle removing a selected coverage
  const handleRemoveCoverage = (coverageId) => {
    const newSelected = { ...selectedCoverages };
    delete newSelected[coverageId];
    setSelectedCoverages(newSelected);
  };

  // Enhanced product creation with pricing and rules inheritance
  const handleEnhancedCreateProduct = async () => {
    if (!newProductName || !formNumber || !effectiveDate || !file || Object.keys(selectedCoverages).length === 0) {
      alert('Please fill in all required fields and select at least one coverage.');
      return;
    }

    try {
      // Upload file to Firebase Storage
      const storageRef = ref(storage, `products/${file.name}`);
      await uploadBytes(storageRef, file);
      const downloadUrl = await getDownloadURL(storageRef);

      // Create new product
      const productRef = await addDoc(collection(db, 'products'), {
        name: newProductName,
        formNumber,
        productCode,
        formDownloadUrl: downloadUrl,
        effectiveDate,
      });
      const newProductId = productRef.id;

      // Clone selected coverages with their metadata
      const newCoverageIds = {};
      const newFormIds = {};

      for (const coverageId in selectedCoverages) {
        const coverage = coverages.find(c => c.id === coverageId);
        const newCoverageRef = await addDoc(collection(db, `products/${newProductId}/coverages`), {
          name: coverage.name,
          coverageCode: coverage.coverageCode || '',
          coverageName: coverage.coverageName || coverage.name,
          scopeOfCoverage: coverage.scopeOfCoverage || '',
          limits: coverage.limits || [],
          deductibles: coverage.deductibles || [],
          states: coverage.states || [],
          category: coverage.category || 'Base Coverage',
          parentCoverageId: coverage.parentCoverageId || null,
          formIds: [],
        });
        newCoverageIds[coverageId] = newCoverageRef.id;
      }

      // Clone associated forms
      const allFormIds = [...new Set(Object.values(selectedCoverages).flat())];
      for (const formId of allFormIds) {
        const form = forms.find(f => f.id === formId);
        if (form) {
          const relatedCoverageIds = Object.entries(selectedCoverages)
            .filter(([_, formIds]) => formIds.includes(formId))
            .map(([covId, _]) => newCoverageIds[covId])
            .filter(Boolean);

          const newFormRef = await addDoc(collection(db, 'forms'), {
            formName: form.formName || null,
            formNumber: form.formNumber,
            effectiveDate: form.effectiveDate || effectiveDate,
            type: form.type || 'ISO',
            category: form.category || 'Base Coverage Form',
            productId: newProductId,
            coverageIds: relatedCoverageIds,
            downloadUrl: form.downloadUrl || '',
            filePath: form.filePath || null,
          });
          newFormIds[formId] = newFormRef.id;
        }
      }

      // Update coverage formIds
      for (const coverageId in selectedCoverages) {
        const newCoverageId = newCoverageIds[coverageId];
        const relatedFormIds = selectedCoverages[coverageId]
          .map(fId => newFormIds[fId])
          .filter(Boolean);

        await updateDoc(doc(db, `products/${newProductId}/coverages`, newCoverageId), {
          formIds: relatedFormIds,
        });
      }

      // Clone relevant pricing steps
      const relevantSteps = getRelevantPricingSteps();
      for (const step of relevantSteps) {
        const newCoverageNames = step.coverages?.map(covId => {
          const oldCoverage = coverages.find(c => c.id === covId);
          return oldCoverage?.name || oldCoverage?.coverageName;
        }).filter(Boolean) || [];

        await addDoc(collection(db, `products/${newProductId}/steps`), {
          stepName: step.stepName,
          stepType: step.stepType,
          coverages: newCoverageNames,
          states: step.states || [],
          value: step.value || 1,
          rounding: step.rounding || 'none',
          order: step.order || 0,
          operand: step.operand || '',
          table: step.table || '',
          calculation: step.calculation || '',
        });
      }

      alert('Product created successfully with inherited pricing and metadata! Returning to ProductHub.');
      navigate('/');
    } catch (error) {
      console.error('Error creating product:', error);
      alert('Failed to create product. Please try again.');
    }
  };


  if (cloneLoading) {
    return (
      <Page>
        <MainNavigation />
        <MainContent>
          <LoadingContainer>
            <LoadingSpinner />
            <p style={{marginTop: 16, color: '#6b7280'}}>Cloning productâ€¦</p>
          </LoadingContainer>
        </MainContent>
      </Page>
    );
  }

  if (loading) {
    return (
      <Page>
        <MainNavigation />
        <MainContent>
          <LoadingContainer>
            <LoadingSpinner />
          </LoadingContainer>
        </MainContent>
      </Page>
    );
  }

  // --- CLONE PRODUCT HANDLER ---
  const handleCloneProduct = async (sourceId: string) => {
    if (!window.confirm('Clone this product and all of its related data?')) return;
    try {
      setCloneLoading(true);
      const result = await cloneProduct(sourceId);

      if (result.success) {
        alert(`Product cloned successfully! New product ID: ${result.newProductId}`);
        navigate('/');
      } else {
        alert(`Clone failed: ${result.error}`);
      }
    } catch (err) {
      console.error('Clone error:', err);
      alert('Clone failed: ' + (err as Error).message);
    } finally {
      setCloneLoading(false);
    }
  };

  return (
    <Page>
      <style>{GlobalStyle}</style>
      <MainNavigation />

      <MainContent>
        <EnhancedHeader
          title="AI Product Builder"
          subtitle="Describe your product vision and I'll help you build it intelligently"
          icon={WrenchScrewdriverIcon}
        />

        {/* AI Chat Interface */}
        <AIBuilderContainer>
          <ChatHeader>
            <ChatTitle>
              <CpuChipIcon width={20} height={20} />
              AI Product Assistant
              <SparklesIcon width={16} height={16} style={{ marginLeft: 'auto', opacity: 0.8 }} />
            </ChatTitle>
          </ChatHeader>

          <ChatMessages>
            {chatMessages.length === 0 ? (
              <WelcomeMessage>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', marginBottom: '16px' }}>
                  <LightBulbIcon width={24} height={24} style={{ color: '#6366f1' }} />
                  <h4 style={{ margin: 0, color: '#374151' }}>Welcome to AI Product Builder</h4>
                </div>
                <p style={{ margin: '0 0 16px 0', color: '#6b7280', lineHeight: '1.6' }}>
                  I'm your intelligent assistant for building insurance products. I can analyze your existing
                  {Object.keys(products).length} products, {coverages.length} coverages, and {forms.length} forms
                  to help you create the perfect new product.
                </p>
                <p style={{ margin: 0, color: '#6b7280', fontSize: '14px' }}>
                  Try asking me something like "Create a condo insurance product" or click a suggestion below:
                </p>
                <SuggestionChips>
                  {aiSuggestions.map((suggestion, index) => (
                    <SuggestionChip
                      key={index}
                      onClick={() => handleSuggestionClick(suggestion)}
                    >
                      {suggestion}
                    </SuggestionChip>
                  ))}
                </SuggestionChips>
              </WelcomeMessage>
            ) : (
              chatMessages.map((message, index) => (
                <ChatMessage key={index} isUser={message.role === 'user'}>
                  <MessageBubble isUser={message.role === 'user'}>
                    {message.role === 'user' ? (
                      message.content
                    ) : (
                      <MarkdownRenderer>{message.content}</MarkdownRenderer>
                    )}
                  </MessageBubble>
                </ChatMessage>
              ))
            )}

            {chatLoading && (
              <ChatMessage isUser={false}>
                <MessageBubble isUser={false}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <div style={{
                      width: '16px',
                      height: '16px',
                      border: '2px solid #e5e7eb',
                      borderTop: '2px solid #6366f1',
                      borderRadius: '50%',
                      animation: 'spin 1s linear infinite'
                    }} />
                    Analyzing your request...
                  </div>
                </MessageBubble>
              </ChatMessage>
            )}
          </ChatMessages>

          <ChatInputContainer>
            <ChatInput
              placeholder="Describe the product you want to build..."
              value={chatInput}
              onChange={(e) => setChatInput(e.target.value)}
              onKeyDown={handleChatKeyDown}
              rows={1}
            />
            <SendButton
              onClick={handleChatMessage}
              disabled={!chatInput.trim() || chatLoading}
            >
              <PaperAirplaneIcon />
              Send
            </SendButton>
          </ChatInputContainer>
        </AIBuilderContainer>

        {/* Modern Product Builder Interface */}
        <ProductBuilderGrid>
          {/* Coverage Browser */}
          <CoverageBrowserContainer>
            <CoverageBrowserHeader>
              <SectionTitle style={{ margin: '0 0 16px 0' }}>Coverage Library</SectionTitle>
              <SearchFilterContainer>
                <div style={{ position: 'relative' }}>
                  <SearchInput
                    placeholder="Search coverages by name, code, or scope..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                  <SearchIconWrapper>
                    <MagnifyingGlassIcon width={16} height={16} />
                  </SearchIconWrapper>
                </div>
                <FilterRow>
                  <FilterSelect
                    value={selectedProductFilter}
                    onChange={(e) => setSelectedProductFilter(e.target.value)}
                  >
                    <option value="">All Products</option>
                    {uniqueProducts.map(product => (
                      <option key={product.id} value={product.id}>
                        {product.name}
                      </option>
                    ))}
                  </FilterSelect>
                  <FilterSelect
                    value={selectedCategoryFilter}
                    onChange={(e) => setSelectedCategoryFilter(e.target.value)}
                  >
                    <option value="">All Categories</option>
                    {uniqueCategories.map(category => (
                      <option key={category} value={category}>
                        {category}
                      </option>
                    ))}
                  </FilterSelect>
                </FilterRow>
              </SearchFilterContainer>
            </CoverageBrowserHeader>

            <CoverageCardsGrid>
              {filteredCoverages.map(coverage => {
                const associatedForms = getAssociatedForms(coverage.id);
                const isSelected = !!selectedCoverages[coverage.id];

                return (
                  <CoverageCard
                    key={coverage.id}
                    selected={isSelected}
                    onClick={() => handleSmartCoverageSelect(coverage)}
                  >
                    <CoverageCardHeader>
                      <CoverageCardTitle>
                        {coverage.name || coverage.coverageName || 'Unnamed Coverage'}
                      </CoverageCardTitle>
                      {coverage.category && (
                        <CoverageCardBadge>{coverage.category}</CoverageCardBadge>
                      )}
                    </CoverageCardHeader>

                    <CoverageCardMeta>
                      <div>Product: {products[coverage.productId] || 'Unknown'}</div>
                      {coverage.coverageCode && <div>Code: {coverage.coverageCode}</div>}
                    </CoverageCardMeta>

                    {coverage.scopeOfCoverage && (
                      <div style={{
                        fontSize: '11px',
                        color: '#6b7280',
                        marginBottom: '8px',
                        lineHeight: '1.4'
                      }}>
                        {coverage.scopeOfCoverage.substring(0, 100)}
                        {coverage.scopeOfCoverage.length > 100 && '...'}
                      </div>
                    )}

                    <CoverageCardActions>
                      <FormCount>{associatedForms.length} forms</FormCount>
                      <SelectButton selected={isSelected}>
                        {isSelected ? 'Selected' : 'Select'}
                      </SelectButton>
                    </CoverageCardActions>
                  </CoverageCard>
                );
              })}
            </CoverageCardsGrid>
          </CoverageBrowserContainer>

          {/* Product Builder Panel */}
          <ProductBuilderPanel>
            <ProductBuilderHeader>
              <SectionTitle style={{ margin: '0 0 8px 0' }}>Product Builder</SectionTitle>
              <div style={{ fontSize: '13px', color: '#6b7280' }}>
                {Object.keys(selectedCoverages).length} coverages selected
              </div>
            </ProductBuilderHeader>

            <ProductBuilderContent>
              {/* Selected Coverages */}
              {Object.keys(selectedCoverages).length > 0 && (
                <SelectedCoveragesContainer>
                  <h4 style={{ margin: '0 0 12px 0', fontSize: '14px', fontWeight: '600', color: '#374151' }}>
                    Selected Coverages
                  </h4>
                  <SelectedCoveragesList>
                    {Object.keys(selectedCoverages).map(coverageId => {
                      const coverage = coverages.find(c => c.id === coverageId);
                      const associatedForms = getAssociatedForms(coverageId);

                      return (
                        <SelectedCoverageItem key={coverageId}>
                          <SelectedCoverageInfo>
                            <SelectedCoverageName>
                              {coverage?.name || coverage?.coverageName || 'Unknown Coverage'}
                            </SelectedCoverageName>
                            <SelectedCoverageProduct>
                              {products[coverage?.productId]} â€¢ {associatedForms.length} forms
                            </SelectedCoverageProduct>
                          </SelectedCoverageInfo>
                          <RemoveCoverageButton
                            onClick={(e) => {
                              e.stopPropagation();
                              handleRemoveCoverage(coverageId);
                            }}
                          >
                            <XMarkIcon width={14} height={14} />
                          </RemoveCoverageButton>
                        </SelectedCoverageItem>
                      );
                    })}
                  </SelectedCoveragesList>
                </SelectedCoveragesContainer>
              )}

              {/* Product Details Form */}
              <ProductDetailsForm>
                <FormGroup>
                  <FormLabel>Product Name *</FormLabel>
                  <CompactFormInput
                    placeholder="Enter product name"
                    value={newProductName}
                    onChange={e => setNewProductName(e.target.value)}
                  />
                </FormGroup>

                <FormGroup>
                  <FormLabel>Form Number *</FormLabel>
                  <CompactFormInput
                    placeholder="Form Number"
                    value={formNumber}
                    onChange={e => setFormNumber(e.target.value)}
                  />
                </FormGroup>

                <FormGroup>
                  <FormLabel>Product Code</FormLabel>
                  <CompactFormInput
                    placeholder="Product Code"
                    value={productCode}
                    onChange={e => setProductCode(e.target.value)}
                  />
                </FormGroup>

                <FormGroup>
                  <FormLabel>Effective Date *</FormLabel>
                  <CompactFormInput
                    placeholder="MM/YYYY"
                    value={effectiveDate}
                    onChange={e => setEffectiveDate(e.target.value)}
                  />
                </FormGroup>

                <FormGroup>
                  <FormLabel>Product Document *</FormLabel>
                  <FileUploadArea
                    onClick={() => document.getElementById('file-upload').click()}
                  >
                    <FileUploadText>
                      {file ? file.name : 'Click to upload product document'}
                    </FileUploadText>
                    <div style={{ fontSize: '11px', color: '#9ca3af' }}>
                      PDF, DOC, or DOCX files
                    </div>
                    <FileUploadInput
                      id="file-upload"
                      type="file"
                      accept=".pdf,.doc,.docx"
                      onChange={e => setFile(e.target.files[0])}
                    />
                  </FileUploadArea>
                </FormGroup>
              </ProductDetailsForm>

              <ActionButtonsContainer>
                <PrimaryActionButton
                  onClick={handleEnhancedCreateProduct}
                  disabled={
                    !newProductName ||
                    !formNumber ||
                    !effectiveDate ||
                    !file ||
                    Object.keys(selectedCoverages).length === 0
                  }
                >
                  <PlusIcon width={16} height={16} />
                  Create Product
                </PrimaryActionButton>
                <SecondaryActionButton onClick={() => setCloneModalOpen(true)}>
                  <DocumentDuplicateIcon width={16} height={16} />
                  Clone Existing
                </SecondaryActionButton>
              </ActionButtonsContainer>
            </ProductBuilderContent>
          </ProductBuilderPanel>

          {/* Preview Panel */}
          <PreviewPanel>
            <PreviewHeader>
              <SectionTitle style={{ margin: '0 0 8px 0' }}>Product Preview</SectionTitle>
              <div style={{ fontSize: '13px', color: '#6b7280' }}>
                Live preview of your new product
              </div>
            </PreviewHeader>

            <PreviewContent>
              <PreviewSection>
                <PreviewSectionTitle>Product Information</PreviewSectionTitle>
                <PreviewItem>
                  <PreviewLabel>Name:</PreviewLabel>
                  <PreviewValue>{newProductName || 'Not specified'}</PreviewValue>
                </PreviewItem>
                <PreviewItem>
                  <PreviewLabel>Form Number:</PreviewLabel>
                  <PreviewValue>{formNumber || 'Not specified'}</PreviewValue>
                </PreviewItem>
                <PreviewItem>
                  <PreviewLabel>Product Code:</PreviewLabel>
                  <PreviewValue>{productCode || 'Not specified'}</PreviewValue>
                </PreviewItem>
                <PreviewItem>
                  <PreviewLabel>Effective Date:</PreviewLabel>
                  <PreviewValue>{effectiveDate || 'Not specified'}</PreviewValue>
                </PreviewItem>
                <PreviewItem>
                  <PreviewLabel>Document:</PreviewLabel>
                  <PreviewValue>{file ? file.name : 'Not uploaded'}</PreviewValue>
                </PreviewItem>
              </PreviewSection>

              <PreviewSection>
                <PreviewSectionTitle>Coverage Summary</PreviewSectionTitle>
                <PreviewItem>
                  <PreviewLabel>Total Coverages:</PreviewLabel>
                  <PreviewValue>{Object.keys(selectedCoverages).length}</PreviewValue>
                </PreviewItem>
                <PreviewItem>
                  <PreviewLabel>Total Forms:</PreviewLabel>
                  <PreviewValue>
                    {[...new Set(Object.values(selectedCoverages).flat())].length}
                  </PreviewValue>
                </PreviewItem>
                <PreviewItem>
                  <PreviewLabel>Pricing Steps:</PreviewLabel>
                  <PreviewValue>{getRelevantPricingSteps().length} inherited</PreviewValue>
                </PreviewItem>
                <PreviewItem>
                  <PreviewLabel>Rules:</PreviewLabel>
                  <PreviewValue>{getRelevantRules().length} inherited</PreviewValue>
                </PreviewItem>
              </PreviewSection>

              {Object.keys(selectedCoverages).length > 0 && (
                <PreviewSection>
                  <PreviewSectionTitle>Selected Coverages</PreviewSectionTitle>
                  {Object.keys(selectedCoverages).slice(0, 5).map(coverageId => {
                    const coverage = coverages.find(c => c.id === coverageId);
                    const formCount = selectedCoverages[coverageId]?.length || 0;

                    return (
                      <PreviewItem key={coverageId}>
                        <PreviewLabel>
                          {coverage?.name || coverage?.coverageName || 'Unknown'}
                        </PreviewLabel>
                        <PreviewValue>{formCount} forms</PreviewValue>
                      </PreviewItem>
                    );
                  })}
                  {Object.keys(selectedCoverages).length > 5 && (
                    <PreviewItem>
                      <PreviewLabel>...</PreviewLabel>
                      <PreviewValue>
                        +{Object.keys(selectedCoverages).length - 5} more
                      </PreviewValue>
                    </PreviewItem>
                  )}
                </PreviewSection>
              )}
            </PreviewContent>
          </PreviewPanel>
        </ProductBuilderGrid>


        {/* Modal for Multiple Associations */}
        {modalOpen && (
          <ModalOverlay onClick={() => setModalOpen(false)}>
            <ModalContainer onClick={e => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>
                  Select Forms for {modalItem.name}
                </ModalTitle>
                <CloseButton onClick={() => setModalOpen(false)}>
                  <XMarkIcon style={{ width: 20, height: 20 }} />
                </CloseButton>
              </ModalHeader>
              <div style={{ marginTop: 16 }}>
                {forms
                  .filter(f => f.coverageIds?.includes(modalItem.id))
                  .map(form => {
                    const checked = selectedCoverages[modalItem.id]?.includes(form.id) || false;
                    return (
                      <div key={form.id} style={{
                        display: 'flex',
                        alignItems: 'center',
                        marginBottom: 12,
                        padding: '8px 12px',
                        borderRadius: '8px',
                        background: checked ? 'rgba(99, 102, 241, 0.1)' : 'transparent',
                        border: '1px solid rgba(226, 232, 240, 0.6)',
                        transition: 'all 0.2s ease'
                      }}>
                        <input
                          type="checkbox"
                          checked={checked}
                          onChange={e => {
                            const currentForms = selectedCoverages[modalItem.id] || [];
                            if (e.target.checked) {
                              handleModalSubmit(modalItem.id, [...currentForms, form.id]);
                            } else {
                              handleModalSubmit(modalItem.id, currentForms.filter(id => id !== form.id));
                            }
                          }}
                          style={{ marginRight: 12 }}
                        />
                        <span style={{
                          color: '#374151',
                          fontWeight: checked ? '600' : '400'
                        }}>
                          {form.formName || form.formNumber}
                        </span>
                      </div>
                    );
                  })}
              </div>
            </ModalContainer>
          </ModalOverlay>
        )}
        {/* Clone Product Modal */}
        {cloneModalOpen && (
          <ModalOverlay onClick={() => setCloneModalOpen(false)}>
            <ModalContainer onClick={e => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>Select Product to Clone</ModalTitle>
                <CloseButton onClick={() => setCloneModalOpen(false)}>
                  <XMarkIcon width={20} height={20} />
                </CloseButton>
              </ModalHeader>

              <div style={{ maxHeight: 320, overflowY: 'auto', marginTop: 12 }}>
                {Object.entries(products)
                  .sort((a, b) => a[1].localeCompare(b[1]))
                  .map(([pid, name]) => (
                    <label key={pid} style={{
                      display: 'block',
                      padding: '12px 16px',
                      margin: '4px 0',
                      borderRadius: '8px',
                      background: cloneTargetId === pid ? 'rgba(99, 102, 241, 0.1)' : 'transparent',
                      border: '1px solid rgba(226, 232, 240, 0.6)',
                      cursor: 'pointer',
                      transition: 'all 0.2s ease'
                    }}>
                      <input
                        type="radio"
                        name="cloneTarget"
                        value={pid}
                        checked={cloneTargetId === pid}
                        onChange={() => setCloneTargetId(pid)}
                        style={{ marginRight: 12 }}
                      />
                      <span style={{
                        color: '#374151',
                        fontWeight: cloneTargetId === pid ? '600' : '400'
                      }}>
                        {name}
                      </span>
                    </label>
                  ))}
              </div>

              <div style={{ marginTop: 24, display: 'flex', gap: 12 }}>
                <ModernButton
                  disabled={!cloneTargetId}
                  onClick={async () => {
                    await handleCloneProduct(cloneTargetId);
                    setCloneModalOpen(false);
                  }}
                >
                  Clone
                </ModernButton>
                <button
                  style={{
                    padding: '12px 24px',
                    border: '1px solid rgba(226, 232, 240, 0.6)',
                    borderRadius: '12px',
                    background: 'transparent',
                    color: '#6b7280',
                    cursor: 'pointer',
                    fontWeight: '600',
                    transition: 'all 0.2s ease'
                  }}
                  onClick={() => setCloneModalOpen(false)}
                >
                  Cancel
                </button>
              </div>
            </ModalContainer>
          </ModalOverlay>
        )}
      </MainContent>
    </Page>
  );
};

export default ProductBuilder;
```

---

## src/components/ProductExplorer.tsx

**Path:** `src/components/ProductExplorer.tsx`

```tsx
import { useState, useEffect } from 'react';
import { collection, collectionGroup, getDocs } from 'firebase/firestore';
import { db } from '../firebase';
import MainNavigation from './ui/Navigation';
import EnhancedHeader from './ui/EnhancedHeader';
import { PageContainer, PageContent } from './ui/PageContainer';
import { Breadcrumb } from './ui/Breadcrumb';

import styled, { keyframes } from 'styled-components';
import { MapIcon } from '@heroicons/react/24/solid';

/* ------------------- Styled Components ------------------- */

/* ------------------- tiny spinner ------------------- */
const spin = keyframes`0%{transform:rotate(0)}100%{transform:rotate(360deg)}`;
const Spinner = styled.div`
  margin:120px auto;width:40px;height:40px;border-radius:50%;
  border:4px solid #e5e7eb;border-top-color:#6366f1;animation:${spin}1s linear infinite;
`;
/* ---------------------------------------------------- */

/* layout columns */
const Grid = styled.div`
  display:grid;
  grid-template-columns:1fr 1fr 1fr;
  gap:24px;
  @media(max-width:900px){ grid-template-columns:1fr; }
`;
const Column = styled.div`
  background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.05);
  padding:16px;min-height:300px;overflow-y:auto;
`;
const ColumnTitle = styled.h2`
  font-size:18px;font-weight:600;margin-bottom:12px;
  background:linear-gradient(90deg,#0074E1,#60419F);
  -webkit-background-clip:text;color:transparent;
`;
const Item = styled.div`
  padding:8px 12px;margin-bottom:6px;border-radius:6px;cursor:pointer;
  background:${p=>p.selected?'#A100FF':'#F9FAFB'};
  color:${p=>p.selected?'#fff':'#1F2937'};
  transition: all 0.2s ease;
  border: 1px solid ${p=>p.selected?'#A100FF':'transparent'};
  &:hover{
    background:${p=>p.selected?'#8800d1':'#E5E7EB'};
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
`;
const Empty = styled.p`
  font-size:14px;color:#6B7280;font-style:italic;
`;

const SearchInfo = styled.div`
  background: linear-gradient(135deg, #eff6ff 0%, #f0f9ff 100%);
  border: 1px solid #bfdbfe;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 16px;
  font-size: 13px;
  color: #1e40af;
  display: flex;
  align-items: center;
  justify-content: space-between;
`;

const ClearSearchButton = styled.button`
  background: none;
  border: none;
  color: #6366f1;
  cursor: pointer;
  font-size: 12px;
  text-decoration: underline;

  &:hover {
    color: #4f46e5;
  }
`;



export default function ProductExplorer() {
  const [loading,setLoading]      = useState(true);
  const [products,setProducts]    = useState([]);
  const [coverages,setCoverages]  = useState([]);
  const [selectedProduct,setSelProduct]   = useState(null);
  const [selectedCoverage,setSelCoverage] = useState(null);
  const [searchQuery, setSearchQuery] = useState('');

  /* fetch everything once */
  useEffect(()=>{
    (async()=>{
      try {
        setLoading(true);
        const proSnap = await getDocs(collection(db,'products'));
        const covSnap = await getDocs(collectionGroup(db,'coverages'));
        setProducts(proSnap.docs.map(d=>({id:d.id,...d.data()})));
        setCoverages(covSnap.docs.map(d=>({
          id:d.id,...d.data(),productId:d.ref.parent.parent.id
        })));
      } catch (error) {
        console.error('Error fetching products and coverages:', error);
        // Continue with empty data if fetch fails
        setProducts([]);
        setCoverages([]);
      } finally {
        setLoading(false);
      }
    })();
  },[]);

  /* Enhanced search filtering with intelligent cross-filtering */
  const searchLower = searchQuery.toLowerCase();

  // Get all coverages (top-level and sub-coverages)
  const allTopCoverages = coverages.filter(c => !c.parentCoverageId);
  const allSubCoverages = coverages.filter(c => c.parentCoverageId);

  // Find matches across all entities
  const matchingProducts = products.filter(p =>
    p.name.toLowerCase().includes(searchLower)
  );

  const matchingTopCoverages = allTopCoverages.filter(c =>
    c.name.toLowerCase().includes(searchLower)
  );

  const matchingSubCoverages = allSubCoverages.filter(c =>
    c.name.toLowerCase().includes(searchLower)
  );

  // Get related entities based on matches
  const getRelatedProductIds = () => {
    const productIds = new Set();

    // Add directly matching products
    matchingProducts.forEach(p => productIds.add(p.id));

    // Add products that have matching coverages
    matchingTopCoverages.forEach(c => productIds.add(c.productId));
    matchingSubCoverages.forEach(c => productIds.add(c.productId));

    return Array.from(productIds);
  };

  const getRelatedCoverageIds = () => {
    const coverageIds = new Set();

    // Add directly matching top coverages
    matchingTopCoverages.forEach(c => coverageIds.add(c.id));

    // Add parent coverages of matching sub-coverages
    matchingSubCoverages.forEach(sc => {
      if (sc.parentCoverageId) {
        coverageIds.add(sc.parentCoverageId);
      }
    });

    return Array.from(coverageIds);
  };

  // Apply filtering based on search query
  const filteredProducts = searchQuery === ''
    ? products
    : products.filter(p => getRelatedProductIds().includes(p.id));

  // Show coverages based on selection and search
  const getDisplayCoverages = () => {
    if (searchQuery === '') {
      // No search - show coverages for selected product only
      return selectedProduct
        ? coverages.filter(c => c.productId === selectedProduct.id && !c.parentCoverageId)
        : [];
    } else {
      // With search - show all related coverages
      const relatedCoverageIds = getRelatedCoverageIds();
      const relatedProductIds = getRelatedProductIds();

      return allTopCoverages.filter(c =>
        relatedCoverageIds.includes(c.id) ||
        (selectedProduct && c.productId === selectedProduct.id) ||
        relatedProductIds.includes(c.productId)
      );
    }
  };

  const topCoverages = getDisplayCoverages();

  // Show sub-coverages based on selection and search
  const getDisplaySubCoverages = () => {
    if (searchQuery === '') {
      // No search - show sub-coverages for selected coverage only
      return selectedCoverage
        ? coverages.filter(c => c.parentCoverageId === selectedCoverage.id)
        : [];
    } else {
      // With search - show all matching sub-coverages and related ones
      const result = [...matchingSubCoverages];

      // Add sub-coverages of selected coverage if any
      if (selectedCoverage) {
        const selectedSubCoverages = coverages.filter(c => c.parentCoverageId === selectedCoverage.id);
        selectedSubCoverages.forEach(sc => {
          if (!result.find(r => r.id === sc.id)) {
            result.push(sc);
          }
        });
      }

      return result;
    }
  };

  const subCoverages = getDisplaySubCoverages();

  if (loading) return(
    <PageContainer withOverlay={true}>
      <MainNavigation />
      <PageContent><Spinner/></PageContent>
    </PageContainer>
  );

  return (
    <PageContainer withOverlay={true}>
      <MainNavigation />

      <PageContent>
        <Breadcrumb
          items={[
            { label: 'Home', path: '/' },
            { label: 'Products', path: '/products' },
            { label: 'Explorer' }
          ]}
        />

        <EnhancedHeader
          title="Product Explorer"
          subtitle={searchQuery
            ? `Found ${filteredProducts.length} products, ${topCoverages.length} coverages, ${subCoverages.length} sub-coverages matching "${searchQuery}"`
            : `Navigate through ${products.length} products, ${allTopCoverages.length} coverages, ${allSubCoverages.length} sub-coverages`
          }
          icon={MapIcon}
          searchProps={{
            placeholder: "Search products, coverages, or sub-coverages...",
            value: searchQuery,
            onChange: (e) => setSearchQuery(e.target.value)
          }}
        />

        {searchQuery && (
          <SearchInfo>
            <span>
              ðŸ” Showing all related items for "{searchQuery}" - click any item to auto-select its dependencies
            </span>
            <ClearSearchButton onClick={() => setSearchQuery('')}>
              Clear search
            </ClearSearchButton>
          </SearchInfo>
        )}

        <Grid>
          {/* column 1 â€“ products */}
          <Column>
            <ColumnTitle>Products</ColumnTitle>
            {filteredProducts.length?filteredProducts.map(p=>(
              <Item key={p.id}
                    selected={selectedProduct?.id===p.id}
                    onClick={()=>{setSelProduct(p);setSelCoverage(null);}}>
                {p.name}
              </Item>
            )):<Empty>No products found</Empty>}
          </Column>

          {/* column 2 â€“ coverages */}
          <Column>
            <ColumnTitle>Coverages</ColumnTitle>
            {searchQuery === '' ? (
              // No search - require product selection
              selectedProduct ? (
                topCoverages.length ? topCoverages.map(c => (
                  <Item key={c.id}
                        selected={selectedCoverage?.id === c.id}
                        onClick={() => setSelCoverage(c)}>
                    {c.name}
                    {searchQuery && c.productId !== selectedProduct?.id && (
                      <div style={{ fontSize: '11px', color: '#6b7280', marginTop: '2px' }}>
                        from {products.find(p => p.id === c.productId)?.name}
                      </div>
                    )}
                  </Item>
                )) : <Empty>No coverages</Empty>
              ) : <Empty>Select a product</Empty>
            ) : (
              // With search - show all matching coverages
              topCoverages.length ? topCoverages.map(c => (
                <Item key={c.id}
                      selected={selectedCoverage?.id === c.id}
                      onClick={() => {
                        setSelCoverage(c);
                        // Auto-select the product if not already selected
                        if (!selectedProduct || selectedProduct.id !== c.productId) {
                          const product = products.find(p => p.id === c.productId);
                          if (product) setSelProduct(product);
                        }
                      }}>
                  {c.name}
                  {c.productId !== selectedProduct?.id && (
                    <div style={{ fontSize: '11px', color: '#6b7280', marginTop: '2px' }}>
                      from {products.find(p => p.id === c.productId)?.name}
                    </div>
                  )}
                </Item>
              )) : <Empty>No matching coverages</Empty>
            )}
          </Column>

          {/* column 3 â€“ sub-coverages */}
          <Column>
            <ColumnTitle>Subâ€‘Coverages</ColumnTitle>
            {searchQuery === '' ? (
              // No search - require coverage selection
              selectedCoverage ? (
                subCoverages.length ? subCoverages.map(sc => (
                  <Item key={sc.id}>{sc.name}</Item>
                )) : <Empty>No sub coverages</Empty>
              ) : <Empty>Select a coverage</Empty>
            ) : (
              // With search - show all matching sub-coverages
              subCoverages.length ? subCoverages.map(sc => {
                const parentCoverage = coverages.find(c => c.id === sc.parentCoverageId);
                const product = products.find(p => p.id === sc.productId);
                return (
                  <Item key={sc.id}
                        onClick={() => {
                          // Auto-select parent coverage and product
                          if (parentCoverage && (!selectedCoverage || selectedCoverage.id !== parentCoverage.id)) {
                            setSelCoverage(parentCoverage);
                          }
                          if (product && (!selectedProduct || selectedProduct.id !== product.id)) {
                            setSelProduct(product);
                          }
                        }}>
                    {sc.name}
                    {(sc.parentCoverageId !== selectedCoverage?.id || sc.productId !== selectedProduct?.id) && (
                      <div style={{ fontSize: '11px', color: '#6b7280', marginTop: '2px' }}>
                        under {parentCoverage?.name} â€¢ {product?.name}
                      </div>
                    )}
                  </Item>
                );
              }) : <Empty>No matching sub-coverages</Empty>
            )}
          </Column>
        </Grid>
      </PageContent>
    </PageContainer>
  );
}
```

---

## src/components/ProductHub.tsx

**Path:** `src/components/ProductHub.tsx`

```tsx
import React, { useEffect, useState, useMemo, useCallback, memo } from 'react';
import styled from 'styled-components';
import MainNavigation from './ui/Navigation';
import EnhancedHeader from './ui/EnhancedHeader';
import { PageContainer, PageContent } from './ui/PageContainer';
import {
  collection,
  addDoc,
  deleteDoc,
  doc,
  updateDoc,
  getDocs,
  query,
  where
} from 'firebase/firestore';
import { db, storage, functions } from '@/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { httpsCallable } from 'firebase/functions';
import {
  TrashIcon,
  PencilIcon,
  InformationCircleIcon,
  PlusIcon,
  PaperAirplaneIcon,
  Squares2X2Icon,
  TableCellsIcon,
  CubeIcon,
  XMarkIcon,
  MagnifyingGlassIcon
} from '@heroicons/react/24/solid';
import DataDictionaryModal from './DataDictionaryModal';
import ConfirmationModal from './ui/ConfirmationModal';
import useProducts from '@hooks/useProducts';
import MarkdownRenderer from '@utils/markdownParser';
import ProductCard from './ui/ProductCard';
import { normalizeFirestoreData } from '@utils/firestoreHelpers';
import VirtualizedGrid from './ui/VirtualizedGrid';
import { debounce } from '@utils/performance';
import { extractPdfText } from '@utils/pdfChunking';
import LoadingSpinner from './ui/LoadingSpinner';
import { EmptyState } from './ui/EmptyState';
import { logAuditEvent } from '@services/auditService';


/* ---------- Styled Components ---------- */

const HeaderActionButton = styled.button.withConfig({
  shouldForwardProp: (prop) => !['variant'].includes(prop),
})<{ variant?: 'primary' | 'secondary' }>`
  display: flex;
  align-items: center;
  gap: 8px;
  background: ${props => props.variant === 'secondary'
    ? 'rgba(255, 255, 255, 0.9)'
    : 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)'};
  color: ${props => props.variant === 'secondary' ? '#6366f1' : '#ffffff'};
  border: ${props => props.variant === 'secondary' ? '1px solid rgba(99, 102, 241, 0.2)' : 'none'};
  border-radius: 12px;
  padding: 12px 20px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  box-shadow: ${props => props.variant === 'secondary'
    ? '0 2px 8px rgba(99, 102, 241, 0.1)'
    : '0 4px 16px rgba(99, 102, 241, 0.25)'};
  transition: all 0.3s ease;
  letter-spacing: -0.01em;
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s ease;
  }

  &:hover {
    background: ${props => props.variant === 'secondary'
      ? 'rgba(99, 102, 241, 0.1)'
      : 'linear-gradient(135deg, #5b5bf6 0%, #7c3aed 100%)'};
    transform: translateY(-2px);
    box-shadow: ${props => props.variant === 'secondary'
      ? '0 4px 16px rgba(99, 102, 241, 0.2)'
      : '0 8px 24px rgba(99, 102, 241, 0.35)'};
    border-color: ${props => props.variant === 'secondary' ? 'rgba(99, 102, 241, 0.3)' : 'transparent'};

    &::before {
      left: 100%;
    }
  }

  &:active {
    transform: translateY(0);
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

// Action Bar
const ActionBar = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 32px;
  gap: 20px;
  flex-wrap: wrap;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(12px);
  padding: 20px 24px;
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
`;

// Filter Bar
const FilterBar = styled.div`
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
  padding: 16px 24px;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(12px);
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  margin-bottom: 24px;
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
`;

const FilterSelect = styled.select`
  padding: 8px 12px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 8px;
  background: white;
  font-size: 13px;
  font-weight: 500;
  color: #374151;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: #6366f1;
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
  }

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const ClearFiltersButton = styled.button`
  padding: 8px 12px;
  background: rgba(239, 68, 68, 0.1);
  color: #dc2626;
  border: 1px solid rgba(239, 68, 68, 0.2);
  border-radius: 8px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(239, 68, 68, 0.15);
    border-color: rgba(239, 68, 68, 0.3);
  }
`;

// Keyboard shortcuts hint
const KeyboardHint = styled.div`
  display: flex;
  gap: 16px;
  padding: 12px 16px;
  background: rgba(99, 102, 241, 0.05);
  border-radius: 8px;
  border: 1px solid rgba(99, 102, 241, 0.1);
  font-size: 12px;
  color: #6b7280;
  margin-bottom: 16px;
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
`;

const KeyboardShortcut = styled.span`
  display: flex;
  align-items: center;
  gap: 6px;

  kbd {
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(226, 232, 240, 0.8);
    border-radius: 4px;
    padding: 2px 6px;
    font-size: 11px;
    font-weight: 600;
    color: #374151;
  }
`;

// Stats Bar
const StatsBar = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 16px;
  padding: 16px 24px;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
  border-radius: 12px;
  border: 1px solid rgba(99, 102, 241, 0.1);
  margin-bottom: 24px;
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;

  @media (max-width: 640px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
    padding: 12px 16px;
  }
`;

const StatBox = styled.div`
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 12px;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 8px;
  border: 1px solid rgba(226, 232, 240, 0.6);
`;

const StatBoxValue = styled.div`
  font-size: 18px;
  font-weight: 700;
  color: #6366f1;
`;

const StatBoxLabel = styled.div`
  font-size: 12px;
  font-weight: 600;
  color: #6b7280;
  text-transform: uppercase;
  letter-spacing: 0.5px;
`;

// Bulk Actions Toolbar
const BulkActionsToolbar = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 12px 16px;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
  border-radius: 8px;
  border: 1px solid rgba(99, 102, 241, 0.2);
  margin-bottom: 16px;
  animation: slideDown 0.2s ease;

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
`;

const BulkActionCount = styled.span`
  font-size: 13px;
  font-weight: 600;
  color: #6366f1;
`;

const BulkActionButton = styled.button`
  padding: 8px 12px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
  }

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
`;

// AI Suggestions Banner
const SuggestionsBanner = styled.div`
  padding: 16px;
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(99, 102, 241, 0.1) 100%);
  border-radius: 8px;
  border: 1px solid rgba(59, 130, 246, 0.2);
  margin-bottom: 16px;
`;

const SuggestionsTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #1e40af;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
`;

const SuggestionsList = styled.ul`
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 6px;

  li {
    font-size: 12px;
    color: #1e40af;
    padding-left: 20px;
    position: relative;

    &::before {
      content: 'ðŸ’¡';
      position: absolute;
      left: 0;
    }
  }
`;

// Toast notification
const ToastContainer = styled.div`
  position: fixed;
  bottom: 24px;
  right: 24px;
  z-index: 2000;
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-width: 400px;

  @media (max-width: 640px) {
    bottom: 16px;
    right: 16px;
    left: 16px;
    max-width: none;
  }
`;

const Toast = styled.div<{ $type?: 'success' | 'error' | 'info' }>`
  padding: 16px 20px;
  border-radius: 12px;
  background: ${props => {
    switch (props.$type) {
      case 'success': return '#dcfce7';
      case 'error': return '#fee2e2';
      case 'info': return '#dbeafe';
      default: return '#f3f4f6';
    }
  }};
  border: 1px solid ${props => {
    switch (props.$type) {
      case 'success': return '#86efac';
      case 'error': return '#fca5a5';
      case 'info': return '#93c5fd';
      default: return '#e5e7eb';
    }
  }};
  color: ${props => {
    switch (props.$type) {
      case 'success': return '#166534';
      case 'error': return '#991b1b';
      case 'info': return '#1e40af';
      default: return '#374151';
    }
  }};
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  animation: slideIn 0.3s ease-out;

  @keyframes slideIn {
    from {
      transform: translateX(400px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
`;

const ActionGroup = styled.div`
  display: flex;
  gap: 12px;
  align-items: center;
`;

// Unified Command Bar - Apple-inspired search + actions header
const CommandBar = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 32px;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.85);
  backdrop-filter: blur(20px) saturate(180%);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.6);
  box-shadow:
    0 1px 3px rgba(0, 0, 0, 0.04),
    0 4px 12px rgba(0, 0, 0, 0.03),
    inset 0 1px 0 rgba(255, 255, 255, 0.8);
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    padding: 1px;
    background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0.2) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    pointer-events: none;
  }
`;

const CommandBarLeft = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const CommandBarCenter = styled.div`
  flex: 1;
  display: flex;
  justify-content: center;
  max-width: 640px;
  min-width: 320px;
`;

const CommandBarRight = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const SearchWrapper = styled.div`
  width: 100%;
  position: relative;
  display: flex;
  align-items: center;
`;

const SearchInputStyled = styled.input`
  width: 100%;
  padding: 12px 16px 12px 44px;
  background: rgba(0, 0, 0, 0.03);
  border: 1px solid rgba(0, 0, 0, 0.06);
  border-radius: 12px;
  font-size: 14px;
  font-weight: 450;
  color: #1a1a1a;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  letter-spacing: -0.01em;

  &::placeholder {
    color: #8e8e93;
    font-weight: 400;
  }

  &:hover {
    background: rgba(0, 0, 0, 0.04);
    border-color: rgba(0, 0, 0, 0.08);
  }

  &:focus {
    outline: none;
    background: #ffffff;
    border-color: rgba(99, 102, 241, 0.5);
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.12);
  }
`;

const SearchIconWrapper = styled.div`
  position: absolute;
  left: 14px;
  top: 50%;
  transform: translateY(-50%);
  color: #8e8e93;
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;

  svg {
    width: 18px;
    height: 18px;
  }
`;

const ViewToggleGroup = styled.div`
  display: flex;
  gap: 2px;
  background: rgba(0, 0, 0, 0.04);
  padding: 4px;
  border-radius: 10px;
`;

const ViewToggleButton = styled.button.withConfig({
  shouldForwardProp: (prop) => !['active'].includes(prop),
})<{ active?: boolean }>`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 8px 14px;
  border: none;
  border-radius: 8px;
  background: ${({ active }) => active ? '#ffffff' : 'transparent'};
  color: ${({ active }) => active ? '#1a1a1a' : '#6b7280'};
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
  box-shadow: ${({ active }) => active ? '0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06)' : 'none'};

  svg {
    width: 16px;
    height: 16px;
  }

  &:hover {
    background: ${({ active }) => active ? '#ffffff' : 'rgba(255,255,255,0.6)'};
    color: ${({ active }) => active ? '#1a1a1a' : '#4b5563'};
  }

  &:active {
    transform: scale(0.98);
  }
`;

const AddProductButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 18px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: #ffffff;
  border: none;
  border-radius: 10px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 2px 8px rgba(99, 102, 241, 0.25);
  letter-spacing: -0.01em;
  white-space: nowrap;

  svg {
    width: 16px;
    height: 16px;
  }

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(99, 102, 241, 0.35);
    background: linear-gradient(135deg, #5b5ce6 0%, #7c4dff 100%);
  }

  &:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.25);
  }
`;

const ProductsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 32px;
  margin-bottom: 60px;
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;

  @media (max-width: 1024px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 24px;
  }

  @media (max-width: 768px) {
    grid-template-columns: 1fr;
    gap: 20px;
    margin-bottom: 40px;
  }

  @media (max-width: 480px) {
    gap: 16px;
  }
`;

// Table Container for table view
const TableContainer = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  padding: 24px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  margin-bottom: 60px;
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
`;

const TableHead = styled.thead`
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
`;

const TableRow = styled.tr`
  border-bottom: 1px solid #e2e8f0;
  transition: all 0.2s ease;
  cursor: pointer;

  &:hover {
    background: rgba(99, 102, 241, 0.05);
    transform: translateX(2px);
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
  }

  &:last-child {
    border-bottom: none;
  }
`;

const TableHeader = styled.th`
  padding: 16px 12px;
  text-align: left;
  font-size: 14px;
  font-weight: 600;
  color: #475569;
  text-transform: uppercase;
  letter-spacing: 0.05em;
`;

const TableCell = styled.td`
  padding: 16px 12px;
  font-size: 14px;
  color: #64748b;
  vertical-align: middle;
`;

const TableActions = styled.div`
  display: flex;
  gap: 8px;
  justify-content: center;
`;

// Removed duplicate styled components - now using separate ProductCard component

// Keep IconButton for table view
const IconButton = styled.button`
  width: 36px;
  height: 36px;
  border: none;
  border-radius: 12px;
  background: rgba(248, 250, 252, 0.8);
  backdrop-filter: blur(10px);
  color: #64748b;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  border: 1px solid rgba(226, 232, 240, 0.6);

  &:hover {
    background: rgba(99, 102, 241, 0.08);
    color: #6366f1;
    border-color: rgba(99, 102, 241, 0.3);
    transform: translateY(-1px);
  }

  &.danger:hover {
    background: rgba(239, 68, 68, 0.08);
    color: #ef4444;
    border-color: rgba(239, 68, 68, 0.3);
  }

  @media (max-width: 768px) {
    width: 32px;
    height: 32px;
  }
`;

// AddButton styled component for action buttons
const AddButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 2px 8px rgba(99, 102, 241, 0.2);

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }

  &:active {
    transform: translateY(0);
  }

  @media (max-width: 768px) {
    padding: 8px 12px;
    font-size: 12px;
  }
`;

/* ---------- modal components ---------- */
const Modal = styled.div`
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 20px;
  backdrop-filter: blur(4px);
`;

const ModalContent = styled.div`
  background: #ffffff;
  border-radius: 16px;
  padding: 0;
  width: 100%;
  max-width: 650px;
  max-height: 90vh;
  overflow: hidden;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.2);
`;

/* ---------- Enhanced AI Content Modal Components ---------- */
const EnhancedModalContent = styled.div`
  background: #ffffff;
  border-radius: 16px;
  padding: 0;
  width: 100%;
  max-width: 768px;
  max-height: 90vh;
  overflow: hidden;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.2);
  display: flex;
  flex-direction: column;
`;

const StickyModalHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px 32px;
  border-bottom: 1px solid #e5e7eb;
  background: #ffffff;
  position: sticky;
  top: 0;
  z-index: 10;
`;

const EnhancedModalTitle = styled.h2`
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: #111827;
  letter-spacing: -0.01em;
`;

const ScrollableModalBody = styled.div`
  max-height: 70vh;
  overflow-y: auto;
  padding: 32px;
  background: #ffffff;

  /* Custom scrollbar */
  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: #f1f5f9;
  }

  &::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
  }
`;

const AIContentContainer = styled.div`
  /* Typography hierarchy for AI content */
  h1, h2 {
    font-size: 20px;
    font-weight: 700;
    color: #111827;
    margin: 0 0 16px 0;
    line-height: 1.3;
  }

  h3 {
    font-size: 16px;
    font-weight: 600;
    color: #374151;
    margin: 24px 0 12px 0;
    line-height: 1.4;
  }

  p {
    font-size: 14px;
    color: #4b5563;
    line-height: 1.6;
    margin: 0 0 16px 0;
  }

  strong, b {
    font-weight: 600;
    color: #374151;
  }

  ul, ol {
    margin: 16px 0;
    padding-left: 20px;
  }

  li {
    font-size: 14px;
    color: #4b5563;
    line-height: 1.6;
    margin: 4px 0;
  }

  /* Visual rhythm and spacing */
  > * + * {
    margin-top: 16px;
  }

  /* Highlight key terms */
  strong:contains("Limits:"),
  strong:contains("Perils:"),
  strong:contains("Coverage:"),
  strong:contains("Deductible:") {
    color: #6366f1;
    background: rgba(99, 102, 241, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
  }
`;

const ContentSection = styled.div`
  margin-bottom: 32px;
  padding: 24px;
  background: #f8fafc;
  border-radius: 12px;
  border: 1px solid #e2e8f0;

  &:last-child {
    margin-bottom: 0;
  }
`;

const SectionHeader = styled.h3`
  font-size: 16px;
  font-weight: 600;
  color: #374151;
  margin: 0 0 16px 0;
  padding-bottom: 8px;
  border-bottom: 2px solid #e5e7eb;
`;

const ModalHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px 24px 0;
  margin-bottom: 24px;
  position: relative;
`;

const ModalTitle = styled.h3`
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #111827;
`;

const CloseButton = styled.button`
  position: absolute;
  top: 16px;
  right: 16px;
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 8px;
  background: rgba(107, 114, 128, 0.1);
  color: #6b7280;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 20;

  &:hover {
    background: rgba(107, 114, 128, 0.2);
    color: #374151;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

/* ---------- AI Content Processing Utilities ---------- */
const processAIContent = (content) => {
  if (!content) return '';

  // Clean up excessive line breaks and whitespace
  let cleaned = content
    .replace(/\n{3,}/g, '\n\n')
    .replace(/\s{2,}/g, ' ')
    .trim();

  // Enhance key terms with highlighting
  const keyTerms = [
    'Limits:', 'Perils:', 'Coverage:', 'Deductible:', 'Premium:',
    'Exclusions:', 'Conditions:', 'Territory:', 'Policy Period:'
  ];

  keyTerms.forEach(term => {
    const regex = new RegExp(`\\b${term}`, 'gi');
    cleaned = cleaned.replace(regex, `**${term}**`);
  });

  return cleaned;
};

const renderAIContent = (content) => {
  const processedContent = processAIContent(content);
  return (
    <AIContentContainer>
      <MarkdownRenderer>{processedContent}</MarkdownRenderer>
    </AIContentContainer>
  );
};

const FormField = styled.div`
  margin-bottom: 24px;
  padding: 0 24px;

  &:last-of-type {
    margin-bottom: 0;
  }
`;

const FormLabel = styled.label`
  display: block;
  font-size: 13px;
  font-weight: 600;
  color: #111827;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
`;

const FormLabelHint = styled.span`
  display: block;
  font-size: 12px;
  font-weight: 400;
  color: #6b7280;
  text-transform: none;
  letter-spacing: normal;
  margin-top: 4px;
`;

const FormInput = styled.input`
  width: 100%;
  padding: 12px 16px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  font-size: 14px;
  color: #111827;
  background: #ffffff;
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: #7c3aed;
    box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }

  &:disabled {
    background: #f3f4f6;
    color: #9ca3af;
    cursor: not-allowed;
  }
`;

const FileInput = styled.input`
  width: 100%;
  padding: 12px 16px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  font-size: 14px;
  color: #111827;
  background: #ffffff;
  cursor: pointer;

  &:focus {
    outline: none;
    border-color: #7c3aed;
    box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
  }
`;

const FileName = styled.div`
  margin-top: 8px;
  font-size: 12px;
  color: #6b7280;
  padding: 8px 12px;
  background: #f9fafb;
  border-radius: 6px;
`;

const ModalActions = styled.div`
  display: flex;
  gap: 12px;
  padding: 24px;
  justify-content: flex-end;
  border-top: 1px solid #e5e7eb;
  background: #f9fafb;
`;

const SaveButton = styled.button`
  padding: 12px 24px;
  background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 50%, #a855f7 100%);
  color: #ffffff;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
  }

  &:active:not(:disabled) {
    transform: translateY(0);
  }

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
`;

const CancelButton = styled.button`
  padding: 12px 24px;
  background: #ffffff;
  color: #6b7280;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: #f9fafb;
    color: #374151;
    border-color: #d1d5db;
  }
`;

const FormError = styled.div`
  padding: 12px 16px;
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.2);
  border-radius: 8px;
  color: #dc2626;
  font-size: 13px;
  font-weight: 500;
  margin-bottom: 20px;
`;

/* ---------- summary modal components ---------- */
/* ---------- details modal components ---------- */
const DetailsList = styled.div`
  padding: 0 24px 24px;
`;

const DetailItem = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 0;
  border-bottom: 1px solid #f3f4f6;

  &:last-child {
    border-bottom: none;
  }
`;

const DetailLabel = styled.div`
  font-size: 14px;
  font-weight: 500;
  color: #374151;
`;

const DetailValue = styled.div`
  font-size: 14px;
  color: #6b7280;
`;

const DetailLink = styled.a`
  color: #7c3aed;
  text-decoration: none;
  font-weight: 500;

  &:hover {
    text-decoration: underline;
  }
`;

const ChatInput = styled.textarea`
  flex: 1;
  padding: 12px 16px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  font-size: 14px;
  color: #111827;
  background: #ffffff;
  resize: none;
  min-height: 44px;
  max-height: 120px;
  font-family: inherit;

  &:focus {
    outline: none;
    border-color: #7c3aed;
    box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const ChatSendButton = styled.button`
  width: 44px;
  height: 44px;
  border: none;
  border-radius: 8px;
  background: #7c3aed;
  color: #ffffff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;

  &:hover:not(:disabled) {
    background: #6d28d9;
  }

  &:disabled {
    background: #e5e7eb;
    cursor: not-allowed;
  }
`;

/* ---------- system prompts ---------- */
const SYSTEM_INSTRUCTIONS = `
Persona: You are an expert in P&C insurance products. Your task is to analyze the provided insurance document text and extract key information into a structured JSON format.

**Understand the following definitions:**

- **Product:** The name of the insurance product, representing a distinct insurance offering or line. It is typically defined by a base coverage form (e.g., Commercial Property product uses base form CP 00 10) that encompasses one or more core coverages. It may also include additional endorsement coverages offered under the same product but not included in the base form.
- **Coverage:** A specific provision within an insurance policy that offers protection against designated perils or risks to particular subjects, such as property, persons, or liabilities. It outlines the extent of the insurer's obligation to compensate for covered losses, including maximum limits per occurrence and in aggregate, conditions under which coverage applies, exclusions that limit its scope, and any deductibles the insured must meet before benefits are paid.

**Instructions:**

1. **Determine the Form Category:**
   - **Base Coverage Form:** Contains one or more coverages, does not amend another document, and includes policy language such as definitions and conditions.
   - **Coverage Endorsement:** Modifies an existing insurance document, such as the base coverage form, to add new coverage to the policy.
   - **Exclusion:** Excludes coverages, terms of coverages, and other items from the policy, reducing coverage offered.
   - **Notice:** A policyholder notice explaining certain revisions and other mandatory legal disclaimers.
   - **Dec/Quote:** The cover letter of the policy explaining all the policyholder information, coverages, limits, deductibles, list of forms attached, etc.

2. **Identify and List All Coverages Individually:**
   - For each coverage, extract the following details:
     - **coverageName:** The name of the coverage. If not explicitly stated, infer based on context.
     - **scopeOfCoverage:** A description of what is covered, including specific items or scenarios (2-3 sentences max)
     - **limits:** Any monetary or other limits applied to the coverage. Include specific values if available.
     - **perilsCovered:** An array of perils or risks that are covered under this coverage.
     - **enhances:** (For endorsements) An array of coverage names that this endorsement modifies or enhances. Leave empty if not applicable.
   - If the form is an endorsement, ensure to identify which coverages it enhances or modifies.

3. **Extract General Conditions and Exclusions:**
   - **generalConditions:** An array of conditions that apply to the entire document or policy (2-3 sentences max)
   - **generalExclusions:** An array of exclusions that apply to the entire document or policy (2-3 sentences max)
   - These should be distinct from conditions and exclusions specific to individual coverages.

**Important Guidelines:**
- Use your knowledge of insurance to interpret the text conceptually. Do not rely solely on exact wording, as phrasing can vary across insurers.
- Read the entire document, ignoring any irrelevant formatting or sections that do not pertain to coverages or general conditions/exclusions.
- Be thorough and ensure all coverages are captured, including any endorsements.
- If a coverage name is not explicitly stated, infer it based on the context.
- Do not include any information not supported by the document.
- For fields that are not applicable or not found, use an empty array for lists or an empty string for text fields.

**Output Format:**
{
  "category": "document_type",
  "coverages": [
    {
      "coverageName": "name",
      "scopeOfCoverage": "description",
      "limits": "limits_description",
      "perilsCovered": ["peril1", "peril2"],
      "enhances": ["coverage1", "coverage2"]
    }
  ],
  "generalConditions": ["condition1", "condition2"],
  "generalExclusions": ["exclusion1", "exclusion2"]
}
`;

// Memoized ProductHub component for better performance
const ProductHub = memo(() => {
  // Fetch all products including archived
  const { data: products, loading, error } = useProducts({ enableCache: true, maxResults: 500, includeArchived: true });
  const [searchTerm, setSearchTerm] = useState('');
  const [rawSearch, setRawSearch] = useState('');

  // Modal states
  const [modalOpen, setModalOpen] = useState(false);
  const [editingId, setEditingId] = useState(null);
  const [dictModalOpen, setDictModalOpen] = useState(false);
  const [summaryModalOpen, setSummaryModalOpen] = useState(false);
  const [chatModalOpen, setChatModalOpen] = useState(false);
  const [detailsModalOpen, setDetailsModalOpen] = useState(false);
  const [confirmDeleteOpen, setConfirmDeleteOpen] = useState(false);
  const [deleteProductId, setDeleteProductId] = useState<string | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);

  // Form states
  const [name, setName] = useState('');
  const [formNumber, setFormNumber] = useState('');
  const [productCode, setProductCode] = useState('');
  const [effectiveDate, setEffectiveDate] = useState('');
  const [file, setFile] = useState(null);
  const [formErrors, setFormErrors] = useState({});
  const [isSaving, setIsSaving] = useState(false);

  // AI states
  const [loadingSummary, setLoadingSummary] = useState({});
  const [modalData, setModalData] = useState(null);
  const [selectedProduct, setSelectedProduct] = useState(null);

  // Chat states
  const [chatMessages, setChatMessages] = useState([]);
  const [chatInput, setChatInput] = useState('');
  const [chatLoading, setChatLoading] = useState(false);
  const [chatPdfText, setChatPdfText] = useState('');

  // View mode state - Default to card view
  const [viewMode, setViewMode] = useState('cards'); // 'cards' or 'table'

  // Filter states
  const [sortBy, setSortBy] = useState('name'); // 'name', 'date', 'coverage-count'
  const [filterStatus, setFilterStatus] = useState('all'); // 'all', 'active', 'inactive'

  // Multi-select state
  const [selectedProducts, setSelectedProducts] = useState<Set<string>>(new Set());

  // Toast notification state
  const [toasts, setToasts] = useState<Array<{ id: string; message: string; type: 'success' | 'error' | 'info' }>>([]);

  // Helper function to show toast
  const showToast = (message: string, type: 'success' | 'error' | 'info' = 'info') => {
    const id = Math.random().toString(36).substr(2, 9);
    setToasts(prev => [...prev, { id, message, type }]);
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id));
    }, 3000);
  };

  // Get AI suggestions for products
  const getAISuggestions = useCallback(() => {
    const suggestions = [];

    if (products.length === 0) {
      suggestions.push('Start by creating your first product using a template');
    }

    const productsWithoutCoverages = products.filter(p => !p.coverageCount || p.coverageCount === 0);
    if (productsWithoutCoverages.length > 0) {
      suggestions.push(`${productsWithoutCoverages.length} product(s) need coverages added`);
    }

    const productsWithoutForms = products.filter(p => !p.formDownloadUrl);
    if (productsWithoutForms.length > 0) {
      suggestions.push(`${productsWithoutForms.length} product(s) are missing form documents`);
    }

    return suggestions;
  }, [products]);

  // Optimized debounced search
  const debouncedSetSearchTerm = useCallback(
    debounce((term) => {
      setSearchTerm(term.trim());
    }, 300),
    []
  );

  useEffect(() => {
    debouncedSetSearchTerm(rawSearch);
  }, [rawSearch, debouncedSetSearchTerm]);

  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Escape key - close modals
      if (e.key === 'Escape') {
        setModalOpen(false);
        setSummaryModalOpen(false);
        setDetailsModalOpen(false);
        setChatModalOpen(false);
        setDictModalOpen(false);
      }
      // Ctrl/Cmd + N - new product
      if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        e.preventDefault();
        setModalOpen(true);
      }
      // Ctrl/Cmd + K - focus search
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        const searchInput = document.querySelector('input[placeholder*="Search"]') as HTMLInputElement;
        if (searchInput) searchInput.focus();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  // Enhanced modal accessibility - prevent body scroll when modal is open
  useEffect(() => {
    const isAnyModalOpen = modalOpen || summaryModalOpen || detailsModalOpen ||
                          chatModalOpen || dictModalOpen;

    if (isAnyModalOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }

    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [modalOpen, summaryModalOpen, detailsModalOpen, chatModalOpen, dictModalOpen]);

  // Optimized product filtering with enhanced search, status, and sorting
  // Always show archived products after active ones
  const filtered = useMemo(() => {
    let result = [...products];

    // Apply search filter
    if (searchTerm) {
      const q = searchTerm.toLowerCase();
      result = result.filter(p =>
        p.name?.toLowerCase().includes(q) ||
        p.formNumber?.toLowerCase().includes(q) ||
        p.productCode?.toLowerCase().includes(q)
      );
    }

    // Apply status filter
    if (filterStatus !== 'all') {
      result = result.filter(p => (p.status || 'active') === filterStatus);
    }

    // Separate active and archived products
    const activeProducts = result.filter(p => !p.archived);
    const archivedProducts = result.filter(p => p.archived);

    // Apply sorting to each group separately
    const sortFn = (a, b) => {
      switch (sortBy) {
        case 'date':
          return (b.updatedAt?.getTime?.() || 0) - (a.updatedAt?.getTime?.() || 0);
        case 'coverage-count':
          return (b.coverageCount || 0) - (a.coverageCount || 0);
        case 'name':
        default:
          return (a.name || '').localeCompare(b.name || '');
      }
    };

    // Sort each group and combine with active first, then archived
    return [...activeProducts.sort(sortFn), ...archivedProducts.sort(sortFn)];
  }, [products, searchTerm, filterStatus, sortBy]);

  // Export products as JSON
  const handleExport = useCallback(() => {
    const dataToExport = selectedProducts.size > 0
      ? filtered.filter(p => selectedProducts.has(p.id))
      : filtered;

    const jsonString = JSON.stringify(dataToExport, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `products-export-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    showToast(`Exported ${dataToExport.length} product(s) successfully`, 'success');
  }, [filtered, selectedProducts, showToast]);

  // Memoized helper functions to prevent unnecessary re-renders
  const handleOpenDetails = useCallback((product) => {
    setSelectedProduct(product);
    setDetailsModalOpen(true);
  }, []);

  const handleEdit = useCallback((product) => {
    setEditingId(product.id);
    setName(product.name);
    setFormNumber(product.formNumber || '');
    setProductCode(product.productCode || '');
    setEffectiveDate(product.effectiveDate || '');
    setModalOpen(true);
  }, []);

  const handleArchive = useCallback((id) => {
    setDeleteProductId(id);
    setConfirmDeleteOpen(true);
  }, []);

  const handleConfirmDelete = useCallback(async () => {
    if (!deleteProductId) return;

    setIsDeleting(true);
    try {
      const product = products.find(p => p.id === deleteProductId);
      const isArchiving = !product?.archived;

      await updateDoc(doc(db, 'products', deleteProductId), {
        archived: isArchiving,
        updatedAt: new Date()
      });

      // Log audit event
      await logAuditEvent(isArchiving ? 'ARCHIVE' : 'UNARCHIVE', 'PRODUCT', deleteProductId, {
        entityName: product?.name,
        reason: 'User-initiated action'
      });

      showToast(
        `Product "${product?.name}" ${isArchiving ? 'archived' : 'unarchived'} successfully`,
        'success'
      );
      setConfirmDeleteOpen(false);
      setDeleteProductId(null);
    } catch (error) {
      console.error('Archive action failed:', error);
      showToast('Failed to update product. Please try again.', 'error');
    } finally {
      setIsDeleting(false);
    }
  }, [deleteProductId, products, showToast]);

  const handleSummary = async (id, url) => {
    if (!url) {
      alert('No form uploaded for this product.');
      return;
    }
    setLoadingSummary(prev => ({ ...prev, [id]: true }));

    try {
      console.log('ðŸ” Starting PDF extraction from URL:', url);

      // Extract text from PDF using centralized utility
      const text = await extractPdfText(url);

      console.log('ðŸ“ PDF text extracted:', {
        textLength: text?.length || 0,
        textType: typeof text,
        firstChars: text?.substring(0, 100) || 'EMPTY',
        trimmedLength: text?.trim().length || 0
      });

      // Validate extracted text
      if (!text || text.trim().length === 0) {
        throw new Error('No text could be extracted from the PDF');
      }

      // Keep first ~100k tokens to stay safely under GPT limit
      const snippet = text.split(/\s+/).slice(0, 100000).join(' ');

      console.log('âœ‚ï¸ Text snippet created:', {
        snippetLength: snippet.length,
        snippetType: typeof snippet,
        trimmedSnippetLength: snippet.trim().length,
        firstChars: snippet.substring(0, 100)
      });

      // Validate snippet before sending
      if (!snippet || snippet.trim().length < 50) {
        throw new Error('Extracted text is too short to generate a meaningful summary');
      }

      // Estimate payload size (rough approximation)
      const payloadSize = new Blob([snippet]).size;
      const payloadSizeMB = (payloadSize / (1024 * 1024)).toFixed(2);

      console.log('ðŸ“„ Sending PDF text to AI:', {
        originalLength: text.length,
        snippetLength: snippet.length,
        wordCount: snippet.split(/\s+/).length,
        payloadSizeMB: payloadSizeMB,
        pdfTextParam: snippet.substring(0, 200) + '...'
      });

      // Firebase Callable Functions have a 10MB payload limit
      if (payloadSize > 9 * 1024 * 1024) { // 9MB to be safe
        throw new Error(`PDF text is too large (${payloadSizeMB}MB). Please use a smaller document.`);
      }

      // Call Cloud Function (secure proxy to OpenAI)
      const generateSummary = httpsCallable(functions, 'generateProductSummary');

      // Ensure we're sending a plain object with string values
      const payload = {
        pdfText: String(snippet),
        systemPrompt: String(SYSTEM_INSTRUCTIONS.trim())
      };

      console.log('ðŸš€ Calling Cloud Function with payload:', {
        hasPdfText: !!payload.pdfText,
        pdfTextType: typeof payload.pdfText,
        pdfTextLength: payload.pdfText.length,
        hasSystemPrompt: !!payload.systemPrompt
      });

      const result = await generateSummary(payload);

      if (!result.data.success) {
        throw new Error('Failed to generate summary');
      }

      // Clean response
      const cleaned = result.data.content
        .replace(/```json\n?/, '')
        .replace(/\n?```/, '')
        .replace(/[\u200B-\u200D\uFEFF]/g, '')
        .trim();

      let summaryJson;
      try {
        summaryJson = JSON.parse(cleaned);
      } catch {
        throw new Error('Failed to parse AI response');
      }

      if (!summaryJson.category || !Array.isArray(summaryJson.coverages)) {
        throw new Error('Invalid AI response format');
      }

      setModalData(summaryJson);
      setSummaryModalOpen(true);
    } catch (err) {
      console.error(err);
      alert(err.message || 'Summary failed.');
    } finally {
      setLoadingSummary(prev => ({ ...prev, [id]: false }));
    }
  };

  const openChat = async (product) => {
    setSelectedProduct(product);
    setChatModalOpen(true);
    setChatMessages([]);
    setChatInput('');
    setChatLoading(false);

    // Load PDF text for context if available
    if (product.formDownloadUrl) {
      try {
        const text = await extractPdfText(product.formDownloadUrl);
        setChatPdfText(text.split(/\s+/).slice(0, 100000).join(' '));
      } catch (err) {
        console.error('Failed to load PDF for chat:', err);
        setChatPdfText('');
      }
    } else {
      setChatPdfText('');
    }
  };

  const resetForm = () => {
    setEditingId(null);
    setName('');
    setFormNumber('');
    setProductCode('');
    setEffectiveDate('');
    setFile(null);
  };

  const formatYear = value => {
    return value.replace(/\D/g, '').slice(0, 4);
  };

  const validateForm = () => {
    const errors = {};
    if (!name?.trim()) errors.name = 'Product name is required';
    if (!formNumber?.trim()) errors.formNumber = 'Form number is required';
    if (!effectiveDate?.trim()) errors.effectiveDate = 'Year is required';
    if (effectiveDate && !/^\d{4}$/.test(effectiveDate)) {
      errors.effectiveDate = 'Please enter a 4-digit year (e.g., 2024)';
    }
    return errors;
  };

  const handleSave = async () => {
    const errors = validateForm();
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors);
      return;
    }

    setIsSaving(true);
    try {
      let downloadUrl = '';
      if (file) {
        const sref = ref(storage, `forms/${file.name}`);
        await uploadBytes(sref, file);
        downloadUrl = await getDownloadURL(sref);
      }

      if (editingId) {
        // When updating, only include formDownloadUrl if a new file was uploaded
        const updateData: any = {
          name: name.trim(),
          formNumber: formNumber.trim(),
          productCode: productCode.trim(),
          updatedAt: new Date()
        };

        // Only update formDownloadUrl if a new file was provided
        if (downloadUrl) {
          updateData.formDownloadUrl = downloadUrl;
        }

        await updateDoc(doc(db, 'products', editingId), updateData);
        showToast(`Product "${name.trim()}" updated successfully`, 'success');
      } else {
        await addDoc(collection(db, 'products'), {
          name: name.trim(),
          formNumber: formNumber.trim(),
          productCode: productCode.trim(),
          effectiveDate: effectiveDate.trim(),
          formDownloadUrl: downloadUrl,
          status: 'active',
          createdAt: new Date(),
          updatedAt: new Date()
        });
        showToast(`Product "${name.trim()}" created successfully`, 'success');
      }
      setModalOpen(false);
      resetForm();
      setFormErrors({});
    } catch (error) {
      console.error('Save failed:', error);
      setFormErrors({ submit: 'Failed to save product. Please try again.' });
      showToast('Failed to save product. Please try again.', 'error');
    } finally {
      setIsSaving(false);
    }
  };

  const handleChatSend = async () => {
    if (!chatInput.trim() || chatLoading) return;

    const userMessage = chatInput.trim();
    setChatInput('');
    setChatMessages(prev => [...prev, { role: 'user', content: userMessage }]);
    setChatLoading(true);

    try {
      const systemPrompt = `You are an expert insurance assistant helping with questions about the product "${selectedProduct?.name}". ${
        chatPdfText ? 'Use the following form text as context for your answers:\n\n' + chatPdfText.slice(0, 50000) : 'No form text is available for this product.'
      }`;

      // Call Cloud Function (secure proxy to OpenAI)
      const generateChat = httpsCallable(functions, 'generateChatResponse');
      const result = await generateChat({
        messages: [
          { role: 'system', content: systemPrompt },
          ...chatMessages.slice(-10), // Keep last 10 messages for context
          { role: 'user', content: userMessage }
        ],
        model: 'gpt-4o-mini',
        maxTokens: 1000,
        temperature: 0.7
      });

      if (!result.data.success) {
        throw new Error('Failed to generate chat response');
      }

      const aiResponse = result.data.content?.trim();

      if (aiResponse) {
        setChatMessages(prev => [...prev, { role: 'assistant', content: aiResponse }]);
      } else {
        throw new Error('No response from AI');
      }
    } catch (error) {
      console.error('Chat failed:', error);
      setChatMessages(prev => [...prev, {
        role: 'assistant',
        content: 'Sorry, I encountered an error. Please try again.'
      }]);
    } finally {
      setChatLoading(false);
    }
  };



  if (loading) {
    return (
      <PageContainer withOverlay={true}>
        <MainNavigation />
        <PageContent>
          <div style={{ textAlign: 'center', padding: '60px 20px' }}>
            <LoadingSpinner type="circular" size="40px" />
            <p style={{ marginTop: '16px', color: '#6b7280', fontSize: '14px' }}>Loading products...</p>
          </div>
        </PageContent>
      </PageContainer>
    );
  }

  if (error) {
    return (
      <PageContainer withOverlay={true}>
        <MainNavigation />
        <PageContent>
          <EmptyState
            icon={<InformationCircleIcon style={{ width: '48px', height: '48px' }} />}
            title="Error loading products"
            description="Please try refreshing the page."
            variant="default"
          />
        </PageContent>
      </PageContainer>
    );
  }

  return (
    <PageContainer withOverlay={true}>
      <MainNavigation />

      <PageContent>
        {/* Page Header */}
        <EnhancedHeader
          title="Product Hub"
          subtitle={`Explore and manage ${filtered.length} active product line${filtered.length !== 1 ? 's' : ''}`}
          icon={CubeIcon}
        />

        {/* Command Bar with Search, Toggle, and Add */}
        <CommandBar>
          <CommandBarLeft>
            <ViewToggleGroup>
              <ViewToggleButton
                active={viewMode === 'cards'}
                onClick={() => setViewMode('cards')}
                title="Card view"
                aria-label="Switch to card view"
              >
                <Squares2X2Icon />
                Cards
              </ViewToggleButton>
              <ViewToggleButton
                active={viewMode === 'table'}
                onClick={() => setViewMode('table')}
                title="Table view"
                aria-label="Switch to table view"
              >
                <TableCellsIcon />
                Table
              </ViewToggleButton>
            </ViewToggleGroup>
          </CommandBarLeft>

          <CommandBarCenter>
            <SearchWrapper>
              <SearchIconWrapper>
                <MagnifyingGlassIcon />
              </SearchIconWrapper>
              <SearchInputStyled
                type="text"
                placeholder="Search products..."
                value={rawSearch}
                onChange={(e) => setRawSearch(e.target.value)}
                aria-label="Search by product name, form number, or code"
              />
            </SearchWrapper>
          </CommandBarCenter>

          <CommandBarRight>
            <AddProductButton onClick={() => setModalOpen(true)}>
              <PlusIcon />
              Add Product
            </AddProductButton>
          </CommandBarRight>
        </CommandBar>

        {/* Bulk Actions Toolbar */}
        {selectedProducts.size > 0 && (
          <BulkActionsToolbar role="toolbar" aria-label="Bulk actions">
            <BulkActionCount>{selectedProducts.size} selected</BulkActionCount>
            <BulkActionButton onClick={handleExport} title="Export selected products as JSON">
              ðŸ“¥ Export
            </BulkActionButton>
            <BulkActionButton onClick={() => setSelectedProducts(new Set())}>
              Clear Selection
            </BulkActionButton>
          </BulkActionsToolbar>
        )}

        {filtered.length > 0 ? (
          viewMode === 'cards' ? (
            // Use virtualization for large lists (>20 items) for better performance
            filtered.length > 20 ? (
              <VirtualizedGrid
                items={filtered}
                renderItem={(product) => (
                  <ProductCard
                    key={product.id}
                    product={product}
                    onEdit={handleEdit}
                    onArchive={handleArchive}
                    onOpenDetails={handleOpenDetails}
                    onSummary={handleSummary}
                    onChat={openChat}
                    loadingSummary={loadingSummary[product.id]}
                  />
                )}
                columnCount={2}
                rowHeight={350}
                height={600}
              />
            ) : (
              <ProductsGrid>
                {filtered.map(product => (
                  <ProductCard
                    key={product.id}
                    product={product}
                    onEdit={handleEdit}
                    onArchive={handleArchive}
                    onOpenDetails={handleOpenDetails}
                    onSummary={handleSummary}
                    onChat={openChat}
                    loadingSummary={loadingSummary[product.id]}
                  />
                ))}
              </ProductsGrid>
            )
          ) : (
            <TableContainer>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableHeader>Product Name</TableHeader>
                    <TableHeader>Form Number</TableHeader>
                    <TableHeader>Product Code</TableHeader>
                    <TableHeader>Effective Date</TableHeader>
                    <TableHeader align="center">Actions</TableHeader>
                  </TableRow>
                </TableHead>
                <tbody>
                  {filtered.map(product => (
                    <TableRow key={product.id}>
                      <TableCell>
                        <strong>{product.name}</strong>
                      </TableCell>
                      <TableCell>
                        {product.formDownloadUrl ? (
                          <a
                            href={product.formDownloadUrl}
                            target="_blank"
                            rel="noopener noreferrer"
                            style={{ color: '#6366f1', textDecoration: 'none' }}
                          >
                            {product.formNumber || 'Download'}
                          </a>
                        ) : (
                          product.formNumber || '-'
                        )}
                      </TableCell>
                      <TableCell>{product.productCode || '-'}</TableCell>
                      <TableCell>{product.effectiveDate || '-'}</TableCell>
                      <TableCell>
                        <TableActions>
                          <IconButton onClick={() => handleOpenDetails(product)}>
                            <InformationCircleIcon width={14} height={14} />
                          </IconButton>
                          {!product.archived && (
                            <IconButton onClick={() => handleEdit(product)}>
                              <PencilIcon width={14} height={14} />
                            </IconButton>
                          )}
                          <IconButton className="danger" onClick={() => handleArchive(product.id)}>
                            <TrashIcon width={14} height={14} />
                          </IconButton>
                        </TableActions>
                      </TableCell>
                    </TableRow>
                  ))}
                </tbody>
              </Table>
            </TableContainer>
          )
        ) : (
          <div>
            <EmptyState
              icon={<CubeIcon style={{ width: '48px', height: '48px' }} />}
              title={searchTerm ? 'No products match your search' : 'No products yet'}
              description={
                searchTerm
                  ? `No products found for "${searchTerm}". Try adjusting your search terms, filters, or create a new product.`
                  : 'Get started by creating your first insurance product. Click "Add Product" above or use Cmd+N.'
              }
              variant="default"
            />
          </div>
        )}
      </PageContent>

      {/* Add/Edit Modal */}
      {modalOpen && (
        <Modal
          onClick={() => { setModalOpen(false); resetForm(); }}
          role="dialog"
          aria-modal="true"
          aria-labelledby="product-modal-title"
        >
          <ModalContent onClick={e => e.stopPropagation()}>
            <ModalHeader>
              <ModalTitle id="product-modal-title">{editingId ? 'Edit' : 'Add'} Product</ModalTitle>
              <CloseButton
                onClick={() => { setModalOpen(false); resetForm(); }}
                aria-label="Close modal"
                title="Close (Esc)"
              >
                <XMarkIcon width={16} height={16} />
              </CloseButton>
            </ModalHeader>
            <div style={{ padding: '24px', overflowY: 'auto', maxHeight: 'calc(90vh - 180px)' }}>
              {formErrors.submit && <FormError>{formErrors.submit}</FormError>}

              <FormField>
                <FormLabel htmlFor="product-name">
                  Product Name
                  {formErrors.name && <FormLabelHint style={{ color: '#dc2626' }}>âœ• {formErrors.name}</FormLabelHint>}
                </FormLabel>
                <FormInput
                  id="product-name"
                  placeholder="e.g., Commercial Property"
                  value={name}
                  onChange={e => { setName(e.target.value); if (formErrors.name) setFormErrors(prev => ({ ...prev, name: '' })); }}
                  style={{ borderColor: formErrors.name ? '#dc2626' : undefined }}
                  aria-invalid={!!formErrors.name}
                  aria-describedby={formErrors.name ? 'product-name-error' : undefined}
                />
                {formErrors.name && <div id="product-name-error" style={{ display: 'none' }}>{formErrors.name}</div>}
              </FormField>

              <FormField>
                <FormLabel>
                  Form Number
                  {formErrors.formNumber && <FormLabelHint style={{ color: '#dc2626' }}>âœ• {formErrors.formNumber}</FormLabelHint>}
                </FormLabel>
                <FormInput
                  placeholder="e.g., CP 00 10"
                  value={formNumber}
                  onChange={e => { setFormNumber(e.target.value); if (formErrors.formNumber) setFormErrors(prev => ({ ...prev, formNumber: '' })); }}
                  style={{ borderColor: formErrors.formNumber ? '#dc2626' : undefined }}
                />
              </FormField>

              <FormField>
                <FormLabel>Product Code</FormLabel>
                <FormInput
                  placeholder="e.g., CPP"
                  value={productCode}
                  onChange={e => setProductCode(e.target.value)}
                />
              </FormField>

              <FormField>
                <FormLabel>
                  Year
                  {formErrors.effectiveDate && <FormLabelHint style={{ color: '#dc2626' }}>âœ• {formErrors.effectiveDate}</FormLabelHint>}
                </FormLabel>
                <FormInput
                  placeholder="e.g., 2024"
                  maxLength={4}
                  value={effectiveDate}
                  onChange={e => { setEffectiveDate(formatYear(e.target.value)); if (formErrors.effectiveDate) setFormErrors(prev => ({ ...prev, effectiveDate: '' })); }}
                  style={{ borderColor: formErrors.effectiveDate ? '#dc2626' : undefined }}
                />
              </FormField>

              <FormField>
                <FormLabel>Upload Form (PDF)</FormLabel>
                <FileInput
                  type="file"
                  accept=".pdf"
                  onChange={e => setFile(e.target.files[0])}
                />
                {file && <FileName>{file.name}</FileName>}
              </FormField>
            </div>

            <ModalActions>
              <CancelButton onClick={() => { setModalOpen(false); resetForm(); }}>
                Cancel
              </CancelButton>
              <SaveButton onClick={handleSave} disabled={isSaving}>
                {isSaving ? 'Saving...' : (editingId ? 'Update' : 'Create')}
              </SaveButton>
            </ModalActions>
          </ModalContent>
        </Modal>
      )}

      {/* Enhanced Summary Modal */}
      {summaryModalOpen && modalData && (
        <Modal onClick={() => setSummaryModalOpen(false)}>
          <EnhancedModalContent onClick={e => e.stopPropagation()}>
            <StickyModalHeader>
              <EnhancedModalTitle>AI Summary</EnhancedModalTitle>
              <CloseButton onClick={() => setSummaryModalOpen(false)}>
                <XMarkIcon />
              </CloseButton>
            </StickyModalHeader>
            <ScrollableModalBody>
              <ContentSection>
                <SectionHeader>Form Category</SectionHeader>
                <p>{modalData.category || 'Not specified'}</p>
              </ContentSection>

              {Array.isArray(modalData.coverages) && modalData.coverages.length > 0 && (
                <ContentSection>
                  <SectionHeader>Coverages ({modalData.coverages.length})</SectionHeader>
                  {modalData.coverages.map((c, idx) => (
                    <div key={idx} style={{ marginBottom: '24px', paddingBottom: '16px', borderBottom: '1px solid #e5e7eb' }}>
                      <h3 style={{ margin: '0 0 12px 0', fontSize: '16px', fontWeight: '600', color: '#111827' }}>
                        {c.coverageName || 'Unnamed Coverage'}
                      </h3>
                      {c.scopeOfCoverage && (
                        <p style={{ margin: '0 0 8px 0', fontSize: '14px', color: '#4b5563', lineHeight: '1.6' }}>
                          {c.scopeOfCoverage}
                        </p>
                      )}
                      {c.limits && (
                        <p style={{ margin: '0 0 8px 0', fontSize: '14px', color: '#4b5563' }}>
                          <strong style={{ color: '#6366f1' }}>Limits:</strong> {c.limits}
                        </p>
                      )}
                      {Array.isArray(c.perilsCovered) && c.perilsCovered.length > 0 && (
                        <p style={{ margin: '0', fontSize: '14px', color: '#4b5563' }}>
                          <strong style={{ color: '#6366f1' }}>Perils:</strong> {c.perilsCovered.join(', ')}
                        </p>
                      )}
                    </div>
                  ))}
                </ContentSection>
              )}

              {Array.isArray(modalData.generalConditions) && modalData.generalConditions.length > 0 && (
                <ContentSection>
                  <SectionHeader>General Conditions</SectionHeader>
                  <ul style={{ margin: '0', paddingLeft: '20px' }}>
                    {modalData.generalConditions.map((condition, idx) => (
                      <li key={idx} style={{ margin: '4px 0', fontSize: '14px', color: '#4b5563', lineHeight: '1.6' }}>
                        {condition}
                      </li>
                    ))}
                  </ul>
                </ContentSection>
              )}

              {Array.isArray(modalData.generalExclusions) && modalData.generalExclusions.length > 0 && (
                <ContentSection>
                  <SectionHeader>General Exclusions</SectionHeader>
                  <ul style={{ margin: '0', paddingLeft: '20px' }}>
                    {modalData.generalExclusions.map((exclusion, idx) => (
                      <li key={idx} style={{ margin: '4px 0', fontSize: '14px', color: '#4b5563', lineHeight: '1.6' }}>
                        {exclusion}
                      </li>
                    ))}
                  </ul>
                </ContentSection>
              )}
            </ScrollableModalBody>
          </EnhancedModalContent>
        </Modal>
      )}

      {/* Details Modal */}
      {detailsModalOpen && selectedProduct && (
        <Modal onClick={() => setDetailsModalOpen(false)}>
          <ModalContent onClick={e => e.stopPropagation()}>
            <ModalHeader>
              <ModalTitle>Product Details</ModalTitle>
              <CloseButton onClick={() => setDetailsModalOpen(false)}>âœ•</CloseButton>
            </ModalHeader>
            <DetailsList>
              <DetailItem>
                <DetailLabel>Form Number:</DetailLabel>
                <DetailValue>
                  {selectedProduct.formDownloadUrl ? (
                    <DetailLink href={selectedProduct.formDownloadUrl} target="_blank" rel="noopener noreferrer">
                      {selectedProduct.formNumber || 'Download'}
                    </DetailLink>
                  ) : (
                    selectedProduct.formNumber || '-'
                  )}
                </DetailValue>
              </DetailItem>
              <DetailItem>
                <DetailLabel>Product Code:</DetailLabel>
                <DetailValue>{selectedProduct.productCode || '-'}</DetailValue>
              </DetailItem>
              <DetailItem>
                <DetailLabel>Effective Date:</DetailLabel>
                <DetailValue>{selectedProduct.effectiveDate || '-'}</DetailValue>
              </DetailItem>
            </DetailsList>
          </ModalContent>
        </Modal>
      )}

      {/* Data Dictionary Modal */}
      <DataDictionaryModal
        open={dictModalOpen}
        onClose={() => setDictModalOpen(false)}
      />

      {/* Enhanced Chat Modal */}
      {chatModalOpen && selectedProduct && (
        <Modal onClick={() => setChatModalOpen(false)}>
          <EnhancedModalContent onClick={e => e.stopPropagation()}>
            <StickyModalHeader>
              <EnhancedModalTitle>Chat with {selectedProduct.name}</EnhancedModalTitle>
              <CloseButton onClick={() => setChatModalOpen(false)}>
                <XMarkIcon />
              </CloseButton>
            </StickyModalHeader>
            <div style={{ display: 'flex', flexDirection: 'column', height: '500px' }}>
              <div style={{ flex: 1, overflowY: 'auto', padding: '24px 32px 16px', background: '#f8fafc' }}>
                {chatMessages.length === 0 && (
                  <div style={{
                    textAlign: 'center',
                    color: '#6b7280',
                    fontStyle: 'italic',
                    padding: '40px 20px',
                    background: '#ffffff',
                    borderRadius: '12px',
                    border: '1px solid #e5e7eb'
                  }}>
                    Ask me anything about this insurance product. I have access to the form content to help answer your questions.
                  </div>
                )}
                {chatMessages.map((msg, idx) => (
                  <div key={idx} style={{
                    marginBottom: '16px',
                    display: 'flex',
                    justifyContent: msg.role === 'user' ? 'flex-end' : 'flex-start'
                  }}>
                    <div style={{
                      maxWidth: '80%',
                      padding: '12px 16px',
                      borderRadius: '12px',
                      background: msg.role === 'user' ? '#6366f1' : '#ffffff',
                      color: msg.role === 'user' ? '#ffffff' : '#374151',
                      border: msg.role === 'user' ? 'none' : '1px solid #e5e7eb',
                      fontSize: '14px',
                      lineHeight: '1.5',
                      boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)'
                    }}>
                      {msg.role === 'user' ? (
                        msg.content
                      ) : (
                        <div style={{ color: '#374151' }}>
                          <MarkdownRenderer>{msg.content}</MarkdownRenderer>
                        </div>
                      )}
                    </div>
                  </div>
                ))}
                {chatLoading && (
                  <div style={{ display: 'flex', justifyContent: 'flex-start', marginBottom: '16px' }}>
                    <div style={{
                      padding: '12px 16px',
                      borderRadius: '12px',
                      background: '#ffffff',
                      border: '1px solid #e5e7eb',
                      boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)'
                    }}>
                      <LoadingSpinner />
                    </div>
                  </div>
                )}
              </div>
              <div style={{
                padding: '16px 32px 32px',
                borderTop: '1px solid #e5e7eb',
                background: '#ffffff'
              }}>
                <div style={{ display: 'flex', gap: '12px', alignItems: 'flex-end' }}>
                  <ChatInput
                    placeholder="Ask a question about this product..."
                    value={chatInput}
                    onChange={e => setChatInput(e.target.value)}
                    onKeyDown={e => e.key === 'Enter' && !e.shiftKey && (e.preventDefault(), handleChatSend())}
                  />
                  <ChatSendButton onClick={handleChatSend} disabled={!chatInput.trim() || chatLoading}>
                    <PaperAirplaneIcon width={16} height={16} />
                  </ChatSendButton>
                </div>
              </div>
            </div>
          </EnhancedModalContent>
        </Modal>
      )}

      {/* Data Dictionary Modal */}
      <DataDictionaryModal
        open={dictModalOpen}
        onClose={() => setDictModalOpen(false)}
      />

      {/* Archive/Unarchive Confirmation Modal */}
      {(() => {
        const product = products.find(p => p.id === deleteProductId);
        const isArchiving = !product?.archived;
        return (
          <ConfirmationModal
            isOpen={confirmDeleteOpen}
            title={isArchiving ? "Archive Product" : "Unarchive Product"}
            message={`Are you sure you want to ${isArchiving ? 'archive' : 'unarchive'} "${product?.name || 'this product'}"? ${isArchiving ? 'Archived products will not appear in search or AI features.' : 'This product will be available again in search and AI features.'}`}
            confirmText={isArchiving ? "Archive" : "Unarchive"}
            cancelText="Cancel"
            isDangerous={isArchiving}
            isLoading={isDeleting}
            onConfirm={handleConfirmDelete}
            onCancel={() => {
              setConfirmDeleteOpen(false);
              setDeleteProductId(null);
            }}
          />
        );
      })()}

      {/* Toast Notifications */}
      <ToastContainer>
        {toasts.map(toast => (
          <Toast key={toast.id} $type={toast.type}>
            {toast.message}
          </Toast>
        ))}
      </ToastContainer>
    </PageContainer>
  );
});

ProductHub.displayName = 'ProductHub';

export default ProductHub;
```

---

## src/components/RequireAuth.tsx

**Path:** `src/components/RequireAuth.tsx`

```tsx
// src/components/RequireAuth.tsx
import React, { useEffect, useState } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { onAuthStateChanged, getAuth, type User } from 'firebase/auth';
import logger, { LOG_CATEGORIES } from '@utils/logger';

/**
 * RequireAuth
 * 
 * Guards protected routes by verifying Firebase Auth state.
 * Provides a secure, reactive gate compared to sessionStorage.
 * - Displays a loading gate while determining auth status
 * - Redirects unauthenticated users to /login (with return path)
 * - Supports session fallback for local dev if needed
 */
interface RequireAuthProps {
  children: React.ReactNode;
}

const RequireAuth: React.FC<RequireAuthProps> = ({ children }) => {
  const location = useLocation();
  const [authUser, setAuthUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const auth = getAuth();

    const unsubscribe = onAuthStateChanged(
      auth,
      (user) => {
        setAuthUser(user);
        setLoading(false);
        if (user) {
          logger.info(LOG_CATEGORIES.DATA, 'User authenticated', {
            uid: user.uid,
            email: user.email
          });
        } else {
          logger.info(LOG_CATEGORIES.DATA, 'No active Firebase session');
        }
      },
      (error) => {
        logger.error(LOG_CATEGORIES.ERROR, 'Auth state listener failed', {}, error as Error);
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, []);

  // Fallback for local development (when Firebase Auth may be disabled)
  const sessionStatus = sessionStorage.getItem('ph-authed');
  const sessionAuthenticated = sessionStatus === 'admin' || sessionStatus === 'guest';
  const isAuthenticated = !!authUser || sessionAuthenticated;

  if (loading) {
    return (
      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          minHeight: '100vh',
          color: '#6b7280',
          fontSize: 16
        }}
      >
        Checking authenticationâ€¦
      </div>
    );
  }

  return isAuthenticated ? (
    <>{children}</>
  ) : (
    <Navigate to="/login" state={{ from: location }} replace />
  );
};

export default RequireAuth;
```

---

## src/components/RulesScreen.tsx

**Path:** `src/components/RulesScreen.tsx`

```tsx
// src/components/RulesScreen.js
import React, { useEffect, useState, useRef, useMemo, useCallback } from 'react';
import styled from 'styled-components';
import { useNavigate, useParams } from 'react-router-dom';
import { db } from '../firebase';
import { collection, getDocs, addDoc, deleteDoc, doc, updateDoc, getDoc } from 'firebase/firestore';
import { CoverageSnapshot } from '@components/common/CoverageSnapshot';
import {
  PlusIcon,
  TrashIcon,
  XMarkIcon,
  PencilIcon,
  MagnifyingGlassIcon,
  ArrowLeftIcon,
  Cog6ToothIcon,
  ShieldCheckIcon,
  DocumentTextIcon,

  Squares2X2Icon,
  TableCellsIcon,
  ListBulletIcon,
  ArrowUpIcon,
  ArrowDownIcon,
  TagIcon,
  BuildingOfficeIcon,
  CurrencyDollarIcon
} from '@heroicons/react/24/solid';

import MainNavigation from '../components/ui/Navigation';
import { PageContainer, PageContent } from '../components/ui/PageContainer';
import EnhancedHeader from '../components/ui/EnhancedHeader';


/* ---------- Modern Styled Components ---------- */
import { keyframes } from 'styled-components';

// Animations
const slideIn = keyframes`
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
`;

// Rules Stats Dashboard
const RulesStatsDashboard = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
  animation: ${slideIn} 0.4s ease-out;
`;

const RulesStatCard = styled.div<{ $color?: string }>`
  background: white;
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: ${({ $color }) => $color || 'linear-gradient(90deg, #6366f1, #8b5cf6)'};
  }

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
    border-color: transparent;
  }
`;

const RulesStatValue = styled.div`
  font-size: 28px;
  font-weight: 700;
  color: #1e293b;
  margin-bottom: 4px;
  letter-spacing: -0.02em;
`;

const RulesStatLabel = styled.div`
  font-size: 13px;
  font-weight: 500;
  color: #64748b;
  display: flex;
  align-items: center;
  gap: 6px;

  svg {
    width: 14px;
    height: 14px;
    opacity: 0.7;
  }
`;

// Main Container
const Container = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
  display: flex;
  flex-direction: column;
`;

const MainContent = styled.main`
  flex: 1;
  padding: 32px 32px 80px;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;

  @media (max-width: 768px) {
    padding: 24px 20px 60px;
  }
`;

// Header Section
const HeaderSection = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 32px;
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  background: white;
  color: #6b7280;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: #6366f1;
    background: rgba(99, 102, 241, 0.05);
    color: #6366f1;
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

const TitleContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const TitleIcon = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 48px;
  height: 48px;
  border-radius: 12px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;

  svg {
    width: 24px;
    height: 24px;
  }
`;

const PageTitle = styled.h1`
  margin: 0;
  font-size: 28px;
  font-weight: 700;
  background: linear-gradient(135deg, #1e293b 0%, #475569 50%, #64748b 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  letter-spacing: -0.02em;
`;

// Search Container
const SearchContainer = styled.div`
  position: relative;
  margin-bottom: 24px;
  max-width: 500px;
`;

const SearchInput = styled.input`
  width: 100%;
  padding: 12px 16px 12px 44px;
  font-size: 16px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(20px);
  transition: all 0.3s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    background: white;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;

const SearchIcon = styled.div`
  position: absolute;
  left: 14px;
  top: 50%;
  transform: translateY(-50%);
  color: #94a3b8;
  pointer-events: none;

  svg {
    width: 20px;
    height: 20px;
  }
`;

// Enhanced Filter Controls
const FilterContainer = styled.div`
  display: flex;
  gap: 12px;
  margin-bottom: 24px;
  flex-wrap: wrap;
  align-items: center;
`;

const FilterRow = styled.div`
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: center;
  width: 100%;
  margin-bottom: 16px;

  &:last-child {
    margin-bottom: 0;
  }
`;

const FilterSelect = styled.select`
  padding: 8px 12px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 8px;
  background: white;
  font-size: 14px;
  color: #374151;
  cursor: pointer;
  transition: all 0.2s ease;
  height: 40px;
  min-width: 140px;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const FilterLabel = styled.label`
  font-size: 13px;
  font-weight: 600;
  color: #374151;
  margin-right: 8px;
  white-space: nowrap;
`;

const FilterGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(255, 255, 255, 0.8);
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid rgba(226, 232, 240, 0.6);
`;



const ViewModeToggle = styled.div`
  display: flex;
  background: rgba(255, 255, 255, 0.9);
  border-radius: 8px;
  padding: 4px;
  border: 1px solid rgba(226, 232, 240, 0.6);
`;

const ViewModeButton = styled.button.withConfig({
  shouldForwardProp: (prop) => !['active'].includes(prop),
})`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border: none;
  border-radius: 6px;
  background: ${({ active }) => active ? '#6366f1' : 'transparent'};
  color: ${({ active }) => active ? 'white' : '#64748b'};
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: ${({ active }) => active ? '#5b5bd6' : 'rgba(99, 102, 241, 0.1)'};
    color: ${({ active }) => active ? 'white' : '#6366f1'};
  }

  svg {
    width: 14px;
    height: 14px;
  }
`;

const SortControls = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
`;

const SortSelect = styled.select`
  padding: 6px 10px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 6px;
  background: white;
  font-size: 13px;
  color: #374151;
  cursor: pointer;
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
  }
`;

const SortOrderButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 6px;
  background: white;
  color: #6b7280;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: #6366f1;
    background: rgba(99, 102, 241, 0.05);
    color: #6366f1;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;



// Toggle Switch for Proprietary Filter
const ToggleContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  height: 36px;
`;

const ToggleLabel = styled.span`
  font-size: 13px;
  font-weight: 500;
  color: #374151;
`;

const ToggleSwitch = styled.div`
  position: relative;
  width: 44px;
  height: 24px;
  background: ${props => props.active ? '#6366f1' : '#e5e7eb'};
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: ${props => props.active ? '#5b5bd6' : '#d1d5db'};
  }
`;

const ToggleKnob = styled.div`
  position: absolute;
  top: 2px;
  left: ${props => props.active ? '22px' : '2px'};
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
`;

// Rules Grid
const RulesGrid = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-bottom: 120px;

  @media (max-width: 768px) {
    gap: 12px;
  }
`;

// Rule Card
const RuleCard = styled.div`
  background: white;
  border-radius: 12px;
  padding: 20px;
  border: 1px solid #e2e8f0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.2s ease;
  position: relative;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
    border-color: #6366f1;
  }
`;

const CardHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 16px;
  gap: 12px;
`;

const CardTitleContainer = styled.div`
  flex: 1;
`;

const CardTitle = styled.h3`
  margin: 0 0 4px 0;
  font-size: 18px;
  font-weight: 600;
  color: #1e293b;
  line-height: 1.3;
`;

const CardSubtitle = styled.div`
  font-size: 14px;
  color: #64748b;
  display: flex;
  align-items: center;
  gap: 8px;
`;

const CardActions = styled.div`
  display: flex;
  gap: 8px;
`;

const IconButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 8px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  background: white;
  color: #6b7280;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: #6366f1;
    background: rgba(99, 102, 241, 0.05);
    color: #6366f1;
  }

  &.danger:hover {
    border-color: #ef4444;
    background: rgba(239, 68, 68, 0.05);
    color: #ef4444;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const CardContent = styled.div`
  margin-bottom: 16px;
`;

const RuleSection = styled.div`
  margin-bottom: 12px;

  &:last-child {
    margin-bottom: 0;
  }
`;

const SectionLabel = styled.div`
  font-size: 12px;
  font-weight: 600;
  color: #6b7280;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 4px;
`;

const SectionContent = styled.div`
  font-size: 14px;
  color: #374151;
  line-height: 1.5;

  &.code {
    font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    background: rgba(248, 250, 252, 0.8);
    padding: 8px 12px;
    border-radius: 6px;
    border: 1px solid rgba(226, 232, 240, 0.6);
    white-space: pre-wrap;
    word-break: break-word;
  }
`;

const CardMetrics = styled.div`
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
`;

const MetricBadge = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  background: ${props => {
    if (props.type === 'proprietary') return 'rgba(239, 68, 68, 0.1)';
    if (props.type === 'product') return 'rgba(99, 102, 241, 0.1)';
    return 'rgba(107, 114, 128, 0.1)';
  }};
  color: ${props => {
    if (props.type === 'proprietary') return '#ef4444';
    if (props.type === 'product') return '#6366f1';
    return '#6b7280';
  }};
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;

  svg {
    width: 12px;
    height: 12px;
  }
`;

// Add Button
const AddButton = styled.button`
  position: fixed;
  bottom: 24px;
  right: 24px;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 16px 20px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 16px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(99, 102, 241, 0.3);
  transition: all 0.3s ease;
  z-index: 100;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 32px rgba(99, 102, 241, 0.4);
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

// Modal Components
const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(4px);
`;

const ModalContainer = styled.div`
  background: white;
  border-radius: 16px;
  padding: 24px;
  max-width: 600px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
`;

const ModalHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
`;

const ModalTitle = styled.h2`
  margin: 0;
  font-size: 20px;
  font-weight: 600;
  color: #1e293b;
`;

const CloseButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  border: none;
  background: rgba(107, 114, 128, 0.1);
  color: #6b7280;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const FormGroup = styled.div`
  margin-bottom: 20px;
`;

const FormLabel = styled.label`
  display: block;
  font-size: 14px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 6px;
`;

const FormInput = styled.input`
  width: 100%;
  padding: 12px 16px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 8px;
  font-size: 14px;
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #94a3b8;
  }
`;



const FormSelect = styled.select`
  width: 100%;
  padding: 12px 16px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 8px;
  font-size: 14px;
  background: white;
  cursor: pointer;
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const FormCheckbox = styled.input`
  margin-right: 8px;
  transform: scale(1.2);
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 24px;
`;

const PrimaryButton = styled.button`
  padding: 12px 20px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
`;

const SecondaryButton = styled.button`
  padding: 12px 20px;
  background: white;
  color: #6b7280;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 8px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: #6366f1;
    color: #6366f1;
  }
`;

// Empty State
const EmptyState = styled.div`
  text-align: center;
  padding: 60px 20px;
  color: #6b7280;
`;

const EmptyStateTitle = styled.h3`
  margin: 0 0 8px 0;
  font-size: 18px;
  font-weight: 600;
  color: #374151;
`;

const EmptyStateText = styled.p`
  margin: 0;
  font-size: 14px;
  line-height: 1.5;
`;

/**
 * Memoized Rule Card Item Component
 * Prevents unnecessary re-renders when parent component updates
 */
interface RuleCardItemProps {
  rule: any;
  getProductName: (productId: string) => string;
  getTargetName: (rule: any) => string;
  getRuleTypeColor: (ruleType: string) => string;
  onEdit: (rule: any) => void;
  onDelete: (ruleId: string) => void;
}

const RuleCardItem = React.memo(({
  rule,
  getProductName,
  getTargetName,
  getRuleTypeColor,
  onEdit,
  onDelete
}: RuleCardItemProps) => (
  <RuleCard>
    <CardHeader>
      <CardTitleContainer>
        <CardTitle>
          {rule.name || 'Unnamed Rule'}
        </CardTitle>
        <CardSubtitle>
          <span>{getProductName(rule.productId)}</span>
          {rule.ruleType && (
            <>
              <span>â€¢</span>
              <span style={{ color: getRuleTypeColor(rule.ruleType) }}>
                {rule.ruleType}
              </span>
            </>
          )}
          {rule.targetId && (
            <>
              <span>â€¢</span>
              <span>{getTargetName(rule)}</span>
            </>
          )}
        </CardSubtitle>
      </CardTitleContainer>
      <CardActions>
        <IconButton onClick={() => onEdit(rule)}>
          <PencilIcon />
        </IconButton>
        <IconButton className="danger" onClick={() => onDelete(rule.id)}>
          <TrashIcon />
        </IconButton>
      </CardActions>
    </CardHeader>

    <CardContent>
      {rule.condition && (
        <RuleSection>
          <SectionLabel>When</SectionLabel>
          <SectionContent>{rule.condition}</SectionContent>
        </RuleSection>
      )}

      {rule.outcome && (
        <RuleSection>
          <SectionLabel>Then</SectionLabel>
          <SectionContent>{rule.outcome}</SectionContent>
        </RuleSection>
      )}

      {rule.reference && (
        <RuleSection>
          <SectionLabel>Reference</SectionLabel>
          <SectionContent>{rule.reference}</SectionContent>
        </RuleSection>
      )}
    </CardContent>

    <CardMetrics>
      {rule.ruleType && (
        <MetricBadge style={{ backgroundColor: `${getRuleTypeColor(rule.ruleType)}15`, color: getRuleTypeColor(rule.ruleType), border: `1px solid ${getRuleTypeColor(rule.ruleType)}30` }}>
          {rule.ruleType === 'Coverage' && <ShieldCheckIcon />}
          {rule.ruleType === 'Forms' && <DocumentTextIcon />}
          {rule.ruleType === 'Pricing' && <CurrencyDollarIcon />}
          {rule.ruleType === 'Product' && <BuildingOfficeIcon />}
          {rule.ruleType} Rule
        </MetricBadge>
      )}
      {rule.ruleCategory && (
        <MetricBadge style={{ backgroundColor: 'rgba(34, 197, 94, 0.1)', color: '#22c55e', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
          <TagIcon />
          {rule.ruleCategory}
        </MetricBadge>
      )}
      {rule.status && rule.status !== 'Active' && (
        <MetricBadge style={{
          backgroundColor: rule.status === 'Draft' ? 'rgba(251, 191, 36, 0.1)' : 'rgba(107, 114, 128, 0.1)',
          color: rule.status === 'Draft' ? '#fbbf24' : '#6b7280',
          border: `1px solid ${rule.status === 'Draft' ? 'rgba(251, 191, 36, 0.3)' : 'rgba(107, 114, 128, 0.3)'}`
        }}>
          {rule.status}
        </MetricBadge>
      )}
      {rule.proprietary && (
        <MetricBadge type="proprietary">
          <ShieldCheckIcon />
          Proprietary
        </MetricBadge>
      )}
      {rule.reference && (
        <MetricBadge>
          <DocumentTextIcon />
          Referenced
        </MetricBadge>
      )}
    </CardMetrics>
  </RuleCard>
), (prevProps, nextProps) => {
  // Custom comparison: only re-render if rule data or callbacks change
  return (
    prevProps.rule === nextProps.rule &&
    prevProps.onEdit === nextProps.onEdit &&
    prevProps.onDelete === nextProps.onDelete
  );
});

RuleCardItem.displayName = 'RuleCardItem';

export default function RulesScreen() {
  const navigate = useNavigate();
  const { productId: preselectedProductId, coverageId: preselectedCoverageId } = useParams();

  // State management
  const [rules, setRules] = useState([]);
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [modalOpen, setModalOpen] = useState(false);
  const [editingRule, setEditingRule] = useState(null);
  const [selectedCoverageName, setSelectedCoverageName] = useState('');
  const [selectedCoverageData, setSelectedCoverageData] = useState<any>(null);
  const [parentCoverageData, setParentCoverageData] = useState<any>(null);
  const [coverageFormsCount, setCoverageFormsCount] = useState(0);
  const [coverageStatesCount, setCoverageStatesCount] = useState(0);

  // Enhanced form state with comprehensive rule structure
  const [formData, setFormData] = useState({
    name: '',
    productId: preselectedProductId || '',
    ruleType: '', // 'Product', 'Coverage', 'Forms', 'Pricing'
    ruleCategory: '', // 'Eligibility', 'Pricing', 'Compliance', 'Coverage', 'Forms'
    targetId: '',
    condition: '',
    outcome: '',
    reference: '',
    proprietary: false,
    status: 'Active' // 'Active', 'Inactive', 'Draft', 'Under Review'
  });

  // Additional state for dynamic data and enhanced functionality
  const [coverages, setCoverages] = useState([]);
  const [forms, setForms] = useState([]);
  const [pricingSteps, setPricingSteps] = useState([]);
  const [loadingTargets, setLoadingTargets] = useState(false);
  const [ruleCategories] = useState(['Eligibility', 'Pricing', 'Compliance', 'Coverage', 'Forms']);
  const [statuses] = useState(['Active', 'Inactive', 'Draft', 'Under Review', 'Archived']);

  // Enhanced search and filter state
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedProductFilter, setSelectedProductFilter] = useState('');
  const [selectedTypeFilter, setSelectedTypeFilter] = useState('');
  const [selectedCategoryFilter, setSelectedCategoryFilter] = useState('');
  const [selectedStatusFilter, setSelectedStatusFilter] = useState('');
  const [sortBy, setSortBy] = useState('name');
  const [sortOrder, setSortOrder] = useState('asc');
  const [viewMode, setViewMode] = useState('cards'); // 'cards', 'table', 'hierarchy'
  const searchRef = useRef(null);

  // Load data on mount
  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        // Fetch rules
        const rulesSnap = await getDocs(collection(db, 'rules'));
        const rulesList = rulesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setRules(rulesList);

        // Fetch products for associations
        const productsSnap = await getDocs(collection(db, 'products'));
        const productsList = productsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setProducts(productsList);

        // Fetch all forms for rule targeting
        const formsSnap = await getDocs(collection(db, 'forms'));
        const formsList = formsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setForms(formsList);

        // Fetch pricing steps for pricing rules
        const stepsSnap = await getDocs(collection(db, 'steps'));
        const stepsList = stepsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setPricingSteps(stepsList);

        // If we have a preselected product, load its coverages and pricing steps
        if (preselectedProductId) {
          await loadCoveragesForProduct(preselectedProductId);
          loadPricingStepsForProduct(preselectedProductId);
        }

        // If we have a preselected coverage, load full coverage data for snapshot
        if (preselectedProductId && preselectedCoverageId) {
          const coverageDocRef = doc(db, `products/${preselectedProductId}/coverages`, preselectedCoverageId);
          const coverageSnap = await getDoc(coverageDocRef);
          if (coverageSnap.exists()) {
            const coverageData = { id: coverageSnap.id, ...coverageSnap.data() };
            setSelectedCoverageName(coverageData.name || 'Unknown Coverage');
            setSelectedCoverageData(coverageData);
            setCoverageStatesCount((coverageData.states || []).length);

            // Load parent coverage if exists
            if (coverageData.parentCoverageId) {
              const parentRef = doc(db, `products/${preselectedProductId}/coverages`, coverageData.parentCoverageId);
              const parentSnap = await getDoc(parentRef);
              if (parentSnap.exists()) {
                setParentCoverageData({ id: parentSnap.id, ...parentSnap.data() });
              }
            }

            // Load forms count for this coverage
            const formsSnap = await getDocs(collection(db, `products/${preselectedProductId}/coverages/${preselectedCoverageId}/forms`));
            setCoverageFormsCount(formsSnap.size);
          }
        }
      } catch (error) {
        console.error('Error fetching data:', error);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [preselectedProductId, preselectedCoverageId]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === '/' && !e.target.matches('input, textarea')) {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // Enhanced filtering with comprehensive filter options
  const filteredRules = useMemo(() => {
    let filtered = rules;

    // Coverage filter (from URL parameter) - highest priority
    if (preselectedCoverageId) {
      filtered = filtered.filter(rule =>
        rule.ruleType === 'Coverage' && rule.targetId === preselectedCoverageId
      );
    }

    // Product filter (from URL parameter or dropdown)
    if (preselectedProductId) {
      filtered = filtered.filter(rule => rule.productId === preselectedProductId);
    } else if (selectedProductFilter) {
      filtered = filtered.filter(rule => rule.productId === selectedProductFilter);
    }

    // Text search across multiple fields
    if (searchTerm) {
      const search = searchTerm.toLowerCase();
      filtered = filtered.filter(rule =>
        (rule.name || '').toLowerCase().includes(search) ||
        (rule.condition || '').toLowerCase().includes(search) ||
        (rule.outcome || '').toLowerCase().includes(search) ||
        (rule.reference || '').toLowerCase().includes(search) ||
        (rule.ruleType || '').toLowerCase().includes(search) ||
        (rule.ruleCategory || '').toLowerCase().includes(search)
      );
    }

    // Rule category filter
    if (selectedCategoryFilter) {
      filtered = filtered.filter(rule => rule.ruleCategory === selectedCategoryFilter);
    }

    // Status filter
    if (selectedStatusFilter) {
      filtered = filtered.filter(rule => rule.status === selectedStatusFilter);
    }

    // Type filter (proprietary/standard)
    if (selectedTypeFilter === 'proprietary') {
      filtered = filtered.filter(rule => rule.proprietary);
    } else if (selectedTypeFilter === 'standard') {
      filtered = filtered.filter(rule => !rule.proprietary);
    }

    // Sorting
    filtered.sort((a, b) => {
      let aValue = a[sortBy] || '';
      let bValue = b[sortBy] || '';

      if (typeof aValue === 'string') {
        aValue = aValue.toLowerCase();
        bValue = bValue.toLowerCase();
      }

      if (sortOrder === 'asc') {
        return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
      } else {
        return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;
      }
    });

    return filtered;
  }, [rules, searchTerm, selectedProductFilter, selectedCategoryFilter, selectedStatusFilter,
      selectedTypeFilter, sortBy, sortOrder, preselectedProductId, preselectedCoverageId]);

  // Get unique products for filter (memoized to prevent unnecessary re-renders)
  const uniqueProducts = useMemo(
    () => products.filter(p => p.name).sort((a, b) => a.name.localeCompare(b.name)),
    [products]
  );

  // Enhanced form handlers
  const resetForm = () => {
    setFormData({
      name: '',
      productId: preselectedProductId || '',
      ruleType: '',
      ruleCategory: '',
      targetId: '',
      condition: '',
      outcome: '',
      reference: '',
      proprietary: false,
      status: 'Active'
    });
    if (!preselectedProductId) {
      setCoverages([]);
      setPricingSteps([]);
    }
    setEditingRule(null);
  };

  const openModal = async (rule = null) => {
    if (rule) {
      setFormData({
        name: rule.name || '',
        productId: rule.productId || '',
        ruleType: rule.ruleType || '',
        ruleCategory: rule.ruleCategory || '',
        targetId: rule.targetId || '',
        condition: rule.condition || '',
        outcome: rule.outcome || '',
        reference: rule.reference || '',
        proprietary: rule.proprietary || false,
        status: rule.status || 'Active'
      });
      setEditingRule(rule);

      // Load coverages and pricing steps if editing a rule with a product
      if (rule.productId) {
        await loadCoveragesForProduct(rule.productId);
        await loadPricingStepsForProduct(rule.productId);
      }
    } else {
      resetForm();
    }
    setModalOpen(true);
  };

  const closeModal = () => {
    setModalOpen(false);
    resetForm();
  };

  // Load coverages when product is selected
  const loadCoveragesForProduct = async (productId) => {
    if (!productId) {
      setCoverages([]);
      return;
    }

    setLoadingTargets(true);
    try {
      const coveragesSnap = await getDocs(collection(db, `products/${productId}/coverages`));
      const coveragesList = coveragesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setCoverages(coveragesList);
    } catch (error) {
      console.error('Error loading coverages:', error);
      setCoverages([]);
    } finally {
      setLoadingTargets(false);
    }
  };

  // Load pricing steps when product is selected
  const loadPricingStepsForProduct = async (productId) => {
    if (!productId) {
      setPricingSteps([]);
      return;
    }

    try {
      const stepsSnap = await getDocs(collection(db, `products/${productId}/steps`));
      const stepsList = stepsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setPricingSteps(stepsList);
    } catch (error) {
      console.error('Error loading pricing steps:', error);
      setPricingSteps([]);
    }
  };

  // Handle product selection
  const handleProductChange = (productId) => {
    setFormData(prev => ({
      ...prev,
      productId,
      ruleType: '',
      targetId: ''
    }));
    loadCoveragesForProduct(productId);
    loadPricingStepsForProduct(productId);
  };

  // Handle rule type change
  const handleRuleTypeChange = (ruleType) => {
    setFormData(prev => ({
      ...prev,
      ruleType,
      targetId: ''
    }));
  };

  const handleSave = async () => {
    // Validation
    if (!formData.name.trim()) {
      alert('Please enter a rule name.');
      return;
    }
    if (!formData.productId) {
      alert('Please select a product.');
      return;
    }
    if (!formData.ruleType) {
      alert('Please select a rule type.');
      return;
    }
    if (formData.ruleType !== 'Product' && !formData.targetId) {
      alert('Please select a target for this rule.');
      return;
    }

    try {
      const payload = {
        name: formData.name.trim(),
        productId: formData.productId,
        ruleType: formData.ruleType,
        ruleCategory: formData.ruleCategory,
        targetId: formData.targetId,
        condition: formData.condition.trim(),
        outcome: formData.outcome.trim(),
        reference: formData.reference.trim(),
        proprietary: formData.proprietary,
        status: formData.status,
        updatedAt: new Date()
      };

      if (editingRule) {
        // Update existing rule
        await updateDoc(doc(db, 'rules', editingRule.id), payload);
        setRules(rules => rules.map(r => r.id === editingRule.id ? { ...r, ...payload } : r));
      } else {
        // Create new rule
        const docRef = await addDoc(collection(db, 'rules'), {
          ...payload,
          createdAt: new Date()
        });
        setRules(rules => [...rules, { id: docRef.id, ...payload }]);
      }

      closeModal();
    } catch (error) {
      console.error('Error saving rule:', error);
      alert('Failed to save rule. Please try again.');
    }
  };

  const handleDelete = async (ruleId) => {
    if (!window.confirm('Are you sure you want to delete this rule?')) return;

    try {
      await deleteDoc(doc(db, 'rules', ruleId));
      setRules(rules => rules.filter(r => r.id !== ruleId));
    } catch (error) {
      console.error('Error deleting rule:', error);
      alert('Failed to delete rule. Please try again.');
    }
  };

  const getProductName = useCallback((productId) => {
    const product = products.find(p => p.id === productId);
    return product?.name || 'Unknown Product';
  }, [products]);

  const getTargetName = useCallback((rule) => {
    if (!rule.ruleType) return 'Product Level';
    if (rule.ruleType === 'Product') return 'Product Level';
    if (!rule.targetId) return 'No Target';

    switch (rule.ruleType) {
      case 'Coverage':
        // For coverages, we need to find it in the current coverages or make a call
        const coverage = coverages.find(c => c.id === rule.targetId);
        return coverage?.name || 'Unknown Coverage';
      case 'Forms':
        const form = forms.find(f => f.id === rule.targetId);
        return form?.formName || form?.formNumber || 'Unknown Form';
      case 'Pricing':
        const step = pricingSteps.find(s => s.id === rule.targetId);
        return step?.stepName || 'Unknown Pricing Step';
      default:
        return 'Unknown Target';
    }
  }, [coverages, forms, pricingSteps]);

  const getRuleTypeColor = useCallback((ruleType) => {
    switch (ruleType) {
      case 'Product': return '#6366f1';
      case 'Coverage': return '#10b981';
      case 'Forms': return '#f59e0b';
      case 'Pricing': return '#8b5cf6';
      default: return '#6b7280';
    }
  }, []);

  const pageTitle = preselectedCoverageId && selectedCoverageName
    ? `${selectedCoverageName} Rules`
    : preselectedProductId
    ? `${getProductName(preselectedProductId)} Rules`
    : 'Rules Repository';

  const productName = preselectedProductId ? getProductName(preselectedProductId) : 'Products';

  return (
    <PageContainer>
      <MainNavigation />
      <PageContent>
        <EnhancedHeader
          title={pageTitle}
          subtitle={`Manage ${filteredRules.length} rule${filteredRules.length !== 1 ? 's' : ''}`}
          icon={Cog6ToothIcon}
          showBackButton={!!preselectedProductId || !!preselectedCoverageId}
          onBackClick={() => navigate(-1)}
          searchProps={{
            placeholder: preselectedCoverageId
              ? "Search rules for this coverage..."
              : preselectedProductId
              ? "Search coverage and form rules..."
              : "Search rules by name, category, condition, or outcome...",
            value: searchTerm,
            onChange: (e) => setSearchTerm(e.target.value)
          }}
        />

        {/* Coverage Context Snapshot - show when viewing rules for a specific coverage */}
        {preselectedCoverageId && selectedCoverageData && (
          <div style={{ marginBottom: 24 }}>
            <CoverageSnapshot
              name={selectedCoverageData.name}
              coverageCode={selectedCoverageData.coverageCode}
              isOptional={selectedCoverageData.isOptional}
              productName={getProductName(preselectedProductId)}
              parentCoverageName={parentCoverageData?.name}
              statesCount={coverageStatesCount}
              formsCount={coverageFormsCount}
              rulesCount={filteredRules.length}
              triggerLabel={selectedCoverageData.coverageTrigger}
              valuationLabel={selectedCoverageData.valuationMethod}
              territoryLabel={selectedCoverageData.territory}
              coinsuranceLabel={selectedCoverageData.coinsurance}
              waitingPeriodLabel={selectedCoverageData.waitingPeriod}
            />
          </div>
        )}

        {/* Rules Stats Dashboard */}
        <RulesStatsDashboard>
          <RulesStatCard $color="linear-gradient(90deg, #6366f1, #8b5cf6)">
            <RulesStatValue>{rules.length}</RulesStatValue>
            <RulesStatLabel>
              <Cog6ToothIcon />
              Total Rules
            </RulesStatLabel>
          </RulesStatCard>
          <RulesStatCard $color="linear-gradient(90deg, #10b981, #059669)">
            <RulesStatValue>{rules.filter(r => r.status === 'Active').length}</RulesStatValue>
            <RulesStatLabel>
              <ShieldCheckIcon />
              Active Rules
            </RulesStatLabel>
          </RulesStatCard>
          <RulesStatCard $color="linear-gradient(90deg, #f59e0b, #d97706)">
            <RulesStatValue>{rules.filter(r => r.ruleType === 'Coverage').length}</RulesStatValue>
            <RulesStatLabel>
              <ShieldCheckIcon />
              Coverage Rules
            </RulesStatLabel>
          </RulesStatCard>
          <RulesStatCard $color="linear-gradient(90deg, #8b5cf6, #7c3aed)">
            <RulesStatValue>{rules.filter(r => r.ruleType === 'Pricing').length}</RulesStatValue>
            <RulesStatLabel>
              <CurrencyDollarIcon />
              Pricing Rules
            </RulesStatLabel>
          </RulesStatCard>
          <RulesStatCard $color="linear-gradient(90deg, #06b6d4, #0891b2)">
            <RulesStatValue>{rules.filter(r => r.ruleType === 'Forms').length}</RulesStatValue>
            <RulesStatLabel>
              <DocumentTextIcon />
              Form Rules
            </RulesStatLabel>
          </RulesStatCard>
        </RulesStatsDashboard>

        <FilterContainer>
          <FilterRow>
            <FilterGroup>
              <FilterLabel>Product:</FilterLabel>
              <FilterSelect
                value={selectedProductFilter}
                onChange={(e) => setSelectedProductFilter(e.target.value)}
              >
                <option value="">All Products</option>
                {uniqueProducts.map(product => (
                  <option key={product.id} value={product.id}>
                    {product.name}
                  </option>
                ))}
              </FilterSelect>
            </FilterGroup>

            <FilterGroup>
              <FilterLabel>Category:</FilterLabel>
              <FilterSelect
                value={selectedCategoryFilter}
                onChange={(e) => setSelectedCategoryFilter(e.target.value)}
              >
                <option value="">All Categories</option>
                {ruleCategories.map(category => (
                  <option key={category} value={category}>
                    {category}
                  </option>
                ))}
              </FilterSelect>
            </FilterGroup>

            <FilterGroup>
              <FilterLabel>Status:</FilterLabel>
              <FilterSelect
                value={selectedStatusFilter}
                onChange={(e) => setSelectedStatusFilter(e.target.value)}
              >
                <option value="">All Statuses</option>
                {statuses.map(status => (
                  <option key={status} value={status}>
                    {status}
                  </option>
                ))}
              </FilterSelect>
            </FilterGroup>

            <ToggleContainer>
              <ToggleLabel>Proprietary</ToggleLabel>
              <ToggleSwitch
                active={selectedTypeFilter === 'proprietary'}
                onClick={() => setSelectedTypeFilter(selectedTypeFilter === 'proprietary' ? '' : 'proprietary')}
              >
                <ToggleKnob active={selectedTypeFilter === 'proprietary'} />
              </ToggleSwitch>
            </ToggleContainer>



            <SortControls>
              <FilterLabel>Sort:</FilterLabel>
              <SortSelect
                value={sortBy}
                onChange={(e) => setSortBy(e.target.value)}
              >
                <option value="name">Name</option>
                <option value="status">Status</option>
                <option value="ruleCategory">Category</option>
                <option value="updatedAt">Updated</option>
              </SortSelect>
              <SortOrderButton
                onClick={() => setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')}
              >
                {sortOrder === 'asc' ? <ArrowUpIcon /> : <ArrowDownIcon />}
              </SortOrderButton>
            </SortControls>

            <ViewModeToggle>
              <ViewModeButton
                active={viewMode === 'cards'}
                onClick={() => setViewMode('cards')}
              >
                <Squares2X2Icon />
                Cards
              </ViewModeButton>
              <ViewModeButton
                active={viewMode === 'table'}
                onClick={() => setViewMode('table')}
              >
                <TableCellsIcon />
                Table
              </ViewModeButton>
              <ViewModeButton
                active={viewMode === 'hierarchy'}
                onClick={() => setViewMode('hierarchy')}
              >
                <ListBulletIcon />
                Hierarchy
              </ViewModeButton>
            </ViewModeToggle>
          </FilterRow>


        </FilterContainer>

        {loading ? (
          <div style={{ textAlign: 'center', padding: '60px 20px', color: '#6b7280' }}>
            Loading rules...
          </div>
        ) : filteredRules.length === 0 ? (
          <EmptyState>
            <EmptyStateTitle>No rules found</EmptyStateTitle>
            <EmptyStateText>
              {searchTerm || selectedProductFilter || selectedTypeFilter
                ? 'Try adjusting your search or filters'
                : 'Get started by adding your first rule'}
            </EmptyStateText>
          </EmptyState>
        ) : (
          <RulesGrid>
            {filteredRules.map(rule => (
              <RuleCardItem
                key={rule.id}
                rule={rule}
                getProductName={getProductName}
                getTargetName={getTargetName}
                getRuleTypeColor={getRuleTypeColor}
                onEdit={openModal}
                onDelete={handleDelete}
              />
            ))}
          </RulesGrid>
        )}

        <AddButton onClick={() => openModal()}>
          <PlusIcon />
          Add Rule
        </AddButton>

        {modalOpen && (
          <ModalOverlay onClick={closeModal}>
            <ModalContainer onClick={(e) => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>
                  {editingRule ? 'Edit Rule' : 'Add New Rule'}
                </ModalTitle>
                <CloseButton onClick={closeModal}>
                  <XMarkIcon />
                </CloseButton>
              </ModalHeader>

              <FormGroup>
                <FormLabel>Rule Name *</FormLabel>
                <FormInput
                  placeholder="Enter descriptive rule name"
                  value={formData.name}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                />
              </FormGroup>

              {!preselectedProductId && (
                <FormGroup>
                  <FormLabel>Product *</FormLabel>
                  <FormSelect
                    value={formData.productId}
                    onChange={(e) => handleProductChange(e.target.value)}
                  >
                    <option value="">Select a product</option>
                    {uniqueProducts.map(product => (
                      <option key={product.id} value={product.id}>
                        {product.name}
                      </option>
                    ))}
                  </FormSelect>
                </FormGroup>
              )}

              {preselectedProductId && (
                <FormGroup>
                  <FormLabel>Product</FormLabel>
                  <FormInput
                    value={getProductName(preselectedProductId)}
                    disabled
                    style={{ backgroundColor: '#f8fafc', color: '#64748b' }}
                  />
                </FormGroup>
              )}

              {formData.productId && (
                <FormGroup>
                  <FormLabel>Rule Type *</FormLabel>
                  <FormSelect
                    value={formData.ruleType}
                    onChange={(e) => handleRuleTypeChange(e.target.value)}
                  >
                    <option value="">Select rule type</option>
                    <option value="Product">Product Rule</option>
                    <option value="Coverage">Coverage Rule</option>
                    <option value="Forms">Forms Rule</option>
                    <option value="Pricing">Pricing Rule</option>
                  </FormSelect>
                </FormGroup>
              )}

              <FormGroup>
                <FormLabel>Rule Category *</FormLabel>
                <FormSelect
                  value={formData.ruleCategory}
                  onChange={(e) => setFormData({ ...formData, ruleCategory: e.target.value })}
                >
                  <option value="">Select category</option>
                  {ruleCategories.map(category => (
                    <option key={category} value={category}>
                      {category}
                    </option>
                  ))}
                </FormSelect>
              </FormGroup>

              {formData.ruleType && formData.ruleType !== 'Product' && (
                <FormGroup>
                  <FormLabel>
                    {formData.ruleType === 'Coverage' && 'Target Coverage *'}
                    {formData.ruleType === 'Forms' && 'Target Form *'}
                    {formData.ruleType === 'Pricing' && 'Target Pricing Step *'}
                  </FormLabel>
                  <FormSelect
                    value={formData.targetId}
                    onChange={(e) => setFormData({ ...formData, targetId: e.target.value })}
                    disabled={loadingTargets}
                  >
                    <option value="">
                      {loadingTargets ? 'Loading...' : `Select ${formData.ruleType.toLowerCase()}`}
                    </option>
                    {formData.ruleType === 'Coverage' &&
                      coverages.map(coverage => (
                        <option key={coverage.id} value={coverage.id}>
                          {coverage.name}
                        </option>
                      ))
                    }
                    {formData.ruleType === 'Forms' &&
                      forms.filter(form => form.productId === formData.productId).map(form => (
                        <option key={form.id} value={form.id}>
                          {form.formName || form.formNumber}
                        </option>
                      ))
                    }
                    {formData.ruleType === 'Pricing' &&
                      pricingSteps.map(step => (
                        <option key={step.id} value={step.id}>
                          {step.stepName}
                        </option>
                      ))
                    }
                  </FormSelect>
                </FormGroup>
              )}

              <FormGroup>
                <FormLabel>When (Condition)</FormLabel>
                <FormInput
                  placeholder="When this condition is met..."
                  value={formData.condition}
                  onChange={(e) => setFormData({ ...formData, condition: e.target.value })}
                />
              </FormGroup>

              <FormGroup>
                <FormLabel>Then (Outcome)</FormLabel>
                <FormInput
                  placeholder="Then this outcome applies..."
                  value={formData.outcome}
                  onChange={(e) => setFormData({ ...formData, outcome: e.target.value })}
                />
              </FormGroup>

              <FormGroup>
                <FormLabel>Reference</FormLabel>
                <FormInput
                  placeholder="Source document, regulation, or standard"
                  value={formData.reference}
                  onChange={(e) => setFormData({ ...formData, reference: e.target.value })}
                />
              </FormGroup>

              <FormGroup>
                <FormLabel>Status</FormLabel>
                <FormSelect
                  value={formData.status}
                  onChange={(e) => setFormData({ ...formData, status: e.target.value })}
                >
                  {statuses.map(status => (
                    <option key={status} value={status}>
                      {status}
                    </option>
                  ))}
                </FormSelect>
              </FormGroup>

              <FormGroup>
                <FormLabel>
                  <FormCheckbox
                    type="checkbox"
                    checked={formData.proprietary}
                    onChange={(e) => setFormData({ ...formData, proprietary: e.target.checked })}
                  />
                  Proprietary Rule
                </FormLabel>
              </FormGroup>

              <ButtonGroup>
                <PrimaryButton onClick={handleSave}>
                  {editingRule ? 'Update Rule' : 'Save Rule'}
                </PrimaryButton>
                <SecondaryButton onClick={closeModal}>
                  Cancel
                </SecondaryButton>
              </ButtonGroup>
            </ModalContainer>
          </ModalOverlay>
        )}

      </PageContent>
    </PageContainer>
  );
}
```

---

## src/components/StatesScreen.tsx

**Path:** `src/components/StatesScreen.tsx`

```tsx
import { useState, useEffect, useRef } from 'react';
import { useParams } from 'react-router-dom';
import { useNavigate } from 'react-router-dom';
import { db } from '@/firebase';
import { doc, getDoc, updateDoc } from 'firebase/firestore';
import { ComposableMap, Geographies, Geography } from 'react-simple-maps';
import styled, { keyframes } from 'styled-components';
import { Page, Container } from '@components/ui/Layout';
import { Button } from '@components/ui/Button';
import { TextInput } from '@components/ui/Input';
import { ArrowLeftIcon, MapIcon } from '@heroicons/react/24/solid';
import MainNavigation from '@components/ui/Navigation';

import { createDirtyState, updateDirtyState, resetDirtyState, buildSaveConfirmation } from '@utils/stateGuards';


// Modern Container
const ModernContainer = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
  display: flex;
  flex-direction: column;
`;

const MainContent = styled.div`
  max-width: 1400px;
  margin: 0 auto;
  padding: 32px 24px;
  position: relative;
  z-index: 1;
  width: 100%;
`;

// Header Section - Consistent with other pages
const HeaderSection = styled.div`
  display: flex;
  align-items: center;
  margin-bottom: 32px;
  gap: 16px;
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border: none;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(10px);
  color: #6b7280;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid rgba(226, 232, 240, 0.6);

  &:hover {
    background: rgba(255, 255, 255, 1);
    color: #374151;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

const TitleContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 1;
`;

const TitleIcon = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 48px;
  height: 48px;
  border-radius: 12px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;

  svg {
    width: 24px;
    height: 24px;
  }
`;

const PageTitle = styled.h1`
  font-size: 28px;
  font-weight: 700;
  background: linear-gradient(135deg, #1e293b 0%, #475569 50%, #64748b 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin: 0;
  letter-spacing: -0.02em;
`;

// Spinner for loading state
const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;
const Spinner = styled.div`
  border: 4px solid #f3f3f3;
  border-top: 4px solid #6366f1;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: ${spin} 1s linear infinite;
  margin: 100px auto;
`;

// States Stats Dashboard
const slideIn = keyframes`
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
`;

const StatesStatsDashboard = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
  animation: ${slideIn} 0.4s ease-out;
`;

const StatesStatCard = styled.div<{ $color?: string }>`
  background: white;
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: ${({ $color }) => $color || 'linear-gradient(90deg, #6366f1, #8b5cf6)'};
  }

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
    border-color: transparent;
  }
`;

const StatesStatValue = styled.div`
  font-size: 28px;
  font-weight: 700;
  color: #1e293b;
  margin-bottom: 4px;
  letter-spacing: -0.02em;
`;

const StatesStatLabel = styled.div`
  font-size: 13px;
  font-weight: 500;
  color: #64748b;
  display: flex;
  align-items: center;
  gap: 6px;

  svg {
    width: 14px;
    height: 14px;
    opacity: 0.7;
  }
`;

// --- NEW UI BITS --------------------------------------------------
const Panel = styled.div`
  flex: 1 1 360px;
  background: #ffffff;
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  max-width: ${props => (props.collapsed ? '48px' : '420px')};
  transition: max-width 0.25s ease;
  overflow: hidden;
`;

const TogglePanelBtn = styled.button`
  position: absolute;
  top: 16px;
  right: -20px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: none;
  background: #7c3aed;
  color: #fff;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  &:hover { background:#5b21b6; }
`;

const Chip = styled.span`
  display:inline-flex;
  align-items:center;
  gap:4px;
  background:#f3f4f6;
  color:#374151;
  border-radius:16px;
  padding:4px 10px;
  font-size:14px;
  margin:4px;
`;

const ChipDelete = styled.button`
  background:none;
  border:none;
  color:#ef4444;
  cursor:pointer;
  line-height:1;
`;

const FloatingBar = styled.div`
  position:fixed;
  bottom:24px;
  right:96px;   /* leave 72px gap (56px circle + 16px margin) */
  display:flex;
  gap:12px;
  z-index:1200;
`;

const allStates = ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'];

function StatesScreen() {
  const { productId } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading] = useState(true);
  const [productName, setProductName] = useState('');
  const [selectedStates, setSelectedStates] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [newState, setNewState] = useState('');
  const [dirtyState, setDirtyState] = useState(createDirtyState([]));

  const [panelCollapsed, setPanelCollapsed] = useState(false);
  const searchRef = useRef(null);
  const [debouncedQuery, setDebouncedQuery] = useState('');

  // keyboard shortcut `/` to jump to search
  useEffect(() => {
    const handler = e => {
      if (e.key === '/' && !e.target.matches('input, textarea, select')) {
        e.preventDefault();
        searchRef.current?.focus();
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);

  // debounce search
  useEffect(() => {
    const t = setTimeout(() => setSearchQuery(debouncedQuery), 250);
    return () => clearTimeout(t);
  }, [debouncedQuery]);

  const stateNameToCode = {
    "Alabama": "AL",
    "Alaska": "AK",
    "Arizona": "AZ",
    "Arkansas": "AR",
    "California": "CA",
    "Colorado": "CO",
    "Connecticut": "CT",
    "Delaware": "DE",
    "Florida": "FL",
    "Georgia": "GA",
    "Hawaii": "HI",
    "Idaho": "ID",
    "Illinois": "IL",
    "Indiana": "IN",
    "Iowa": "IA",
    "Kansas": "KS",
    "Kentucky": "KY",
    "Louisiana": "LA",
    "Maine": "ME",
    "Maryland": "MD",
    "Massachusetts": "MA",
    "Michigan": "MI",
    "Minnesota": "MN",
    "Mississippi": "MS",
    "Missouri": "MO",
    "Montana": "MT",
    "Nebraska": "NE",
    "Nevada": "NV",
    "New Hampshire": "NH",
    "New Jersey": "NJ",
    "New Mexico": "NM",
    "New York": "NY",
    "North Carolina": "NC",
    "North Dakota": "ND",
    "Ohio": "OH",
    "Oklahoma": "OK",
    "Oregon": "OR",
    "Pennsylvania": "PA",
    "Rhode Island": "RI",
    "South Carolina": "SC",
    "South Dakota": "SD",
    "Tennessee": "TN",
    "Texas": "TX",
    "Utah": "UT",
    "Vermont": "VT",
    "Virginia": "VA",
    "Washington": "WA",
    "West Virginia": "WV",
    "Wisconsin": "WI",
    "Wyoming": "WY",
  };

  useEffect(() => {
    const fetchProduct = async () => {
      setLoading(true);
      try {
        const productDoc = await getDoc(doc(db, 'products', productId));
        if (productDoc.exists()) {
          const data = productDoc.data();
          setProductName(data.name);
          const states = data.availableStates || [];
          setSelectedStates(states);
          setDirtyState(createDirtyState(states));
        } else {
          throw new Error("Product not found");
        }
      } catch (error) {
        console.error("Error fetching product:", error);
        alert("Failed to load product data. Please try again.");
      } finally {
        setLoading(false);
      }
    };
    fetchProduct();
  }, [productId]);

  if (loading) {
    return (
      <ModernContainer>
        <MainNavigation />
        <MainContent>
          <Spinner />
        </MainContent>
      </ModernContainer>
    );
  }

  const handleAddState = () => {
    if (newState && !selectedStates.includes(newState)) {
      const newStates = [...selectedStates, newState];
      setSelectedStates(newStates);
      setDirtyState(updateDirtyState(dirtyState, newStates, 'states'));
      setNewState('');
    }
  };

  const handleRemoveState = (state) => {
    const newStates = selectedStates.filter(s => s !== state);
    setSelectedStates(newStates);
    setDirtyState(updateDirtyState(dirtyState, newStates, 'states'));
  };

  const handleSelectAll = () => {
    setSelectedStates([...allStates]);
    setDirtyState(updateDirtyState(dirtyState, allStates, 'states'));
  };

  const handleClearAll = () => {
    setSelectedStates([]);
    setDirtyState(updateDirtyState(dirtyState, [], 'states'));
  };

  const handleSave = async () => {
    if (!dirtyState.isDirty) {
      alert('No changes to save.');
      return;
    }

    const confirmation = buildSaveConfirmation(
      dirtyState.originalValue,
      selectedStates,
      productName
    );

    if (!window.confirm(confirmation)) {
      return;
    }

    try {
      const productRef = doc(db, 'products', productId);
      await updateDoc(productRef, { availableStates: selectedStates });

      setDirtyState(resetDirtyState(dirtyState));
      alert("State availability saved successfully!");
    } catch (error) {
      console.error("Error saving states:", error);
      alert("Failed to save state availability. Please try again.");
    }
  };

  const filteredStates = selectedStates.filter(state =>
    state.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <ModernContainer>
      <MainNavigation />
      <MainContent>
        <HeaderSection>
          <BackButton onClick={() => navigate(-1)}>
            <ArrowLeftIcon />
          </BackButton>
          <TitleContainer>
            <TitleIcon>
              <MapIcon />
            </TitleIcon>
            <PageTitle>
              State Availability for {productName}
            </PageTitle>
          </TitleContainer>
        </HeaderSection>

        {/* States Stats Dashboard */}
        <StatesStatsDashboard>
          <StatesStatCard $color="linear-gradient(90deg, #6366f1, #8b5cf6)">
            <StatesStatValue>{selectedStates.length}</StatesStatValue>
            <StatesStatLabel>
              <MapIcon />
              Selected States
            </StatesStatLabel>
          </StatesStatCard>
          <StatesStatCard $color="linear-gradient(90deg, #10b981, #059669)">
            <StatesStatValue>{allStates.length - selectedStates.length}</StatesStatValue>
            <StatesStatLabel>
              <MapIcon />
              Available to Add
            </StatesStatLabel>
          </StatesStatCard>
          <StatesStatCard $color="linear-gradient(90deg, #f59e0b, #d97706)">
            <StatesStatValue>{Math.round((selectedStates.length / allStates.length) * 100)}%</StatesStatValue>
            <StatesStatLabel>
              <MapIcon />
              US Coverage
            </StatesStatLabel>
          </StatesStatCard>
          <StatesStatCard $color={dirtyState.isDirty ? "linear-gradient(90deg, #ef4444, #dc2626)" : "linear-gradient(90deg, #06b6d4, #0891b2)"}>
            <StatesStatValue>{dirtyState.isDirty ? 'Yes' : 'No'}</StatesStatValue>
            <StatesStatLabel>
              <MapIcon />
              Unsaved Changes
            </StatesStatLabel>
          </StatesStatCard>
        </StatesStatsDashboard>

        <div style={{ display:'flex', flexDirection:'row', gap:24, alignItems:'flex-start', position:'relative' }}>
          {/* MAP AREA (grows) */}
          <div style={{ flex:'1 1 auto', background:'#ffffff', borderRadius:12, padding:20, boxShadow:'0 4px 12px rgba(0,0,0,0.1)', marginBottom:24 }}>
            <h2 style={{ fontSize:24, fontWeight:600, color:'#1F2937', marginBottom:16 }}>US Map</h2>
            <ComposableMap projection="geoAlbersUsa" style={{ width:'100%', height:'auto', margin:'0 auto' }}>
              <Geographies geography="https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json">
                {({ geographies }) =>
                  geographies
                    .filter(geo => stateNameToCode[geo.properties.name])
                    .map(geo => {
                      const stateCode = stateNameToCode[geo.properties.name];
                      return (
                        <Geography
                          key={geo.rsmKey}
                          geography={geo}
                          onClick={() => {
                            if (selectedStates.includes(stateCode)) {
                              setSelectedStates(selectedStates.filter(s => s !== stateCode));
                            } else {
                              setSelectedStates([...selectedStates, stateCode]);
                            }
                          }}
                          style={{
                            default: {
                              fill: selectedStates.includes(stateCode) ? '#3B82F6' : '#E5E7EB',
                              stroke: '#FFFFFF',
                              strokeWidth: 1,
                              outline: 'none',
                              cursor: 'pointer',
                            },
                            hover: {
                              fill: selectedStates.includes(stateCode) ? '#2563EB' : '#D1D5DB',
                              stroke: '#FFFFFF',
                              strokeWidth: 1,
                              outline: 'none',
                              cursor: 'pointer',
                            },
                            pressed: {
                              fill: selectedStates.includes(stateCode) ? '#1E40AF' : '#9CA3AF',
                              stroke: '#FFFFFF',
                              strokeWidth: 1,
                              outline: 'none',
                              cursor: 'pointer',
                            },
                          }}
                        />
                      );
                    })
                }
              </Geographies>
            </ComposableMap>
          </div>

          {/* CONTROL PANEL */}
          <Panel collapsed={panelCollapsed}>
            <TogglePanelBtn onClick={() => setPanelCollapsed(c=>!c)}>
              {panelCollapsed ? 'âŸ¨' : 'âŸ©'}
            </TogglePanelBtn>
            {!panelCollapsed && (
              <>
                <h2 style={{ fontSize:24, fontWeight:600, color:'#1F2937', marginBottom:16 }}>Applicable States</h2>
                <div style={{ display:'flex', gap:12, flexWrap:'wrap', marginBottom:16 }}>
                  <TextInput as="select" value={newState} onChange={e=>setNewState(e.target.value)}>
                    <option value="">Select State</option>
                    {allStates.map(s=> <option key={s} value={s}>{s}</option>)}
                  </TextInput>
                  <Button primary onClick={handleAddState}>Add</Button>
                </div>
                <TextInput
                  ref={searchRef}
                  placeholder="Search States"
                  value={debouncedQuery}
                  onChange={e=>setDebouncedQuery(e.target.value)}
                  style={{ marginBottom:16 }}
                />
                {filteredStates.length > 0 ? (
                  <div style={{ maxHeight:260, overflowY:'auto' }}>
                    {filteredStates.map(state=>(
                      <Chip key={state}>
                        {state}
                        <ChipDelete onClick={()=>handleRemoveState(state)}>Ã—</ChipDelete>
                      </Chip>
                    ))}
                  </div>
                ) : (
                  <p style={{ textAlign:'center', fontSize:18, color:'#6B7280' }}>No States Selected</p>
                )}
              </>
            )}
          </Panel>
        </div>
        <FloatingBar>
          <Button ghost onClick={handleSelectAll}>Select&nbsp;All</Button>
          <Button ghost onClick={handleClearAll}>Clear&nbsp;All</Button>
          <Button success onClick={handleSave}>Save</Button>
        </FloatingBar>

      </MainContent>
    </ModernContainer>
  );
}

export default StatesScreen;
```

---

## src/components/TableScreen.tsx

**Path:** `src/components/TableScreen.tsx`

```tsx
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { db } from '../firebase';
import { collection, getDocs, addDoc, deleteDoc, doc, getDoc, updateDoc } from 'firebase/firestore';
import {
  TrashIcon,
  PencilIcon,
  XMarkIcon,
  ArrowLeftIcon,
  TableCellsIcon,
  PlusIcon
} from '@heroicons/react/24/solid';

import { Button } from '../components/ui/Button';
import { TextInput } from '../components/ui/Input';
import {
  Table,
  THead,
  Tr,
  Th,
  Td,
  Overlay,
  Modal,
  ModalTitle,
  CloseBtn
} from '../components/ui/Table';
import MainNavigation from './ui/Navigation';

import styled, { keyframes } from 'styled-components';

/* ---------- styled helpers ---------- */
// Modern Container with responsive design
const ModernContainer = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
  position: relative;
`;

const MainContent = styled.div`
  max-width: 1400px;
  margin: 0 auto;
  padding: 32px 24px;
  position: relative;
  z-index: 1;
`;

// Header components consistent with pricing screen
const BackButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border: none;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.9);
  color: #64748b;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(12px);
  border: 1px solid rgba(226, 232, 240, 0.6);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(99, 102, 241, 0.15);
    border-color: rgba(99, 102, 241, 0.2);
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

const TitleContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 1;
`;

const TitleIcon = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 8px;
  color: white;

  svg {
    width: 16px;
    height: 16px;
  }
`;

const CoveragePageHeaderSection = styled.div`
  display: flex;
  align-items: center;
  margin-bottom: 32px;
  gap: 16px;
`;

const CoveragePageTitle = styled.h1`
  font-size: 24px;
  font-weight: 700;
  background: linear-gradient(135deg, #1e293b 0%, #475569 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin: 0;
  letter-spacing: -0.025em;

  @media (max-width: 768px) {
    font-size: 20px;
  }
`;

const Card = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  padding: 28px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  margin-bottom: 32px;
  transition: all 0.3s ease;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
  }
`;

const spin = keyframes`
  0%{transform:rotate(0deg);}
  100%{transform:rotate(360deg);}
`;
const Spinner = styled.div`
  border:4px solid #f3f3f3;
  border-top:4px solid #6366f1;
  border-radius:50%;
  width:40px;
  height:40px;
  animation:${spin} 1s linear infinite;
  margin:100px auto;
`;

// Enhanced Excel-like table styling
const ExcelTable = styled.div`
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  overflow: hidden;
  background: white;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
`;

const ExcelRow = styled.div`
  display: flex;
  border-bottom: 1px solid #e2e8f0;

  &:last-child {
    border-bottom: none;
  }
`;

const ExcelCell = styled.div`
  min-width: 120px;
  height: 40px;
  border-right: 1px solid #e2e8f0;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;

  &:last-child {
    border-right: none;
  }

  ${props => props.isHeader && `
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    font-weight: 600;
    color: #374151;
    font-size: 14px;
    letter-spacing: 0.025em;
  `}

  ${props => props.isRowHeader && `
    background: rgba(248, 250, 252, 0.8);
    font-weight: 600;
    color: #475569;
    min-width: 100px;
  `}

  input {
    width: 100%;
    height: 100%;
    border: none;
    background: transparent;
    text-align: center;
    font-size: 14px;
    padding: 8px;

    &:focus {
      outline: 2px solid #6366f1;
      outline-offset: -2px;
      background: rgba(99, 102, 241, 0.05);
    }

    &:hover {
      background: rgba(248, 250, 252, 0.8);
    }
  }
`;

// Enhanced dimension selection styling
const DimensionCard = styled.div`
  padding: 16px;
  border: 2px solid ${props => props.selected ? '#6366f1' : '#e5e7eb'};
  border-radius: 12px;
  cursor: pointer;
  background: ${props => props.selected ? 'rgba(99, 102, 241, 0.05)' : 'white'};
  transition: all 0.2s ease;
  opacity: ${props => props.disabled ? 0.5 : 1};

  &:hover {
    ${props => !props.disabled && `
      border-color: #6366f1;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
    `}
  }

  .dimension-name {
    font-weight: 600;
    font-size: 14px;
    color: #374151;
    margin-bottom: 4px;
  }

  .dimension-values {
    font-size: 12px;
    color: #6b7280;
  }
`;

const SelectedDimensionTag = styled.span`
  background: #eef2ff;
  border-radius: 12px;
  padding: 6px 12px;
  font-size: 13px;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  border: 1px solid #c7d2fe;

  svg {
    cursor: pointer;
    color: #6366f1;

    &:hover {
      color: #4f46e5;
    }
  }
`;

// Modern button styling to match Add Product button
const ModernButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: #ffffff;
  border: none;
  border-radius: 12px;
  padding: 12px 20px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  box-shadow: 0 4px 16px rgba(99, 102, 241, 0.25);
  transition: all 0.3s ease;
  letter-spacing: -0.01em;

  &:hover:not(:disabled) {
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(99, 102, 241, 0.35);
  }

  &:active:not(:disabled) {
    transform: translateY(-1px);
  }

  &:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;




// helper to normalise a dimension's values into an array
const getDimValues = (dim) => {
  if (!dim) return [''];
  if (Array.isArray(dim.values)) return dim.values;
  if (typeof dim.values === 'string') {
    return dim.values.split(',').map(v => v.trim()).filter(Boolean);
  }
  return [''];
};

function TableScreen() {
  const { productId, stepId } = useParams();
  const navigate = useNavigate();
  const [step, setStep] = useState(null);
  const [dimensions, setDimensions] = useState([]);
  const [newDimension, setNewDimension] = useState({ name: '', values: [], technicalCode: '' });
  const [selectedDimensions, setSelectedDimensions] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [valueInput, setValueInput] = useState('');
  const [editingDimensionId, setEditingDimensionId] = useState(null);
  const [tableData, setTableData] = useState({});
  const [modalOpen, setModalOpen] = useState(false);
  // list of IT codes from data dictionary
  const [itCodes, setItCodes] = useState([]);



  useEffect(() => {
    const fetchData = async () => {
      try {
        const stepDoc = await getDoc(doc(db, `products/${productId}/steps`, stepId));
        if (stepDoc.exists()) {
          setStep(stepDoc.data());
        } else {
          throw new Error("Step not found");
        }

        const dimensionsSnapshot = await getDocs(collection(db, `products/${productId}/steps/${stepId}/dimensions`));
        const dimensionList = dimensionsSnapshot.docs.map(d => {
          const data = d.data();
          const valuesArr = Array.isArray(data.values)
            ? data.values
            : String(data.values || '')
                .split(',')
                .map(v => v.trim())
                .filter(Boolean);
          return {
            id: d.id,
            ...data,
            values: valuesArr.join(', ')       // keep string form for consistency
          };
        });

        // pull IT codes from dataDictionary collection
        const codesSnap = await getDocs(collection(db, 'dataDictionary'));
        const codeList = codesSnap.docs.map(d => (d.data().code || '').trim()).filter(Boolean);
        setItCodes(codeList);

        setDimensions(dimensionList);

        // Auto-select dimensions by default (first two dimensions)
        if (dimensionList.length >= 2) {
          setSelectedDimensions([dimensionList[0], dimensionList[1]]);
        } else if (dimensionList.length === 1) {
          setSelectedDimensions([dimensionList[0]]);
        }

        // Initialize table data
        const initialData = {};
        const rowDim = dimensionList.find(dim => dim.type === 'Row') || dimensionList[0];
        const colDim = dimensionList.find(dim => dim.type === 'Column') || dimensionList[1];
        const rowValues = getDimValues(rowDim);
        const colValues = getDimValues(colDim);

        rowValues.forEach(row => {
          colValues.forEach(col => {
            initialData[`${row}-${col}`] = '';
          });
        });
        setTableData(initialData);
      } catch (error) {
        console.error("Error fetching data:", error);
        alert("Failed to load table data. Please try again.");
      }
    };
    fetchData();
  }, [productId, stepId]);

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setNewDimension(prev => ({ ...prev, [name]: value }));
  };



  const handleTableDataChange = (key, value) => {
    setTableData(prev => ({ ...prev, [key]: value }));
  };

  // Dimension selection handlers
  const handleSelectDimension = (dimension) => {
    if (selectedDimensions.some(d => d.id === dimension.id)) {
      // Remove if already selected
      setSelectedDimensions(prev => prev.filter(d => d.id !== dimension.id));
    } else if (selectedDimensions.length < 2) {
      // Add if under limit
      setSelectedDimensions(prev => [...prev, dimension]);
    }
  };

  const handleRemoveDimension = (dimensionId) => {
    setSelectedDimensions(prev => prev.filter(d => d.id !== dimensionId));
  };

  // Filter dimensions based on search query
  const filteredDimensions = dimensions.filter(dimension =>
    dimension.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    (dimension.values || '').toLowerCase().includes(searchQuery.toLowerCase())
  );

  const openAddModal = () => {
    setNewDimension({ name: '', values: [], technicalCode: '' });
    setEditingDimensionId(null);
    setModalOpen(true);
  };

  const openEditModal = (dimension) => {
    setEditingDimensionId(dimension.id);
    setNewDimension({
      name: dimension.name,
      values: (dimension.values || '').split(',').map(v => v.trim()).filter(Boolean),
      technicalCode: dimension.technicalCode
    });
    setModalOpen(true);
  };

  const handleAddDimension = async () => {
    if (!newDimension.name || newDimension.values.length === 0) {
      alert('Please fill in the Name and Values fields');
      return;
    }
    try {
      const docRef = await addDoc(collection(db, `products/${productId}/steps/${stepId}/dimensions`), {
        name: newDimension.name,
        values: newDimension.values.join(', '),
        technicalCode: newDimension.technicalCode
      });
      const updatedDimensions = [...dimensions, {
        id: docRef.id,
        ...newDimension,
        values: newDimension.values.join(', ')
      }];
      setDimensions(updatedDimensions);
      setModalOpen(false);

      // Update table data
      const rowDim = updatedDimensions.find(dim => dim.type === 'Row');
      const colDim = updatedDimensions.find(dim => dim.type === 'Column');
      const rowValues = getDimValues(rowDim);
      const colValues = getDimValues(colDim);
      const newTableData = {};
      rowValues.forEach(row => {
        colValues.forEach(col => {
          newTableData[`${row}-${col}`] = tableData[`${row}-${col}`] || '';
        });
      });
      setTableData(newTableData);
    } catch (error) {
      console.error("Error adding dimension:", error);
      alert("Failed to add dimension. Please try again.");
    }
  };

  const handleUpdateDimension = async () => {
    if (!newDimension.name || newDimension.values.length === 0) {
      alert('Please fill in the Name and Values fields');
      return;
    }
    try {
      await updateDoc(doc(db, `products/${productId}/steps/${stepId}/dimensions`, editingDimensionId), {
        name: newDimension.name,
        values: newDimension.values.join(', '),
        technicalCode: newDimension.technicalCode
      });
      const updatedDimensions = dimensions.map(dim =>
        dim.id === editingDimensionId
          ? { id: dim.id, ...newDimension, values: newDimension.values.join(', ') }
          : dim
      );
      setDimensions(updatedDimensions);
      setEditingDimensionId(null);
      setModalOpen(false);

      // Update table data
      const rowDim = updatedDimensions.find(dim => dim.type === 'Row');
      const colDim = updatedDimensions.find(dim => dim.type === 'Column');
      const rowValues = getDimValues(rowDim);
      const colValues = getDimValues(colDim);
      const newTableData = {};
      rowValues.forEach(row => {
        colValues.forEach(col => {
          newTableData[`${row}-${col}`] = tableData[`${row}-${col}`] || '';
        });
      });
      setTableData(newTableData);
    } catch (error) {
      console.error("Error updating dimension:", error);
      alert("Failed to update dimension. Please try again.");
    }
  };

  const handleDeleteDimension = async (dimensionId) => {
    if (window.confirm("Are you sure you want to delete this dimension?")) {
      try {
        await deleteDoc(doc(db, `products/${productId}/steps/${stepId}/dimensions`, dimensionId));
        const updatedDimensions = dimensions.filter(dim => dim.id !== dimensionId);
        setDimensions(updatedDimensions);

        // Update table data
        const rowDim = updatedDimensions.find(dim => dim.type === 'Row');
        const colDim = updatedDimensions.find(dim => dim.type === 'Column');
        const rowValues = getDimValues(rowDim);
        const colValues = getDimValues(colDim);
        const newTableData = {};
        rowValues.forEach(row => {
          colValues.forEach(col => {
            newTableData[`${row}-${col}`] = tableData[`${row}-${col}`] || '';
          });
        });
        setTableData(newTableData);
      } catch (error) {
        console.error("Error deleting dimension:", error);
        alert("Failed to delete dimension. Please try again.");
      }
    }
  };



  // Loading spinner
  if(!dimensions.length && !step){
    return (
      <ModernContainer>
        <MainNavigation />
        <MainContent>
          <Spinner/>
        </MainContent>
      </ModernContainer>
    );
  }



  // Enhanced Excel-like table renderer
  const renderExcelTable = () => {
    if (selectedDimensions.length !== 2) return null;

    const rowDimension = selectedDimensions[0];
    const colDimension = selectedDimensions[1];
    const rowValues = getDimValues(rowDimension);
    const colValues = getDimValues(colDimension);

    return (
      <ExcelTable>
        {/* Header row */}
        <ExcelRow>
          <ExcelCell isHeader style={{ minWidth: '100px' }}>
            {/* Empty corner cell */}
          </ExcelCell>
          {colValues.map((col, index) => (
            <ExcelCell key={index} isHeader>
              {col}
            </ExcelCell>
          ))}
        </ExcelRow>

        {/* Data rows */}
        {rowValues.map((row, rowIndex) => (
          <ExcelRow key={rowIndex}>
            <ExcelCell isRowHeader>
              {row}
            </ExcelCell>
            {colValues.map((col, colIndex) => {
              const cellKey = `${row}-${col}`;
              return (
                <ExcelCell key={colIndex}>
                  <input
                    type="number"
                    value={tableData[cellKey] || ''}
                    onChange={(e) => {
                      const value = e.target.value;
                      // Only allow numbers (including decimals)
                      if (value === '' || /^\d*\.?\d*$/.test(value)) {
                        handleTableDataChange(cellKey, value);
                      }
                    }}
                    placeholder="0"
                    step="any"
                  />
                </ExcelCell>
              );
            })}
          </ExcelRow>
        ))}
      </ExcelTable>
    );
  };

  return (
    <ModernContainer>
      <MainNavigation />
      <MainContent>
        <CoveragePageHeaderSection>
          <BackButton onClick={() => navigate(`/pricing/${productId}`)}>
            <ArrowLeftIcon />
          </BackButton>
          <TitleContainer>
            <TitleIcon>
              <TableCellsIcon />
            </TitleIcon>
            <CoveragePageTitle>
              Table: {step?.stepName || 'Loadingâ€¦'}
            </CoveragePageTitle>
          </TitleContainer>
        </CoveragePageHeaderSection>

        {/* Enhanced Excel-like Table */}
        {selectedDimensions.length === 2 ? (
          <Card>
            <div style={{ marginBottom: '24px' }}>
              <h3 style={{ fontSize: '18px', fontWeight: '600', color: '#374151', marginBottom: '12px' }}>
                Data Table
              </h3>
              <div style={{ display: 'flex', gap: '24px', marginBottom: '16px' }}>
                <div>
                  <span style={{ fontSize: '14px', fontWeight: '500', color: '#6b7280' }}>Rows: </span>
                  <span style={{ fontSize: '14px', fontWeight: '600', color: '#374151' }}>
                    {selectedDimensions[0]?.name} ({getDimValues(selectedDimensions[0]).length} values)
                  </span>
                </div>
                <div>
                  <span style={{ fontSize: '14px', fontWeight: '500', color: '#6b7280' }}>Columns: </span>
                  <span style={{ fontSize: '14px', fontWeight: '600', color: '#374151' }}>
                    {selectedDimensions[1]?.name} ({getDimValues(selectedDimensions[1]).length} values)
                  </span>
                </div>
              </div>
            </div>
            {renderExcelTable()}
          </Card>
        ) : (
          <Card style={{ padding: '40px', textAlign: 'center', color: '#6B7280' }}>
            <h3 style={{ margin: '0 0 8px 0', color: '#374151' }}>No Table to Display</h3>
            <p style={{ margin: '0' }}>
              Please select exactly 2 dimensions below to generate a table.
            </p>
          </Card>
        )}

        {/* Dimension Selection Section */}
        <Card style={{ marginBottom: '24px' }}>
          <div style={{ padding: '20px' }}>
            <h3 style={{ margin: '0 0 16px 0', fontSize: '18px', fontWeight: '600', color: '#374151' }}>
              Select Dimensions for Table (Choose up to 2)
            </h3>

            {/* Search Box */}
            <div style={{ marginBottom: '16px' }}>
              <TextInput
                type="text"
                placeholder="Search dimensions..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                style={{ width: '100%', maxWidth: '400px' }}
              />
            </div>

            {/* Selected Dimensions Display */}
            {selectedDimensions.length > 0 && (
              <div style={{ marginBottom: '16px' }}>
                <p style={{ margin: '0 0 8px 0', fontSize: '14px', fontWeight: '500', color: '#374151' }}>
                  Selected Dimensions ({selectedDimensions.length}/2):
                </p>
                <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                  {selectedDimensions.map((dim, index) => (
                    <SelectedDimensionTag key={dim.id}>
                      {index === 0 ? 'Rows' : 'Columns'}: {dim.name}
                      <XMarkIcon
                        width={14}
                        height={14}
                        onClick={() => handleRemoveDimension(dim.id)}
                      />
                    </SelectedDimensionTag>
                  ))}
                </div>
              </div>
            )}

            {/* Available Dimensions */}
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: '12px' }}>
              {filteredDimensions.map(dimension => (
                <DimensionCard
                  key={dimension.id}
                  selected={selectedDimensions.some(d => d.id === dimension.id)}
                  disabled={selectedDimensions.length >= 2 && !selectedDimensions.some(d => d.id === dimension.id)}
                  onClick={() => handleSelectDimension(dimension)}
                >
                  <div className="dimension-name">
                    {dimension.name}
                  </div>
                  <div className="dimension-values">
                    {dimension.values} ({(dimension.values || '').split(',').length} values)
                  </div>
                </DimensionCard>
              ))}
            </div>
          </div>
        </Card>

        {/* Add Dimension Button */}
        <div style={{margin:'16px 0'}}>
          <ModernButton onClick={openAddModal}>
            <PlusIcon width={16} height={16} />
            Add Dimension
          </ModernButton>
        </div>

        {/* Dimensions Table */}
        <Card>
          <Table>
            <THead>
              <Tr>
                <Th>Dimension Name</Th>
                <Th>Dimension Values</Th>
                <Th>IT&nbsp;Code</Th>
                <Th>Actions</Th>
              </Tr>
            </THead>
            <tbody>
              {dimensions.map(dimension => (
                <Tr key={dimension.id}>
                  <Td>{dimension.name}</Td>
                  <Td>{dimension.values}</Td>
                  <Td>{dimension.technicalCode}</Td>
                  <Td>
                    <div style={{display:'flex',gap:10}}>
                      <Button
                        variant="ghost"
                        onClick={() => openEditModal(dimension)}
                        title="Edit dimension"
                        style={{ padding: 4, minWidth: 0 }}
                      >
                        <PencilIcon width={16} height={16} />
                      </Button>
                      <Button
                        variant="ghost"
                        onClick={() => handleDeleteDimension(dimension.id)}
                        title="Delete dimension"
                        style={{ color: '#DC2626', padding: 4, minWidth: 0 }}
                      >
                        <TrashIcon width={16} height={16} />
                      </Button>
                    </div>
                  </Td>
                </Tr>
              ))}
            </tbody>
          </Table>
        </Card>

        {/* Modal for Adding/Editing Dimension */}
        {modalOpen && (
          <Overlay onClick={() => setModalOpen(false)}>
            <Modal onClick={e => e.stopPropagation()}>
              <CloseBtn onClick={() => setModalOpen(false)}>
                <XMarkIcon width={16} height={16} />
              </CloseBtn>
              <ModalTitle>{editingDimensionId ? 'Edit Dimension' : 'Add New Dimension'}</ModalTitle>
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: 10, marginBottom: 20 }}>
                <TextInput
                  type="text"
                  name="name"
                  value={newDimension.name}
                  onChange={handleInputChange}
                  placeholder="Name (e.g., Roof Age)"
                />
                {/* Dimension values input UI */}
                <div style={{display:'flex',alignItems:'center',gap:8,width:'100%'}}>
                  <TextInput
                    placeholder="Add a value and press +"
                    value={valueInput}
                    onChange={e => setValueInput(e.target.value)}
                    style={{flex:1}}
                  />
                  <Button
                    variant="primary"
                    onClick={()=>{
                      const v = valueInput.trim();
                      if(v && !newDimension.values.includes(v)){
                        setNewDimension(prev=>({...prev, values:[...prev.values, v]}));
                      }
                      setValueInput('');
                    }}
                    title="Add value"
                    style={{padding:'8px 12px', minWidth: 'auto'}}
                  >
                    <PlusIcon width={14} height={14} />
                  </Button>
                </div>
                <div style={{marginTop:8,display:'flex',flexWrap:'wrap',gap:6}}>
                  {newDimension.values.map((v,idx)=>(
                    <span key={idx} style={{
                      background:'#EEF2FF',
                      borderRadius:12,
                      padding:'4px 10px',
                      fontSize:13,
                      display:'inline-flex',
                      alignItems:'center',
                      gap:4
                    }}>
                      {v}
                      <XMarkIcon
                        width={12}
                        height={12}
                        style={{cursor:'pointer'}}
                        onClick={()=> setNewDimension(prev=>({...prev, values:prev.values.filter(x=>x!==v)}))}
                      />
                    </span>
                  ))}
                </div>

                {/* IT Code select moved below states */}
                <label style={{ fontSize: 14, color: '#374151', marginBottom: 2, width: '100%' }}>IT&nbsp;Code (optional)</label>
                <TextInput
                  as="select"
                  name="technicalCode"
                  value={newDimension.technicalCode}
                  onChange={handleInputChange}
                  style={{ minWidth: 180, fontSize: 13 }}
                >
                  <option value="" disabled style={{ color: '#6B7280', fontSize: 13 }}>
                    Select IT Code
                  </option>
                  {itCodes.map(code => (
                    <option key={code} value={code}>{code}</option>
                  ))}
                </TextInput>
                <ModernButton
                  onClick={editingDimensionId ? handleUpdateDimension : handleAddDimension}
                  style={{ minWidth: 160, marginTop: 4 }}
                >
                  {editingDimensionId ? 'Update Dimension' : 'Add Dimension'}
                </ModernButton>
              </div>
            </Modal>
          </Overlay>
        )}
      </MainContent>
    </ModernContainer>
  );
}

export default TableScreen;
```

---

## src/components/TaskManagement.tsx

**Path:** `src/components/TaskManagement.tsx`

```tsx
// src/components/TaskManagement.js
import React, { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import {
  PlusIcon,
  XMarkIcon,
  LightBulbIcon,
  DocumentCheckIcon,
  ShieldCheckIcon,
  RocketLaunchIcon,
  CalendarIcon,
  UserIcon,
  ClipboardDocumentListIcon
} from '@heroicons/react/24/solid';
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  onSnapshot,
  serverTimestamp
} from 'firebase/firestore';
import { db } from '@/firebase';
import MainNavigation from './ui/Navigation';
import EnhancedHeader from './ui/EnhancedHeader';
import { PageContainer, PageContent } from './ui/PageContainer';
import { Breadcrumb } from './ui/Breadcrumb';

// ============================================================================
// Styled Components
// ============================================================================

const ActionBar = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 32px;
  padding: 0 4px;

  @media (max-width: 768px) {
    flex-direction: column;
    gap: 16px;
    align-items: stretch;
  }
`;

const ActionGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;

  @media (max-width: 768px) {
    justify-content: center;
  }
`;

const FilterSelect = styled.select`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  font-size: 14px;
  background: white;
  color: #374151;
  cursor: pointer;
  min-width: 140px;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const TaskStats = styled.div`
  display: flex;
  gap: 24px;
  margin-bottom: 24px;
  padding: 16px;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(20px);
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.5);
`;

const StatItem = styled.div`
  text-align: center;

  .number {
    font-size: 24px;
    font-weight: 700;
    color: #1f2937;
    margin-bottom: 4px;
  }

  .label {
    font-size: 12px;
    color: #6b7280;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
`;

const HeaderActionButton = styled.button`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 12px;
  padding: 12px 20px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  font-size: 14px;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const FilterGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;

  @media (max-width: 768px) {
    flex-wrap: wrap;
    justify-content: center;
  }
`;





const KanbanBoard = styled.div`
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 24px;
  margin-top: 32px;

  @media (max-width: 1200px) {
    grid-template-columns: repeat(2, 1fr);
  }

  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
`;

const Column = styled.div`
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(20px);
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(226, 232, 240, 0.5);
  min-height: 600px;
  transition: all 0.3s ease;

  &.drag-over {
    background: rgba(99, 102, 241, 0.05);
    border-color: #6366f1;
    transform: scale(1.02);
  }
`;

const ColumnHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
  padding-bottom: 16px;
  border-bottom: 2px solid ${props => props.color || '#e5e7eb'};
`;

const ColumnIcon = styled.div`
  width: 40px;
  height: 40px;
  border-radius: 10px;
  background: ${props => props.color || '#f3f4f6'};
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;

  svg {
    width: 20px;
    height: 20px;
  }
`;

const ColumnTitle = styled.h3`
  font-size: 16px;
  font-weight: 600;
  color: #1f2937;
  margin: 0;
  flex: 1;
`;

const TaskCount = styled.span`
  background: ${props => props.color || '#f3f4f6'};
  color: white;
  font-size: 12px;
  font-weight: 600;
  padding: 4px 8px;
  border-radius: 6px;
  min-width: 20px;
  text-align: center;
`;

const TasksContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const TaskCard = styled.div`
  background: white;
  border-radius: 12px;
  padding: 16px;
  border: 1px solid #e5e7eb;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  cursor: grab;
  transition: all 0.2s ease;
  position: relative;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
    border-color: #6366f1;
  }

  &:active {
    cursor: grabbing;
  }

  &.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
  }

  &.overdue {
    border-left: 4px solid #ef4444;
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.02) 0%, rgba(255, 255, 255, 1) 100%);
  }
`;

const TaskHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
`;

const TaskTitle = styled.h4`
  font-size: 14px;
  font-weight: 600;
  color: #1f2937;
  margin: 0;
  line-height: 1.4;
  flex: 1;
`;

const DeleteButton = styled.button`
  background: none;
  border: none;
  color: #9ca3af;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;

  &:hover {
    color: #ef4444;
    background: rgba(239, 68, 68, 0.1);
  }

  svg {
    width: 14px;
    height: 14px;
  }
`;

const TaskDescription = styled.p`
  font-size: 12px;
  color: #6b7280;
  margin: 0 0 12px 0;
  line-height: 1.4;
`;

const TaskMeta = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 11px;
  color: #9ca3af;
`;

const PriorityBadge = styled.span`
  background: ${props => {
    switch (props.priority) {
      case 'high': return '#fee2e2';
      case 'medium': return '#fef3c7';
      case 'low': return '#dcfce7';
      default: return '#f3f4f6';
    }
  }};
  color: ${props => {
    switch (props.priority) {
      case 'high': return '#dc2626';
      case 'medium': return '#d97706';
      case 'low': return '#16a34a';
      default: return '#6b7280';
    }
  }};
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 500;
  text-transform: capitalize;
`;

// Modal styles
const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
`;

const Modal = styled.div`
  background: white;
  border-radius: 16px;
  padding: 24px;
  width: 90%;
  max-width: 500px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
`;

const ModalHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
`;

const ModalTitle = styled.h3`
  font-size: 18px;
  font-weight: 600;
  color: #1f2937;
  margin: 0;
`;

const FormGroup = styled.div`
  margin-bottom: 16px;
`;

const Label = styled.label`
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: #374151;
  margin-bottom: 6px;
`;

const Input = styled.input`
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  font-size: 14px;
  transition: border-color 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const TextArea = styled.textarea`
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  font-size: 14px;
  resize: vertical;
  min-height: 80px;
  transition: border-color 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const Select = styled.select`
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  font-size: 14px;
  background: white;
  transition: border-color 0.2s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 24px;
`;

const Button = styled.button`
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid transparent;

  &.primary {
    background: #6366f1;
    color: white;
    border-color: #6366f1;

    &:hover {
      background: #5a67d8;
      border-color: #5a67d8;
    }
  }

  &.secondary {
    background: white;
    color: #374151;
    border-color: #d1d5db;

    &:hover {
      background: #f9fafb;
      border-color: #9ca3af;
    }
  }
`;

// ============================================================================
// Main Component
// ============================================================================

export default function TaskManagement() {
  const [tasks, setTasks] = useState([]);
  const [showModal, setShowModal] = useState(false);
  const [draggedTask, setDraggedTask] = useState(null);
  const [priorityFilter, setPriorityFilter] = useState('all');
  const [assigneeFilter, setAssigneeFilter] = useState('all');
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    priority: 'medium',
    assignee: '',
    dueDate: '',
    phase: 'research'
  });

  // Task phases configuration
  const phases = [
    {
      id: 'research',
      title: 'Research & Ideation',
      icon: <LightBulbIcon />,
      color: '#f59e0b',
      description: 'Market analysis, competitive research, product ideation'
    },
    {
      id: 'develop',
      title: 'Product Development',
      icon: <DocumentCheckIcon />,
      color: '#3b82f6',
      description: 'Product design, coverage creation, form development'
    },
    {
      id: 'compliance',
      title: 'Compliance & Filings',
      icon: <ShieldCheckIcon />,
      color: '#8b5cf6',
      description: 'Regulatory review, state filings, compliance checks'
    },
    {
      id: 'implementation',
      title: 'Implementation & Launch',
      icon: <RocketLaunchIcon />,
      color: '#10b981',
      description: 'System setup, training, go-to-market execution'
    }
  ];

  // Load tasks from Firestore
  useEffect(() => {
    const unsubscribe = onSnapshot(
      collection(db, 'tasks'),
      (snapshot) => {
        const taskList = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        setTasks(taskList);
      },
      (error) => {
        console.error('Error fetching tasks:', error);
      }
    );

    return unsubscribe;
  }, []);

  // Handle form input changes
  const handleInputChange = useCallback((field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  }, []);

  // Create new task
  const handleCreateTask = async () => {
    if (!formData.title.trim()) return;

    try {
      await addDoc(collection(db, 'tasks'), {
        ...formData,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });

      setFormData({
        title: '',
        description: '',
        priority: 'medium',
        assignee: '',
        dueDate: '',
        phase: 'research'
      });
      setShowModal(false);
    } catch (error) {
      console.error('Error creating task:', error);
    }
  };

  // Delete task
  const handleDeleteTask = async (taskId) => {
    if (!window.confirm('Are you sure you want to delete this task?')) return;

    try {
      await deleteDoc(doc(db, 'tasks', taskId));
    } catch (error) {
      console.error('Error deleting task:', error);
    }
  };

  // Drag and drop handlers
  const handleDragStart = (e, task) => {
    setDraggedTask(task);
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');
  };

  const handleDragEnd = (e) => {
    e.target.classList.remove('dragging');
    setDraggedTask(null);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  };

  const handleDragEnter = (e) => {
    e.preventDefault();
    e.currentTarget.classList.add('drag-over');
  };

  const handleDragLeave = (e) => {
    e.currentTarget.classList.remove('drag-over');
  };

  const handleDrop = async (e, newPhase) => {
    e.preventDefault();
    e.currentTarget.classList.remove('drag-over');

    if (!draggedTask || draggedTask.phase === newPhase) return;

    try {
      await updateDoc(doc(db, 'tasks', draggedTask.id), {
        phase: newPhase,
        updatedAt: serverTimestamp()
      });
    } catch (error) {
      console.error('Error updating task phase:', error);
    }
  };

  // Filter tasks based on current filters
  const filteredTasks = tasks.filter(task => {
    if (priorityFilter !== 'all' && task.priority !== priorityFilter) return false;
    if (assigneeFilter !== 'all' && task.assignee !== assigneeFilter) return false;
    return true;
  });

  // Get tasks for a specific phase
  const getTasksForPhase = (phaseId) => {
    return filteredTasks.filter(task => task.phase === phaseId);
  };

  // Get unique assignees for filter
  const getUniqueAssignees = () => {
    const assignees = tasks.map(task => task.assignee).filter(Boolean);
    return [...new Set(assignees)];
  };

  // Calculate task statistics
  const getTaskStats = () => {
    const total = filteredTasks.length;
    const highPriority = filteredTasks.filter(task => task.priority === 'high').length;
    const overdue = filteredTasks.filter(task => {
      if (!task.dueDate) return false;
      return new Date(task.dueDate) < new Date();
    }).length;
    const completed = filteredTasks.filter(task => task.phase === 'implementation').length;

    return { total, highPriority, overdue, completed };
  };





  // Format date for display
  const formatDate = (dateString) => {
    if (!dateString) return '';
    return new Date(dateString).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric'
    });
  };

  // Check if task is overdue
  const isTaskOverdue = (task) => {
    if (!task.dueDate) return false;
    return new Date(task.dueDate) < new Date();
  };

  return (
    <PageContainer withOverlay={true}>
      <MainNavigation />
      <PageContent>
        <Breadcrumb
          items={[
            { label: 'Home', path: '/' },
            { label: 'Tasks' }
          ]}
        />

        <EnhancedHeader
          title="Product Task Management"
          subtitle={`Manage ${filteredTasks.length} task${filteredTasks.length !== 1 ? 's' : ''} across the complete product development lifecycle`}
          icon={ClipboardDocumentListIcon}
        />

        <ActionBar>
          <ActionGroup>
            <FilterGroup>
              <FilterSelect
                value={priorityFilter}
                onChange={(e) => setPriorityFilter(e.target.value)}
              >
                <option value="all">All Priorities</option>
                <option value="high">High Priority</option>
                <option value="medium">Medium Priority</option>
                <option value="low">Low Priority</option>
              </FilterSelect>

              <FilterSelect
                value={assigneeFilter}
                onChange={(e) => setAssigneeFilter(e.target.value)}
              >
                <option value="all">All Assignees</option>
                {getUniqueAssignees().map(assignee => (
                  <option key={assignee} value={assignee}>{assignee}</option>
                ))}
              </FilterSelect>
            </FilterGroup>
          </ActionGroup>

          <ActionGroup>
            <HeaderActionButton onClick={() => setShowModal(true)}>
              <PlusIcon />
              Add New Task
            </HeaderActionButton>
          </ActionGroup>
        </ActionBar>

        <TaskStats>
          <StatItem>
            <div className="number">{getTaskStats().total}</div>
            <div className="label">Total Tasks</div>
          </StatItem>
          <StatItem>
            <div className="number">{getTaskStats().highPriority}</div>
            <div className="label">High Priority</div>
          </StatItem>
          <StatItem>
            <div className="number">{getTaskStats().overdue}</div>
            <div className="label">Overdue</div>
          </StatItem>
          <StatItem>
            <div className="number">{getTaskStats().completed}</div>
            <div className="label">In Implementation</div>
          </StatItem>
        </TaskStats>

        <KanbanBoard>
          {phases.map(phase => (
            <Column
              key={phase.id}
              onDragOver={handleDragOver}
              onDragEnter={handleDragEnter}
              onDragLeave={handleDragLeave}
              onDrop={(e) => handleDrop(e, phase.id)}
            >
              <ColumnHeader color={phase.color}>
                <ColumnIcon color={phase.color}>
                  {phase.icon}
                </ColumnIcon>
                <div>
                  <ColumnTitle>{phase.title}</ColumnTitle>
                  <div style={{ fontSize: '12px', color: '#6b7280', marginTop: '2px' }}>
                    {phase.description}
                  </div>
                </div>
                <TaskCount color={phase.color}>
                  {getTasksForPhase(phase.id).length}
                </TaskCount>
              </ColumnHeader>

              <TasksContainer>
                {getTasksForPhase(phase.id).map(task => (
                  <TaskCard
                    key={task.id}
                    draggable
                    onDragStart={(e) => handleDragStart(e, task)}
                    onDragEnd={handleDragEnd}
                    className={isTaskOverdue(task) ? 'overdue' : ''}
                  >
                    <TaskHeader>
                      <TaskTitle>{task.title}</TaskTitle>
                      <DeleteButton onClick={() => handleDeleteTask(task.id)}>
                        <XMarkIcon />
                      </DeleteButton>
                    </TaskHeader>

                    {task.description && (
                      <TaskDescription>{task.description}</TaskDescription>
                    )}

                    <TaskMeta>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <PriorityBadge priority={task.priority}>
                          {task.priority}
                        </PriorityBadge>
                        {task.assignee && (
                          <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                            <UserIcon style={{ width: '12px', height: '12px' }} />
                            {task.assignee}
                          </div>
                        )}
                      </div>
                      {task.dueDate && (
                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                          <CalendarIcon style={{ width: '12px', height: '12px' }} />
                          {formatDate(task.dueDate)}
                        </div>
                      )}
                    </TaskMeta>
                  </TaskCard>
                ))}
              </TasksContainer>
            </Column>
          ))}
        </KanbanBoard>

        {/* Add Task Modal */}
        {showModal && (
          <Overlay onClick={() => setShowModal(false)}>
            <Modal onClick={(e) => e.stopPropagation()}>
              <ModalHeader>
                <ModalTitle>Create New Task</ModalTitle>
                <DeleteButton onClick={() => setShowModal(false)}>
                  <XMarkIcon />
                </DeleteButton>
              </ModalHeader>

              <FormGroup>
                <Label>Task Title *</Label>
                <Input
                  type="text"
                  value={formData.title}
                  onChange={(e) => handleInputChange('title', e.target.value)}
                  placeholder="Enter task title..."
                />
              </FormGroup>

              <FormGroup>
                <Label>Description</Label>
                <TextArea
                  value={formData.description}
                  onChange={(e) => handleInputChange('description', e.target.value)}
                  placeholder="Describe the task..."
                />
              </FormGroup>

              <FormGroup>
                <Label>Phase</Label>
                <Select
                  value={formData.phase}
                  onChange={(e) => handleInputChange('phase', e.target.value)}
                >
                  {phases.map(phase => (
                    <option key={phase.id} value={phase.id}>
                      {phase.title}
                    </option>
                  ))}
                </Select>
              </FormGroup>

              <FormGroup>
                <Label>Priority</Label>
                <Select
                  value={formData.priority}
                  onChange={(e) => handleInputChange('priority', e.target.value)}
                >
                  <option value="low">Low</option>
                  <option value="medium">Medium</option>
                  <option value="high">High</option>
                </Select>
              </FormGroup>

              <FormGroup>
                <Label>Assignee</Label>
                <Input
                  type="text"
                  value={formData.assignee}
                  onChange={(e) => handleInputChange('assignee', e.target.value)}
                  placeholder="Assign to..."
                />
              </FormGroup>

              <FormGroup>
                <Label>Due Date</Label>
                <Input
                  type="date"
                  value={formData.dueDate}
                  onChange={(e) => handleInputChange('dueDate', e.target.value)}
                />
              </FormGroup>

              <ButtonGroup>
                <Button className="secondary" onClick={() => setShowModal(false)}>
                  Cancel
                </Button>
                <Button className="primary" onClick={handleCreateTask}>
                  Create Task
                </Button>
              </ButtonGroup>
            </Modal>
          </Overlay>
        )}
      </PageContent>
    </PageContainer>
  );
}
```

---

## src/components/common/Badge.tsx

**Path:** `src/components/common/Badge.tsx`

```tsx
/**
 * Badge - Unified badge/chip component with design token integration
 * 
 * Provides consistent status indicators and labels across the application
 * with proper color coding and accessibility.
 */

import React from 'react';
import styled, { css } from 'styled-components';

type BadgeVariant = 'default' | 'primary' | 'success' | 'warning' | 'error' | 'info';
type BadgeSize = 'small' | 'medium' | 'large';

interface BadgeProps {
  variant?: BadgeVariant;
  size?: BadgeSize;
  children: React.ReactNode;
  className?: string;
  dot?: boolean;
  icon?: React.ReactNode;
}

const getVariantStyles = (variant: BadgeVariant) => {
  switch (variant) {
    case 'primary':
      return css`
        background: ${({ theme }) => theme.colours.primaryLighter};
        color: ${({ theme }) => theme.colours.primary};
        border-color: ${({ theme }) => theme.colours.primaryLight};
      `;
    case 'success':
      return css`
        background: ${({ theme }) => theme.colours.successLighter};
        color: ${({ theme }) => theme.colours.successDark};
        border-color: ${({ theme }) => theme.colours.successLight};
      `;
    case 'warning':
      return css`
        background: ${({ theme }) => theme.colours.warningLighter};
        color: ${({ theme }) => theme.colours.warningDark};
        border-color: ${({ theme }) => theme.colours.warningLight};
      `;
    case 'error':
      return css`
        background: ${({ theme }) => theme.colours.errorLighter};
        color: ${({ theme }) => theme.colours.errorDark};
        border-color: ${({ theme }) => theme.colours.errorLight};
      `;
    case 'info':
      return css`
        background: ${({ theme }) => theme.colours.infoLighter};
        color: ${({ theme }) => theme.colours.infoDark};
        border-color: ${({ theme }) => theme.colours.infoLight};
      `;
    default:
      return css`
        background: ${({ theme }) => theme.colours.backgroundSubtle};
        color: ${({ theme }) => theme.colours.textSecondary};
        border-color: ${({ theme }) => theme.colours.border};
      `;
  }
};

const getSizeStyles = (size: BadgeSize) => {
  switch (size) {
    case 'small':
      return css`
        padding: 2px 8px;
        font-size: 11px;
      `;
    case 'large':
      return css`
        padding: 6px 14px;
        font-size: 14px;
      `;
    default:
      return css`
        padding: 4px 10px;
        font-size: 12px;
      `;
  }
};

const StyledBadge = styled.span<{ $variant: BadgeVariant; $size: BadgeSize }>`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-weight: 500;
  border-radius: 9999px;
  border: 1px solid transparent;
  white-space: nowrap;
  font-family: ${({ theme }) => theme.fontFamily};
  ${({ $variant }) => getVariantStyles($variant)}
  ${({ $size }) => getSizeStyles($size)}
`;

const Dot = styled.span<{ $variant: BadgeVariant }>`
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: currentColor;
`;

export const Badge: React.FC<BadgeProps> = ({
  variant = 'default',
  size = 'medium',
  children,
  className,
  dot,
  icon
}) => (
  <StyledBadge $variant={variant} $size={size} className={className}>
    {dot && <Dot $variant={variant} />}
    {icon && <span style={{ display: 'flex' }}>{icon}</span>}
    {children}
  </StyledBadge>
);

// Status-specific badges for common use cases
export const StatusBadge: React.FC<{
  status: 'active' | 'inactive' | 'pending' | 'error' | 'draft';
  children?: React.ReactNode;
}> = ({ status, children }) => {
  const variantMap: Record<typeof status, BadgeVariant> = {
    active: 'success',
    inactive: 'default',
    pending: 'warning',
    error: 'error',
    draft: 'info'
  };

  const labelMap: Record<typeof status, string> = {
    active: 'Active',
    inactive: 'Inactive',
    pending: 'Pending',
    error: 'Error',
    draft: 'Draft'
  };

  return (
    <Badge variant={variantMap[status]} dot>
      {children || labelMap[status]}
    </Badge>
  );
};

// Count badge for notifications
export const CountBadge = styled.span<{ $variant?: BadgeVariant }>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  padding: 0 6px;
  font-size: 11px;
  font-weight: 600;
  border-radius: 10px;
  background: ${({ theme, $variant }) => 
    $variant === 'error' ? theme.colours.error : theme.colours.primary};
  color: white;
  font-family: ${({ theme }) => theme.fontFamily};
`;

export default Badge;

```

---

## src/components/common/CommandPalette.tsx

**Path:** `src/components/common/CommandPalette.tsx`

```tsx
/**
 * CommandPalette - Enhanced global command palette accessible via Cmd+K
 *
 * Features:
 * - Fuzzy search with highlighting
 * - Recent actions tracking
 * - Keyboard shortcuts display
 * - AI-powered suggestions section
 * - Grouped results by category
 * - Smooth animations and transitions
 */

import React, { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import styled, { keyframes, css } from 'styled-components';
import {
  MagnifyingGlassIcon,
  HomeIcon,
  CubeIcon,
  DocumentTextIcon,
  CircleStackIcon,
  CheckCircleIcon,
  WrenchIcon,
  CpuChipIcon,
  XMarkIcon,
  ClockIcon,
  SparklesIcon,
  ArrowRightIcon,
  ChartBarIcon,
  Cog6ToothIcon,
  BookOpenIcon
} from '@heroicons/react/24/outline';

const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const slideDown = keyframes`
  from { opacity: 0; transform: translateY(-20px) scale(0.95); }
  to { opacity: 1; transform: translateY(0) scale(1); }
`;

const Overlay = styled.div`
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
  z-index: 9999;
  animation: ${fadeIn} 0.15s ease-out;
`;

const PaletteContainer = styled.div`
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  width: 100%;
  max-width: 560px;
  background: ${({ theme }) => theme.colours.backgroundElevated};
  border-radius: ${({ theme }) => theme.radiusLg};
  box-shadow: ${({ theme }) => theme.shadowXl};
  overflow: hidden;
  z-index: 10000;
  animation: ${slideDown} 0.2s ease-out;
`;

const SearchWrapper = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px 20px;
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
`;

const SearchIconStyled = styled(MagnifyingGlassIcon)`
  width: 20px;
  height: 20px;
  color: ${({ theme }) => theme.colours.textMuted};
  flex-shrink: 0;
`;

const SearchInput = styled.input`
  flex: 1;
  border: none;
  background: transparent;
  font-size: 16px;
  color: ${({ theme }) => theme.colours.text};
  outline: none;
  font-family: ${({ theme }) => theme.fontFamily};

  &::placeholder {
    color: ${({ theme }) => theme.colours.textMuted};
  }
`;

const CloseButton = styled.button`
  background: ${({ theme }) => theme.colours.backgroundSubtle};
  border: none;
  padding: 6px;
  border-radius: ${({ theme }) => theme.radiusSm};
  cursor: pointer;
  color: ${({ theme }) => theme.colours.textMuted};
  display: flex;
  align-items: center;
  justify-content: center;
  
  &:hover {
    color: ${({ theme }) => theme.colours.text};
    background: ${({ theme }) => theme.colours.hover};
  }
`;

const ResultsList = styled.div`
  max-height: 400px;
  overflow-y: auto;
  padding: 8px;
`;

const ResultItem = styled.button<{ $isSelected: boolean }>`
  width: 100%;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  border: none;
  background: ${({ theme, $isSelected }) => 
    $isSelected ? theme.colours.primaryLighter : 'transparent'};
  border-radius: ${({ theme }) => theme.radiusMd};
  cursor: pointer;
  text-align: left;
  transition: background 0.1s ease;

  &:hover {
    background: ${({ theme }) => theme.colours.hover};
  }

  svg {
    width: 18px;
    height: 18px;
    color: ${({ theme, $isSelected }) => 
      $isSelected ? theme.colours.primary : theme.colours.textMuted};
    flex-shrink: 0;
  }
`;

const ResultText = styled.div`
  flex: 1;
`;

const ResultTitle = styled.div`
  font-size: 14px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
`;

const ResultDescription = styled.div`
  font-size: 12px;
  color: ${({ theme }) => theme.colours.textMuted};
  margin-top: 2px;
`;

const Shortcut = styled.kbd`
  font-size: 11px;
  padding: 3px 6px;
  background: ${({ theme }) => theme.colours.backgroundSubtle};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 4px;
  color: ${({ theme }) => theme.colours.textMuted};
  font-family: ${({ theme }) => theme.fontFamily};
`;

const NoResults = styled.div`
  padding: 32px 16px;
  text-align: center;
  color: ${({ theme }) => theme.colours.textMuted};
  font-size: 14px;
`;

// Category Section
const CategorySection = styled.div`
  &:not(:first-child) {
    margin-top: 8px;
    border-top: 1px solid ${({ theme }) => theme.colours.border};
    padding-top: 8px;
  }
`;

const CategoryLabel = styled.div`
  padding: 8px 16px 4px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: ${({ theme }) => theme.colours.textMuted};
  display: flex;
  align-items: center;
  gap: 6px;

  svg {
    width: 12px;
    height: 12px;
  }
`;

// AI Suggestion Badge
const AISuggestionBadge = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  font-size: 10px;
  font-weight: 600;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.15));
  color: #6366f1;
  border-radius: 20px;
  margin-left: 8px;

  svg {
    width: 10px;
    height: 10px;
  }
`;

// Keyboard hint at bottom
const KeyboardHints = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 10px 16px;
  border-top: 1px solid ${({ theme }) => theme.colours.border};
  background: ${({ theme }) => theme.colours.backgroundSubtle};
  font-size: 12px;
  color: ${({ theme }) => theme.colours.textMuted};
`;

const KeyHint = styled.span`
  display: flex;
  align-items: center;
  gap: 6px;
`;

const KeyBadge = styled.kbd`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  padding: 0 5px;
  font-size: 11px;
  font-weight: 500;
  background: ${({ theme }) => theme.colours.background};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
`;

// Match highlighting
const HighlightedText = styled.span<{ $isMatch?: boolean }>`
  ${({ $isMatch }) => $isMatch && css`
    background: rgba(99, 102, 241, 0.2);
    color: #6366f1;
    border-radius: 2px;
    padding: 0 2px;
  `}
`;

// Fuzzy search helper
const fuzzyMatch = (text: string, query: string): { matches: boolean; indices: number[] } => {
  const lowerText = text.toLowerCase();
  const lowerQuery = query.toLowerCase();
  const indices: number[] = [];
  let queryIndex = 0;

  for (let i = 0; i < lowerText.length && queryIndex < lowerQuery.length; i++) {
    if (lowerText[i] === lowerQuery[queryIndex]) {
      indices.push(i);
      queryIndex++;
    }
  }

  return {
    matches: queryIndex === lowerQuery.length,
    indices
  };
};

const highlightMatches = (text: string, indices: number[]): React.ReactNode => {
  if (indices.length === 0) return text;

  const result: React.ReactNode[] = [];
  let lastIndex = 0;

  indices.forEach((idx, i) => {
    if (idx > lastIndex) {
      result.push(<span key={`text-${i}`}>{text.slice(lastIndex, idx)}</span>);
    }
    result.push(<HighlightedText key={`match-${i}`} $isMatch>{text[idx]}</HighlightedText>);
    lastIndex = idx + 1;
  });

  if (lastIndex < text.length) {
    result.push(<span key="text-end">{text.slice(lastIndex)}</span>);
  }

  return <>{result}</>;
};

// Recent actions storage key
const RECENT_ACTIONS_KEY = 'command-palette-recent';

interface CommandItem {
  id: string;
  title: string;
  description?: string;
  icon: React.ReactNode;
  action: () => void;
  keywords?: string[];
  category?: 'navigation' | 'action' | 'ai' | 'settings';
  shortcut?: string;
}

interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  additionalCommands?: CommandItem[];
}

export const CommandPalette: React.FC<CommandPaletteProps> = ({
  isOpen,
  onClose,
  additionalCommands = []
}) => {
  const [query, setQuery] = useState('');
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [recentIds, setRecentIds] = useState<string[]>([]);
  const inputRef = useRef<HTMLInputElement>(null);
  const navigate = useNavigate();

  // Load recent actions from localStorage
  useEffect(() => {
    try {
      const stored = localStorage.getItem(RECENT_ACTIONS_KEY);
      if (stored) setRecentIds(JSON.parse(stored));
    } catch { /* ignore */ }
  }, []);

  // Save recent action
  const saveRecentAction = useCallback((id: string) => {
    setRecentIds(prev => {
      const updated = [id, ...prev.filter(i => i !== id)].slice(0, 5);
      localStorage.setItem(RECENT_ACTIONS_KEY, JSON.stringify(updated));
      return updated;
    });
  }, []);

  const baseCommands: CommandItem[] = useMemo(() => [
    { id: 'home', title: 'Go to Home', description: 'Dashboard and AI assistant', icon: <HomeIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/'), keywords: ['dashboard', 'main'], category: 'navigation', shortcut: 'âŒ˜1' },
    { id: 'products', title: 'Go to Products', description: 'Product management', icon: <CubeIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/products'), keywords: ['product', 'insurance'], category: 'navigation', shortcut: 'âŒ˜2' },
    { id: 'builder', title: 'Open Builder', description: 'Build new products', icon: <WrenchIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/builder'), keywords: ['create', 'new'], category: 'navigation' },
    { id: 'ai-builder', title: 'AI Builder', description: 'AI-powered product creation', icon: <CpuChipIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/ai-builder'), keywords: ['ai', 'assistant'], category: 'ai' },
    { id: 'data-dictionary', title: 'Data Dictionary', description: 'Manage data definitions', icon: <CircleStackIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/data-dictionary'), keywords: ['data', 'fields'], category: 'navigation' },
    { id: 'tasks', title: 'Task Management', description: 'View and manage tasks', icon: <CheckCircleIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/tasks'), keywords: ['todo', 'work'], category: 'navigation' },
    { id: 'claims', title: 'Claims Analysis', description: 'Analyze claims data', icon: <DocumentTextIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/claims-analysis'), keywords: ['claims', 'analysis'], category: 'navigation' },
    { id: 'analytics', title: 'View Analytics', description: 'Product performance metrics', icon: <ChartBarIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/analytics'), keywords: ['metrics', 'reports'], category: 'navigation' },
    { id: 'settings', title: 'Settings', description: 'Application preferences', icon: <Cog6ToothIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/settings'), keywords: ['preferences', 'config'], category: 'settings' },
    { id: 'docs', title: 'Documentation', description: 'Help and guides', icon: <BookOpenIcon style={{ width: 18, height: 18 }} />, action: () => window.open('/docs', '_blank'), keywords: ['help', 'guide'], category: 'action' },
    { id: 'ai-suggest', title: 'AI Suggestions', description: 'Get AI-powered recommendations', icon: <SparklesIcon style={{ width: 18, height: 18 }} />, action: () => navigate('/ai-builder'), keywords: ['recommend', 'smart'], category: 'ai' },
  ], [navigate]);

  const allCommands = useMemo(() => [...baseCommands, ...additionalCommands], [baseCommands, additionalCommands]);

  // Fuzzy search with scoring
  const filteredCommands = useMemo(() => {
    if (!query.trim()) return allCommands;

    const results = allCommands.map(cmd => {
      const titleMatch = fuzzyMatch(cmd.title, query);
      const descMatch = cmd.description ? fuzzyMatch(cmd.description, query) : { matches: false, indices: [] };
      const keywordMatch = cmd.keywords?.some(k => k.toLowerCase().includes(query.toLowerCase()));

      return {
        cmd,
        matches: titleMatch.matches || descMatch.matches || keywordMatch,
        titleIndices: titleMatch.indices,
        score: titleMatch.matches ? titleMatch.indices.length : (descMatch.matches ? descMatch.indices.length * 0.5 : 0)
      };
    }).filter(r => r.matches);

    // Sort by score (higher is better match)
    results.sort((a, b) => b.score - a.score);

    return results.map(r => ({ ...r.cmd, _titleIndices: r.titleIndices }));
  }, [query, allCommands]);

  // Get recent commands
  const recentCommands = useMemo(() => {
    if (query.trim()) return [];
    return recentIds.map(id => allCommands.find(c => c.id === id)).filter(Boolean) as CommandItem[];
  }, [query, recentIds, allCommands]);

  // Group commands by category
  const groupedCommands = useMemo(() => {
    if (query.trim()) return { all: filteredCommands };

    const groups: Record<string, CommandItem[]> = {
      recent: recentCommands,
      ai: allCommands.filter(c => c.category === 'ai'),
      navigation: allCommands.filter(c => c.category === 'navigation'),
      action: allCommands.filter(c => c.category === 'action'),
      settings: allCommands.filter(c => c.category === 'settings'),
    };

    return groups;
  }, [query, filteredCommands, recentCommands, allCommands]);

  // Flatten for keyboard navigation
  const flatCommands = useMemo(() => {
    if (query.trim()) return filteredCommands;
    return [...recentCommands, ...allCommands.filter(c => !recentIds.includes(c.id))];
  }, [query, filteredCommands, recentCommands, allCommands, recentIds]);

  // Reset selection when query changes
  useEffect(() => { setSelectedIndex(0); }, [query]);

  // Focus input on open
  useEffect(() => {
    if (isOpen) {
      setQuery('');
      setSelectedIndex(0);
      setTimeout(() => inputRef.current?.focus(), 50);
    }
  }, [isOpen]);

  const executeCommand = useCallback((cmd: CommandItem) => {
    saveRecentAction(cmd.id);
    cmd.action();
    onClose();
  }, [saveRecentAction, onClose]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setSelectedIndex(i => Math.min(i + 1, flatCommands.length - 1));
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setSelectedIndex(i => Math.max(i - 1, 0));
    } else if (e.key === 'Enter' && flatCommands[selectedIndex]) {
      e.preventDefault();
      executeCommand(flatCommands[selectedIndex]);
    } else if (e.key === 'Escape') {
      onClose();
    }
  }, [flatCommands, selectedIndex, executeCommand, onClose]);

  const renderCommandItem = (cmd: CommandItem & { _titleIndices?: number[] }, _index: number, globalIndex: number) => (
    <ResultItem
      key={cmd.id}
      $isSelected={globalIndex === selectedIndex}
      onClick={() => executeCommand(cmd)}
      onMouseEnter={() => setSelectedIndex(globalIndex)}
    >
      {cmd.icon}
      <ResultText>
        <ResultTitle>
          {cmd._titleIndices ? highlightMatches(cmd.title, cmd._titleIndices) : cmd.title}
          {cmd.category === 'ai' && (
            <AISuggestionBadge>
              <SparklesIcon /> AI
            </AISuggestionBadge>
          )}
        </ResultTitle>
        {cmd.description && <ResultDescription>{cmd.description}</ResultDescription>}
      </ResultText>
      {cmd.shortcut && <Shortcut>{cmd.shortcut}</Shortcut>}
    </ResultItem>
  );

  if (!isOpen) return null;

  let globalIndex = 0;

  return (
    <>
      <Overlay onClick={onClose} />
      <PaletteContainer role="dialog" aria-modal="true" aria-label="Command palette" onKeyDown={handleKeyDown}>
        <SearchWrapper>
          <SearchIconStyled />
          <SearchInput ref={inputRef} value={query} onChange={e => setQuery(e.target.value)} placeholder="Type a command or search..." autoComplete="off" />
          <CloseButton onClick={onClose} aria-label="Close"><XMarkIcon style={{ width: 16, height: 16 }} /></CloseButton>
        </SearchWrapper>
        <ResultsList>
          {query.trim() ? (
            // Search results
            filteredCommands.length > 0 ? (
              filteredCommands.map((cmd, index) => renderCommandItem(cmd as CommandItem & { _titleIndices?: number[] }, index, index))
            ) : (
              <NoResults>No commands found for "{query}"</NoResults>
            )
          ) : (
            // Grouped view
            <>
              {groupedCommands.recent && groupedCommands.recent.length > 0 && (
                <CategorySection>
                  <CategoryLabel><ClockIcon /> Recent</CategoryLabel>
                  {groupedCommands.recent.map((cmd, index) => {
                    const item = renderCommandItem(cmd, index, globalIndex);
                    globalIndex++;
                    return item;
                  })}
                </CategorySection>
              )}
              {groupedCommands.ai && groupedCommands.ai.length > 0 && (
                <CategorySection>
                  <CategoryLabel><SparklesIcon /> AI-Powered</CategoryLabel>
                  {groupedCommands.ai.filter(c => !recentIds.includes(c.id)).map((cmd, index) => {
                    const item = renderCommandItem(cmd, index, globalIndex);
                    globalIndex++;
                    return item;
                  })}
                </CategorySection>
              )}
              {groupedCommands.navigation && groupedCommands.navigation.length > 0 && (
                <CategorySection>
                  <CategoryLabel><ArrowRightIcon /> Navigation</CategoryLabel>
                  {groupedCommands.navigation.filter(c => !recentIds.includes(c.id)).map((cmd, index) => {
                    const item = renderCommandItem(cmd, index, globalIndex);
                    globalIndex++;
                    return item;
                  })}
                </CategorySection>
              )}
            </>
          )}
        </ResultsList>
        <KeyboardHints>
          <KeyHint><KeyBadge>â†‘â†“</KeyBadge> Navigate</KeyHint>
          <KeyHint><KeyBadge>â†µ</KeyBadge> Select</KeyHint>
          <KeyHint><KeyBadge>esc</KeyBadge> Close</KeyHint>
        </KeyboardHints>
      </PaletteContainer>
    </>
  );
};

// Hook to manage command palette state with keyboard shortcut
export const useCommandPalette = () => {
  const [isOpen, setIsOpen] = useState(false);

  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        setIsOpen(prev => !prev);
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);

  return { isOpen, open: () => setIsOpen(true), close: () => setIsOpen(false) };
};

export default CommandPalette;

```

---

## src/components/common/CoverageSnapshot.tsx

**Path:** `src/components/common/CoverageSnapshot.tsx`

```tsx
import React from 'react';
import {
  ShieldCheckIcon,
  DocumentTextIcon,
  Cog6ToothIcon,
  MapIcon
} from '@heroicons/react/24/outline';

import {
  EnhancedCard,
  CardHeader,
  CardTitle,
  CardSubtitle,
  CardContent,
  TypeBadge,
  CountBadge
} from './DesignSystem';
import { TextMuted, Code } from './Typography';

interface CoverageSnapshotProps {
  name: string;
  coverageCode?: string;
  isOptional?: boolean;
  productName?: string;
  parentCoverageName?: string;
  statesCount?: number;
  formsCount?: number;
  rulesCount?: number;
  healthLabel?: string;
  healthScore?: number;
  healthTooltip?: string;
  triggerLabel?: string;
  valuationLabel?: string;
  territoryLabel?: string;
  coinsuranceLabel?: string;
  waitingPeriodLabel?: string;
}

interface MetricBadgeProps {
  icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
  label: string;
  count?: number;
}

const MetricBadge: React.FC<MetricBadgeProps> = ({ icon: Icon, label, count }) => (
  <div style={{ display: 'flex', alignItems: 'center', gap: 8, fontSize: 12 }}>
    <Icon width={16} height={16} />
    <span>{label}</span>
    {typeof count === 'number' && (
      <CountBadge $variant={count > 0 ? 'success' : 'default'}>
        {count}
      </CountBadge>
    )}
  </div>
);

const AttributePill: React.FC<{ label: string; value: string }> = ({ label, value }) => (
  <span
    style={{
      display: 'inline-flex',
      alignItems: 'center',
      gap: 4,
      padding: '4px 10px',
      borderRadius: 9999,
      background: 'rgba(148, 163, 184, 0.12)',
      color: '#0f172a',
      fontSize: 12,
      fontWeight: 500,
      whiteSpace: 'nowrap'
    }}
  >
    <span style={{ opacity: 0.75 }}>{label}:</span>
    <span>{value}</span>
  </span>
);

export const CoverageSnapshot: React.FC<CoverageSnapshotProps> = ({
  name,
  coverageCode,
  isOptional,
  productName,
  parentCoverageName,
  statesCount,
  formsCount,
  rulesCount,
  healthLabel,
  healthScore,
  healthTooltip,
  triggerLabel,
  valuationLabel,
  territoryLabel,
  coinsuranceLabel,
  waitingPeriodLabel
}) => {
  const hasAttributes = !!(
    triggerLabel ||
    valuationLabel ||
    territoryLabel ||
    coinsuranceLabel ||
    waitingPeriodLabel
  );

  return (
    <EnhancedCard $variant="outlined">
      <CardHeader>
        <div>
          <CardTitle>
            <ShieldCheckIcon width={18} height={18} />
            {name}
            {typeof isOptional === 'boolean' && (
              <TypeBadge $color={isOptional ? '#0ea5e9' : '#10b981'}>
                {isOptional ? 'Optional coverage' : 'Required coverage'}
              </TypeBadge>
            )}
          </CardTitle>
          <CardSubtitle>
            {coverageCode && <Code>{coverageCode}</Code>}
            {productName && (
              <>
                {' Â· '} {productName}
              </>
            )}
            {parentCoverageName && (
              <>
                {' Â· '} Sub-coverage of {parentCoverageName}
              </>
            )}
          </CardSubtitle>
        </div>

        {healthLabel && typeof healthScore === 'number' && (
          <div style={{ textAlign: 'right' }} title={healthTooltip}>
            <TextMuted>Coverage health</TextMuted>
            <div style={{ fontSize: 13, fontWeight: 600 }}>
              {healthLabel} Â· {healthScore}%
            </div>
          </div>
        )}
      </CardHeader>

      <CardContent>
        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 16, marginBottom: hasAttributes ? 12 : 0 }}>
          {typeof statesCount === 'number' && (
            <MetricBadge icon={MapIcon} label="States" count={statesCount} />
          )}
          {typeof formsCount === 'number' && (
            <MetricBadge icon={DocumentTextIcon} label="Forms" count={formsCount} />
          )}
          {typeof rulesCount === 'number' && (
            <MetricBadge icon={Cog6ToothIcon} label="Rules" count={rulesCount} />
          )}
        </div>

        {hasAttributes && (
          <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
            {triggerLabel && <AttributePill label="Trigger" value={triggerLabel} />}
            {valuationLabel && <AttributePill label="Valuation" value={valuationLabel} />}
            {territoryLabel && <AttributePill label="Territory" value={territoryLabel} />}
            {coinsuranceLabel && <AttributePill label="Coinsurance" value={coinsuranceLabel} />}
            {waitingPeriodLabel && <AttributePill label="Wait" value={waitingPeriodLabel} />}
          </div>
        )}
      </CardContent>
    </EnhancedCard>
  );
};

export default CoverageSnapshot;

```

---

## src/components/common/DesignSystem.tsx

**Path:** `src/components/common/DesignSystem.tsx`

```tsx
/**
 * DesignSystem - Shared design tokens and components
 * 
 * Provides consistent styling across all pages with:
 * - Animation keyframes
 * - Color system
 * - Shared styled components
 * - Statistics dashboard components
 * - Enhanced modal components
 */

import styled, { keyframes, css } from 'styled-components';

// ============ Animation Keyframes ============

export const fadeInUp = keyframes`
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
`;

export const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

export const scaleIn = keyframes`
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
`;

export const slideDown = keyframes`
  from { opacity: 0; max-height: 0; transform: translateY(-8px); }
  to { opacity: 1; max-height: 2000px; transform: translateY(0); }
`;

export const slideUp = keyframes`
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
`;

export const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
`;

export const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

export const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

export const ripple = keyframes`
  0% { transform: scale(0); opacity: 1; }
  100% { transform: scale(4); opacity: 0; }
`;

export const glow = keyframes`
  0%, 100% { box-shadow: 0 0 5px rgba(99, 102, 241, 0.2); }
  50% { box-shadow: 0 0 20px rgba(99, 102, 241, 0.4); }
`;

// ============ Color System ============

export const colors = {
  primary: '#6366f1',
  primaryDark: '#4f46e5',
  primaryLight: '#818cf8',
  secondary: '#8b5cf6',
  success: '#10b981',
  successDark: '#059669',
  warning: '#f59e0b',
  warningDark: '#d97706',
  error: '#ef4444',
  errorDark: '#dc2626',
  info: '#06b6d4',
  infoDark: '#0891b2',
  
  gray50: '#f8fafc',
  gray100: '#f1f5f9',
  gray200: '#e2e8f0',
  gray300: '#cbd5e1',
  gray400: '#94a3b8',
  gray500: '#64748b',
  gray600: '#475569',
  gray700: '#334155',
  gray800: '#1e293b',
  gray900: '#0f172a',
};

export const gradients = {
  primary: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
  success: 'linear-gradient(135deg, #10b981 0%, #059669 100%)',
  warning: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
  info: 'linear-gradient(135deg, #06b6d4 0%, #0891b2 100%)',
  error: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)',
  background: 'linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%)',
};

// ============ Statistics Dashboard ============

export const StatsDashboard = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
  margin-bottom: 32px;
  animation: ${fadeInUp} 0.4s ease-out;

  @media (max-width: 768px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
  }
`;

export const StatCard = styled.div<{ $color?: string; $clickable?: boolean }>`
  background: white;
  border-radius: 16px;
  padding: 20px 24px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.03);
  position: relative;
  overflow: hidden;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  ${({ $clickable }) => $clickable && 'cursor: pointer;'}

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: ${({ $color }) => $color || gradients.primary};
  }

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.08);
    border-color: rgba(99, 102, 241, 0.3);
  }
`;

export const StatValue = styled.div`
  font-size: 32px;
  font-weight: 700;
  color: ${colors.gray800};
  letter-spacing: -0.02em;
  line-height: 1.2;
`;

export const StatLabel = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  font-weight: 500;
  color: ${colors.gray500};
  margin-top: 4px;

  svg {
    width: 14px;
    height: 14px;
    opacity: 0.7;
  }
`;

export const StatTrend = styled.span<{ $positive?: boolean }>`
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  font-weight: 600;
  color: ${({ $positive }) => $positive ? colors.success : colors.error};
  margin-top: 8px;

  svg {
    width: 12px;
    height: 12px;
  }
`;

// ============ Enhanced Card Components ============

export const EnhancedCard = styled.div<{ $variant?: 'default' | 'elevated' | 'outlined'; $delay?: number }>`
  background: white;
  border-radius: 16px;
  padding: 24px;
  border: 1px solid rgba(226, 232, 240, 0.9);
  box-shadow: ${({ $variant }) =>
    $variant === 'elevated'
      ? '0 8px 24px rgba(0, 0, 0, 0.08)'
      : '0 4px 16px rgba(0, 0, 0, 0.04)'};
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  animation: ${fadeInUp} 0.35s ease-out backwards;
  animation-delay: ${({ $delay }) => ($delay || 0) * 0.05}s;
  position: relative;
  overflow: hidden;

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 20px 40px rgba(99, 102, 241, 0.12);
    border-color: rgba(99, 102, 241, 0.4);
  }
`;

export const CardHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 16px;
`;

export const CardTitle = styled.h3`
  font-size: 18px;
  font-weight: 600;
  color: ${colors.gray800};
  margin: 0;
  display: flex;
  align-items: center;
  gap: 10px;
`;

export const CardSubtitle = styled.p`
  font-size: 14px;
  color: ${colors.gray500};
  margin: 4px 0 0 0;
`;

export const CardContent = styled.div`
  flex: 1;
`;

export const CardFooter = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid rgba(226, 232, 240, 0.6);
`;

export const CardActions = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

// ============ Icon Button ============

export const IconButton = styled.button<{ $variant?: 'default' | 'ghost' | 'danger' }>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 10px;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;

  ${({ $variant }) => {
    switch ($variant) {
      case 'danger':
        return css`
          background: rgba(239, 68, 68, 0.1);
          color: ${colors.error};
          &:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: scale(1.05);
          }
        `;
      case 'ghost':
        return css`
          background: transparent;
          color: ${colors.gray500};
          &:hover {
            background: rgba(99, 102, 241, 0.1);
            color: ${colors.primary};
          }
        `;
      default:
        return css`
          background: rgba(99, 102, 241, 0.1);
          color: ${colors.primary};
          &:hover {
            background: rgba(99, 102, 241, 0.2);
            transform: scale(1.05);
          }
        `;
    }
  }}

  svg {
    width: 18px;
    height: 18px;
  }

  &:active {
    transform: scale(0.95);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
`;

// ============ Badge Components ============

export const TypeBadge = styled.span<{ $color?: string }>`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 600;
  text-transform: capitalize;
  background: ${({ $color }) => $color ? `${$color}15` : 'rgba(99, 102, 241, 0.1)'};
  color: ${({ $color }) => $color || colors.primary};
  border: 1px solid ${({ $color }) => $color ? `${$color}30` : 'rgba(99, 102, 241, 0.2)'};

  svg {
    width: 14px;
    height: 14px;
  }
`;

export const CountBadge = styled.span<{ $variant?: 'default' | 'success' | 'warning' | 'error' }>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 24px;
  height: 24px;
  padding: 0 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 700;

  ${({ $variant }) => {
    switch ($variant) {
      case 'success':
        return css`
          background: rgba(16, 185, 129, 0.15);
          color: ${colors.successDark};
        `;
      case 'warning':
        return css`
          background: rgba(245, 158, 11, 0.15);
          color: ${colors.warningDark};
        `;
      case 'error':
        return css`
          background: rgba(239, 68, 68, 0.15);
          color: ${colors.errorDark};
        `;
      default:
        return css`
          background: rgba(100, 116, 139, 0.1);
          color: ${colors.gray600};
        `;
    }
  }}
`;

// ============ Empty State ============

export const EmptyStateContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 40px;
  text-align: center;
  animation: ${fadeIn} 0.5s ease-out;
`;

export const EmptyStateIcon = styled.div<{ $color?: string }>`
  width: 80px;
  height: 80px;
  border-radius: 24px;
  background: ${({ $color }) => $color ? `${$color}10` : 'rgba(99, 102, 241, 0.1)'};
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;

  svg {
    width: 40px;
    height: 40px;
    color: ${({ $color }) => $color || colors.primary};
    opacity: 0.8;
  }
`;

export const EmptyStateTitle = styled.h3`
  font-size: 20px;
  font-weight: 600;
  color: ${colors.gray800};
  margin: 0 0 8px 0;
`;

export const EmptyStateDescription = styled.p`
  font-size: 15px;
  color: ${colors.gray500};
  margin: 0 0 24px 0;
  max-width: 400px;
  line-height: 1.5;
`;

// ============ Loading Spinner ============

export const LoadingSpinner = styled.div<{ $size?: number; $color?: string }>`
  width: ${({ $size }) => $size || 24}px;
  height: ${({ $size }) => $size || 24}px;
  border: 2.5px solid rgba(99, 102, 241, 0.2);
  border-top-color: ${({ $color }) => $color || colors.primary};
  border-radius: 50%;
  animation: ${spin} 0.8s linear infinite;
`;

export const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 20px;
  gap: 16px;
`;

export const LoadingText = styled.span`
  font-size: 14px;
  color: ${colors.gray500};
  font-weight: 500;
`;

// ============ Action Bar for Bulk Operations ============

export const ActionBar = styled.div<{ $visible?: boolean }>`
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%) ${({ $visible }) => $visible ? 'translateY(0)' : 'translateY(100px)'};
  background: white;
  border-radius: 16px;
  padding: 12px 20px;
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
  border: 1px solid rgba(99, 102, 241, 0.2);
  display: flex;
  align-items: center;
  gap: 16px;
  z-index: 100;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  opacity: ${({ $visible }) => $visible ? 1 : 0};
  pointer-events: ${({ $visible }) => $visible ? 'auto' : 'none'};
`;

export const ActionBarCount = styled.span`
  font-size: 14px;
  font-weight: 600;
  color: ${colors.gray700};
  padding-right: 16px;
  border-right: 1px solid ${colors.gray200};
`;

export const ActionBarButton = styled.button<{ $variant?: 'default' | 'danger' }>`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;

  ${({ $variant }) => $variant === 'danger' ? css`
    background: rgba(239, 68, 68, 0.1);
    color: ${colors.error};
    &:hover { background: rgba(239, 68, 68, 0.2); }
  ` : css`
    background: rgba(99, 102, 241, 0.1);
    color: ${colors.primary};
    &:hover { background: rgba(99, 102, 241, 0.2); }
  `}

  svg {
    width: 16px;
    height: 16px;
  }
`;

// ============ Slider Component ============

export const SliderContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

export const SliderTrack = styled.div`
  position: relative;
  height: 8px;
  background: ${colors.gray100};
  border-radius: 4px;
  cursor: pointer;
`;

export const SliderFill = styled.div<{ $percentage: number; $color?: string }>`
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: ${({ $percentage }) => $percentage}%;
  background: ${({ $color }) => $color || gradients.primary};
  border-radius: 4px;
  transition: width 0.2s ease;
`;

export const SliderThumb = styled.div<{ $percentage: number }>`
  position: absolute;
  top: 50%;
  left: ${({ $percentage }) => $percentage}%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  background: white;
  border: 2px solid ${colors.primary};
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  cursor: grab;
  transition: transform 0.15s ease, box-shadow 0.15s ease;

  &:hover {
    transform: translate(-50%, -50%) scale(1.15);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
  }

  &:active {
    cursor: grabbing;
    transform: translate(-50%, -50%) scale(1.1);
  }
`;

export const SliderLabels = styled.div`
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: ${colors.gray400};
`;

// ============ Quick Amount Buttons ============

export const QuickAmountContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
`;

export const QuickAmountButton = styled.button<{ $active?: boolean }>`
  padding: 6px 14px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 600;
  border: 1.5px solid ${({ $active }) => $active ? colors.primary : colors.gray200};
  background: ${({ $active }) => $active ? 'rgba(99, 102, 241, 0.1)' : 'white'};
  color: ${({ $active }) => $active ? colors.primary : colors.gray600};
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: ${colors.primary};
    background: rgba(99, 102, 241, 0.05);
  }
`;

// ============ Section Header ============

export const SectionHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
`;

export const SectionTitle = styled.h2`
  font-size: 20px;
  font-weight: 700;
  color: ${colors.gray800};
  margin: 0;
  display: flex;
  align-items: center;
  gap: 10px;
`;

export const SectionSubtitle = styled.p`
  font-size: 14px;
  color: ${colors.gray500};
  margin: 4px 0 0 0;
`;

// ============ Filter Chips ============

export const FilterChipsContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 20px;
`;

export const FilterChip = styled.button<{ $active?: boolean }>`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  border-radius: 24px;
  font-size: 13px;
  font-weight: 500;
  border: 1.5px solid ${({ $active }) => $active ? colors.primary : colors.gray200};
  background: ${({ $active }) => $active ? 'rgba(99, 102, 241, 0.1)' : 'white'};
  color: ${({ $active }) => $active ? colors.primary : colors.gray600};
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: ${colors.primary};
    background: rgba(99, 102, 241, 0.05);
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

// ============ Gradient Bar ============

export const GradientBar = styled.div<{ $gradient?: string }>`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: ${({ $gradient }) => $gradient || gradients.primary};
  border-radius: 16px 16px 0 0;
`;

```

---

## src/components/common/ProgressBar.tsx

**Path:** `src/components/common/ProgressBar.tsx`

```tsx
/**
 * ProgressBar - Determinate progress indicator for multi-step processes
 * 
 * Provides visual feedback for operations with known progress,
 * such as file uploads, multi-step wizards, or batch operations.
 */

import React from 'react';
import styled, { keyframes, css } from 'styled-components';

const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
`;

type ProgressBarVariant = 'primary' | 'success' | 'warning' | 'error';
type ProgressBarSize = 'small' | 'medium' | 'large';

interface ProgressBarProps {
  value: number; // 0-100
  variant?: ProgressBarVariant;
  size?: ProgressBarSize;
  showLabel?: boolean;
  label?: string;
  animated?: boolean;
  striped?: boolean;
  className?: string;
}

const getVariantColor = (variant: ProgressBarVariant) => {
  switch (variant) {
    case 'success': return css`${({ theme }) => theme.colours.success}`;
    case 'warning': return css`${({ theme }) => theme.colours.warning}`;
    case 'error': return css`${({ theme }) => theme.colours.error}`;
    default: return css`${({ theme }) => theme.colours.primary}`;
  }
};

const getSizeHeight = (size: ProgressBarSize) => {
  switch (size) {
    case 'small': return '6px';
    case 'large': return '16px';
    default: return '10px';
  }
};

const Container = styled.div`
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const LabelRow = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const LabelText = styled.span`
  font-size: 13px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
`;

const ValueText = styled.span`
  font-size: 13px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.textSecondary};
`;

const Track = styled.div<{ $size: ProgressBarSize }>`
  width: 100%;
  height: ${({ $size }) => getSizeHeight($size)};
  background: ${({ theme }) => theme.colours.backgroundSubtle};
  border-radius: 9999px;
  overflow: hidden;
  position: relative;
`;

const Fill = styled.div<{
  $value: number;
  $variant: ProgressBarVariant;
  $animated: boolean;
  $striped: boolean;
}>`
  height: 100%;
  width: ${({ $value }) => `${Math.min(100, Math.max(0, $value))}%`};
  background: ${({ $variant }) => getVariantColor($variant)};
  border-radius: 9999px;
  transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;

  ${({ $animated }) => $animated && css`
    animation: ${pulse} 1.5s ease-in-out infinite;
  `}

  ${({ $striped }) => $striped && css`
    background-image: linear-gradient(
      45deg,
      rgba(255, 255, 255, 0.15) 25%,
      transparent 25%,
      transparent 50%,
      rgba(255, 255, 255, 0.15) 50%,
      rgba(255, 255, 255, 0.15) 75%,
      transparent 75%,
      transparent
    );
    background-size: 16px 16px;
    animation: ${shimmer} 1s linear infinite;
  `}
`;

export const ProgressBar: React.FC<ProgressBarProps> = ({
  value,
  variant = 'primary',
  size = 'medium',
  showLabel = false,
  label,
  animated = false,
  striped = false,
  className
}) => {
  const clampedValue = Math.min(100, Math.max(0, value));

  return (
    <Container className={className} role="progressbar" aria-valuenow={clampedValue} aria-valuemin={0} aria-valuemax={100}>
      {(showLabel || label) && (
        <LabelRow>
          <LabelText>{label || 'Progress'}</LabelText>
          <ValueText>{Math.round(clampedValue)}%</ValueText>
        </LabelRow>
      )}
      <Track $size={size}>
        <Fill
          $value={clampedValue}
          $variant={variant}
          $animated={animated}
          $striped={striped}
        />
      </Track>
    </Container>
  );
};

// Step progress for multi-step forms/wizards
interface StepProgressProps {
  currentStep: number;
  totalSteps: number;
  stepLabels?: string[];
  className?: string;
}

const StepContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 4px;
`;

const StepDot = styled.div<{ $isActive: boolean; $isCompleted: boolean }>`
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: ${({ theme, $isActive, $isCompleted }) =>
    $isCompleted ? theme.colours.success :
    $isActive ? theme.colours.primary :
    theme.colours.backgroundSubtle};
  border: 2px solid ${({ theme, $isActive, $isCompleted }) =>
    $isCompleted ? theme.colours.success :
    $isActive ? theme.colours.primary :
    theme.colours.border};
  transition: all 0.2s ease;
`;

const StepConnector = styled.div<{ $isCompleted: boolean }>`
  flex: 1;
  height: 2px;
  background: ${({ theme, $isCompleted }) =>
    $isCompleted ? theme.colours.success : theme.colours.border};
  transition: background 0.2s ease;
`;

export const StepProgress: React.FC<StepProgressProps> = ({
  currentStep,
  totalSteps,
  className
}) => (
  <StepContainer className={className} role="progressbar" aria-valuenow={currentStep} aria-valuemin={1} aria-valuemax={totalSteps}>
    {Array.from({ length: totalSteps }).map((_, index) => (
      <React.Fragment key={index}>
        <StepDot
          $isActive={index === currentStep - 1}
          $isCompleted={index < currentStep - 1}
        />
        {index < totalSteps - 1 && (
          <StepConnector $isCompleted={index < currentStep - 1} />
        )}
      </React.Fragment>
    ))}
  </StepContainer>
);

export default ProgressBar;

```

---

## src/components/common/Skeleton.tsx

**Path:** `src/components/common/Skeleton.tsx`

```tsx
/**
 * Skeleton - Advanced placeholder loading components
 *
 * Features:
 * - Branded shimmer animation with AI-inspired glow
 * - Multiple variants for different content types
 * - Staggered animation delays for visual hierarchy
 * - Accessible loading states
 * - Performance optimized with will-change
 */

import React from 'react';
import styled, { keyframes, css } from 'styled-components';

const shimmer = keyframes`
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
`;

const pulse = keyframes`
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
`;

const aiGlow = keyframes`
  0%, 100% {
    box-shadow: 0 0 0 rgba(99, 102, 241, 0);
  }
  50% {
    box-shadow: 0 0 20px rgba(99, 102, 241, 0.1);
  }
`;

interface SkeletonBaseProps {
  $width?: string | undefined;
  $height?: string | undefined;
  $borderRadius?: string | undefined;
  $variant?: 'default' | 'subtle' | 'branded' | undefined;
  $animated?: boolean | undefined;
  $delay?: number | undefined;
}

const getVariantStyles = (variant: string = 'default') => {
  switch (variant) {
    case 'subtle':
      return css`
        background: linear-gradient(
          90deg,
          rgba(241, 245, 249, 0.5) 25%,
          rgba(226, 232, 240, 0.5) 50%,
          rgba(241, 245, 249, 0.5) 75%
        );
      `;
    case 'branded':
      return css`
        background: linear-gradient(
          90deg,
          rgba(99, 102, 241, 0.08) 25%,
          rgba(139, 92, 246, 0.12) 50%,
          rgba(99, 102, 241, 0.08) 75%
        );
        animation: ${shimmer} 1.5s ease-in-out infinite, ${aiGlow} 3s ease-in-out infinite;
      `;
    default:
      return css`
        background: linear-gradient(
          90deg,
          #f1f5f9 25%,
          #e2e8f0 50%,
          #f1f5f9 75%
        );
      `;
  }
};

const SkeletonBase = styled.div<SkeletonBaseProps>`
  ${({ $variant }) => getVariantStyles($variant)}
  background-size: 200% 100%;
  animation: ${shimmer} 1.5s ease-in-out infinite;
  animation-delay: ${({ $delay = 0 }) => $delay}ms;
  border-radius: ${({ $borderRadius, theme }) => $borderRadius || theme.radiusSm};
  width: ${({ $width }) => $width || '100%'};
  height: ${({ $height }) => $height || '20px'};
  will-change: background-position;

  ${({ $animated = true }) => !$animated && css`
    animation: ${pulse} 2s ease-in-out infinite;
  `}
`;

// Basic skeleton variants
export const SkeletonText = styled(SkeletonBase)`
  height: 16px;
  margin-bottom: 8px;
  
  &:last-child {
    width: 70%;
  }
`;

export const SkeletonHeading = styled(SkeletonBase)`
  height: 28px;
  width: 60%;
  margin-bottom: 16px;
`;

export const SkeletonAvatar = styled(SkeletonBase)`
  width: 40px;
  height: 40px;
  border-radius: 50%;
  flex-shrink: 0;
`;

export const SkeletonButton = styled(SkeletonBase)`
  width: 120px;
  height: 40px;
  border-radius: ${({ theme }) => theme.radiusMd};
`;

export const SkeletonCard = styled.div`
  padding: 20px;
  background: ${({ theme }) => theme.colours.background};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: ${({ theme }) => theme.radiusMd};
`;

// Table skeleton
const TableSkeletonWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const TableRowSkeleton = styled.div`
  display: flex;
  gap: 16px;
  padding: 12px 16px;
  background: ${({ theme }) => theme.colours.background};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: ${({ theme }) => theme.radiusSm};
`;

interface SkeletonTableProps {
  rows?: number;
  columns?: number;
}

export const SkeletonTable: React.FC<SkeletonTableProps> = ({ rows = 5, columns = 4 }) => (
  <TableSkeletonWrapper role="status" aria-label="Loading table data">
    {Array.from({ length: rows }).map((_, rowIndex) => (
      <TableRowSkeleton key={rowIndex}>
        {Array.from({ length: columns }).map((_, colIndex) => (
          <SkeletonBase
            key={colIndex}
            $width={colIndex === 0 ? '30%' : `${70 / (columns - 1)}%`}
            $height="16px"
          />
        ))}
      </TableRowSkeleton>
    ))}
  </TableSkeletonWrapper>
);

// Card list skeleton
const CardListWrapper = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 16px;
`;

interface SkeletonCardListProps {
  count?: number;
}

export const SkeletonCardList: React.FC<SkeletonCardListProps> = ({ count = 6 }) => (
  <CardListWrapper role="status" aria-label="Loading cards">
    {Array.from({ length: count }).map((_, index) => (
      <SkeletonCard key={index}>
        <SkeletonHeading />
        <SkeletonText />
        <SkeletonText />
        <SkeletonText />
      </SkeletonCard>
    ))}
  </CardListWrapper>
);

// Form skeleton
export const SkeletonForm: React.FC<{ fields?: number }> = ({ fields = 4 }) => (
  <div role="status" aria-label="Loading form" style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
    {Array.from({ length: fields }).map((_, index) => (
      <div key={index}>
        <SkeletonBase $width="120px" $height="14px" style={{ marginBottom: '8px' }} />
        <SkeletonBase $width="100%" $height="40px" $borderRadius="8px" />
      </div>
    ))}
    <SkeletonButton style={{ marginTop: '8px' }} />
  </div>
);

// Generic configurable skeleton
interface SkeletonProps {
  width?: string;
  height?: string;
  borderRadius?: string;
  className?: string;
  variant?: 'default' | 'subtle' | 'branded';
  delay?: number;
}

export const Skeleton: React.FC<SkeletonProps> = ({
  width = '100%',
  height = '16px',
  borderRadius = '6px',
  className,
  variant = 'default',
  delay = 0
}) => (
  <SkeletonBase
    $width={width}
    $height={height}
    $borderRadius={borderRadius}
    $variant={variant}
    $delay={delay}
    className={className}
    role="status"
    aria-label="Loading"
  />
);

// Product Card Skeleton - matches ProductCard layout
const ProductCardSkeletonWrapper = styled.div`
  padding: 24px;
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 16px;
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const ProductCardHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
`;

const ProductCardContent = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const ProductCardFooter = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 8px;
`;

export const SkeletonProductCard: React.FC<{ index?: number }> = ({ index = 0 }) => (
  <ProductCardSkeletonWrapper role="status" aria-label="Loading product">
    <ProductCardHeader>
      <SkeletonBase
        $width="48px"
        $height="48px"
        $borderRadius="12px"
        $variant="branded"
        $delay={index * 100}
      />
      <div style={{ flex: 1 }}>
        <SkeletonBase $width="70%" $height="20px" $delay={index * 100 + 50} />
        <SkeletonBase $width="40%" $height="14px" style={{ marginTop: 8 }} $delay={index * 100 + 100} />
      </div>
    </ProductCardHeader>
    <ProductCardContent>
      <SkeletonBase $width="100%" $height="14px" $delay={index * 100 + 150} />
      <SkeletonBase $width="85%" $height="14px" $delay={index * 100 + 200} />
    </ProductCardContent>
    <ProductCardFooter>
      <SkeletonBase $width="80px" $height="24px" $borderRadius="12px" $delay={index * 100 + 250} />
      <SkeletonBase $width="100px" $height="32px" $borderRadius="8px" $delay={index * 100 + 300} />
    </ProductCardFooter>
  </ProductCardSkeletonWrapper>
);

// Chat Message Skeleton - for AI chat interfaces
const ChatMessageSkeletonWrapper = styled.div<{ $isUser?: boolean }>`
  display: flex;
  gap: 12px;
  flex-direction: ${({ $isUser }) => $isUser ? 'row-reverse' : 'row'};
  padding: 16px;
`;

const ChatBubble = styled.div<{ $isUser?: boolean }>`
  max-width: 70%;
  padding: 16px 20px;
  background: ${({ $isUser }) => $isUser ? 'rgba(99, 102, 241, 0.1)' : 'rgba(255, 255, 255, 0.9)'};
  border-radius: ${({ $isUser }) => $isUser ? '20px 20px 4px 20px' : '20px 20px 20px 4px'};
  border: 1px solid rgba(226, 232, 240, 0.5);
`;

export const SkeletonChatMessage: React.FC<{ isUser?: boolean; lines?: number }> = ({
  isUser = false,
  lines = 3
}) => (
  <ChatMessageSkeletonWrapper $isUser={isUser} role="status" aria-label="Loading message">
    <SkeletonBase $width="36px" $height="36px" $borderRadius="50%" $variant="branded" />
    <ChatBubble $isUser={isUser}>
      {Array.from({ length: lines }).map((_, i) => (
        <SkeletonBase
          key={i}
          $width={i === lines - 1 ? '60%' : '100%'}
          $height="14px"
          $variant={isUser ? 'branded' : 'default'}
          $delay={i * 100}
          style={{ marginBottom: i < lines - 1 ? 8 : 0 }}
        />
      ))}
    </ChatBubble>
  </ChatMessageSkeletonWrapper>
);

// Stats/Metrics Skeleton
const StatsGridSkeleton = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
`;

const StatCardSkeleton = styled.div`
  padding: 20px;
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 12px;
`;

export const SkeletonStats: React.FC<{ count?: number }> = ({ count = 4 }) => (
  <StatsGridSkeleton role="status" aria-label="Loading statistics">
    {Array.from({ length: count }).map((_, index) => (
      <StatCardSkeleton key={index}>
        <SkeletonBase $width="100px" $height="12px" $delay={index * 50} />
        <SkeletonBase $width="140px" $height="32px" $variant="branded" style={{ marginTop: 12 }} $delay={index * 50 + 50} />
        <SkeletonBase $width="80px" $height="14px" style={{ marginTop: 8 }} $delay={index * 50 + 100} />
      </StatCardSkeleton>
    ))}
  </StatsGridSkeleton>
);

// Page Header Skeleton
export const SkeletonPageHeader: React.FC = () => (
  <div role="status" aria-label="Loading page header" style={{ marginBottom: 32 }}>
    <div style={{ display: 'flex', alignItems: 'center', gap: 16 }}>
      <SkeletonBase $width="48px" $height="48px" $borderRadius="12px" $variant="branded" />
      <div style={{ flex: 1 }}>
        <SkeletonBase $width="300px" $height="32px" />
        <SkeletonBase $width="200px" $height="16px" style={{ marginTop: 8 }} $delay={100} />
      </div>
      <SkeletonBase $width="140px" $height="40px" $borderRadius="10px" $delay={200} />
    </div>
  </div>
);

// Navigation Skeleton
export const SkeletonNavigation: React.FC = () => (
  <div
    role="status"
    aria-label="Loading navigation"
    style={{
      display: 'flex',
      alignItems: 'center',
      gap: 8,
      padding: '12px 24px',
      background: 'rgba(255, 255, 255, 0.9)',
      borderBottom: '1px solid rgba(226, 232, 240, 0.8)'
    }}
  >
    {Array.from({ length: 6 }).map((_, index) => (
      <SkeletonBase
        key={index}
        $width="80px"
        $height="32px"
        $borderRadius="8px"
        $delay={index * 50}
      />
    ))}
    <div style={{ marginLeft: 'auto' }}>
      <SkeletonBase $width="120px" $height="36px" $borderRadius="10px" $delay={350} />
    </div>
  </div>
);

export default Skeleton;
```

---

## src/components/common/StatusAnnouncer.tsx

**Path:** `src/components/common/StatusAnnouncer.tsx`

```tsx
/**
 * StatusAnnouncer - Accessible live region for announcing status updates to screen readers
 * 
 * This component provides an invisible region that announces dynamic content changes
 * to assistive technologies without interrupting the current reading flow.
 * 
 * Usage:
 *   const { announce } = useStatusAnnouncer();
 *   announce('Form submitted successfully', 'polite');
 */

import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';
import styled from 'styled-components';

// Styled component for visually hidden but accessible content
const ScreenReaderOnly = styled.div`
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
`;

type Politeness = 'polite' | 'assertive';

interface StatusAnnouncerContextType {
  announce: (message: string, politeness?: Politeness) => void;
}

const StatusAnnouncerContext = createContext<StatusAnnouncerContextType | null>(null);

export const useStatusAnnouncer = (): StatusAnnouncerContextType => {
  const context = useContext(StatusAnnouncerContext);
  if (!context) {
    throw new Error('useStatusAnnouncer must be used within a StatusAnnouncerProvider');
  }
  return context;
};

interface StatusAnnouncerProviderProps {
  children: React.ReactNode;
}

export const StatusAnnouncerProvider: React.FC<StatusAnnouncerProviderProps> = ({ children }) => {
  const [politeAnnouncement, setPoliteAnnouncement] = useState<string>('');
  const [assertiveAnnouncement, setAssertiveAnnouncement] = useState<string>('');
  const politeTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const assertiveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const idCounter = useRef(0);

  const announce = useCallback((message: string, politeness: Politeness = 'polite') => {
    // Increment counter to ensure new message is announced even if same text
    idCounter.current += 1;
    const uniqueMessage = message;

    if (politeness === 'assertive') {
      // Clear previous timeout
      if (assertiveTimeoutRef.current) {
        clearTimeout(assertiveTimeoutRef.current);
      }
      // Clear then set to trigger announcement
      setAssertiveAnnouncement('');
      setTimeout(() => setAssertiveAnnouncement(uniqueMessage), 50);
      // Clear after announcement
      assertiveTimeoutRef.current = setTimeout(() => setAssertiveAnnouncement(''), 1000);
    } else {
      if (politeTimeoutRef.current) {
        clearTimeout(politeTimeoutRef.current);
      }
      setPoliteAnnouncement('');
      setTimeout(() => setPoliteAnnouncement(uniqueMessage), 50);
      politeTimeoutRef.current = setTimeout(() => setPoliteAnnouncement(''), 1000);
    }
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (politeTimeoutRef.current) clearTimeout(politeTimeoutRef.current);
      if (assertiveTimeoutRef.current) clearTimeout(assertiveTimeoutRef.current);
    };
  }, []);

  return (
    <StatusAnnouncerContext.Provider value={{ announce }}>
      {children}
      
      {/* Polite announcements - waits for user to finish reading */}
      <ScreenReaderOnly
        role="status"
        aria-live="polite"
        aria-atomic="true"
      >
        {politeAnnouncement}
      </ScreenReaderOnly>

      {/* Assertive announcements - interrupts immediately */}
      <ScreenReaderOnly
        role="alert"
        aria-live="assertive"
        aria-atomic="true"
      >
        {assertiveAnnouncement}
      </ScreenReaderOnly>
    </StatusAnnouncerContext.Provider>
  );
};

export default StatusAnnouncerProvider;

```

---

## src/components/common/Toast.tsx

**Path:** `src/components/common/Toast.tsx`

```tsx
/**
 * Toast - Enhanced notification system
 *
 * Features:
 * - Stacked notifications with smart positioning
 * - Progress bars for timed dismissal
 * - Action buttons with undo functionality
 * - Pause on hover
 * - AI-themed styling
 * - Accessible announcements
 *
 * Usage:
 *   const { showToast } = useToast();
 *   showToast({
 *     message: 'Changes saved!',
 *     type: 'success',
 *     action: { label: 'Undo', onClick: () => undoChanges() }
 *   });
 */

import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';
import styled, { keyframes, css } from 'styled-components';
import {
  CheckIcon,
  XMarkIcon,
  ExclamationCircleIcon,
  InformationCircleIcon,
  ExclamationTriangleIcon,
  SparklesIcon
} from '@heroicons/react/24/outline';

const slideIn = keyframes`
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
`;

const slideOut = keyframes`
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
`;

const progressShrink = keyframes`
  from { width: 100%; }
  to { width: 0%; }
`;

const ToastContainer = styled.div`
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-width: 420px;
  pointer-events: none;

  & > * {
    pointer-events: auto;
  }
`;

type ToastType = 'success' | 'error' | 'warning' | 'info' | 'ai';

interface ToastAction {
  label: string;
  onClick: () => void;
}

interface ToastItemProps {
  $type: ToastType;
  $isExiting: boolean;
  $isPaused: boolean;
}

const getTypeColor = (type: ToastType, theme: any) => {
  switch (type) {
    case 'success': return theme.colours.success;
    case 'error': return theme.colours.error;
    case 'warning': return theme.colours.warning;
    case 'ai': return '#6366f1';
    default: return theme.colours.primary;
  }
};

const ToastItem = styled.div<ToastItemProps>`
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colours.backgroundElevated};
  border: 1px solid ${({ theme, $type }) => getTypeColor($type, theme)};
  border-radius: ${({ theme }) => theme.radiusMd};
  box-shadow: ${({ theme }) => theme.shadowLg}, 0 0 0 1px rgba(0, 0, 0, 0.05);
  animation: ${({ $isExiting }) => ($isExiting ? slideOut : slideIn)} 0.3s ease forwards;
  min-width: 300px;
  overflow: hidden;
  transition: transform 0.2s ease, box-shadow 0.2s ease;

  ${({ $type }) => $type === 'ai' && css`
    border-image: linear-gradient(135deg, #6366f1, #8b5cf6, #06b6d4) 1;
    box-shadow: 0 4px 20px rgba(99, 102, 241, 0.15), 0 0 0 1px rgba(99, 102, 241, 0.1);
  `}

  &:hover {
    transform: translateX(-4px);
    box-shadow: ${({ theme }) => theme.shadowXl};
  }
`;

const ToastContent = styled.div`
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 14px 16px;
`;

const IconWrapper = styled.div<{ $type: ToastType }>`
  flex-shrink: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${({ theme, $type }) => getTypeColor($type, theme)};
`;

const Content = styled.div`
  flex: 1;
  min-width: 0;
`;

const Title = styled.div`
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  margin-bottom: 2px;
`;

const Message = styled.div`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textSecondary};
  word-wrap: break-word;
`;

const ActionsRow = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
`;

const ActionButton = styled.button<{ $type: ToastType }>`
  padding: 6px 12px;
  font-size: 13px;
  font-weight: 500;
  background: ${({ theme, $type }) => `${getTypeColor($type, theme)}15`};
  color: ${({ theme, $type }) => getTypeColor($type, theme)};
  border: 1px solid ${({ theme, $type }) => `${getTypeColor($type, theme)}30`};
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: ${({ theme, $type }) => `${getTypeColor($type, theme)}25`};
    transform: translateY(-1px);
  }

  &:active {
    transform: translateY(0);
  }
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  padding: 4px;
  cursor: pointer;
  color: ${({ theme }) => theme.colours.textMuted};
  border-radius: ${({ theme }) => theme.radiusSm};
  transition: all 0.2s ease;
  flex-shrink: 0;

  &:hover {
    color: ${({ theme }) => theme.colours.text};
    background: ${({ theme }) => theme.colours.hover};
  }
`;

const ProgressBar = styled.div<{ $type: ToastType; $duration: number; $isPaused: boolean }>`
  height: 3px;
  background: ${({ theme, $type }) => `${getTypeColor($type, theme)}30`};
  position: relative;
  overflow: hidden;

  &::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: ${({ theme, $type }) => getTypeColor($type, theme)};
    animation: ${progressShrink} ${({ $duration }) => $duration}ms linear forwards;
    animation-play-state: ${({ $isPaused }) => ($isPaused ? 'paused' : 'running')};
  }
`;

interface Toast {
  id: string;
  type: ToastType;
  title?: string;
  message: string;
  duration?: number;
  isExiting?: boolean;
  action?: ToastAction;
  showProgress?: boolean;
  isPaused?: boolean;
}

interface ToastContextType {
  showToast: (toast: Omit<Toast, 'id'>) => void;
  dismissToast: (id: string) => void;
}

const ToastContext = createContext<ToastContextType | null>(null);

export const useToast = (): ToastContextType => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
};

const IconStyled = styled.span`
  width: 20px;
  height: 20px;
  display: flex;

  svg {
    width: 100%;
    height: 100%;
  }
`;

const getIcon = (type: ToastType) => {
  switch (type) {
    case 'success': return <IconStyled><CheckIcon /></IconStyled>;
    case 'error': return <IconStyled><ExclamationCircleIcon /></IconStyled>;
    case 'warning': return <IconStyled><ExclamationTriangleIcon /></IconStyled>;
    case 'ai': return <IconStyled><SparklesIcon /></IconStyled>;
    default: return <IconStyled><InformationCircleIcon /></IconStyled>;
  }
};

// Individual toast component with pause functionality
const ToastItemComponent: React.FC<{
  toast: Toast;
  onDismiss: (id: string) => void;
  onPause: (id: string, paused: boolean) => void;
}> = ({ toast, onDismiss, onPause }) => {
  const duration = toast.duration ?? 5000;
  const showProgress = toast.showProgress !== false && duration > 0;

  return (
    <ToastItem
      $type={toast.type}
      $isExiting={toast.isExiting || false}
      $isPaused={toast.isPaused || false}
      role="alert"
      onMouseEnter={() => onPause(toast.id, true)}
      onMouseLeave={() => onPause(toast.id, false)}
    >
      <ToastContent>
        <IconWrapper $type={toast.type}>{getIcon(toast.type)}</IconWrapper>
        <Content>
          {toast.title && <Title>{toast.title}</Title>}
          <Message>{toast.message}</Message>
          {toast.action && (
            <ActionsRow>
              <ActionButton
                $type={toast.type}
                onClick={() => {
                  toast.action?.onClick();
                  onDismiss(toast.id);
                }}
              >
                {toast.action.label}
              </ActionButton>
            </ActionsRow>
          )}
        </Content>
        <CloseButton onClick={() => onDismiss(toast.id)} aria-label="Dismiss">
          <XMarkIcon style={{ width: 16, height: 16 }} />
        </CloseButton>
      </ToastContent>
      {showProgress && (
        <ProgressBar
          $type={toast.type}
          $duration={duration}
          $isPaused={toast.isPaused || false}
        />
      )}
    </ToastItem>
  );
};

export const ToastProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [toasts, setToasts] = useState<Toast[]>([]);
  const timeoutsRef = useRef<Map<string, { timeout: NodeJS.Timeout; remaining: number; startTime: number }>>(new Map());

  const dismissToast = useCallback((id: string) => {
    // Clear any existing timeout
    const timeoutData = timeoutsRef.current.get(id);
    if (timeoutData) {
      clearTimeout(timeoutData.timeout);
      timeoutsRef.current.delete(id);
    }

    setToasts(prev => prev.map(t => t.id === id ? { ...t, isExiting: true } : t));
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id));
    }, 300);
  }, []);

  const pauseToast = useCallback((id: string, paused: boolean) => {
    setToasts(prev => prev.map(t => t.id === id ? { ...t, isPaused: paused } : t));

    const timeoutData = timeoutsRef.current.get(id);
    if (!timeoutData) return;

    if (paused) {
      // Pause: clear timeout and save remaining time
      clearTimeout(timeoutData.timeout);
      const elapsed = Date.now() - timeoutData.startTime;
      timeoutData.remaining = Math.max(0, timeoutData.remaining - elapsed);
    } else {
      // Resume: create new timeout with remaining time
      timeoutData.startTime = Date.now();
      timeoutData.timeout = setTimeout(() => dismissToast(id), timeoutData.remaining);
    }
  }, [dismissToast]);

  const showToast = useCallback((toast: Omit<Toast, 'id'>) => {
    const id = `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const newToast: Toast = { ...toast, id, isExiting: false, isPaused: false };
    setToasts(prev => {
      // Limit to 5 toasts max
      const updated = [...prev, newToast];
      if (updated.length > 5) {
        const oldest = updated[0];
        if (oldest) {
          dismissToast(oldest.id);
        }
        return updated.slice(1);
      }
      return updated;
    });

    const duration = toast.duration ?? 5000;
    if (duration > 0) {
      const timeout = setTimeout(() => dismissToast(id), duration);
      timeoutsRef.current.set(id, { timeout, remaining: duration, startTime: Date.now() });
    }
  }, [dismissToast]);

  useEffect(() => {
    return () => {
      timeoutsRef.current.forEach(data => clearTimeout(data.timeout));
    };
  }, []);

  return (
    <ToastContext.Provider value={{ showToast, dismissToast }}>
      {children}
      <ToastContainer role="region" aria-label="Notifications" aria-live="polite">
        {toasts.map(toast => (
          <ToastItemComponent
            key={toast.id}
            toast={toast}
            onDismiss={dismissToast}
            onPause={pauseToast}
          />
        ))}
      </ToastContainer>
    </ToastContext.Provider>
  );
};

// Convenience functions for common toast types
export const createToastHelpers = (showToast: ToastContextType['showToast']) => ({
  success: (message: string, options?: Partial<Toast>) =>
    showToast({ type: 'success', message, ...options }),
  error: (message: string, options?: Partial<Toast>) =>
    showToast({ type: 'error', message, duration: 8000, ...options }),
  warning: (message: string, options?: Partial<Toast>) =>
    showToast({ type: 'warning', message, ...options }),
  info: (message: string, options?: Partial<Toast>) =>
    showToast({ type: 'info', message, ...options }),
  ai: (message: string, options?: Partial<Toast>) =>
    showToast({ type: 'ai', message, title: 'AI Assistant', ...options }),
});

export default ToastProvider;

```

---

## src/components/common/Typography.tsx

**Path:** `src/components/common/Typography.tsx`

```tsx
/**
 * Typography - Unified typography components with design token integration
 *
 * Provides consistent typography across the application with proper
 * semantic HTML, accessibility, and design system compliance.
 */

import styled, { css } from 'styled-components';

// Base styles shared across typography components
const baseStyles = css`
  margin: 0;
  font-family: ${({ theme }) => theme.font};
`;

// Heading variants
export const H1 = styled.h1`
  ${baseStyles}
  font-size: 32px;
  font-weight: 700;
  line-height: 1.2;
  letter-spacing: -0.02em;
  color: ${({ theme }) => theme.colours.text};
`;

export const H2 = styled.h2`
  ${baseStyles}
  font-size: 24px;
  font-weight: 600;
  line-height: 1.3;
  letter-spacing: -0.01em;
  color: ${({ theme }) => theme.colours.text};
`;

export const H3 = styled.h3`
  ${baseStyles}
  font-size: 20px;
  font-weight: 600;
  line-height: 1.4;
  color: ${({ theme }) => theme.colours.text};
`;

export const H4 = styled.h4`
  ${baseStyles}
  font-size: 16px;
  font-weight: 600;
  line-height: 1.4;
  color: ${({ theme }) => theme.colours.text};
`;

// Body text variants
export const Body = styled.p`
  ${baseStyles}
  font-size: 14px;
  font-weight: 400;
  line-height: 1.6;
  color: ${({ theme }) => theme.colours.text};
`;

export const BodyLarge = styled.p`
  ${baseStyles}
  font-size: 16px;
  font-weight: 400;
  line-height: 1.6;
  color: ${({ theme }) => theme.colours.text};
`;

export const BodySmall = styled.p`
  ${baseStyles}
  font-size: 13px;
  font-weight: 400;
  line-height: 1.5;
  color: ${({ theme }) => theme.colours.textSecondary};
`;

// Secondary/muted text
export const TextMuted = styled.span`
  ${baseStyles}
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textMuted};
`;

export const TextSecondary = styled.span`
  ${baseStyles}
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textSecondary};
`;

// Labels
export const Label = styled.label`
  ${baseStyles}
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
  margin-bottom: 6px;
`;

export const LabelSmall = styled.label`
  ${baseStyles}
  display: block;
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: ${({ theme }) => theme.colours.textMuted};
  margin-bottom: 4px;
`;

// Caption
export const Caption = styled.span`
  ${baseStyles}
  font-size: 12px;
  line-height: 1.4;
  color: ${({ theme }) => theme.colours.textMuted};
`;

// Code/mono text
export const Code = styled.code`
  ${baseStyles}
  font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 13px;
  padding: 2px 6px;
  background: ${({ theme }) => theme.colours.backgroundSubtle};
  border-radius: ${({ theme }) => theme.radiusSm};
  color: ${({ theme }) => theme.colours.text};
`;

// Link styled as text
export const TextLink = styled.a`
  ${baseStyles}
  font-size: 14px;
  color: ${({ theme }) => theme.colours.primary};
  text-decoration: none;
  cursor: pointer;
  transition: color 0.2s ease;

  &:hover {
    color: ${({ theme }) => theme.colours.primaryDark};
    text-decoration: underline;
  }
`;

// Error text
export const TextError = styled.span`
  ${baseStyles}
  font-size: 13px;
  color: ${({ theme }) => theme.colours.error};
`;

// Success text
export const TextSuccess = styled.span`
  ${baseStyles}
  font-size: 13px;
  color: ${({ theme }) => theme.colours.success};
`;

// Truncated text with ellipsis
export const TruncatedText = styled.span<{ $maxWidth?: string }>`
  ${baseStyles}
  display: inline-block;
  max-width: ${({ $maxWidth }) => $maxWidth || '200px'};
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

export default {
  H1, H2, H3, H4,
  Body, BodyLarge, BodySmall,
  TextMuted, TextSecondary, TextError, TextSuccess,
  Label, LabelSmall, Caption, Code, TextLink, TruncatedText
};

```

---

## src/components/common/index.ts

**Path:** `src/components/common/index.ts`

```typescript
/**
 * Common Components Index
 *
 * Central export for all common/shared UI components.
 * Import from '@/components/common' for convenience.
 */

// Status and Notifications
export { StatusAnnouncerProvider, useStatusAnnouncer } from './StatusAnnouncer';
export { ToastProvider, useToast } from './Toast';

// Loading and Progress
export {
  Skeleton,
  SkeletonText,
  SkeletonHeading,
  SkeletonAvatar,
  SkeletonButton,
  SkeletonCard,
  SkeletonTable,
  SkeletonCardList,
  SkeletonForm,
  SkeletonProductCard,
  SkeletonStats,
  SkeletonPageHeader
} from './Skeleton';
export { ProgressBar, StepProgress } from './ProgressBar';

// Typography
export {
  H1, H2, H3, H4,
  Body, BodyLarge, BodySmall,
  TextMuted, TextSecondary, TextError, TextSuccess,
  Label, LabelSmall, Caption, Code, TextLink, TruncatedText
} from './Typography';

// Badges
export { Badge, StatusBadge, CountBadge as BadgeCount } from './Badge';

// Summary/snapshot components
export { CoverageSnapshot } from './CoverageSnapshot';

// Navigation
export { CommandPalette, useCommandPalette } from './CommandPalette';

// Design System
export {
  // Animations
  fadeInUp,
  fadeIn,
  scaleIn,
  slideDown,
  slideUp,
  pulse,
  shimmer,
  spin,
  glow,
  ripple,
  // Colors
  colors,
  gradients,
  // Statistics Dashboard
  StatsDashboard,
  StatCard,
  StatValue,
  StatLabel,
  StatTrend,
  // Card Components
  EnhancedCard,
  CardHeader,
  CardTitle,
  CardSubtitle,
  CardContent,
  CardFooter,
  CardActions,
  // Buttons
  IconButton,
  // Badges
  TypeBadge,
  CountBadge,
  // Empty State
  EmptyStateContainer,
  EmptyStateIcon,
  EmptyStateTitle,
  EmptyStateDescription,
  // Loading
  LoadingSpinner,
  LoadingContainer,
  LoadingText,
  // Action Bar
  ActionBar,
  ActionBarCount,
  ActionBarButton,
  // Slider
  SliderContainer,
  SliderTrack,
  SliderFill,
  SliderThumb,
  SliderLabels,
  // Quick Amounts
  QuickAmountContainer,
  QuickAmountButton,
  // Section Header
  SectionHeader,
  SectionTitle,
  SectionSubtitle,
  // Filters
  FilterChipsContainer,
  FilterChip,
  // Gradient
  GradientBar
} from './DesignSystem';
```

---

## src/components/inputs/CoinsuranceInput.tsx

**Path:** `src/components/inputs/CoinsuranceInput.tsx`

```tsx
/**
 * CoinsuranceInput Component
 * Multi-select for available coinsurance options with min/max range
 */

import React from 'react';
import styled from 'styled-components';

// Standard P&C coinsurance options
const COINSURANCE_OPTIONS = [50, 60, 70, 80, 90, 100];

interface CoinsuranceInputProps {
  selectedOptions?: number[];
  minimum?: number;
  maximum?: number;
  onChange: (options: number[], min?: number, max?: number) => void;
}

export const CoinsuranceInput: React.FC<CoinsuranceInputProps> = ({
  selectedOptions = [],
  minimum,
  maximum,
  onChange,
}) => {
  const handleToggle = (pct: number) => {
    let newOptions: number[];
    if (selectedOptions.includes(pct)) {
      newOptions = selectedOptions.filter(v => v !== pct);
    } else {
      newOptions = [...selectedOptions, pct].sort((a, b) => a - b);
    }
    // Auto-calculate min/max from selection
    const newMin = newOptions.length > 0 ? Math.min(...newOptions) : undefined;
    const newMax = newOptions.length > 0 ? Math.max(...newOptions) : undefined;
    onChange(newOptions, newMin, newMax);
  };

  const handleMinChange = (value: number | undefined) => {
    onChange(selectedOptions, value, maximum);
  };

  const handleMaxChange = (value: number | undefined) => {
    onChange(selectedOptions, minimum, value);
  };

  return (
    <Container>
      <SectionLabel>Available Coinsurance Options</SectionLabel>
      <CheckboxGrid>
        {COINSURANCE_OPTIONS.map((pct) => (
          <CheckboxItem
            key={pct}
            $selected={selectedOptions.includes(pct)}
            onClick={() => handleToggle(pct)}
          >
            <Checkbox
              type="checkbox"
              checked={selectedOptions.includes(pct)}
              onChange={() => handleToggle(pct)}
            />
            <CheckboxLabel>{pct}%</CheckboxLabel>
          </CheckboxItem>
        ))}
      </CheckboxGrid>

      <RangeSection>
        <RangeLabel>Coinsurance Range</RangeLabel>
        <RangeInputs>
          <RangeField>
            <RangeFieldLabel>Minimum</RangeFieldLabel>
            <RangeInputWrapper>
              <RangeInput
                type="number"
                min="0"
                max="100"
                step="5"
                placeholder="Min"
                value={minimum ?? ''}
                onChange={(e) => handleMinChange(e.target.value ? parseInt(e.target.value) : undefined)}
              />
              <PercentSymbol>%</PercentSymbol>
            </RangeInputWrapper>
          </RangeField>
          <RangeDivider>to</RangeDivider>
          <RangeField>
            <RangeFieldLabel>Maximum</RangeFieldLabel>
            <RangeInputWrapper>
              <RangeInput
                type="number"
                min="0"
                max="100"
                step="5"
                placeholder="Max"
                value={maximum ?? ''}
                onChange={(e) => handleMaxChange(e.target.value ? parseInt(e.target.value) : undefined)}
              />
              <PercentSymbol>%</PercentSymbol>
            </RangeInputWrapper>
          </RangeField>
        </RangeInputs>
      </RangeSection>

      {selectedOptions.length > 0 && (
        <SelectedSummary>
          <SelectedCount>{selectedOptions.length} option{selectedOptions.length > 1 ? 's' : ''} selected</SelectedCount>
          <SelectedList>{selectedOptions.map(p => `${p}%`).join(', ')}</SelectedList>
        </SelectedSummary>
      )}
    </Container>
  );
};

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const SectionLabel = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
  text-transform: uppercase;
  letter-spacing: 0.5px;
`;

const CheckboxGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
`;

const CheckboxItem = styled.div<{ $selected: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  background: ${({ $selected }) => $selected ? 'rgba(99, 102, 241, 0.08)' : '#f9fafb'};
  border: 1px solid ${({ $selected }) => $selected ? '#6366f1' : '#e5e7eb'};
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.15s ease;

  &:hover {
    border-color: ${({ $selected }) => $selected ? '#6366f1' : '#d1d5db'};
    background: ${({ $selected }) => $selected ? 'rgba(99, 102, 241, 0.12)' : '#f3f4f6'};
  }
`;

const Checkbox = styled.input`
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: #6366f1;
`;

const CheckboxLabel = styled.span`
  font-size: 14px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours?.text || '#111827'};
`;

const RangeSection = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-top: 8px;
  border-top: 1px solid ${({ theme }) => theme.colours?.border || '#e5e7eb'};
`;

const RangeLabel = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
`;

const RangeInputs = styled.div`
  display: flex;
  align-items: flex-end;
  gap: 12px;
`;

const RangeField = styled.div`
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
`;

const RangeFieldLabel = styled.label`
  font-size: 12px;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
`;

const RangeInputWrapper = styled.div`
  display: flex;
  align-items: center;
  gap: 4px;
`;

const RangeInput = styled.input`
  width: 80px;
  padding: 8px 10px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const PercentSymbol = styled.span`
  font-size: 14px;
  font-weight: 500;
  color: #6b7280;
`;

const RangeDivider = styled.span`
  font-size: 14px;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
  padding-bottom: 10px;
`;

const SelectedSummary = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: rgba(99, 102, 241, 0.08);
  border-radius: 6px;
`;

const SelectedCount = styled.span`
  font-size: 13px;
  font-weight: 600;
  color: #6366f1;
`;

const SelectedList = styled.span`
  font-size: 13px;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
`;
```

---

## src/components/inputs/WaitingPeriodInput.tsx

**Path:** `src/components/inputs/WaitingPeriodInput.tsx`

```tsx
/**
 * WaitingPeriodInput Component
 * Input for waiting period with unit selection (days/months)
 */

import React from 'react';
import styled from 'styled-components';

interface WaitingPeriodInputProps {
  value?: number;
  unit?: 'days' | 'months';
  onChange: (value: number | undefined, unit: 'days' | 'months') => void;
}

export const WaitingPeriodInput: React.FC<WaitingPeriodInputProps> = ({
  value,
  unit = 'days',
  onChange,
}) => {
  return (
    <Container>
      <InputRow>
        <NumberInput
          type="number"
          min="0"
          placeholder="Enter waiting period"
          value={value || ''}
          onChange={(e) => {
            const val = e.target.value ? parseInt(e.target.value) : undefined;
            onChange(val, unit);
          }}
        />
        <UnitSelect
          value={unit}
          onChange={(e) => onChange(value, e.target.value as 'days' | 'months')}
        >
          <option value="days">Days</option>
          <option value="months">Months</option>
        </UnitSelect>
      </InputRow>

      {value && (
        <DisplayValue>
          {value} {unit}
        </DisplayValue>
      )}
    </Container>
  );
};

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const InputRow = styled.div`
  display: flex;
  gap: 12px;
  align-items: center;
`;

const NumberInput = styled.input`
  flex: 1;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const UnitSelect = styled.select`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;
  background: white;
  cursor: pointer;
  min-width: 100px;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const DisplayValue = styled.div`
  padding: 8px 12px;
  background: #f3f4f6;
  border-radius: 6px;
  font-size: 14px;
  color: #374151;
  font-weight: 500;
`;
```

---

## src/components/inputs/index.ts

**Path:** `src/components/inputs/index.ts`

```typescript
/**
 * Inputs Index
 * Centralized exports for specialized input components
 */

export { default as CoinsuranceInput } from './CoinsuranceInput';
export { default as WaitingPeriodInput } from './WaitingPeriodInput';

```

---

## src/components/modals/DeductiblesModal.tsx

**Path:** `src/components/modals/DeductiblesModal.tsx`

```tsx
/**
 * DeductiblesModal Component
 * Enhanced modal for managing coverage deductibles with professional styling
 *
 * Features:
 * - Statistics dashboard with deductible overview
 * - Type-specific icons and color coding
 * - Interactive quick amount selection
 * - Smooth animations and transitions
 * - Skeleton loading states
 */

import React, { useState, useMemo } from 'react';
import styled from 'styled-components';
import {
  XMarkIcon,
  PlusIcon,
  TrashIcon,
  CheckCircleIcon,
  CurrencyDollarIcon,
  ChartBarIcon,
  ReceiptPercentIcon,
  StarIcon,
  CalculatorIcon,
  BanknotesIcon
} from '@heroicons/react/24/outline';
import { StarIcon as StarIconSolid } from '@heroicons/react/24/solid';
import { CoverageDeductible } from '@types';
import { useCoverageData } from '@hooks/useCoverageData';
import { DeductibleTypeSelector } from '../selectors/DeductibleTypeSelector';
import { validateCoverageDeductible, formatValidationResult } from '@services/validationService';
import {
  colors,
  gradients,
  fadeInUp,
  scaleIn,
  StatsDashboard,
  StatCard,
  StatValue,
  StatLabel,
  TypeBadge,
  EmptyStateContainer,
  EmptyStateIcon,
  EmptyStateTitle,
  EmptyStateDescription,
  QuickAmountContainer,
  QuickAmountButton
} from '../common/DesignSystem';
import { Skeleton } from '../common/Skeleton';

// Deductible type configuration with icons and colors
const deductibleTypeConfig: Record<string, { icon: React.ReactNode; color: string; label: string }> = {
  flat: {
    icon: <CurrencyDollarIcon />,
    color: colors.primary,
    label: 'Flat Amount'
  },
  percentage: {
    icon: <ReceiptPercentIcon />,
    color: colors.secondary,
    label: 'Percentage'
  },
  split: {
    icon: <CalculatorIcon />,
    color: colors.info,
    label: 'Split'
  },
  disappearing: {
    icon: <BanknotesIcon />,
    color: colors.success,
    label: 'Disappearing'
  },
};

// Quick amount presets for flat deductibles
const quickAmounts = [250, 500, 1000, 2500, 5000, 10000];

// Quick percentage presets
const quickPercentages = [1, 2, 5, 10, 15, 20];

interface DeductiblesModalProps {
  isOpen: boolean;
  onClose: () => void;
  productId: string;
  coverageId: string;
  coverageName: string;
  onSave?: () => void;
}

export const DeductiblesModal: React.FC<DeductiblesModalProps> = ({
  isOpen,
  onClose,
  productId,
  coverageId,
  coverageName,
  onSave,
}) => {
  const { deductibles, loading, addDeductible, deleteDeductible, setDefaultDeductible } = useCoverageData(productId, coverageId);
  const [editingDeductible, setEditingDeductible] = useState<Partial<CoverageDeductible> | null>(null);
  const [isAdding, setIsAdding] = useState(false);

  // Calculate statistics
  const stats = useMemo(() => {
    if (!deductibles.length) return { total: 0, defaults: 0, required: 0, flat: 0 };
    const defaults = deductibles.filter(d => d.isDefault).length;
    const required = deductibles.filter(d => d.isRequired).length;
    const flat = deductibles.filter(d => d.deductibleType === 'flat').length;
    return { total: deductibles.length, defaults, required, flat };
  }, [deductibles]);

  const getDeductibleTypeConfig = (type: string) => {
    return deductibleTypeConfig[type] || deductibleTypeConfig.flat;
  };

  const formatAmount = (amount: number) => {
    if (amount >= 1000) return `$${(amount / 1000).toFixed(0)}K`;
    return `$${amount.toLocaleString()}`;
  };

  if (!isOpen) return null;

  const handleAdd = async () => {
    if (!editingDeductible || !editingDeductible.deductibleType) {
      alert('Please select a deductible type');
      return;
    }

    if (editingDeductible.deductibleType === 'percentage' && !editingDeductible.percentage) {
      alert('Please enter a percentage');
      return;
    }

    if (editingDeductible.deductibleType !== 'percentage' && !editingDeductible.amount) {
      alert('Please enter an amount');
      return;
    }

    // Validate the deductible
    const validationResult = validateCoverageDeductible(editingDeductible);
    if (!validationResult.isValid) {
      alert('Validation errors:\n\n' + formatValidationResult(validationResult));
      return;
    }

    // Show warnings but allow save
    if (validationResult.warnings.length > 0) {
      const proceed = window.confirm(
        'Warnings:\n\n' +
        validationResult.warnings.map(w => `â€¢ ${w.message}`).join('\n') +
        '\n\nDo you want to proceed anyway?'
      );
      if (!proceed) return;
    }

    try {
      await addDeductible({
        ...editingDeductible,
        coverageId,
        productId,
      });
      setEditingDeductible(null);
      setIsAdding(false);
      if (onSave) onSave();
    } catch (error: any) {
      alert('Failed to add deductible: ' + error.message);
    }
  };

  const handleDelete = async (deductibleId: string) => {
    if (confirm('Are you sure you want to delete this deductible?')) {
      try {
        await deleteDeductible(deductibleId);
        if (onSave) onSave();
      } catch (error: any) {
        alert('Failed to delete deductible: ' + error.message);
      }
    }
  };

  const handleSetDefault = async (deductibleId: string) => {
    try {
      await setDefaultDeductible(deductibleId);
      if (onSave) onSave();
    } catch (error: any) {
      alert('Failed to set default deductible: ' + error.message);
    }
  };

  const handleClose = () => {
    setEditingDeductible(null);
    setIsAdding(false);
    onClose();
  };

  return (
    <Overlay onClick={handleClose}>
      <ModalContainer onClick={(e) => e.stopPropagation()}>
        <Header>
          <HeaderContent>
            <HeaderIcon>
              <CurrencyDollarIcon />
            </HeaderIcon>
            <HeaderText>
              <Title>Manage Deductibles</Title>
              <Subtitle>{coverageName}</Subtitle>
            </HeaderText>
          </HeaderContent>
          <CloseButton onClick={handleClose}>
            <XMarkIcon />
          </CloseButton>
        </Header>
        <GradientBar />

        <Content>
          {loading ? (
            <LoadingContainer>
              <StatsDashboard>
                {[1, 2, 3, 4].map(i => (
                  <StatCard key={i}>
                    <Skeleton width="60px" height="12px" />
                    <Skeleton width="80px" height="28px" style={{ marginTop: 8 }} />
                  </StatCard>
                ))}
              </StatsDashboard>
              {[1, 2, 3].map(i => (
                <Skeleton key={i} width="100%" height="80px" borderRadius="12px" style={{ marginBottom: 12 }} />
              ))}
            </LoadingContainer>
          ) : (
            <>
              {/* Statistics Dashboard */}
              <StatsDashboard>
                <StatCard $color={gradients.primary}>
                  <StatValue>{stats.total}</StatValue>
                  <StatLabel>
                    <ChartBarIcon />
                    Total Deductibles
                  </StatLabel>
                </StatCard>
                <StatCard $color={gradients.success}>
                  <StatValue>{stats.defaults}</StatValue>
                  <StatLabel>
                    <StarIcon />
                    Defaults
                  </StatLabel>
                </StatCard>
                <StatCard $color={gradients.warning}>
                  <StatValue>{stats.required}</StatValue>
                  <StatLabel>
                    <CheckCircleIcon />
                    Required
                  </StatLabel>
                </StatCard>
                <StatCard $color={gradients.info}>
                  <StatValue>{stats.flat}</StatValue>
                  <StatLabel>
                    <CurrencyDollarIcon />
                    Flat Amount
                  </StatLabel>
                </StatCard>
              </StatsDashboard>

              {/* Add New Deductible Section */}
              {isAdding ? (
                <AddSection>
                  <AddSectionHeader>
                    <PlusIcon style={{ width: 20, height: 20, color: colors.primary }} />
                    <SectionTitle>Add New Deductible</SectionTitle>
                  </AddSectionHeader>
                  <DeductibleTypeSelector
                    value={editingDeductible || { deductibleType: 'flat' }}
                    onChange={setEditingDeductible}
                  />

                  {/* Quick Amount/Percentage Buttons */}
                  <QuickAmountSection>
                    <QuickAmountLabel>
                      {editingDeductible?.deductibleType === 'percentage' ? 'Quick Percentage' : 'Quick Amount'} Selection
                    </QuickAmountLabel>
                    <QuickAmountContainer>
                      {editingDeductible?.deductibleType === 'percentage'
                        ? quickPercentages.map(pct => (
                            <QuickAmountButton
                              key={pct}
                              $active={editingDeductible?.percentage === pct}
                              onClick={() => setEditingDeductible(prev => ({ ...prev, percentage: pct }))}
                            >
                              {pct}%
                            </QuickAmountButton>
                          ))
                        : quickAmounts.map(amount => (
                            <QuickAmountButton
                              key={amount}
                              $active={editingDeductible?.amount === amount}
                              onClick={() => setEditingDeductible(prev => ({ ...prev, amount }))}
                            >
                              {formatAmount(amount)}
                            </QuickAmountButton>
                          ))
                      }
                    </QuickAmountContainer>
                  </QuickAmountSection>

                  <ButtonGroup>
                    <AddButton onClick={handleAdd}>
                      <CheckCircleIcon style={{ width: 18, height: 18 }} />
                      Add Deductible
                    </AddButton>
                    <CancelButton onClick={() => {
                      setIsAdding(false);
                      setEditingDeductible(null);
                    }}>
                      Cancel
                    </CancelButton>
                  </ButtonGroup>
                </AddSection>
              ) : (
                <AddNewButton onClick={() => {
                  setIsAdding(true);
                  setEditingDeductible({ deductibleType: 'flat' });
                }}>
                  <PlusIcon style={{ width: 20, height: 20 }} />
                  Add New Deductible
                </AddNewButton>
              )}

              {/* Existing Deductibles List */}
              <ListSection>
                <SectionHeader>
                  <SectionTitle>Current Deductibles</SectionTitle>
                  <CountBadge>{deductibles.length}</CountBadge>
                </SectionHeader>
                {deductibles.length === 0 ? (
                  <EmptyStateContainer>
                    <EmptyStateIcon>
                      <CurrencyDollarIcon />
                    </EmptyStateIcon>
                    <EmptyStateTitle>No Deductibles Configured</EmptyStateTitle>
                    <EmptyStateDescription>
                      Add deductibles to define the amounts policyholders must pay before coverage kicks in.
                      Click "Add New Deductible" to get started.
                    </EmptyStateDescription>
                  </EmptyStateContainer>
                ) : (
                  <DeductiblesList>
                    {deductibles.map((deductible, index) => {
                      const config = getDeductibleTypeConfig(deductible.deductibleType);
                      return (
                        <DeductibleCard key={deductible.id} $isDefault={deductible.isDefault} $delay={index}>
                          <DeductibleCardGradient $color={config.color} />
                          <DeductibleHeader>
                            <DeductibleInfo>
                              <DeductibleTypeIcon $color={config.color}>
                                {config.icon}
                              </DeductibleTypeIcon>
                              <DeductibleDisplay>
                                <DeductibleValue>{deductible.displayValue}</DeductibleValue>
                                <TypeBadge $color={config.color}>
                                  {config.icon}
                                  {config.label}
                                </TypeBadge>
                              </DeductibleDisplay>
                            </DeductibleInfo>
                            <DeductibleActions>
                              {deductible.isDefault ? (
                                <DefaultIndicator>
                                  <StarIconSolid />
                                  Default
                                </DefaultIndicator>
                              ) : (
                                <SetDefaultButton onClick={() => handleSetDefault(deductible.id)}>
                                  <StarIcon style={{ width: 14, height: 14 }} />
                                  Set Default
                                </SetDefaultButton>
                              )}
                              <DeleteButton onClick={() => handleDelete(deductible.id)}>
                                <TrashIcon />
                              </DeleteButton>
                            </DeductibleActions>
                          </DeductibleHeader>
                          <DeductibleMeta>
                            {deductible.isRequired && (
                              <RequiredBadge>
                                <CheckCircleIcon />
                                Required
                              </RequiredBadge>
                            )}
                            {deductible.appliesTo && deductible.appliesTo.length > 0 && (
                              <AppliesTo>Applies to: {deductible.appliesTo.join(', ')}</AppliesTo>
                            )}
                            {(deductible.minimumRetained || deductible.maximumRetained) && (
                              <Range>
                                Retained: ${deductible.minimumRetained?.toLocaleString() || '0'} - ${deductible.maximumRetained?.toLocaleString() || 'âˆž'}
                              </Range>
                            )}
                          </DeductibleMeta>
                        </DeductibleCard>
                      );
                    })}
                  </DeductiblesList>
                )}
              </ListSection>
            </>
          )}
        </Content>

        <Footer>
          <FooterInfo>
            {deductibles.length > 0 && (
              <FooterText>{deductibles.length} deductible{deductibles.length !== 1 ? 's' : ''} configured</FooterText>
            )}
          </FooterInfo>
          <CloseFooterButton onClick={handleClose}>
            <CheckCircleIcon style={{ width: 18, height: 18 }} />
            Done
          </CloseFooterButton>
        </Footer>
      </ModalContainer>
    </Overlay>
  );
};

// Styled Components
const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  animation: ${fadeInUp} 0.2s ease-out;
`;

const ModalContainer = styled.div`
  background: white;
  border-radius: 20px;
  width: 90%;
  max-width: 900px;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  animation: ${scaleIn} 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
`;

const GradientBar = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: ${gradients.primary};
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px 28px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.8);
`;

const HeaderContent = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
`;

const HeaderIcon = styled.div`
  width: 48px;
  height: 48px;
  border-radius: 14px;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
  display: flex;
  align-items: center;
  justify-content: center;

  svg {
    width: 24px;
    height: 24px;
    color: ${colors.primary};
  }
`;

const HeaderText = styled.div``;

const Title = styled.h2`
  font-size: 22px;
  font-weight: 700;
  color: ${colors.gray800};
  margin: 0;
  letter-spacing: -0.02em;
`;

const Subtitle = styled.p`
  font-size: 14px;
  color: ${colors.gray500};
  margin: 2px 0 0 0;
`;

const CloseButton = styled.button`
  width: 40px;
  height: 40px;
  border-radius: 12px;
  background: ${colors.gray50};
  border: none;
  cursor: pointer;
  color: ${colors.gray500};
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;

  svg {
    width: 20px;
    height: 20px;
  }

  &:hover {
    background: ${colors.gray100};
    color: ${colors.gray700};
    transform: scale(1.05);
  }
`;
const Content = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 28px;
  background: ${colors.gray50};
`;

const LoadingContainer = styled.div`
  animation: ${fadeInUp} 0.3s ease-out;
`;

const AddSection = styled.div`
  background: white;
  border-radius: 16px;
  padding: 24px;
  margin-bottom: 24px;
  border: 2px dashed rgba(99, 102, 241, 0.3);
  animation: ${fadeInUp} 0.3s ease-out;
`;

const AddSectionHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
`;

const SectionTitle = styled.h3`
  font-size: 16px;
  font-weight: 600;
  color: ${colors.gray800};
  margin: 0;
`;

const SectionHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
`;

const CountBadge = styled.span`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 28px;
  height: 28px;
  padding: 0 10px;
  border-radius: 14px;
  background: rgba(99, 102, 241, 0.1);
  color: ${colors.primary};
  font-size: 13px;
  font-weight: 700;
`;

const QuickAmountSection = styled.div`
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid ${colors.gray100};
`;

const QuickAmountLabel = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: ${colors.gray600};
  margin-bottom: 10px;
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: 12px;
  margin-top: 24px;
`;

const AddButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 24px;
  background: ${gradients.primary};
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
  }
`;

const CancelButton = styled.button`
  padding: 12px 24px;
  background: white;
  color: ${colors.gray600};
  border: 1.5px solid ${colors.gray200};
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: ${colors.gray100};
    border-color: ${colors.gray300};
  }
`;

const AddNewButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 16px 24px;
  background: white;
  color: ${colors.primary};
  border: 2px dashed rgba(99, 102, 241, 0.4);
  border-radius: 16px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  margin-bottom: 24px;
  width: 100%;
  transition: all 0.3s ease;

  svg {
    width: 22px;
    height: 22px;
  }

  &:hover {
    background: rgba(99, 102, 241, 0.05);
    border-color: ${colors.primary};
    transform: translateY(-2px);
  }
`;

const ListSection = styled.div`
  animation: ${fadeInUp} 0.4s ease-out;
`;

const DeductiblesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const DeductibleCard = styled.div<{ $isDefault?: boolean; $delay?: number }>`
  background: white;
  border: 1.5px solid ${props => props.$isDefault ? colors.primary : 'rgba(226, 232, 240, 0.9)'};
  border-radius: 16px;
  padding: 20px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  animation: ${fadeInUp} 0.35s ease-out backwards;
  animation-delay: ${props => (props.$delay || 0) * 0.05}s;

  ${props => props.$isDefault && `
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
  `}

  &:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 24px rgba(99, 102, 241, 0.12);
    border-color: ${colors.primary};
  }
`;

const DeductibleCardGradient = styled.div<{ $color?: string }>`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: ${props => props.$color || colors.primary};
`;

const DeductibleHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
`;

const DeductibleInfo = styled.div`
  display: flex;
  align-items: flex-start;
  gap: 16px;
`;

const DeductibleTypeIcon = styled.div<{ $color?: string }>`
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: ${props => props.$color ? `${props.$color}15` : 'rgba(99, 102, 241, 0.1)'};
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;

  svg {
    width: 22px;
    height: 22px;
    color: ${props => props.$color || colors.primary};
  }
`;

const DeductibleDisplay = styled.div`
  display: flex;
  flex-direction: column;
  gap: 6px;
`;

const DeductibleValue = styled.div`
  font-size: 24px;
  font-weight: 700;
  color: ${colors.gray800};
  letter-spacing: -0.02em;
`;

const DeductibleActions = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const SetDefaultButton = styled.button`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  background: rgba(99, 102, 241, 0.1);
  color: ${colors.primary};
  border: none;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.2);
    transform: scale(1.02);
  }
`;

const DefaultIndicator = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(234, 179, 8, 0.15) 100%);
  color: ${colors.warningDark};
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;

  svg {
    width: 16px;
    height: 16px;
    color: ${colors.warning};
  }
`;

const DeleteButton = styled.button`
  width: 36px;
  height: 36px;
  background: rgba(239, 68, 68, 0.1);
  color: ${colors.error};
  border: none;
  border-radius: 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;

  svg {
    width: 18px;
    height: 18px;
  }

  &:hover {
    background: rgba(239, 68, 68, 0.2);
    transform: scale(1.05);
  }
`;

const DeductibleMeta = styled.div`
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 12px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid ${colors.gray100};
`;

const RequiredBadge = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 5px 12px;
  background: rgba(245, 158, 11, 0.12);
  color: ${colors.warningDark};
  border-radius: 20px;
  font-size: 12px;
  font-weight: 600;

  svg {
    width: 14px;
    height: 14px;
  }
`;

const AppliesTo = styled.div`
  font-size: 13px;
  color: ${colors.gray500};
  display: flex;
  align-items: center;
  gap: 6px;
`;

const Range = styled.div`
  font-size: 13px;
  color: ${colors.gray500};
  display: flex;
  align-items: center;
  gap: 6px;
`;

const Footer = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 28px;
  border-top: 1px solid rgba(226, 232, 240, 0.8);
  background: white;
`;

const FooterInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const FooterText = styled.span`
  font-size: 13px;
  color: ${colors.gray500};
`;

const CloseFooterButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 28px;
  background: ${gradients.success};
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
  }
`;
```

---

## src/components/modals/LimitsModal.tsx

**Path:** `src/components/modals/LimitsModal.tsx`

```tsx
/**
 * LimitsModal Component
 * Enhanced modal for managing coverage limits with professional styling
 *
 * Features:
 * - Statistics dashboard with limit overview
 * - Type-specific icons and color coding
 * - Interactive slider for quick amount selection
 * - Smooth animations and transitions
 * - Skeleton loading states
 */

import React, { useState, useMemo } from 'react';
import styled from 'styled-components';
import {
  XMarkIcon,
  PlusIcon,
  TrashIcon,
  CheckCircleIcon,
  ShieldCheckIcon,
  CurrencyDollarIcon,
  ChartBarIcon,
  ArrowsPointingOutIcon,
  StarIcon,
  ExclamationCircleIcon
} from '@heroicons/react/24/outline';
import { StarIcon as StarIconSolid } from '@heroicons/react/24/solid';
import { CoverageLimit } from '@types';
import { useCoverageData } from '@hooks/useCoverageData';
import { LimitTypeSelector } from '../selectors/LimitTypeSelector';
import { validateCoverageLimit, formatValidationResult } from '@services/validationService';
import {
  colors,
  gradients,
  fadeInUp,
  scaleIn,
  StatsDashboard,
  StatCard,
  StatValue,
  StatLabel,
  TypeBadge,
  EmptyStateContainer,
  EmptyStateIcon,
  EmptyStateTitle,
  EmptyStateDescription,
  QuickAmountContainer,
  QuickAmountButton
} from '../common/DesignSystem';
import { Skeleton } from '../common/Skeleton';

interface LimitsModalProps {
  isOpen: boolean;
  onClose: () => void;
  productId: string;
  coverageId: string;
  coverageName: string;
  onSave?: () => void;
}

// Limit type configuration with icons and colors
const limitTypeConfig: Record<string, { icon: React.ReactNode; color: string; label: string }> = {
  perOccurrence: {
    icon: <ShieldCheckIcon />,
    color: colors.primary,
    label: 'Per Occurrence'
  },
  aggregate: {
    icon: <ChartBarIcon />,
    color: colors.secondary,
    label: 'Aggregate'
  },
  combined: {
    icon: <ArrowsPointingOutIcon />,
    color: colors.info,
    label: 'Combined'
  },
  perPerson: {
    icon: <CurrencyDollarIcon />,
    color: colors.success,
    label: 'Per Person'
  },
  perAccident: {
    icon: <ExclamationCircleIcon />,
    color: colors.warning,
    label: 'Per Accident'
  },
};

// Quick amount presets
const quickAmounts = [25000, 50000, 100000, 250000, 500000, 1000000];

export const LimitsModal: React.FC<LimitsModalProps> = ({
  isOpen,
  onClose,
  productId,
  coverageId,
  coverageName,
  onSave,
}) => {
  const { limits, loading, addLimit, updateLimit, deleteLimit, setDefaultLimit } = useCoverageData(productId, coverageId);
  const [editingLimit, setEditingLimit] = useState<Partial<CoverageLimit> | null>(null);
  const [isAdding, setIsAdding] = useState(false);

  // Calculate statistics
  const stats = useMemo(() => {
    if (!limits.length) return { total: 0, defaults: 0, required: 0, avgAmount: 0 };
    const defaults = limits.filter(l => l.isDefault).length;
    const required = limits.filter(l => l.isRequired).length;
    const amounts = limits.map(l => l.amount || 0).filter(a => a > 0);
    const avgAmount = amounts.length > 0 ? amounts.reduce((a, b) => a + b, 0) / amounts.length : 0;
    return { total: limits.length, defaults, required, avgAmount };
  }, [limits]);

  if (!isOpen) return null;

  const handleAdd = async () => {
    if (!editingLimit || !editingLimit.limitType || !editingLimit.amount) {
      alert('Please select a limit type and enter an amount');
      return;
    }

    // Validate the limit
    const validationResult = validateCoverageLimit(editingLimit);
    if (!validationResult.isValid) {
      alert('Validation errors:\n\n' + formatValidationResult(validationResult));
      return;
    }

    // Show warnings but allow save
    if (validationResult.warnings.length > 0) {
      const proceed = window.confirm(
        'Warnings:\n\n' +
        validationResult.warnings.map(w => `â€¢ ${w.message}`).join('\n') +
        '\n\nDo you want to proceed anyway?'
      );
      if (!proceed) return;
    }

    try {
      await addLimit({
        ...editingLimit,
        coverageId,
        productId,
      });
      setEditingLimit(null);
      setIsAdding(false);
      if (onSave) onSave();
    } catch (error: any) {
      alert('Failed to add limit: ' + error.message);
    }
  };

  const handleDelete = async (limitId: string) => {
    if (confirm('Are you sure you want to delete this limit?')) {
      try {
        await deleteLimit(limitId);
        if (onSave) onSave();
      } catch (error: any) {
        alert('Failed to delete limit: ' + error.message);
      }
    }
  };

  const handleSetDefault = async (limitId: string) => {
    try {
      await setDefaultLimit(limitId);
      if (onSave) onSave();
    } catch (error: any) {
      alert('Failed to set default limit: ' + error.message);
    }
  };

  const handleClose = () => {
    setEditingLimit(null);
    setIsAdding(false);
    onClose();
  };

  const getLimitTypeConfig = (type: string) => {
    return limitTypeConfig[type] || limitTypeConfig.perOccurrence;
  };

  const formatAmount = (amount: number) => {
    if (amount >= 1000000) return `$${(amount / 1000000).toFixed(1)}M`;
    if (amount >= 1000) return `$${(amount / 1000).toFixed(0)}K`;
    return `$${amount.toLocaleString()}`;
  };

  return (
    <Overlay onClick={handleClose}>
      <ModalContainer onClick={(e) => e.stopPropagation()}>
        <Header>
          <HeaderContent>
            <HeaderIcon>
              <ShieldCheckIcon />
            </HeaderIcon>
            <HeaderText>
              <Title>Manage Limits</Title>
              <Subtitle>{coverageName}</Subtitle>
            </HeaderText>
          </HeaderContent>
          <CloseButton onClick={handleClose}>
            <XMarkIcon />
          </CloseButton>
        </Header>
        <GradientBar />

        <Content>
          {loading ? (
            <LoadingContainer>
              <StatsDashboard>
                {[1, 2, 3, 4].map(i => (
                  <StatCard key={i}>
                    <Skeleton width="60px" height="12px" />
                    <Skeleton width="80px" height="28px" style={{ marginTop: 8 }} />
                  </StatCard>
                ))}
              </StatsDashboard>
              {[1, 2, 3].map(i => (
                <Skeleton key={i} width="100%" height="80px" borderRadius="12px" style={{ marginBottom: 12 }} />
              ))}
            </LoadingContainer>
          ) : (
            <>
              {/* Statistics Dashboard */}
              <StatsDashboard>
                <StatCard $color={gradients.primary}>
                  <StatValue>{stats.total}</StatValue>
                  <StatLabel>
                    <ChartBarIcon />
                    Total Limits
                  </StatLabel>
                </StatCard>
                <StatCard $color={gradients.success}>
                  <StatValue>{stats.defaults}</StatValue>
                  <StatLabel>
                    <StarIcon />
                    Defaults
                  </StatLabel>
                </StatCard>
                <StatCard $color={gradients.warning}>
                  <StatValue>{stats.required}</StatValue>
                  <StatLabel>
                    <CheckCircleIcon />
                    Required
                  </StatLabel>
                </StatCard>
                <StatCard $color={gradients.info}>
                  <StatValue>{formatAmount(stats.avgAmount)}</StatValue>
                  <StatLabel>
                    <CurrencyDollarIcon />
                    Avg Amount
                  </StatLabel>
                </StatCard>
              </StatsDashboard>

              {/* Add New Limit Section */}
              {isAdding ? (
                <AddSection>
                  <AddSectionHeader>
                    <PlusIcon style={{ width: 20, height: 20, color: colors.primary }} />
                    <SectionTitle>Add New Limit</SectionTitle>
                  </AddSectionHeader>
                  <LimitTypeSelector
                    value={editingLimit || { limitType: 'perOccurrence' }}
                    onChange={setEditingLimit}
                  />

                  {/* Quick Amount Buttons */}
                  <QuickAmountSection>
                    <QuickAmountLabel>Quick Amount Selection</QuickAmountLabel>
                    <QuickAmountContainer>
                      {quickAmounts.map(amount => (
                        <QuickAmountButton
                          key={amount}
                          $active={editingLimit?.amount === amount}
                          onClick={() => setEditingLimit(prev => ({ ...prev, amount }))}
                        >
                          {formatAmount(amount)}
                        </QuickAmountButton>
                      ))}
                    </QuickAmountContainer>
                  </QuickAmountSection>

                  <ButtonGroup>
                    <AddButton onClick={handleAdd}>
                      <CheckCircleIcon style={{ width: 18, height: 18 }} />
                      Add Limit
                    </AddButton>
                    <CancelButton onClick={() => {
                      setIsAdding(false);
                      setEditingLimit(null);
                    }}>
                      Cancel
                    </CancelButton>
                  </ButtonGroup>
                </AddSection>
              ) : (
                <AddNewButton onClick={() => {
                  setIsAdding(true);
                  setEditingLimit({ limitType: 'perOccurrence' });
                }}>
                  <PlusIcon style={{ width: 20, height: 20 }} />
                  Add New Limit
                </AddNewButton>
              )}

              {/* Existing Limits List */}
              <ListSection>
                <SectionHeader>
                  <SectionTitle>Current Limits</SectionTitle>
                  <CountBadge>{limits.length}</CountBadge>
                </SectionHeader>
                {limits.length === 0 ? (
                  <EmptyStateContainer>
                    <EmptyStateIcon>
                      <ShieldCheckIcon />
                    </EmptyStateIcon>
                    <EmptyStateTitle>No Limits Configured</EmptyStateTitle>
                    <EmptyStateDescription>
                      Add coverage limits to define the maximum amounts your policy will pay.
                      Click "Add New Limit" to get started.
                    </EmptyStateDescription>
                  </EmptyStateContainer>
                ) : (
                  <LimitsList>
                    {limits.map((limit, index) => {
                      const config = getLimitTypeConfig(limit.limitType);
                      return (
                        <LimitCard key={limit.id} $isDefault={limit.isDefault} $delay={index}>
                          <LimitCardGradient $color={config.color} />
                          <LimitHeader>
                            <LimitInfo>
                              <LimitTypeIcon $color={config.color}>
                                {config.icon}
                              </LimitTypeIcon>
                              <LimitDisplay>
                                <LimitValue>{limit.displayValue}</LimitValue>
                                <TypeBadge $color={config.color}>
                                  {config.icon}
                                  {config.label}
                                </TypeBadge>
                              </LimitDisplay>
                            </LimitInfo>
                            <LimitActions>
                              {limit.isDefault ? (
                                <DefaultIndicator>
                                  <StarIconSolid />
                                  Default
                                </DefaultIndicator>
                              ) : (
                                <SetDefaultButton onClick={() => handleSetDefault(limit.id)}>
                                  <StarIcon style={{ width: 14, height: 14 }} />
                                  Set Default
                                </SetDefaultButton>
                              )}
                              <DeleteButton onClick={() => handleDelete(limit.id)}>
                                <TrashIcon />
                              </DeleteButton>
                            </LimitActions>
                          </LimitHeader>
                          <LimitMeta>
                            {limit.isRequired && (
                              <RequiredBadge>
                                <CheckCircleIcon />
                                Required
                              </RequiredBadge>
                            )}
                            {limit.appliesTo && limit.appliesTo.length > 0 && (
                              <AppliesTo>Applies to: {limit.appliesTo.join(', ')}</AppliesTo>
                            )}
                            {(limit.minAmount || limit.maxAmount) && (
                              <Range>
                                Range: ${limit.minAmount?.toLocaleString() || '0'} - ${limit.maxAmount?.toLocaleString() || 'âˆž'}
                              </Range>
                            )}
                          </LimitMeta>
                        </LimitCard>
                      );
                    })}
                  </LimitsList>
                )}
              </ListSection>
            </>
          )}
        </Content>

        <Footer>
          <FooterInfo>
            {limits.length > 0 && (
              <FooterText>{limits.length} limit{limits.length !== 1 ? 's' : ''} configured</FooterText>
            )}
          </FooterInfo>
          <CloseFooterButton onClick={handleClose}>
            <CheckCircleIcon style={{ width: 18, height: 18 }} />
            Done
          </CloseFooterButton>
        </Footer>
      </ModalContainer>
    </Overlay>
  );
};

// Styled Components
const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  animation: ${fadeInUp} 0.2s ease-out;
`;

const ModalContainer = styled.div`
  background: white;
  border-radius: 20px;
  width: 90%;
  max-width: 900px;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  animation: ${scaleIn} 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
`;

const GradientBar = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: ${gradients.primary};
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px 28px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.8);
`;

const HeaderContent = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
`;

const HeaderIcon = styled.div`
  width: 48px;
  height: 48px;
  border-radius: 14px;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
  display: flex;
  align-items: center;
  justify-content: center;

  svg {
    width: 24px;
    height: 24px;
    color: ${colors.primary};
  }
`;

const HeaderText = styled.div``;

const Title = styled.h2`
  font-size: 22px;
  font-weight: 700;
  color: ${colors.gray800};
  margin: 0;
  letter-spacing: -0.02em;
`;

const Subtitle = styled.p`
  font-size: 14px;
  color: ${colors.gray500};
  margin: 2px 0 0 0;
`;

const CloseButton = styled.button`
  width: 40px;
  height: 40px;
  border-radius: 12px;
  background: ${colors.gray50};
  border: none;
  cursor: pointer;
  color: ${colors.gray500};
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;

  svg {
    width: 20px;
    height: 20px;
  }

  &:hover {
    background: ${colors.gray100};
    color: ${colors.gray700};
    transform: scale(1.05);
  }
`;

const Content = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 28px;
  background: ${colors.gray50};
`;

const LoadingContainer = styled.div`
  animation: ${fadeInUp} 0.3s ease-out;
`;

const AddSection = styled.div`
  background: white;
  border-radius: 16px;
  padding: 24px;
  margin-bottom: 24px;
  border: 2px dashed rgba(99, 102, 241, 0.3);
  animation: ${fadeInUp} 0.3s ease-out;
`;

const AddSectionHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
`;

const SectionTitle = styled.h3`
  font-size: 16px;
  font-weight: 600;
  color: ${colors.gray800};
  margin: 0;
`;

const SectionHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
`;

const CountBadge = styled.span`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 28px;
  height: 28px;
  padding: 0 10px;
  border-radius: 14px;
  background: rgba(99, 102, 241, 0.1);
  color: ${colors.primary};
  font-size: 13px;
  font-weight: 700;
`;

const QuickAmountSection = styled.div`
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid ${colors.gray100};
`;

const QuickAmountLabel = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: ${colors.gray600};
  margin-bottom: 10px;
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: 12px;
  margin-top: 24px;
`;

const AddButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 24px;
  background: ${gradients.primary};
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
  }

  &:active {
    transform: translateY(0);
  }
`;

const CancelButton = styled.button`
  padding: 12px 24px;
  background: white;
  color: ${colors.gray600};
  border: 1.5px solid ${colors.gray200};
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: ${colors.gray100};
    border-color: ${colors.gray300};
  }
`;

const AddNewButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 16px 24px;
  background: white;
  color: ${colors.primary};
  border: 2px dashed rgba(99, 102, 241, 0.4);
  border-radius: 16px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  margin-bottom: 24px;
  width: 100%;
  transition: all 0.3s ease;

  svg {
    width: 22px;
    height: 22px;
  }

  &:hover {
    background: rgba(99, 102, 241, 0.05);
    border-color: ${colors.primary};
    transform: translateY(-2px);
  }
`;

const ListSection = styled.div`
  animation: ${fadeInUp} 0.4s ease-out;
`;

const LimitsList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const LimitCard = styled.div<{ $isDefault?: boolean; $delay?: number }>`
  background: white;
  border: 1.5px solid ${props => props.$isDefault ? colors.primary : 'rgba(226, 232, 240, 0.9)'};
  border-radius: 16px;
  padding: 20px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  animation: ${fadeInUp} 0.35s ease-out backwards;
  animation-delay: ${props => (props.$delay || 0) * 0.05}s;

  ${props => props.$isDefault && `
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
  `}

  &:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 24px rgba(99, 102, 241, 0.12);
    border-color: ${colors.primary};
  }
`;

const LimitCardGradient = styled.div<{ $color?: string }>`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: ${props => props.$color || colors.primary};
`;

const LimitHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
`;

const LimitInfo = styled.div`
  display: flex;
  align-items: flex-start;
  gap: 16px;
`;

const LimitTypeIcon = styled.div<{ $color?: string }>`
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: ${props => props.$color ? `${props.$color}15` : 'rgba(99, 102, 241, 0.1)'};
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;

  svg {
    width: 22px;
    height: 22px;
    color: ${props => props.$color || colors.primary};
  }
`;

const LimitDisplay = styled.div`
  display: flex;
  flex-direction: column;
  gap: 6px;
`;

const LimitValue = styled.div`
  font-size: 24px;
  font-weight: 700;
  color: ${colors.gray800};
  letter-spacing: -0.02em;
`;

const LimitActions = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const SetDefaultButton = styled.button`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  background: rgba(99, 102, 241, 0.1);
  color: ${colors.primary};
  border: none;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.2);
    transform: scale(1.02);
  }
`;

const DefaultIndicator = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(234, 179, 8, 0.15) 100%);
  color: ${colors.warningDark};
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;

  svg {
    width: 16px;
    height: 16px;
    color: ${colors.warning};
  }
`;

const DeleteButton = styled.button`
  width: 36px;
  height: 36px;
  background: rgba(239, 68, 68, 0.1);
  color: ${colors.error};
  border: none;
  border-radius: 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;

  svg {
    width: 18px;
    height: 18px;
  }

  &:hover {
    background: rgba(239, 68, 68, 0.2);
    transform: scale(1.05);
  }
`;

const LimitMeta = styled.div`
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 12px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid ${colors.gray100};
`;

const RequiredBadge = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 5px 12px;
  background: rgba(245, 158, 11, 0.12);
  color: ${colors.warningDark};
  border-radius: 20px;
  font-size: 12px;
  font-weight: 600;

  svg {
    width: 14px;
    height: 14px;
  }
`;

const AppliesTo = styled.div`
  font-size: 13px;
  color: ${colors.gray500};
  display: flex;
  align-items: center;
  gap: 6px;
`;

const Range = styled.div`
  font-size: 13px;
  color: ${colors.gray500};
  display: flex;
  align-items: center;
  gap: 6px;
`;

const Footer = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 28px;
  border-top: 1px solid rgba(226, 232, 240, 0.8);
  background: white;
`;

const FooterInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const FooterText = styled.span`
  font-size: 13px;
  color: ${colors.gray500};
`;

const CloseFooterButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 28px;
  background: ${gradients.success};
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
  }
`;
```

---

## src/components/modals/index.ts

**Path:** `src/components/modals/index.ts`

```typescript
/**
 * Modals Index
 * Centralized exports for all modal components
 */

export { default as DeductiblesModal } from './DeductiblesModal';
export { default as LimitsModal } from './LimitsModal';

```

---

## src/components/packages/PackageBuilder.tsx

**Path:** `src/components/packages/PackageBuilder.tsx`

```tsx
import React, { useState } from 'react';
import styled from 'styled-components';
import { CoveragePackage, Coverage, PackageType } from '../../types';
import { validatePackage, calculatePackagePremium } from '../../hooks/useCoveragePackages';

interface PackageBuilderProps {
  availableCoverages: Coverage[];
  initialData?: CoveragePackage;
  onSave: (packageData: Omit<CoveragePackage, 'id'>) => Promise<void>;
  onCancel: () => void;
  productId: string;
}

export const PackageBuilder: React.FC<PackageBuilderProps> = ({
  availableCoverages,
  initialData,
  onSave,
  onCancel,
  productId,
}) => {
  const [name, setName] = useState(initialData?.name || '');
  const [description, setDescription] = useState(initialData?.description || '');
  const [packageType, setPackageType] = useState<PackageType>(initialData?.packageType || 'custom');
  const [selectedCoverageIds, setSelectedCoverageIds] = useState<string[]>(initialData?.coverageIds || []);
  const [discountPercentage, setDiscountPercentage] = useState<number>(initialData?.discountPercentage || 0);
  const [packagePremium, setPackagePremium] = useState<number | undefined>(initialData?.packagePremium);
  const [useCustomPremium, setUseCustomPremium] = useState(!!initialData?.packagePremium);
  const [errors, setErrors] = useState<string[]>([]);
  const [saving, setSaving] = useState(false);

  const packageTypeOptions = [
    { value: 'required', label: 'Required' },
    { value: 'recommended', label: 'Recommended' },
    { value: 'popular', label: 'Popular' },
    { value: 'custom', label: 'Custom' },
  ];

  const coverageOptions = availableCoverages.map((coverage) => ({
    value: coverage.id,
    label: coverage.name,
  }));

  const selectedCoverages = availableCoverages.filter((c) => 
    selectedCoverageIds.includes(c.id)
  );

  // Calculate estimated premium
  const estimatedPremium = React.useMemo(() => {
    // This is a placeholder - in real implementation, you'd fetch actual premiums
    const individualPremiums = selectedCoverages.map(() => 100); // Placeholder
    return calculatePackagePremium(individualPremiums, discountPercentage);
  }, [selectedCoverages, discountPercentage]);

  const handleSave = async () => {
    const packageData: Omit<CoveragePackage, 'id'> = {
      productId,
      name,
      description,
      packageType,
      coverageIds: selectedCoverageIds,
      discountPercentage: discountPercentage > 0 ? discountPercentage : undefined,
      packagePremium: useCustomPremium ? packagePremium : undefined,
      createdAt: initialData?.createdAt,
      updatedAt: new Date(),
    };

    const validationErrors = validatePackage(packageData);
    if (validationErrors.length > 0) {
      setErrors(validationErrors);
      return;
    }

    setSaving(true);
    setErrors([]);

    try {
      await onSave(packageData);
    } catch (err: any) {
      setErrors([err.message]);
      setSaving(false);
    }
  };

  return (
    <BuilderContainer>
      <BuilderTitle>{initialData ? 'Edit Package' : 'Create Package'}</BuilderTitle>

      {errors.length > 0 && (
        <ErrorBox>
          {errors.map((error, idx) => (
            <ErrorItem key={idx}>{error}</ErrorItem>
          ))}
        </ErrorBox>
      )}

      <FormSection>
        <SectionTitle>Basic Information</SectionTitle>
        
        <FormGroup>
          <Label>Package Name *</Label>
          <Input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="e.g., Essential Coverage Bundle"
          />
        </FormGroup>

        <FormGroup>
          <Label>Description</Label>
          <TextArea
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            placeholder="Describe what this package includes and who it's for..."
            rows={3}
          />
        </FormGroup>

        <FormGroup>
          <Label>Package Type *</Label>
          <select
            value={packageType}
            onChange={(e) => setPackageType(e.target.value as PackageType)}
            style={{ width: '100%', padding: '8px 12px', borderRadius: '4px', border: '1px solid #d1d5db' }}
          >
            {packageTypeOptions.map((opt) => (
              <option key={opt.value} value={opt.value}>{opt.label}</option>
            ))}
          </select>
        </FormGroup>
      </FormSection>

      <FormSection>
        <SectionTitle>Coverages</SectionTitle>
        
        <FormGroup>
          <Label>Select Coverages *</Label>
          <select
            multiple
            value={selectedCoverageIds}
            onChange={(e) => setSelectedCoverageIds(Array.from(e.target.selectedOptions, option => option.value))}
            style={{ width: '100%', padding: '8px 12px', borderRadius: '4px', border: '1px solid #d1d5db', minHeight: '100px' }}
          >
            {coverageOptions.map((opt) => (
              <option key={opt.value} value={opt.value}>{opt.label}</option>
            ))}
          </select>
        </FormGroup>

        {selectedCoverages.length > 0 && (
          <SelectedCoveragesList>
            <ListTitle>Selected Coverages ({selectedCoverages.length})</ListTitle>
            {selectedCoverages.map((coverage) => (
              <CoverageItem key={coverage.id}>
                <CoverageName>{coverage.name}</CoverageName>
                <CoverageType>{coverage.coverageType}</CoverageType>
              </CoverageItem>
            ))}
          </SelectedCoveragesList>
        )}
      </FormSection>

      <FormSection>
        <SectionTitle>Pricing</SectionTitle>
        
        <FormGroup>
          <Label>Discount Percentage</Label>
          <InputWithUnit>
            <Input
              type="number"
              value={discountPercentage}
              onChange={(e) => setDiscountPercentage(Number(e.target.value))}
              min="0"
              max="100"
              step="0.1"
            />
            <Unit>%</Unit>
          </InputWithUnit>
          <HelpText>
            Discount applied to the total of individual coverage premiums
          </HelpText>
        </FormGroup>

        <CheckboxGroup>
          <Checkbox
            type="checkbox"
            checked={useCustomPremium}
            onChange={(e) => setUseCustomPremium(e.target.checked)}
          />
          <CheckboxLabel>Use custom package premium (override calculated premium)</CheckboxLabel>
        </CheckboxGroup>

        {useCustomPremium && (
          <FormGroup>
            <Label>Custom Package Premium</Label>
            <InputWithUnit>
              <Unit>$</Unit>
              <Input
                type="number"
                value={packagePremium || ''}
                onChange={(e) => setPackagePremium(Number(e.target.value))}
                min="0"
                step="0.01"
              />
            </InputWithUnit>
          </FormGroup>
        )}

        {!useCustomPremium && selectedCoverages.length > 0 && (
          <PremiumEstimate>
            <EstimateLabel>Estimated Package Premium:</EstimateLabel>
            <EstimateValue>${estimatedPremium.toFixed(2)}</EstimateValue>
            {discountPercentage > 0 && (
              <DiscountBadge>{discountPercentage}% discount applied</DiscountBadge>
            )}
          </PremiumEstimate>
        )}
      </FormSection>

      <FormActions>
        <CancelButton onClick={onCancel} disabled={saving}>
          Cancel
        </CancelButton>
        <SaveButton onClick={handleSave} disabled={saving}>
          {saving ? 'Saving...' : (initialData ? 'Update Package' : 'Create Package')}
        </SaveButton>
      </FormActions>
    </BuilderContainer>
  );
};

const BuilderContainer = styled.div`
  background: white;
  border-radius: 8px;
  padding: 24px;
`;

const BuilderTitle = styled.h2`
  font-size: 24px;
  font-weight: 600;
  color: #111827;
  margin: 0 0 24px 0;
`;

const ErrorBox = styled.div`
  padding: 12px 16px;
  background: #fee2e2;
  border: 1px solid #fca5a5;
  border-radius: 6px;
  margin-bottom: 24px;
`;

const ErrorItem = styled.div`
  color: #991b1b;
  font-size: 14px;
  margin-bottom: 4px;

  &:last-child {
    margin-bottom: 0;
  }
`;

const FormSection = styled.div`
  margin-bottom: 32px;
  padding-bottom: 32px;
  border-bottom: 1px solid #e5e7eb;

  &:last-of-type {
    border-bottom: none;
  }
`;

const SectionTitle = styled.h3`
  font-size: 18px;
  font-weight: 600;
  color: #111827;
  margin: 0 0 16px 0;
`;

const FormGroup = styled.div`
  margin-bottom: 16px;
`;

const Label = styled.label`
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: #374151;
  margin-bottom: 6px;
`;

const Input = styled.input`
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;
  transition: all 0.2s;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const TextArea = styled.textarea`
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;
  font-family: inherit;
  resize: vertical;
  transition: all 0.2s;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const InputWithUnit = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const Unit = styled.span`
  font-size: 14px;
  font-weight: 500;
  color: #6b7280;
`;

const HelpText = styled.div`
  font-size: 12px;
  color: #6b7280;
  margin-top: 4px;
`;

const CheckboxGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
`;

const Checkbox = styled.input`
  width: 18px;
  height: 18px;
  cursor: pointer;
`;

const CheckboxLabel = styled.label`
  font-size: 14px;
  color: #374151;
  cursor: pointer;
`;

const SelectedCoveragesList = styled.div`
  margin-top: 16px;
  padding: 16px;
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
`;

const ListTitle = styled.div`
  font-size: 14px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 12px;
`;

const CoverageItem = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 4px;
  margin-bottom: 8px;

  &:last-child {
    margin-bottom: 0;
  }
`;

const CoverageName = styled.div`
  font-size: 14px;
  font-weight: 500;
  color: #111827;
`;

const CoverageType = styled.div`
  font-size: 12px;
  color: #6b7280;
  padding: 2px 8px;
  background: #f3f4f6;
  border-radius: 4px;
`;

const PremiumEstimate = styled.div`
  padding: 16px;
  background: #f0f9ff;
  border: 1px solid #bae6fd;
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 12px;
`;

const EstimateLabel = styled.div`
  font-size: 14px;
  font-weight: 500;
  color: #0c4a6e;
`;

const EstimateValue = styled.div`
  font-size: 20px;
  font-weight: 700;
  color: #0369a1;
`;

const DiscountBadge = styled.div`
  padding: 4px 12px;
  background: #22c55e;
  color: white;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 600;
`;

const FormActions = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding-top: 24px;
  border-top: 1px solid #e5e7eb;
`;

const CancelButton = styled.button`
  padding: 10px 20px;
  background: white;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  color: #374151;
  cursor: pointer;
  transition: all 0.2s;

  &:hover {
    background: #f9fafb;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

const SaveButton = styled.button`
  padding: 10px 20px;
  background: #3b82f6;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  color: white;
  cursor: pointer;
  transition: all 0.2s;

  &:hover {
    background: #2563eb;
  }

  &:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }
`;

```

---

## src/components/packages/PackageCard.tsx

**Path:** `src/components/packages/PackageCard.tsx`

```tsx
import React, { memo, useCallback } from 'react';
import styled from 'styled-components';
import { CoveragePackage, Coverage } from '../../types';
import { PencilIcon, TrashIcon, SparklesIcon, CheckCircleIcon } from '@heroicons/react/24/outline';

interface PackageCardProps {
  package: CoveragePackage;
  coverages: Coverage[];
  onEdit?: () => void;
  onDelete?: () => void;
  onSelect?: () => void;
  isSelected?: boolean;
}

export const PackageCard = memo<PackageCardProps>(({
  package: pkg,
  coverages,
  onEdit,
  onDelete,
  onSelect,
  isSelected,
}) => {
  // Memoized event handlers to prevent unnecessary re-renders
  const handleEdit = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onEdit?.();
  }, [onEdit]);

  const handleDelete = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onDelete?.();
  }, [onDelete]);
  const packageCoverages = coverages.filter((c) => pkg.coverageIds.includes(c.id));
  
  const getPackageTypeColor = (type: string) => {
    switch (type) {
      case 'required':
        return { bg: '#fee2e2', color: '#991b1b', border: '#fca5a5' };
      case 'recommended':
        return { bg: '#dbeafe', color: '#1e40af', border: '#93c5fd' };
      case 'popular':
        return { bg: '#fef3c7', color: '#92400e', border: '#fbbf24' };
      default:
        return { bg: '#f3f4f6', color: '#374151', border: '#d1d5db' };
    }
  };

  const typeColors = getPackageTypeColor(pkg.packageType);

  return (
    <Card $selected={isSelected} onClick={onSelect}>
      <CardHeader>
        <HeaderTop>
          <PackageInfo>
            <PackageName>{pkg.name}</PackageName>
            <PackageTypeBadge $colors={typeColors}>
              {pkg.packageType}
            </PackageTypeBadge>
          </PackageInfo>
          
          {(onEdit || onDelete) && (
            <CardActions>
              {onEdit && (
                <IconButton onClick={handleEdit} title="Edit">
                  <PencilIcon width={16} height={16} />
                </IconButton>
              )}
              {onDelete && (
                <IconButton
                  className="danger"
                  onClick={handleDelete}
                  title="Delete"
                >
                  <TrashIcon width={16} height={16} />
                </IconButton>
              )}
            </CardActions>
          )}
        </HeaderTop>

        {pkg.description && (
          <PackageDescription>{pkg.description}</PackageDescription>
        )}
      </CardHeader>

      <CardBody>
        <Section>
          <SectionTitle>Included Coverages ({packageCoverages.length})</SectionTitle>
          <CoverageList>
            {packageCoverages.map((coverage) => (
              <CoverageItem key={coverage.id}>
                <CheckCircleIcon width={16} height={16} />
                <CoverageName>{coverage.name}</CoverageName>
                <CoverageType>{coverage.coverageType}</CoverageType>
              </CoverageItem>
            ))}
          </CoverageList>
        </Section>

        {(pkg.discountPercentage || pkg.packagePremium) && (
          <PricingSection>
            {pkg.discountPercentage && pkg.discountPercentage > 0 && (
              <DiscountBadge>
                <SparklesIcon width={16} height={16} />
                <DiscountText>{pkg.discountPercentage}% Discount</DiscountText>
              </DiscountBadge>
            )}
            
            {pkg.packagePremium && (
              <PremiumDisplay>
                <PremiumLabel>Package Premium:</PremiumLabel>
                <PremiumValue>${pkg.packagePremium.toFixed(2)}</PremiumValue>
              </PremiumDisplay>
            )}
          </PricingSection>
        )}
      </CardBody>

      {isSelected && (
        <SelectedIndicator>
          <CheckCircleIcon width={20} height={20} />
          Selected
        </SelectedIndicator>
      )}
    </Card>
  );
});

const Card = styled.div<{ $selected?: boolean }>`
  background: white;
  border: 2px solid ${({ $selected }) => $selected ? '#3b82f6' : '#e5e7eb'};
  border-radius: 12px;
  padding: 20px;
  transition: all 0.2s;
  cursor: ${({ onClick }) => onClick ? 'pointer' : 'default'};
  position: relative;

  &:hover {
    border-color: ${({ $selected }) => $selected ? '#2563eb' : '#d1d5db'};
    box-shadow: ${({ onClick }) => onClick ? '0 4px 6px -1px rgba(0, 0, 0, 0.1)' : 'none'};
  }
`;

const CardHeader = styled.div`
  margin-bottom: 16px;
`;

const HeaderTop = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 8px;
`;

const PackageInfo = styled.div`
  flex: 1;
`;

const PackageName = styled.h3`
  font-size: 18px;
  font-weight: 600;
  color: #111827;
  margin: 0 0 8px 0;
`;

const PackageTypeBadge = styled.span<{ $colors: { bg: string; color: string; border: string } }>`
  display: inline-block;
  padding: 4px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  background: ${({ $colors }) => $colors.bg};
  color: ${({ $colors }) => $colors.color};
  border: 1px solid ${({ $colors }) => $colors.border};
`;

const PackageDescription = styled.p`
  font-size: 14px;
  color: #6b7280;
  line-height: 1.5;
  margin: 8px 0 0 0;
`;

const CardActions = styled.div`
  display: flex;
  gap: 8px;
`;

const IconButton = styled.button`
  width: 32px;
  height: 32px;
  border-radius: 6px;
  border: 1px solid #e5e7eb;
  background: white;
  color: #6b7280;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;

  &:hover {
    background: #f9fafb;
    border-color: #d1d5db;
    color: #111827;
  }

  &.danger:hover {
    background: #fee2e2;
    border-color: #fca5a5;
    color: #dc2626;
  }
`;

const CardBody = styled.div``;

const Section = styled.div`
  margin-bottom: 16px;
`;

const SectionTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #6b7280;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
`;

const CoverageList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const CoverageItem = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  font-size: 14px;

  svg {
    color: #22c55e;
    flex-shrink: 0;
  }
`;

const CoverageName = styled.span`
  flex: 1;
  font-weight: 500;
  color: #111827;
`;

const CoverageType = styled.span`
  font-size: 12px;
  color: #6b7280;
  padding: 2px 8px;
  background: white;
  border-radius: 4px;
`;

const PricingSection = styled.div`
  padding-top: 16px;
  border-top: 1px solid #e5e7eb;
`;

const DiscountBadge = styled.div`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
  color: white;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 12px;

  svg {
    flex-shrink: 0;
  }
`;

const DiscountText = styled.span``;

const PremiumDisplay = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const PremiumLabel = styled.span`
  font-size: 14px;
  color: #6b7280;
`;

const PremiumValue = styled.span`
  font-size: 24px;
  font-weight: 700;
  color: #111827;
`;

const SelectedIndicator = styled.div`
  position: absolute;
  top: -1px;
  right: -1px;
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: #3b82f6;
  color: white;
  border-radius: 0 10px 0 10px;
  font-size: 12px;
  font-weight: 600;

  svg {
    flex-shrink: 0;
  }
`;

```

---

## src/components/packages/index.ts

**Path:** `src/components/packages/index.ts`

```typescript
/**
 * Packages Index
 * Centralized exports for coverage package components
 */

export { default as PackageBuilder } from './PackageBuilder';
export { default as PackageCard } from './PackageCard';

```

---

## src/components/pricing/PremiumCalculator.tsx

**Path:** `src/components/pricing/PremiumCalculator.tsx`

```tsx
import React, { useState, useMemo } from 'react';
import styled from 'styled-components';
import {
  CalculatorIcon,
  ChartBarIcon,
  ArrowTrendingUpIcon
} from '@heroicons/react/24/outline';

// ============================================================================
// Types
// ============================================================================

interface PricingStep {
  id: string;
  stepType: 'factor' | 'operand';
  stepName?: string;
  value?: number;
  operand?: string;
  coverages?: string[];
  states?: string[];
}

interface CalculationStep {
  stepNumber: number;
  stepName: string;
  operation: string;
  value: number;
  runningTotal: number;
  impact: number;
  impactPercent: number;
}

interface PremiumCalculatorProps {
  steps: PricingStep[];
  selectedCoverage?: string | null;
  selectedStates?: string[];
}

// ============================================================================
// Styled Components
// ============================================================================

const CalculatorContainer = styled.div`
  background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
  border-radius: 16px;
  padding: 24px;
  border: 1px solid #e2e8f0;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
  margin-bottom: 24px;
`;

const CalculatorHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
  padding-bottom: 16px;
  border-bottom: 2px solid #e2e8f0;
`;

const HeaderTitle = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  
  h3 {
    font-size: 18px;
    font-weight: 700;
    color: #1e293b;
    margin: 0;
  }
  
  svg {
    width: 24px;
    height: 24px;
    color: #6366f1;
  }
`;

const PremiumDisplay = styled.div`
  text-align: right;
  
  .label {
    font-size: 12px;
    font-weight: 500;
    color: #64748b;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
  }
  
  .amount {
    font-size: 32px;
    font-weight: 800;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
`;

const TabContainer = styled.div`
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
  border-bottom: 1px solid #e2e8f0;
`;

const Tab = styled.button<{ active: boolean }>`
  padding: 10px 16px;
  border: none;
  background: ${props => props.active ? 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)' : 'transparent'};
  color: ${props => props.active ? '#ffffff' : '#64748b'};
  font-weight: ${props => props.active ? '600' : '500'};
  font-size: 14px;
  border-radius: 8px 8px 0 0;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 6px;
  
  svg {
    width: 16px;
    height: 16px;
  }
  
  &:hover {
    background: ${props => props.active ? 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)' : '#f1f5f9'};
    color: ${props => props.active ? '#ffffff' : '#1e293b'};
  }
`;

const BreakdownContainer = styled.div`
  max-height: 500px;
  overflow-y: auto;
  
  &::-webkit-scrollbar {
    width: 8px;
  }
  
  &::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
  }
  
  &::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 4px;
    
    &:hover {
      background: #94a3b8;
    }
  }
`;

const StepCard = styled.div<{ isOperand?: boolean }>`
  background: ${props => props.isOperand ? '#fef3c7' : '#ffffff'};
  border: 1px solid ${props => props.isOperand ? '#fbbf24' : '#e2e8f0'};
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 12px;
  transition: all 0.2s ease;
  
  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  }
`;

const StepHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
`;

const StepInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const StepNumber = styled.div`
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 14px;
`;

const StepName = styled.div`
  font-weight: 600;
  color: #1e293b;
  font-size: 15px;
`;

const StepValue = styled.div`
  font-weight: 700;
  color: #6366f1;
  font-size: 16px;
`;

const StepDetails = styled.div`
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #e2e8f0;
`;

const DetailItem = styled.div`
  .label {
    font-size: 11px;
    font-weight: 500;
    color: #64748b;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
  }
  
  .value {
    font-size: 14px;
    font-weight: 600;
    color: #1e293b;
  }
`;

const ImpactBadge = styled.div<{ positive?: boolean }>`
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  border-radius: 12px;
  background: ${props => props.positive ? '#dcfce7' : '#fee2e2'};
  color: ${props => props.positive ? '#16a34a' : '#dc2626'};
  font-size: 12px;
  font-weight: 600;
  
  svg {
    width: 14px;
    height: 14px;
  }
`;

const FormulaVisualization = styled.div`
  background: #f8fafc;
  border: 2px dashed #cbd5e1;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 20px;
  font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 14px;
  line-height: 1.8;
  color: #1e293b;
  overflow-x: auto;
  
  .operator {
    color: #f59e0b;
    font-weight: 700;
    padding: 0 8px;
  }
  
  .value {
    color: #6366f1;
    font-weight: 700;
  }
  
  .step-name {
    color: #64748b;
    font-style: italic;
  }
`;

const SummaryCard = styled.div`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 12px;
  padding: 20px;
  color: white;
  margin-top: 20px;
`;

const SummaryGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
`;

const SummaryItem = styled.div`
  .label {
    font-size: 12px;
    opacity: 0.9;
    margin-bottom: 4px;
  }
  
  .value {
    font-size: 20px;
    font-weight: 700;
  }
`;

const EmptyState = styled.div`
  text-align: center;
  padding: 60px 20px;
  color: #64748b;
  
  svg {
    width: 64px;
    height: 64px;
    margin-bottom: 16px;
    opacity: 0.3;
  }
  
  h4 {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 8px;
    color: #1e293b;
  }
  
  p {
    font-size: 14px;
    margin: 0;
  }
`;

// ============================================================================
// Component
// ============================================================================

export const PremiumCalculator: React.FC<PremiumCalculatorProps> = ({
  steps,
  selectedCoverage,
  selectedStates = []
}) => {
  const [activeTab, setActiveTab] = useState<'breakdown' | 'formula'>('breakdown');

  // Filter steps based on coverage and states
  const filteredSteps = useMemo(() => {
    return steps.filter(step => {
      const coverageMatch = !selectedCoverage || (step.coverages && step.coverages.includes(selectedCoverage));
      const stateMatch = selectedStates.length === 0 || selectedStates.every(s => step.states && step.states.includes(s));
      return coverageMatch && stateMatch;
    });
  }, [steps, selectedCoverage, selectedStates]);

  // Calculate premium with detailed breakdown
  const calculation = useMemo(() => {
    let result = 0;
    let currentOperand: string | null = null;
    const calculationSteps: CalculationStep[] = [];
    let stepNumber = 0;

    filteredSteps.forEach((step) => {
      if (step.stepType === 'factor') {
        const value = step.value || 0;
        const previousTotal = result;
        
        if (result === 0 && currentOperand === null) {
          result = value;
        } else if (currentOperand) {
          switch (currentOperand) {
            case '+':
              result += value;
              break;
            case '-':
              result -= value;
              break;
            case '*':
              result *= value;
              break;
            case '/':
              result = value !== 0 ? result / value : result;
              break;
            case '=':
              result = value;
              break;
          }
        }
        
        const impact = result - previousTotal;
        const impactPercent = previousTotal !== 0 ? (impact / previousTotal) * 100 : 0;
        
        stepNumber++;
        calculationSteps.push({
          stepNumber,
          stepName: step.stepName || 'Unnamed Step',
          operation: currentOperand || 'Initial',
          value,
          runningTotal: result,
          impact,
          impactPercent
        });
        
        currentOperand = null;
      } else if (step.stepType === 'operand') {
        currentOperand = step.operand || null;
      }
    });

    return {
      finalPremium: result,
      steps: calculationSteps,
      totalSteps: calculationSteps.length
    };
  }, [filteredSteps]);

  // Generate formula string
  const formulaString = useMemo(() => {
    let formula = '';
    let currentOperand: string | null = null;

    filteredSteps.forEach(step => {
      if (step.stepType === 'factor') {
        if (formula && currentOperand) {
          formula += ` <span class="operator">${currentOperand}</span> `;
        }
        formula += `<span class="value">${step.value || 0}</span> <span class="step-name">(${step.stepName})</span>`;
        currentOperand = null;
      } else if (step.stepType === 'operand') {
        currentOperand = step.operand || null;
      }
    });

    return formula || 'No formula defined';
  }, [filteredSteps]);

  if (filteredSteps.length === 0) {
    return (
      <CalculatorContainer>
        <EmptyState>
          <CalculatorIcon />
          <h4>No Pricing Steps</h4>
          <p>Add pricing steps to see premium calculations</p>
        </EmptyState>
      </CalculatorContainer>
    );
  }

  return (
    <CalculatorContainer>
      <CalculatorHeader>
        <HeaderTitle>
          <CalculatorIcon />
          <h3>Premium Calculator</h3>
        </HeaderTitle>
        <PremiumDisplay>
          <div className="label">Calculated Premium</div>
          <div className="amount">${calculation.finalPremium.toFixed(2)}</div>
        </PremiumDisplay>
      </CalculatorHeader>

      <TabContainer>
        <Tab active={activeTab === 'breakdown'} onClick={() => setActiveTab('breakdown')}>
          <ChartBarIcon />
          Step-by-Step
        </Tab>
        <Tab active={activeTab === 'formula'} onClick={() => setActiveTab('formula')}>
          <CalculatorIcon />
          Formula
        </Tab>
      </TabContainer>

      {activeTab === 'breakdown' && (
        <BreakdownContainer>
          {calculation.steps.map((step, index) => (
            <StepCard key={index}>
              <StepHeader>
                <StepInfo>
                  <StepNumber>{step.stepNumber}</StepNumber>
                  <StepName>{step.stepName}</StepName>
                </StepInfo>
                <StepValue>${step.value.toFixed(2)}</StepValue>
              </StepHeader>
              <StepDetails>
                <DetailItem>
                  <div className="label">Operation</div>
                  <div className="value">{step.operation}</div>
                </DetailItem>
                <DetailItem>
                  <div className="label">Running Total</div>
                  <div className="value">${step.runningTotal.toFixed(2)}</div>
                </DetailItem>
                <DetailItem>
                  <div className="label">Impact</div>
                  <div className="value">
                    <ImpactBadge positive={step.impact >= 0}>
                      {step.impact >= 0 ? <ArrowTrendingUpIcon /> : null}
                      {step.impact >= 0 ? '+' : ''}${step.impact.toFixed(2)}
                      {step.impactPercent !== 0 && ` (${step.impactPercent.toFixed(1)}%)`}
                    </ImpactBadge>
                  </div>
                </DetailItem>
              </StepDetails>
            </StepCard>
          ))}
          
          <SummaryCard>
            <SummaryGrid>
              <SummaryItem>
                <div className="label">Total Steps</div>
                <div className="value">{calculation.totalSteps}</div>
              </SummaryItem>
              <SummaryItem>
                <div className="label">Base Amount</div>
                <div className="value">${calculation.steps[0]?.value.toFixed(2) || '0.00'}</div>
              </SummaryItem>
              <SummaryItem>
                <div className="label">Final Premium</div>
                <div className="value">${calculation.finalPremium.toFixed(2)}</div>
              </SummaryItem>
            </SummaryGrid>
          </SummaryCard>
        </BreakdownContainer>
      )}

      {activeTab === 'formula' && (
        <FormulaVisualization dangerouslySetInnerHTML={{ __html: formulaString }} />
      )}
    </CalculatorContainer>
  );
};

export default PremiumCalculator;

```

---

## src/components/pricing/RatingAlgorithmBuilder.tsx

**Path:** `src/components/pricing/RatingAlgorithmBuilder.tsx`

```tsx
import React, { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import styled, { keyframes } from 'styled-components';
import {
  PlusIcon,
  TrashIcon,
  PencilIcon,
  ChevronUpIcon,
  ChevronDownIcon,
  CalculatorIcon,
  CubeIcon,
  ArrowDownIcon,
  TableCellsIcon,
  MapPinIcon,
  TagIcon,
  SparklesIcon,
  Bars3Icon,
  MagnifyingGlassIcon,
  ArrowDownTrayIcon,
  LightBulbIcon,
  RocketLaunchIcon,
  BoltIcon,
  ClipboardDocumentIcon,
} from '@heroicons/react/24/outline';
import { CheckCircleIcon } from '@heroicons/react/24/solid';

// ============================================================================
// Types
// ============================================================================

export interface RatingStep {
  id: string;
  stepType: 'factor' | 'operand';
  stepName?: string;
  value?: number;
  operand?: string;
  coverages?: string[];
  states?: string[];
  table?: string;
  rounding?: string;
  order: number;
}

export interface Coverage {
  id: string;
  name: string;
  coverageCode: string;
}

export interface RatingAlgorithmBuilderProps {
  steps: RatingStep[];
  coverages: Coverage[];
  onStepsChange: (steps: RatingStep[]) => void;
  onAddStep: () => void;
  onEditStep: (step: RatingStep) => void;
  onDeleteStep: (stepId: string) => Promise<void>;
  onUpdateStepValue: (stepId: string, value: number) => Promise<void>;
  onReorderSteps: (stepId: string, direction: 'up' | 'down') => Promise<void>;
  onAddOperand: (operand: string) => void;
  onOpenCoverageModal: (step: RatingStep) => void;
  onOpenStatesModal: (step: RatingStep) => void;
  onOpenTable?: (step: RatingStep) => void;
  selectedCoverage?: string | null;
  selectedStates?: string[];
  isLoading?: boolean;
}

// ============================================================================
// Animations - Enhanced micro-interactions
// ============================================================================

const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(-8px); }
  to { opacity: 1; transform: translateY(0); }
`;

const fadeInScale = keyframes`
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
`;

const slideUp = keyframes`
  from { opacity: 0; transform: translateY(16px); }
  to { opacity: 1; transform: translateY(0); }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
`;

const flowDown = keyframes`
  0% { transform: translateY(-4px); opacity: 0.5; }
  50% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(4px); opacity: 0.5; }
`;

const float = keyframes`
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-6px); }
`;

const countUp = keyframes`
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
`;

const particleFloat = keyframes`
  0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.6; }
  50% { transform: translateY(-8px) rotate(180deg); opacity: 1; }
`;

// ============================================================================
// Layout Components - Enhanced with Glassmorphism & Mobile-First Responsive
// ============================================================================

const BuilderContainer = styled.div`
  display: grid;
  grid-template-columns: 1fr 380px;
  gap: 32px;
  min-height: 600px;
  animation: ${fadeInScale} 0.4s ease-out;

  @media (max-width: 1400px) {
    grid-template-columns: 1fr 340px;
    gap: 24px;
  }

  @media (max-width: 1200px) {
    grid-template-columns: 1fr;
  }

  @media (max-width: 768px) {
    gap: 16px;
    padding: 0 8px;
  }

  @media (max-width: 480px) {
    gap: 12px;
    padding: 0 4px;
  }
`;

const AlgorithmPanel = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow:
    0 4px 24px rgba(0, 0, 0, 0.06),
    0 1px 2px rgba(0, 0, 0, 0.04),
    inset 0 1px 0 rgba(255, 255, 255, 0.8);
  overflow: hidden;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);

  &:hover {
    box-shadow:
      0 8px 40px rgba(0, 0, 0, 0.08),
      0 2px 4px rgba(0, 0, 0, 0.04),
      inset 0 1px 0 rgba(255, 255, 255, 0.8);
  }
`;

const PanelHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  background: linear-gradient(135deg, rgba(248, 250, 252, 0.9) 0%, rgba(241, 245, 249, 0.9) 100%);
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  flex-wrap: wrap;
  gap: 16px;

  @media (max-width: 768px) {
    padding: 16px;
  }
`;

const PanelTitle = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;

  h2 {
    font-size: 18px;
    font-weight: 700;
    color: #1e293b;
    margin: 0;
    letter-spacing: -0.025em;
  }

  svg {
    width: 24px;
    height: 24px;
    color: #6366f1;
  }
`;

const StepCount = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  font-weight: 600;
  color: #6366f1;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.12) 0%, rgba(139, 92, 246, 0.12) 100%);
  padding: 6px 12px;
  border-radius: 20px;
  border: 1px solid rgba(99, 102, 241, 0.15);
  transition: all 0.2s ease;

  &:hover {
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.18) 0%, rgba(139, 92, 246, 0.18) 100%);
    transform: scale(1.02);
  }
`;

const HeaderActions = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
`;

const SearchInput = styled.div`
  position: relative;
  display: flex;
  align-items: center;

  input {
    width: 200px;
    padding: 8px 12px 8px 36px;
    border: 1px solid rgba(226, 232, 240, 0.8);
    border-radius: 10px;
    font-size: 13px;
    background: rgba(255, 255, 255, 0.9);
    color: #1e293b;
    transition: all 0.2s ease;

    &::placeholder {
      color: #94a3b8;
    }

    &:hover {
      border-color: #cbd5e1;
    }

    &:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
  }

  svg {
    position: absolute;
    left: 12px;
    width: 16px;
    height: 16px;
    color: #94a3b8;
    pointer-events: none;
  }

  @media (max-width: 768px) {
    input {
      width: 160px;
    }
  }
`;

const ActionButtons = styled.div`
  display: flex;
  gap: 8px;
  align-items: center;
`;

const AddStepButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 18px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  border: none;
  border-radius: 10px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(99, 102, 241, 0.25);

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 50%);
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(99, 102, 241, 0.35);

    &::before {
      opacity: 1;
    }
  }

  &:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.25);
  }

  svg {
    width: 18px;
    height: 18px;
  }

  @media (max-width: 768px) {
    padding: 10px 14px;

    span {
      display: none;
    }
  }
`;

const SecondaryButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.9);
  color: #64748b;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.08);
    border-color: rgba(99, 102, 241, 0.2);
    color: #6366f1;
    transform: translateY(-1px);
  }

  svg {
    width: 18px;
    height: 18px;
  }
`;

// ============================================================================
// Step List Components - Enhanced with interactions
// ============================================================================

const StepsList = styled.div`
  padding: 24px;
  min-height: 400px;
  position: relative;

  @media (max-width: 768px) {
    padding: 16px;
  }
`;

// Premium Empty State with engaging visuals
const EmptyState = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 80px 24px;
  text-align: center;
  animation: ${fadeIn} 0.4s ease-out;
  position: relative;
`;

const EmptyStateIllustration = styled.div`
  position: relative;
  width: 160px;
  height: 160px;
  margin-bottom: 24px;
`;

const EmptyStateIcon = styled.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80px;
  height: 80px;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
  border-radius: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: ${float} 3s ease-in-out infinite;

  svg {
    width: 40px;
    height: 40px;
    color: #6366f1;
  }
`;

const EmptyStateRing = styled.div<{ $delay?: number; $size?: number }>`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: ${({ $size }) => $size || 120}px;
  height: ${({ $size }) => $size || 120}px;
  border: 2px dashed rgba(99, 102, 241, 0.2);
  border-radius: 50%;
  animation: ${pulse} 2s ease-in-out infinite;
  animation-delay: ${({ $delay }) => $delay || 0}s;
`;

const EmptyStateParticle = styled.div<{ $x: number; $y: number; $delay: number }>`
  position: absolute;
  top: ${({ $y }) => $y}%;
  left: ${({ $x }) => $x}%;
  width: 8px;
  height: 8px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 50%;
  animation: ${particleFloat} 2.5s ease-in-out infinite;
  animation-delay: ${({ $delay }) => $delay}s;
  opacity: 0.6;
`;

const EmptyStateTitle = styled.h3`
  font-size: 22px;
  font-weight: 700;
  color: #1e293b;
  margin: 0 0 12px;
  letter-spacing: -0.025em;
`;

const EmptyStateDescription = styled.p`
  font-size: 15px;
  color: #64748b;
  margin: 0 0 24px;
  max-width: 360px;
  line-height: 1.6;
`;

const EmptyStateTips = styled.div`
  display: flex;
  gap: 16px;
  margin-top: 32px;
  flex-wrap: wrap;
  justify-content: center;
`;

const EmptyStateTip = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: rgba(248, 250, 252, 0.8);
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 10px;
  font-size: 13px;
  color: #64748b;

  svg {
    width: 16px;
    height: 16px;
    color: #6366f1;
  }
`;

// Enhanced Step Card with glassmorphism and micro-interactions
const StepCard = styled.div<{ $isOperand?: boolean; $isDragging?: boolean; $isExpanded?: boolean }>`
  position: relative;
  background: ${({ $isOperand }) =>
    $isOperand
      ? 'linear-gradient(135deg, rgba(255, 251, 235, 0.95) 0%, rgba(254, 243, 199, 0.95) 100%)'
      : 'rgba(255, 255, 255, 0.98)'};
  backdrop-filter: blur(10px);
  border: 1.5px solid ${({ $isOperand, $isDragging }) =>
    $isDragging ? '#6366f1' : $isOperand ? 'rgba(251, 191, 36, 0.5)' : 'rgba(226, 232, 240, 0.8)'};
  border-radius: 14px;
  margin-bottom: 0;
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  animation: ${slideUp} 0.3s ease-out;
  animation-fill-mode: both;
  opacity: ${({ $isDragging }) => $isDragging ? 0.9 : 1};
  box-shadow: ${({ $isDragging }) =>
    $isDragging
      ? '0 12px 32px rgba(99, 102, 241, 0.2)'
      : '0 2px 8px rgba(0, 0, 0, 0.04)'};

  &:hover {
    border-color: ${({ $isOperand }) => $isOperand ? '#f59e0b' : 'rgba(99, 102, 241, 0.4)'};
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
    transform: translateY(-1px);
  }

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 14px;
    padding: 1.5px;
    background: ${({ $isOperand }) =>
      $isOperand
        ? 'linear-gradient(135deg, rgba(251, 191, 36, 0.3) 0%, rgba(234, 179, 8, 0.1) 100%)'
        : 'linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, transparent 50%)'};
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  &:hover::before {
    opacity: 1;
  }
`;

const StepNumber = styled.div`
  position: absolute;
  top: -8px;
  left: 16px;
  width: 24px;
  height: 24px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: 700;
  color: white;
  box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
  z-index: 1;

  @media (max-width: 480px) {
    width: 20px;
    height: 20px;
    font-size: 10px;
    top: -6px;
    left: 12px;
  }
`;

const DragHandle = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 40px;

  /* Larger touch target on mobile */
  @media (max-width: 768px) {
    width: 32px;
    height: 44px;
    margin-left: -4px;
  }
  color: #cbd5e1;
  cursor: grab;
  transition: color 0.2s ease;
  flex-shrink: 0;
  margin-left: -4px;

  &:hover {
    color: #6366f1;
  }

  &:active {
    cursor: grabbing;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const StepHeader = styled.div`
  display: flex;
  align-items: center;
  padding: 16px 16px 16px 12px;
  gap: 12px;
  min-height: 72px;

  @media (max-width: 768px) {
    padding: 12px;
    gap: 8px;
    flex-wrap: wrap;
  }
`;

const StepIcon = styled.div<{ $type: 'factor' | 'operand' }>`
  width: 44px;
  height: 44px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: ${({ $type }) =>
    $type === 'factor'
      ? 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)'
      : 'linear-gradient(135deg, #f59e0b 0%, #eab308 100%)'
  };
  color: white;
  flex-shrink: 0;
  box-shadow: ${({ $type }) =>
    $type === 'factor'
      ? '0 4px 12px rgba(99, 102, 241, 0.25)'
      : '0 4px 12px rgba(245, 158, 11, 0.25)'
  };
  transition: all 0.2s ease;

  &:hover {
    transform: scale(1.05);
  }

  svg {
    width: 22px;
    height: 22px;
  }
`;

const StepContent = styled.div`
  flex: 1;
  min-width: 0;
`;

const StepName = styled.div`
  font-size: 15px;
  font-weight: 600;
  color: #1e293b;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 8px;
  letter-spacing: -0.01em;
`;

const StepMeta = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
`;

const MetaBadge = styled.button`
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 5px 10px;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%);
  border: 1px solid rgba(99, 102, 241, 0.12);
  border-radius: 8px;
  font-size: 12px;
  font-weight: 500;
  color: #6366f1;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  &:hover {
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
    border-color: rgba(99, 102, 241, 0.25);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.15);

    &::before {
      opacity: 1;
    }
  }

  &:active {
    transform: translateY(0);
  }

  svg {
    width: 13px;
    height: 13px;
    flex-shrink: 0;
  }
`;

const TableBadge = styled(MetaBadge)`
  background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.1) 100%);
  border-color: rgba(16, 185, 129, 0.2);
  color: #059669;

  &:hover {
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.18) 0%, rgba(5, 150, 105, 0.18) 100%);
    border-color: rgba(16, 185, 129, 0.35);
    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.2);
  }
`;

const ValueEditor = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
  flex-shrink: 0;
  position: relative;

  @media (max-width: 768px) {
    margin-left: 0;
    width: 100%;
    justify-content: flex-end;
  }
`;

const ValueInputWrapper = styled.div`
  position: relative;
  display: flex;
  align-items: center;
`;

const ValueInput = styled.input<{ $hasChanged?: boolean }>`
  width: 110px;
  padding: 10px 14px 10px 24px;
  border: 1.5px solid ${({ $hasChanged }) => $hasChanged ? '#6366f1' : 'rgba(226, 232, 240, 0.8)'};
  border-radius: 10px;
  font-size: 16px;
  font-weight: 700;
  color: #1e293b;
  text-align: right;
  background: ${({ $hasChanged }) => $hasChanged ? 'rgba(99, 102, 241, 0.05)' : 'rgba(248, 250, 252, 0.8)'};
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);

  &:hover {
    border-color: #cbd5e1;
    background: rgba(255, 255, 255, 0.9);
  }

  &:focus {
    outline: none;
    border-color: #6366f1;
    background: white;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.12);
  }

  /* Hide spinner buttons */
  &::-webkit-outer-spin-button,
  &::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  -moz-appearance: textfield;
`;

const StepActions = styled.div`
  display: flex;
  align-items: center;
  gap: 2px;
  flex-shrink: 0;
  padding-left: 8px;
  border-left: 1px solid rgba(226, 232, 240, 0.6);
  margin-left: 8px;

  @media (max-width: 768px) {
    padding-left: 0;
    border-left: none;
    margin-left: 0;
  }
`;

const IconButton = styled.button<{ $variant?: 'default' | 'danger' }>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 34px;
  height: 34px;
  border: none;
  border-radius: 8px;
  background: transparent;
  color: ${({ $variant }) => $variant === 'danger' ? '#ef4444' : '#64748b'};
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  /* Minimum touch target for accessibility */
  min-width: 44px;
  min-height: 44px;

  &::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 8px;
    background: currentColor;
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  &:hover {
    background: ${({ $variant }) =>
      $variant === 'danger' ? 'rgba(239, 68, 68, 0.1)' : 'rgba(99, 102, 241, 0.1)'};
    color: ${({ $variant }) => $variant === 'danger' ? '#dc2626' : '#6366f1'};
    transform: translateY(-1px);
  }

  &:active {
    transform: translateY(0);
    background: ${({ $variant }) =>
      $variant === 'danger' ? 'rgba(239, 68, 68, 0.15)' : 'rgba(99, 102, 241, 0.15)'};
  }

  &:disabled {
    opacity: 0.35;
    cursor: not-allowed;
    transform: none;

    &:hover {
      background: transparent;
      transform: none;
    }
  }

  svg {
    width: 16px;
    height: 16px;
    position: relative;
    z-index: 1;
  }

  /* Enhanced touch targets on mobile */
  @media (max-width: 768px) {
    width: 40px;
    height: 40px;

    svg {
      width: 18px;
      height: 18px;
    }
  }

  @media (max-width: 480px) {
    width: 44px;
    height: 44px;

    svg {
      width: 20px;
      height: 20px;
    }
  }
`;

// ============================================================================
// Connector / Flow Components - Animated SVG Bezier Curves
// ============================================================================

const StepConnector = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 40px;
  position: relative;
  margin: 4px 0;
`;

const ConnectorArrow = styled.div`
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.95) 100%);
  backdrop-filter: blur(8px);
  border: 1.5px solid rgba(99, 102, 241, 0.25);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  box-shadow: 0 2px 8px rgba(99, 102, 241, 0.15);
  animation: ${flowDown} 2.5s ease-in-out infinite;
  transition: all 0.2s ease;

  &:hover {
    border-color: rgba(99, 102, 241, 0.5);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
    transform: scale(1.1);
  }

  svg {
    width: 14px;
    height: 14px;
    color: #6366f1;
  }
`;

// Alternative animated line connector
const AnimatedConnectorLine = styled.div`
  position: absolute;
  left: 50%;
  top: 0;
  bottom: 0;
  width: 2px;
  background: linear-gradient(
    to bottom,
    transparent 0%,
    rgba(99, 102, 241, 0.3) 20%,
    rgba(139, 92, 246, 0.5) 50%,
    rgba(99, 102, 241, 0.3) 80%,
    transparent 100%
  );
  overflow: hidden;

  &::after {
    content: '';
    position: absolute;
    width: 6px;
    height: 6px;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    border-radius: 50%;
    left: 50%;
    transform: translateX(-50%);
    animation: ${flowDown} 1.5s ease-in-out infinite;
    box-shadow: 0 0 8px rgba(99, 102, 241, 0.5);
  }
`;

// ============================================================================
// Operand Components - Enhanced styling
// ============================================================================

const OperandDisplay = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 14px 20px;
  gap: 12px;
`;

const OperandSymbol = styled.span`
  font-size: 28px;
  font-weight: 800;
  background: linear-gradient(135deg, #f59e0b 0%, #eab308 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: 0 2px 12px rgba(245, 158, 11, 0.2);
`;

const OperandLabel = styled.span`
  font-size: 13px;
  color: #92400e;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  opacity: 0.9;
`;

// ============================================================================
// Quick Add Operand Bar - Enhanced with floating style
// ============================================================================

const QuickAddBar = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 18px 24px;
  background: linear-gradient(135deg, rgba(248, 250, 252, 0.95) 0%, rgba(241, 245, 249, 0.95) 100%);
  border-top: 1px solid rgba(226, 232, 240, 0.6);
  flex-wrap: wrap;

  @media (max-width: 768px) {
    padding: 14px 16px;
    gap: 8px;
  }
`;

const QuickAddLabel = styled.span`
  font-size: 13px;
  font-weight: 600;
  color: #64748b;
  margin-right: 4px;
  display: flex;
  align-items: center;
  gap: 6px;

  svg {
    width: 14px;
    height: 14px;
    color: #6366f1;
  }
`;

const OperandButtonGroup = styled.div`
  display: flex;
  gap: 6px;
  background: rgba(255, 255, 255, 0.8);
  padding: 4px;
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.6);
`;

const OperandButtonStyled = styled.button<{ $selected?: boolean }>`
  width: 42px;
  height: 42px;
  border-radius: 10px;
  border: 1.5px solid ${({ $selected }) => $selected ? '#6366f1' : 'rgba(226, 232, 240, 0.8)'};
  background: ${({ $selected }) =>
    $selected
      ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%)'
      : 'rgba(255, 255, 255, 0.9)'};
  color: ${({ $selected }) => $selected ? '#6366f1' : '#64748b'};
  font-size: 20px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
  /* Minimum touch target */
  min-width: 44px;
  min-height: 44px;

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  &:hover {
    border-color: #6366f1;
    color: #6366f1;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);

    &::before {
      opacity: 1;
    }
  }

  &:active {
    transform: translateY(0);
    box-shadow: 0 2px 6px rgba(99, 102, 241, 0.15);
  }

  /* Keyboard focus style */
  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
  }

  /* Enhanced touch targets on mobile */
  @media (max-width: 768px) {
    width: 48px;
    height: 48px;
    font-size: 22px;
  }

  @media (max-width: 480px) {
    width: 52px;
    height: 52px;
    font-size: 24px;
    border-radius: 12px;
  }
`;

// ============================================================================
// Preview Panel Components - Premium Breakdown & Visualization
// ============================================================================

const PreviewPanel = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow:
    0 4px 24px rgba(0, 0, 0, 0.06),
    0 1px 2px rgba(0, 0, 0, 0.04),
    inset 0 1px 0 rgba(255, 255, 255, 0.8);
  position: sticky;
  top: 100px;
  height: fit-content;
  max-height: calc(100vh - 120px);
  overflow: hidden;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);

  &:hover {
    box-shadow:
      0 8px 40px rgba(0, 0, 0, 0.08),
      0 2px 4px rgba(0, 0, 0, 0.04),
      inset 0 1px 0 rgba(255, 255, 255, 0.8);
  }

  @media (max-width: 1200px) {
    position: static;
    max-height: none;
  }

  @media (max-width: 768px) {
    border-radius: 16px;
  }

  @media (max-width: 480px) {
    border-radius: 12px;
    margin: 0 -4px;
  }
`;

const PreviewHeader = styled.div`
  padding: 24px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%);
  color: white;
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -50%;
    width: 100%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
    pointer-events: none;
  }

  &::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  }

  @media (max-width: 768px) {
    padding: 20px;
  }

  @media (max-width: 480px) {
    padding: 16px;
  }
`;

const PreviewHeaderTop = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
`;

const PreviewTitle = styled.h3`
  font-size: 12px;
  font-weight: 600;
  margin: 0;
  opacity: 0.85;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  display: flex;
  align-items: center;
  gap: 6px;

  svg {
    width: 14px;
    height: 14px;
  }
`;

const PreviewBadge = styled.div<{ $positive?: boolean }>`
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  background: ${({ $positive }) =>
    $positive ? 'rgba(134, 239, 172, 0.2)' : 'rgba(252, 165, 165, 0.2)'};
  border-radius: 20px;
  font-size: 11px;
  font-weight: 600;

  svg {
    width: 12px;
    height: 12px;
  }
`;

const PreviewAmount = styled.div`
  font-size: 42px;
  font-weight: 800;
  letter-spacing: -0.03em;
  line-height: 1;
  text-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
  animation: ${countUp} 0.4s ease-out;

  @media (max-width: 768px) {
    font-size: 36px;
  }

  @media (max-width: 480px) {
    font-size: 32px;
  }
`;

const PreviewSubtext = styled.div`
  font-size: 13px;
  opacity: 0.75;
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;

  span {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  svg {
    width: 14px;
    height: 14px;
  }

  @media (max-width: 480px) {
    font-size: 12px;
    gap: 6px;
  }
`;

const PreviewActions = styled.div`
  display: flex;
  gap: 8px;
  margin-top: 16px;
  flex-wrap: wrap;

  @media (max-width: 480px) {
    gap: 6px;
    margin-top: 12px;
  }
`;

const PreviewActionButton = styled.button`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  background: rgba(255, 255, 255, 0.15);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  color: white;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(10px);
  /* Minimum touch target */
  min-height: 44px;

  &:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: translateY(-1px);
  }

  &:active {
    transform: translateY(0);
    background: rgba(255, 255, 255, 0.3);
  }

  svg {
    width: 14px;
    height: 14px;
  }

  @media (max-width: 480px) {
    padding: 10px 16px;
    flex: 1;
    justify-content: center;
  }
`;

const PreviewBody = styled.div`
  padding: 20px;
  max-height: 400px;
  overflow-y: auto;

  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: transparent;
  }

  &::-webkit-scrollbar-thumb {
    background: rgba(203, 213, 225, 0.5);
    border-radius: 3px;
  }
`;

const BreakdownTitle = styled.div`
  font-size: 11px;
  font-weight: 600;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;

  button {
    background: none;
    border: none;
    color: #6366f1;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    padding: 0;

    &:hover {
      text-decoration: underline;
    }
  }
`;

const CalculationRow = styled.div<{ $isResult?: boolean; $index?: number }>`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 16px;
  border-radius: 12px;
  margin-bottom: 8px;
  background: ${({ $isResult }) =>
    $isResult
      ? 'linear-gradient(135deg, rgba(240, 253, 244, 0.95) 0%, rgba(220, 252, 231, 0.95) 100%)'
      : 'rgba(248, 250, 252, 0.8)'};
  border: 1px solid ${({ $isResult }) => $isResult ? 'rgba(134, 239, 172, 0.5)' : 'rgba(226, 232, 240, 0.6)'};
  transition: all 0.2s ease;
  animation: ${slideUp} 0.3s ease-out both;
  animation-delay: ${({ $index }) => ($index || 0) * 0.05}s;

  &:hover {
    transform: translateX(4px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  }

  &:last-child {
    margin-bottom: 0;
  }
`;

const CalculationLabel = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 13px;
  color: #64748b;

  .step-num {
    width: 22px;
    height: 22px;
    border-radius: 6px;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: 700;
    color: white;
    box-shadow: 0 2px 6px rgba(99, 102, 241, 0.2);
  }

  .step-name {
    font-weight: 600;
    color: #1e293b;
    max-width: 140px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const OperationBadge = styled.span`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  background: rgba(245, 158, 11, 0.15);
  border-radius: 4px;
  font-size: 12px;
  font-weight: 700;
  color: #d97706;
  margin-right: 4px;
`;

const CalculationValue = styled.div<{ $isResult?: boolean }>`
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: ${({ $isResult }) => $isResult ? '18px' : '14px'};
  font-weight: 700;
  color: ${({ $isResult }) => $isResult ? '#16a34a' : '#1e293b'};
`;

const FormulaPreview = styled.div`
  padding: 16px;
  background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
  border-radius: 12px;
  margin: 0 20px 20px;
  font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 13px;
  color: #e2e8f0;
  overflow-x: auto;
  line-height: 1.8;
  border: 1px solid rgba(51, 65, 85, 0.5);
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);

  .operator {
    color: #fbbf24;
    font-weight: 700;
    padding: 0 8px;
  }

  .value {
    color: #a5b4fc;
    font-weight: 700;
    background: rgba(99, 102, 241, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
  }

  .label {
    color: #64748b;
    font-size: 11px;
    font-style: italic;
  }
`;

const EmptyPreviewState = styled.div`
  text-align: center;
  padding: 48px 24px;
  color: #64748b;

  svg {
    width: 48px;
    height: 48px;
    margin-bottom: 12px;
    opacity: 0.4;
    color: #6366f1;
  }

  p {
    font-size: 14px;
    margin: 0;
    line-height: 1.5;
  }
`;

// ============================================================================
// Helper Functions
// ============================================================================

const getOperandLabel = (op: string): string => {
  switch (op) {
    case '+': return 'Add';
    case '-': return 'Subtract';
    case '*': return 'Multiply';
    case '/': return 'Divide';
    case '=': return 'Equals';
    default: return op;
  }
};

const formatCurrency = (value: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(value);
};

// ============================================================================
// Main Component
// ============================================================================

export const RatingAlgorithmBuilder: React.FC<RatingAlgorithmBuilderProps> = ({
  steps,
  coverages: _coverages,
  onAddStep,
  onEditStep,
  onDeleteStep,
  onUpdateStepValue,
  onReorderSteps,
  onAddOperand,
  onOpenCoverageModal,
  onOpenStatesModal,
  onOpenTable,
  selectedCoverage: _selectedCoverage,
  selectedStates: _selectedStates = [],
  isLoading: _isLoading = false,
}) => {
  const [editingValueId, setEditingValueId] = useState<string | null>(null);
  const [tempValue, setTempValue] = useState<string>('');
  const valueInputRef = useRef<HTMLInputElement>(null);

  // Calculate premium based on steps
  const calculation = useMemo(() => {
    let result = 0;
    let currentOperand: string | null = null;
    const breakdown: Array<{ stepNum: number; name: string; value: number; runningTotal: number; operation: string }> = [];
    let stepNum = 0;

    steps.forEach((step) => {
      if (step.stepType === 'factor') {
        const value = step.value || 0;
        stepNum++;

        if (result === 0 && currentOperand === null) {
          result = value;
        } else if (currentOperand) {
          switch (currentOperand) {
            case '+': result += value; break;
            case '-': result -= value; break;
            case '*': result *= value; break;
            case '/': result = value !== 0 ? result / value : result; break;
            case '=': result = value; break;
          }
        }

        breakdown.push({
          stepNum,
          name: step.stepName || 'Unnamed Step',
          value,
          runningTotal: result,
          operation: currentOperand || 'Initial',
        });

        currentOperand = null;
      } else if (step.stepType === 'operand') {
        currentOperand = step.operand || null;
      }
    });

    return { finalPremium: result, breakdown };
  }, [steps]);

  // Generate formula string
  const formulaString = useMemo(() => {
    let formula = '';
    let currentOperand: string | null = null;

    steps.forEach(step => {
      if (step.stepType === 'factor') {
        if (formula && currentOperand) {
          formula += `<span class="operator">${currentOperand}</span>`;
        }
        formula += `<span class="value">${step.value || 0}</span>`;
        formula += `<span class="label"> (${step.stepName || 'Step'})</span> `;
        currentOperand = null;
      } else if (step.stepType === 'operand') {
        currentOperand = step.operand || null;
      }
    });

    return formula || 'No steps defined';
  }, [steps]);

  // Handle inline value editing
  const startEditing = useCallback((step: RatingStep) => {
    setEditingValueId(step.id);
    setTempValue(String(step.value || 0));
  }, []);

  const saveValue = useCallback(async () => {
    if (editingValueId) {
      const numValue = parseFloat(tempValue) || 0;
      await onUpdateStepValue(editingValueId, numValue);
      setEditingValueId(null);
    }
  }, [editingValueId, tempValue, onUpdateStepValue]);

  const cancelEditing = useCallback(() => {
    setEditingValueId(null);
    setTempValue('');
  }, []);

  // Focus input when editing starts
  useEffect(() => {
    if (editingValueId && valueInputRef.current) {
      valueInputRef.current.focus();
      valueInputRef.current.select();
    }
  }, [editingValueId]);

  // Get factor steps count
  const factorStepsCount = steps.filter(s => s.stepType === 'factor').length;
  const [searchQuery, setSearchQuery] = useState('');

  // Filter steps based on search
  const filteredDisplaySteps = useMemo(() => {
    if (!searchQuery.trim()) return steps;
    const query = searchQuery.toLowerCase();
    return steps.filter(step =>
      step.stepType === 'operand' ||
      step.stepName?.toLowerCase().includes(query) ||
      step.coverages?.some(c => c.toLowerCase().includes(query))
    );
  }, [steps, searchQuery]);

  // Get step number for factor steps
  const getFactorStepNumber = (stepId: string): number => {
    let num = 0;
    for (const step of steps) {
      if (step.stepType === 'factor') {
        num++;
        if (step.id === stepId) return num;
      }
    }
    return 0;
  };

  return (
    <BuilderContainer>
      {/* Main Algorithm Panel */}
      <AlgorithmPanel>
        <PanelHeader>
          <PanelTitle>
            <CalculatorIcon />
            <h2>Rating Algorithm</h2>
            <StepCount>
              <SparklesIcon style={{ width: 12, height: 12 }} />
              {factorStepsCount} {factorStepsCount === 1 ? 'step' : 'steps'}
            </StepCount>
          </PanelTitle>

          <HeaderActions>
            <SearchInput>
              <MagnifyingGlassIcon />
              <input
                type="text"
                placeholder="Search steps..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </SearchInput>

            <ActionButtons>
              <SecondaryButton title="Export algorithm">
                <ArrowDownTrayIcon />
              </SecondaryButton>
              <AddStepButton onClick={onAddStep}>
                <PlusIcon />
                <span>Add Step</span>
              </AddStepButton>
            </ActionButtons>
          </HeaderActions>
        </PanelHeader>

        <StepsList>
          {steps.length === 0 ? (
            <EmptyState>
              <EmptyStateIllustration>
                <EmptyStateRing $size={160} $delay={0} />
                <EmptyStateRing $size={120} $delay={0.3} />
                <EmptyStateRing $size={80} $delay={0.6} />
                <EmptyStateIcon>
                  <RocketLaunchIcon />
                </EmptyStateIcon>
                <EmptyStateParticle $x={15} $y={20} $delay={0} />
                <EmptyStateParticle $x={85} $y={25} $delay={0.5} />
                <EmptyStateParticle $x={10} $y={75} $delay={1} />
                <EmptyStateParticle $x={90} $y={70} $delay={1.5} />
              </EmptyStateIllustration>
              <EmptyStateTitle>Build Your Rating Algorithm</EmptyStateTitle>
              <EmptyStateDescription>
                Create a step-by-step calculation flow to determine premiums.
                Add rating factors, connect them with operators, and watch your algorithm come to life.
              </EmptyStateDescription>
              <AddStepButton onClick={onAddStep}>
                <PlusIcon />
                <span>Add First Step</span>
              </AddStepButton>
              <EmptyStateTips>
                <EmptyStateTip>
                  <LightBulbIcon />
                  Start with a base premium
                </EmptyStateTip>
                <EmptyStateTip>
                  <BoltIcon />
                  Add operators between steps
                </EmptyStateTip>
              </EmptyStateTips>
            </EmptyState>
          ) : (
            filteredDisplaySteps.map((step, index) => (
              <React.Fragment key={step.id}>
                {/* Animated Connector between steps */}
                {index > 0 && (
                  <StepConnector>
                    <AnimatedConnectorLine />
                    <ConnectorArrow>
                      <ArrowDownIcon />
                    </ConnectorArrow>
                  </StepConnector>
                )}

                <StepCard
                  $isOperand={step.stepType === 'operand'}
                  style={{ animationDelay: `${index * 0.05}s` }}
                >
                  {step.stepType === 'factor' && (
                    <StepNumber>{getFactorStepNumber(step.id)}</StepNumber>
                  )}

                  {step.stepType === 'factor' ? (
                    <StepHeader>
                      <DragHandle title="Drag to reorder">
                        <Bars3Icon />
                      </DragHandle>
                      <StepIcon $type="factor">
                        <CubeIcon />
                      </StepIcon>
                      <StepContent>
                        <StepName>
                          {step.stepName || 'Unnamed Step'}
                          {step.table && (
                            <TableBadge
                              onClick={() => onOpenTable ? onOpenTable(step) : onEditStep(step)}
                              title="View/Edit Table"
                            >
                              <TableCellsIcon />
                              {step.table}
                            </TableBadge>
                          )}
                        </StepName>
                        <StepMeta>
                          <MetaBadge onClick={() => onOpenCoverageModal(step)}>
                            <TagIcon />
                            {step.coverages?.length === 1
                              ? step.coverages[0]
                              : `${step.coverages?.length || 0} coverages`}
                          </MetaBadge>
                          <MetaBadge onClick={() => onOpenStatesModal(step)}>
                            <MapPinIcon />
                            {step.states?.length === 50
                              ? 'All States'
                              : `${step.states?.length || 0} states`}
                          </MetaBadge>
                        </StepMeta>
                      </StepContent>
                      <ValueEditor>
                        <ValueInputWrapper>
                          {editingValueId === step.id ? (
                            <ValueInput
                              ref={valueInputRef}
                              type="number"
                              value={tempValue}
                              onChange={(e) => setTempValue(e.target.value)}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') saveValue();
                                if (e.key === 'Escape') cancelEditing();
                              }}
                              onBlur={saveValue}
                              $hasChanged={tempValue !== String(step.value || 0)}
                            />
                          ) : (
                            <ValueInput
                              type="number"
                              value={step.value || 0}
                              onFocus={() => startEditing(step)}
                              readOnly
                            />
                          )}
                        </ValueInputWrapper>
                      </ValueEditor>
                      <StepActions>
                        <IconButton onClick={() => onEditStep(step)} title="Edit step (E)">
                          <PencilIcon />
                        </IconButton>
                        <IconButton
                          onClick={() => onReorderSteps(step.id, 'up')}
                          disabled={index === 0}
                          title="Move up (â†‘)"
                        >
                          <ChevronUpIcon />
                        </IconButton>
                        <IconButton
                          onClick={() => onReorderSteps(step.id, 'down')}
                          disabled={index === steps.length - 1}
                          title="Move down (â†“)"
                        >
                          <ChevronDownIcon />
                        </IconButton>
                        <IconButton
                          $variant="danger"
                          onClick={() => onDeleteStep(step.id)}
                          title="Delete step (Del)"
                        >
                          <TrashIcon />
                        </IconButton>
                      </StepActions>
                    </StepHeader>
                  ) : (
                    /* Operand Step - Enhanced */
                    <StepHeader>
                      <StepIcon $type="operand">
                        <span style={{ fontSize: '18px', fontWeight: 800 }}>{step.operand}</span>
                      </StepIcon>
                      <OperandDisplay>
                        <OperandSymbol>{step.operand}</OperandSymbol>
                        <OperandLabel>{getOperandLabel(step.operand || '')}</OperandLabel>
                      </OperandDisplay>
                      <StepActions style={{ marginLeft: 'auto' }}>
                        <IconButton onClick={() => onEditStep(step)} title="Edit operand">
                          <PencilIcon />
                        </IconButton>
                        <IconButton
                          $variant="danger"
                          onClick={() => onDeleteStep(step.id)}
                          title="Delete operand"
                        >
                          <TrashIcon />
                        </IconButton>
                      </StepActions>
                    </StepHeader>
                  )}
                </StepCard>
              </React.Fragment>
            ))
          )}
        </StepsList>

        {/* Quick Add Operand Bar - Enhanced */}
        {steps.length > 0 && (
          <QuickAddBar>
            <QuickAddLabel>
              <BoltIcon />
              Quick add:
            </QuickAddLabel>
            <OperandButtonGroup>
              {['+', '-', '*', '/', '='].map((op, idx) => (
                <OperandButtonStyled
                  key={op}
                  onClick={() => onAddOperand(op)}
                  title={`${getOperandLabel(op)} (${idx + 1})`}
                >
                  {op}
                </OperandButtonStyled>
              ))}
            </OperandButtonGroup>
            <AddStepButton onClick={onAddStep} style={{ marginLeft: 8 }}>
              <PlusIcon />
              <span>Add Step</span>
            </AddStepButton>
          </QuickAddBar>
        )}
      </AlgorithmPanel>

      {/* Premium Preview Panel - Enhanced */}
      <PreviewPanel>
        <PreviewHeader>
          <PreviewHeaderTop>
            <PreviewTitle>
              <CalculatorIcon />
              Calculated Premium
            </PreviewTitle>
            <PreviewBadge $positive={calculation.finalPremium > 0}>
              <CheckCircleIcon />
              Live
            </PreviewBadge>
          </PreviewHeaderTop>
          <PreviewAmount>{formatCurrency(calculation.finalPremium)}</PreviewAmount>
          <PreviewSubtext>
            <span>
              <CubeIcon />
              {factorStepsCount} factors applied
            </span>
          </PreviewSubtext>
          <PreviewActions>
            <PreviewActionButton title="Export calculation">
              <ArrowDownTrayIcon />
              Export
            </PreviewActionButton>
            <PreviewActionButton title="Copy formula">
              <ClipboardDocumentIcon />
              Copy
            </PreviewActionButton>
          </PreviewActions>
        </PreviewHeader>

        <PreviewBody>
          {calculation.breakdown.length > 0 ? (
            <>
              <BreakdownTitle>
                Calculation Breakdown
                <button>View Details</button>
              </BreakdownTitle>
              {calculation.breakdown.map((row, idx) => (
                <CalculationRow key={idx} $index={idx}>
                  <CalculationLabel>
                    <span className="step-num">{row.stepNum}</span>
                    <span className="step-name">{row.name}</span>
                  </CalculationLabel>
                  <CalculationValue>
                    {row.operation !== 'Initial' && (
                      <OperationBadge>{row.operation}</OperationBadge>
                    )}
                    {formatCurrency(row.value)}
                  </CalculationValue>
                </CalculationRow>
              ))}
              <CalculationRow $isResult $index={calculation.breakdown.length}>
                <CalculationLabel>
                  <CheckCircleIcon style={{ width: 18, height: 18, color: '#16a34a' }} />
                  <span className="step-name" style={{ fontWeight: 700 }}>Final Premium</span>
                </CalculationLabel>
                <CalculationValue $isResult>
                  {formatCurrency(calculation.finalPremium)}
                </CalculationValue>
              </CalculationRow>
            </>
          ) : (
            <EmptyPreviewState>
              <CalculatorIcon />
              <p>Add rating steps to see<br />the calculation breakdown</p>
            </EmptyPreviewState>
          )}
        </PreviewBody>

        {calculation.breakdown.length > 0 && (
          <FormulaPreview dangerouslySetInnerHTML={{ __html: formulaString }} />
        )}
      </PreviewPanel>
    </BuilderContainer>
  );
};

export default RatingAlgorithmBuilder;
```

---

## src/components/pricing/index.ts

**Path:** `src/components/pricing/index.ts`

```typescript
/**
 * Pricing Index
 * Centralized exports for pricing-related components
 */

export { default as PremiumCalculator } from './PremiumCalculator';
export { default as RatingAlgorithmBuilder } from './RatingAlgorithmBuilder';

```

---

## src/components/sections/ClaimsSection.tsx

**Path:** `src/components/sections/ClaimsSection.tsx`

```tsx
/**
 * ClaimsSection Component
 * Section for managing claims-related settings
 */

import React, { memo, useCallback } from 'react';
import styled from 'styled-components';

interface ClaimsSectionProps {
  claimsReportingPeriod?: number;
  hasSubrogationRights?: boolean;
  onChange: (data: {
    claimsReportingPeriod?: number;
    hasSubrogationRights?: boolean;
  }) => void;
}

export const ClaimsSection = memo<ClaimsSectionProps>(({
  claimsReportingPeriod,
  hasSubrogationRights = true,
  onChange,
}) => {
  // Memoized callbacks to prevent unnecessary re-renders
  const handleReportingPeriodChange = useCallback((value: number | undefined) => {
    onChange({
      claimsReportingPeriod: value,
      hasSubrogationRights,
    });
  }, [onChange, hasSubrogationRights]);

  const handleSubrogationChange = useCallback((checked: boolean) => {
    onChange({
      claimsReportingPeriod,
      hasSubrogationRights: checked,
    });
  }, [onChange, claimsReportingPeriod]);

  return (
    <Container>
      <SectionTitle>Claims Management</SectionTitle>
      <HelpText>
        Configure claims reporting requirements and subrogation rights
      </HelpText>

      {/* Claims Reporting Period */}
      <SubSection>
        <SubTitle>Claims Reporting Period</SubTitle>
        <SubHelpText>
          Maximum number of days after a loss occurs to report a claim
        </SubHelpText>

        <InputRow>
          <NumberInput
            type="number"
            min="0"
            placeholder="Enter days"
            value={claimsReportingPeriod || ''}
            onChange={(e) => handleReportingPeriodChange(e.target.value ? parseInt(e.target.value) : undefined)}
          />
          <UnitLabel>days</UnitLabel>
        </InputRow>

        {claimsReportingPeriod && (
          <DisplayValue>
            Claims must be reported within {claimsReportingPeriod} days of the loss
          </DisplayValue>
        )}

        <InfoBox>
          <InfoTitle>Common Reporting Periods</InfoTitle>
          <InfoList>
            <InfoItem><strong>Property Insurance:</strong> 30-60 days</InfoItem>
            <InfoItem><strong>Auto Insurance:</strong> Immediate to 30 days</InfoItem>
            <InfoItem><strong>Liability Insurance:</strong> As soon as practicable</InfoItem>
            <InfoItem><strong>Workers' Compensation:</strong> 24-48 hours for serious injuries</InfoItem>
          </InfoList>
        </InfoBox>
      </SubSection>

      {/* Subrogation Rights */}
      <SubSection>
        <SubTitle>Subrogation Rights</SubTitle>
        <SubHelpText>
          Insurer's right to pursue recovery from third parties responsible for the loss
        </SubHelpText>

        <CheckboxRow>
          <Checkbox
            type="checkbox"
            checked={hasSubrogationRights}
            onChange={(e) => handleSubrogationChange(e.target.checked)}
          />
          <CheckboxLabel>Insurer has subrogation rights</CheckboxLabel>
        </CheckboxRow>

        {hasSubrogationRights ? (
          <InfoBox>
            <InfoTitle>âœ“ Subrogation Enabled</InfoTitle>
            <InfoText>
              After paying a claim, the insurer may pursue recovery from third parties who caused 
              the loss. The insured must cooperate with subrogation efforts and cannot waive rights 
              against third parties without insurer consent.
            </InfoText>
          </InfoBox>
        ) : (
          <WarningBox>
            <WarningTitle>âš ï¸ Subrogation Waived</WarningTitle>
            <WarningText>
              The insurer waives subrogation rights. This is uncommon and typically only used in 
              specific situations such as:
              <ul>
                <li>Blanket waivers for all tenants in a building</li>
                <li>Contractual requirements (e.g., construction contracts)</li>
                <li>Related entities or subsidiaries</li>
              </ul>
              Waiving subrogation may increase premium costs.
            </WarningText>
          </WarningBox>
        )}
      </SubSection>

      {/* Additional Claims Information */}
      <SubSection>
        <SubTitle>Claims Process Notes</SubTitle>
        <SubHelpText>
          Key points about the claims process for this coverage
        </SubHelpText>

        <NotesList>
          <NoteItem>
            <NoteIcon>ðŸ“‹</NoteIcon>
            <NoteText>
              <strong>Notice of Loss:</strong> Insured must provide prompt notice of any occurrence 
              that may result in a claim
            </NoteText>
          </NoteItem>
          <NoteItem>
            <NoteIcon>ðŸ“¸</NoteIcon>
            <NoteText>
              <strong>Documentation:</strong> Insured should document the loss with photos, receipts, 
              and witness statements
            </NoteText>
          </NoteItem>
          <NoteItem>
            <NoteIcon>ðŸ¤</NoteIcon>
            <NoteText>
              <strong>Cooperation:</strong> Insured must cooperate with the insurer's investigation 
              and provide requested information
            </NoteText>
          </NoteItem>
          <NoteItem>
            <NoteIcon>âš–ï¸</NoteIcon>
            <NoteText>
              <strong>No Admission:</strong> Insured should not admit liability or make settlements 
              without insurer approval
            </NoteText>
          </NoteItem>
        </NotesList>
      </SubSection>
    </Container>
  );
});

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 20px;
`;

const SectionTitle = styled.h3`
  font-size: 18px;
  font-weight: 600;
  color: #111827;
  margin: 0;
`;

const HelpText = styled.p`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
  margin: -12px 0 0 0;
`;

const SubSection = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
`;

const SubTitle = styled.h4`
  font-size: 15px;
  font-weight: 600;
  color: #374151;
  margin: 0;
`;

const SubHelpText = styled.span`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
`;

const InputRow = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const NumberInput = styled.input`
  flex: 1;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const UnitLabel = styled.span`
  font-size: 14px;
  font-weight: 500;
  color: #6b7280;
`;

const DisplayValue = styled.div`
  padding: 8px 12px;
  background: #f3f4f6;
  border-radius: 6px;
  font-size: 14px;
  color: #374151;
  font-weight: 500;
`;

const CheckboxRow = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const Checkbox = styled.input`
  width: 18px;
  height: 18px;
  cursor: pointer;
`;

const CheckboxLabel = styled.label`
  font-size: 14px;
  color: #374151;
  font-weight: 500;
  cursor: pointer;
`;

const InfoBox = styled.div`
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  border-radius: 6px;
  padding: 12px;
`;

const InfoTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #1e40af;
  margin-bottom: 8px;
`;

const InfoText = styled.div`
  font-size: 13px;
  color: #1e3a8a;
  line-height: 1.6;
`;

const InfoList = styled.ul`
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 6px;
`;

const InfoItem = styled.li`
  font-size: 13px;
  color: #1e3a8a;
  line-height: 1.5;

  strong {
    color: #1e40af;
    font-weight: 600;
  }
`;

const WarningBox = styled.div`
  background: #fef3c7;
  border: 1px solid #fbbf24;
  border-radius: 6px;
  padding: 12px;
`;

const WarningTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #92400e;
  margin-bottom: 8px;
`;

const WarningText = styled.div`
  font-size: 13px;
  color: #78350f;
  line-height: 1.6;

  ul {
    margin: 8px 0 0 0;
    padding-left: 20px;
  }

  li {
    margin: 4px 0;
  }
`;

const NotesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const NoteItem = styled.div`
  display: flex;
  gap: 12px;
  padding: 12px;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
`;

const NoteIcon = styled.div`
  font-size: 24px;
  flex-shrink: 0;
`;

const NoteText = styled.div`
  font-size: 13px;
  color: #374151;
  line-height: 1.6;

  strong {
    color: #111827;
    font-weight: 600;
  }
`;

```

---

## src/components/sections/EndorsementMetadataSection.tsx

**Path:** `src/components/sections/EndorsementMetadataSection.tsx`

```tsx
/**
 * EndorsementMetadataSection Component
 * Section for managing endorsement-specific metadata
 */

import React, { useState, memo, useCallback } from 'react';
import styled from 'styled-components';
import { EndorsementType } from '../../types';
import { PlusIcon, TrashIcon } from '@heroicons/react/24/outline';

interface EndorsementMetadataSectionProps {
  modifiesCoverageId?: string;
  endorsementType?: EndorsementType;
  supersedes?: string[];
  onChange: (data: {
    modifiesCoverageId?: string;
    endorsementType?: EndorsementType;
    supersedes?: string[];
  }) => void;
}

export const EndorsementMetadataSection = memo<EndorsementMetadataSectionProps>(({
  modifiesCoverageId,
  endorsementType,
  supersedes = [],
  onChange,
}) => {
  const [newSupersedes, setNewSupersedes] = useState('');

  // Memoized callbacks to prevent unnecessary re-renders
  const handleCoverageChange = useCallback((value: string) => {
    onChange({
      modifiesCoverageId: value,
      endorsementType,
      supersedes,
    });
  }, [onChange, endorsementType, supersedes]);

  const handleTypeChange = useCallback((value: EndorsementType) => {
    onChange({
      modifiesCoverageId,
      endorsementType: value,
      supersedes,
    });
  }, [onChange, modifiesCoverageId, supersedes]);

  const handleAddSupersedes = useCallback(() => {
    if (newSupersedes.trim() && !supersedes.includes(newSupersedes.trim())) {
      onChange({
        modifiesCoverageId,
        endorsementType,
        supersedes: [...supersedes, newSupersedes.trim()],
      });
      setNewSupersedes('');
    }
  }, [onChange, newSupersedes, modifiesCoverageId, endorsementType, supersedes]);

  const handleRemoveSupersedes = useCallback((index: number) => {
    onChange({
      modifiesCoverageId,
      endorsementType,
      supersedes: supersedes.filter((_, i) => i !== index),
    });
  }, [onChange, modifiesCoverageId, endorsementType, supersedes]);

  return (
    <Container>
      <SectionTitle>Endorsement Metadata</SectionTitle>
      <HelpText>
        Configure endorsement-specific information for coverage modifications
      </HelpText>

      {/* Endorsement Type */}
      <SubSection>
        <SubTitle>Endorsement Type</SubTitle>
        <SubHelpText>
          How this endorsement modifies the base coverage
        </SubHelpText>

        <Select
          value={endorsementType || ''}
          onChange={(e) => handleTypeChange(e.target.value as EndorsementType)}
        >
          <option value="">Select endorsement type...</option>
          <option value="broadening">Broadening - Expands coverage</option>
          <option value="restrictive">Restrictive - Limits coverage</option>
          <option value="clarifying">Clarifying - Clarifies terms</option>
          <option value="additional">Additional - Adds new coverage</option>
        </Select>

        {endorsementType && (
          <InfoBox type={endorsementType}>
            <InfoTitle>
              {endorsementType === 'broadening' && 'âœ“ Broadening Endorsement'}
              {endorsementType === 'restrictive' && 'âš ï¸ Restrictive Endorsement'}
              {endorsementType === 'clarifying' && 'â„¹ï¸ Clarifying Endorsement'}
              {endorsementType === 'additional' && '+ Additional Coverage'}
            </InfoTitle>
            <InfoText>
              {endorsementType === 'broadening' && 'This endorsement expands the scope of coverage beyond the base policy.'}
              {endorsementType === 'restrictive' && 'This endorsement limits or restricts coverage from the base policy.'}
              {endorsementType === 'clarifying' && 'This endorsement clarifies policy terms without changing coverage scope.'}
              {endorsementType === 'additional' && 'This endorsement adds entirely new coverage not in the base policy.'}
            </InfoText>
          </InfoBox>
        )}
      </SubSection>

      {/* Modifies Coverage */}
      <SubSection>
        <SubTitle>Modifies Coverage</SubTitle>
        <SubHelpText>
          The base coverage that this endorsement modifies (if applicable)
        </SubHelpText>

        <Input
          type="text"
          placeholder="Enter coverage ID or name"
          value={modifiesCoverageId || ''}
          onChange={(e) => handleModifiesChange(e.target.value)}
        />

        {modifiesCoverageId && (
          <InfoBox type="info">
            <InfoText>
              This endorsement modifies: <strong>{modifiesCoverageId}</strong>
            </InfoText>
          </InfoBox>
        )}
      </SubSection>

      {/* Supersedes */}
      <SubSection>
        <SubTitle>Supersedes</SubTitle>
        <SubHelpText>
          Previous endorsements or forms that this endorsement replaces
        </SubHelpText>

        <SupersedesList>
          {supersedes.map((item, index) => (
            <SupersedesItem key={index}>
              <SupersedesName>{item}</SupersedesName>
              <RemoveButton onClick={() => handleRemoveSupersedes(index)}>
                <TrashIcon style={{ width: 16, height: 16 }} />
              </RemoveButton>
            </SupersedesItem>
          ))}
        </SupersedesList>

        <AddRow>
          <AddInput
            type="text"
            placeholder="Enter form number or endorsement name"
            value={newSupersedes}
            onChange={(e) => setNewSupersedes(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleAddSupersedes()}
          />
          <AddButton onClick={handleAddSupersedes}>
            <PlusIcon style={{ width: 20, height: 20 }} />
            Add
          </AddButton>
        </AddRow>

        {supersedes.length > 0 && (
          <InfoBox type="warning">
            <InfoText>
              This endorsement supersedes {supersedes.length} previous {supersedes.length === 1 ? 'form' : 'forms'}.
              The superseded forms should not be used when this endorsement is in effect.
            </InfoText>
          </InfoBox>
        )}
      </SubSection>

      {/* Usage Notes */}
      <SubSection>
        <SubTitle>Endorsement Usage Notes</SubTitle>
        <NotesList>
          <NoteItem>
            <NoteIcon>ðŸ“‹</NoteIcon>
            <NoteText>
              <strong>Effective Date:</strong> Endorsements typically take effect on the policy effective date or renewal date
            </NoteText>
          </NoteItem>
          <NoteItem>
            <NoteIcon>ðŸ“</NoteIcon>
            <NoteText>
              <strong>Premium Impact:</strong> Broadening endorsements usually increase premium, restrictive ones may decrease it
            </NoteText>
          </NoteItem>
          <NoteItem>
            <NoteIcon>âš–ï¸</NoteIcon>
            <NoteText>
              <strong>Conflicts:</strong> If endorsements conflict, the most recent endorsement typically takes precedence
            </NoteText>
          </NoteItem>
        </NotesList>
      </SubSection>
    </Container>
  );
});

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 20px;
`;

const SectionTitle = styled.h3`
  font-size: 18px;
  font-weight: 600;
  color: #111827;
  margin: 0;
`;

const HelpText = styled.p`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
  margin: -12px 0 0 0;
`;

const SubSection = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
`;

const SubTitle = styled.h4`
  font-size: 15px;
  font-weight: 600;
  color: #374151;
  margin: 0;
`;

const SubHelpText = styled.span`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
`;

const Select = styled.select`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;
  background: white;
  cursor: pointer;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const Input = styled.input`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const InfoBox = styled.div<{ type?: string }>`
  background: ${props => {
    if (props.type === 'broadening') return '#d1fae5';
    if (props.type === 'restrictive') return '#fee2e2';
    if (props.type === 'clarifying') return '#dbeafe';
    if (props.type === 'additional') return '#e0e7ff';
    if (props.type === 'warning') return '#fef3c7';
    return '#f3f4f6';
  }};
  border: 1px solid ${props => {
    if (props.type === 'broadening') return '#6ee7b7';
    if (props.type === 'restrictive') return '#fecaca';
    if (props.type === 'clarifying') return '#bfdbfe';
    if (props.type === 'additional') return '#c7d2fe';
    if (props.type === 'warning') return '#fbbf24';
    return '#e5e7eb';
  }};
  border-radius: 6px;
  padding: 12px;
`;

const InfoTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #111827;
  margin-bottom: 4px;
`;

const InfoText = styled.div`
  font-size: 13px;
  color: #374151;
  line-height: 1.5;

  strong {
    font-weight: 600;
  }
`;

const SupersedesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const SupersedesItem = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
`;

const SupersedesName = styled.div`
  font-size: 14px;
  color: #374151;
  font-weight: 500;
`;

const RemoveButton = styled.button`
  padding: 4px 8px;
  background: #fee2e2;
  color: #dc2626;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;

  &:hover {
    background: #fecaca;
  }
`;

const AddRow = styled.div`
  display: flex;
  gap: 8px;
`;

const AddInput = styled.input`
  flex: 1;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const AddButton = styled.button`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 10px 16px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;

  &:hover {
    background: #2563eb;
  }
`;

const NotesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const NoteItem = styled.div`
  display: flex;
  gap: 12px;
  padding: 12px;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
`;

const NoteIcon = styled.div`
  font-size: 24px;
  flex-shrink: 0;
`;

const NoteText = styled.div`
  font-size: 13px;
  color: #374151;
  line-height: 1.6;

  strong {
    color: #111827;
    font-weight: 600;
  }
`;

```

---

## src/components/sections/UnderwritingSection.tsx

**Path:** `src/components/sections/UnderwritingSection.tsx`

```tsx
/**
 * UnderwritingSection Component
 * Section for managing underwriting requirements and eligibility criteria
 */

import React, { useState, memo, useCallback } from 'react';
import styled from 'styled-components';
import { PlusIcon, TrashIcon, CheckCircleIcon, XCircleIcon } from '@heroicons/react/24/outline';

interface UnderwritingSectionProps {
  requiresUnderwriterApproval?: boolean;
  eligibilityCriteria?: string[];
  requiredCoverages?: string[];
  incompatibleCoverages?: string[];
  onChange: (data: {
    requiresUnderwriterApproval?: boolean;
    eligibilityCriteria?: string[];
    requiredCoverages?: string[];
    incompatibleCoverages?: string[];
  }) => void;
}

export const UnderwritingSection = memo<UnderwritingSectionProps>(({
  requiresUnderwriterApproval = false,
  eligibilityCriteria = [],
  requiredCoverages = [],
  incompatibleCoverages = [],
  onChange,
}) => {
  const [newCriterion, setNewCriterion] = useState('');
  const [newRequired, setNewRequired] = useState('');
  const [newIncompatible, setNewIncompatible] = useState('');

  // Memoized callbacks to prevent unnecessary re-renders
  const handleToggleApproval = useCallback((checked: boolean) => {
    onChange({
      requiresUnderwriterApproval: checked,
      eligibilityCriteria,
      requiredCoverages,
      incompatibleCoverages,
    });
  }, [onChange, eligibilityCriteria, requiredCoverages, incompatibleCoverages]);

  const handleAddCriterion = useCallback(() => {
    if (newCriterion.trim()) {
      onChange({
        requiresUnderwriterApproval,
        eligibilityCriteria: [...eligibilityCriteria, newCriterion.trim()],
        requiredCoverages,
        incompatibleCoverages,
      });
      setNewCriterion('');
    }
  }, [onChange, newCriterion, requiresUnderwriterApproval, eligibilityCriteria, requiredCoverages, incompatibleCoverages]);

  const handleRemoveCriterion = useCallback((index: number) => {
    onChange({
      requiresUnderwriterApproval,
      eligibilityCriteria: eligibilityCriteria.filter((_, i) => i !== index),
      requiredCoverages,
      incompatibleCoverages,
    });
  }, [onChange, requiresUnderwriterApproval, eligibilityCriteria, requiredCoverages, incompatibleCoverages]);

  const handleAddRequired = useCallback(() => {
    if (newRequired.trim()) {
      onChange({
        requiresUnderwriterApproval,
        eligibilityCriteria,
        requiredCoverages: [...requiredCoverages, newRequired.trim()],
        incompatibleCoverages,
      });
      setNewRequired('');
    }
  }, [onChange, newRequired, requiresUnderwriterApproval, eligibilityCriteria, requiredCoverages, incompatibleCoverages]);

  const handleRemoveRequired = useCallback((index: number) => {
    onChange({
      requiresUnderwriterApproval,
      eligibilityCriteria,
      requiredCoverages: requiredCoverages.filter((_, i) => i !== index),
      incompatibleCoverages,
    });
  }, [onChange, requiresUnderwriterApproval, eligibilityCriteria, requiredCoverages, incompatibleCoverages]);

  const handleAddIncompatible = useCallback(() => {
    if (newIncompatible.trim()) {
      onChange({
        requiresUnderwriterApproval,
        eligibilityCriteria,
        requiredCoverages,
        incompatibleCoverages: [...incompatibleCoverages, newIncompatible.trim()],
      });
      setNewIncompatible('');
    }
  }, [onChange, newIncompatible, requiresUnderwriterApproval, eligibilityCriteria, requiredCoverages, incompatibleCoverages]);

  const handleRemoveIncompatible = useCallback((index: number) => {
    onChange({
      requiresUnderwriterApproval,
      eligibilityCriteria,
      requiredCoverages,
      incompatibleCoverages: incompatibleCoverages.filter((_, i) => i !== index),
    });
  }, [onChange, requiresUnderwriterApproval, eligibilityCriteria, requiredCoverages, incompatibleCoverages]);

  return (
    <Container>
      <SectionTitle>Underwriting Requirements</SectionTitle>
      <HelpText>
        Define underwriting approval requirements, eligibility criteria, and coverage dependencies
      </HelpText>

      {/* Underwriter Approval */}
      <SubSection>
        <CheckboxRow>
          <Checkbox
            type="checkbox"
            checked={requiresUnderwriterApproval}
            onChange={(e) => handleToggleApproval(e.target.checked)}
          />
          <CheckboxLabel>Requires underwriter approval</CheckboxLabel>
        </CheckboxRow>
        {requiresUnderwriterApproval && (
          <InfoBox>
            <InfoText>
              This coverage requires manual underwriter review and approval before binding.
            </InfoText>
          </InfoBox>
        )}
      </SubSection>

      {/* Eligibility Criteria */}
      <SubSection>
        <SubTitle>Eligibility Criteria</SubTitle>
        <SubHelpText>
          Conditions that must be met for an insured to qualify for this coverage
        </SubHelpText>

        <ItemList>
          {eligibilityCriteria.map((criterion, index) => (
            <ItemRow key={index}>
              <ItemIcon>
                <CheckCircleIcon style={{ width: 20, height: 20, color: '#10b981' }} />
              </ItemIcon>
              <ItemText>{criterion}</ItemText>
              <RemoveButton onClick={() => handleRemoveCriterion(index)}>
                <TrashIcon style={{ width: 16, height: 16 }} />
              </RemoveButton>
            </ItemRow>
          ))}
        </ItemList>

        <AddRow>
          <AddInput
            type="text"
            placeholder="e.g., Building must have sprinkler system"
            value={newCriterion}
            onChange={(e) => setNewCriterion(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleAddCriterion()}
          />
          <AddButton onClick={handleAddCriterion}>
            <PlusIcon style={{ width: 20, height: 20 }} />
            Add
          </AddButton>
        </AddRow>
      </SubSection>

      {/* Required Coverages */}
      <SubSection>
        <SubTitle>Required Coverages</SubTitle>
        <SubHelpText>
          Other coverages that must be purchased along with this coverage
        </SubHelpText>

        <ItemList>
          {requiredCoverages.map((coverage, index) => (
            <ItemRow key={index}>
              <ItemIcon>
                <CheckCircleIcon style={{ width: 20, height: 20, color: '#3b82f6' }} />
              </ItemIcon>
              <ItemText>{coverage}</ItemText>
              <RemoveButton onClick={() => handleRemoveRequired(index)}>
                <TrashIcon style={{ width: 16, height: 16 }} />
              </RemoveButton>
            </ItemRow>
          ))}
        </ItemList>

        <AddRow>
          <AddInput
            type="text"
            placeholder="e.g., General Liability"
            value={newRequired}
            onChange={(e) => setNewRequired(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleAddRequired()}
          />
          <AddButton onClick={handleAddRequired}>
            <PlusIcon style={{ width: 20, height: 20 }} />
            Add
          </AddButton>
        </AddRow>
      </SubSection>

      {/* Incompatible Coverages */}
      <SubSection>
        <SubTitle>Incompatible Coverages</SubTitle>
        <SubHelpText>
          Coverages that cannot be purchased together with this coverage
        </SubHelpText>

        <ItemList>
          {incompatibleCoverages.map((coverage, index) => (
            <ItemRow key={index}>
              <ItemIcon>
                <XCircleIcon style={{ width: 20, height: 20, color: '#ef4444' }} />
              </ItemIcon>
              <ItemText>{coverage}</ItemText>
              <RemoveButton onClick={() => handleRemoveIncompatible(index)}>
                <TrashIcon style={{ width: 16, height: 16 }} />
              </RemoveButton>
            </ItemRow>
          ))}
        </ItemList>

        <AddRow>
          <AddInput
            type="text"
            placeholder="e.g., Named Perils Coverage"
            value={newIncompatible}
            onChange={(e) => setNewIncompatible(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleAddIncompatible()}
          />
          <AddButton onClick={handleAddIncompatible}>
            <PlusIcon style={{ width: 20, height: 20 }} />
            Add
          </AddButton>
        </AddRow>
      </SubSection>
    </Container>
  );
});

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 20px;
`;

const SectionTitle = styled.h3`
  font-size: 18px;
  font-weight: 600;
  color: #111827;
  margin: 0;
`;

const HelpText = styled.p`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
  margin: -12px 0 0 0;
`;

const SubSection = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
`;

const SubTitle = styled.h4`
  font-size: 15px;
  font-weight: 600;
  color: #374151;
  margin: 0;
`;

const SubHelpText = styled.span`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
`;

const CheckboxRow = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const Checkbox = styled.input`
  width: 18px;
  height: 18px;
  cursor: pointer;
`;

const CheckboxLabel = styled.label`
  font-size: 14px;
  color: #374151;
  font-weight: 500;
  cursor: pointer;
`;

const InfoBox = styled.div`
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  border-radius: 6px;
  padding: 10px;
`;

const InfoText = styled.div`
  font-size: 13px;
  color: #1e3a8a;
`;

const ItemList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const ItemRow = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
`;

const ItemIcon = styled.div`
  flex-shrink: 0;
`;

const ItemText = styled.div`
  flex: 1;
  font-size: 14px;
  color: #374151;
`;

const RemoveButton = styled.button`
  padding: 4px 8px;
  background: #fee2e2;
  color: #dc2626;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;

  &:hover {
    background: #fecaca;
  }
`;

const AddRow = styled.div`
  display: flex;
  gap: 8px;
`;

const AddInput = styled.input`
  flex: 1;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const AddButton = styled.button`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 10px 16px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;

  &:hover {
    background: #2563eb;
  }
`;

```

---

## src/components/sections/index.ts

**Path:** `src/components/sections/index.ts`

```typescript
/**
 * Sections Index
 * Centralized exports for coverage detail section components
 */

export { default as ClaimsSection } from './ClaimsSection';
export { default as EndorsementMetadataSection } from './EndorsementMetadataSection';
export { default as UnderwritingSection } from './UnderwritingSection';

```

---

## src/components/selectors/CoverageTriggerSelector.tsx

**Path:** `src/components/selectors/CoverageTriggerSelector.tsx`

```tsx
/**
 * CoverageTriggerSelector Component
 * Premium selector for P&C coverage trigger types
 */

import React from 'react';
import styled, { keyframes, css } from 'styled-components';
import { CoverageTrigger } from '../../types';
import { CheckIcon } from '@heroicons/react/24/solid';
import { ClockIcon, DocumentCheckIcon } from '@heroicons/react/24/outline';

interface CoverageTriggerSelectorProps {
  value?: CoverageTrigger;
  onChange: (trigger: CoverageTrigger) => void;
}

// Common P&C trigger types only
const TRIGGER_OPTIONS: {
  value: CoverageTrigger;
  label: string;
  shortDesc: string;
  icon: 'occurrence' | 'claimsMade';
  color: string;
}[] = [
  {
    value: 'occurrence',
    label: 'Occurrence',
    shortDesc: 'Coverage applies when the incident happens during the policy period',
    icon: 'occurrence',
    color: '#3b82f6'
  },
  {
    value: 'claimsMade',
    label: 'Claims-Made',
    shortDesc: 'Coverage applies when the claim is reported during the policy period',
    icon: 'claimsMade',
    color: '#8b5cf6'
  },
];

export const CoverageTriggerSelector: React.FC<CoverageTriggerSelectorProps> = ({
  value,
  onChange,
}) => {
  return (
    <Container>
      <CardsRow>
        {TRIGGER_OPTIONS.map((option, index) => {
          const isSelected = value === option.value;
          return (
            <TriggerCard
              key={option.value}
              $selected={isSelected}
              $color={option.color}
              $index={index}
              onClick={() => onChange(option.value)}
              role="radio"
              aria-checked={isSelected}
              tabIndex={0}
              onKeyDown={(e) => e.key === 'Enter' && onChange(option.value)}
            >
              {/* Selection indicator */}
              <SelectionRing $selected={isSelected} $color={option.color} />

              {/* Icon */}
              <IconContainer $selected={isSelected} $color={option.color}>
                {option.icon === 'occurrence' && <ClockIcon />}
                {option.icon === 'claimsMade' && <DocumentCheckIcon />}
              </IconContainer>

              {/* Label */}
              <TriggerLabel $selected={isSelected}>{option.label}</TriggerLabel>

              {/* Description */}
              <TriggerDescription $selected={isSelected}>
                {option.shortDesc}
              </TriggerDescription>

              {/* Selected checkmark */}
              {isSelected && (
                <CheckBadge $color={option.color}>
                  <CheckIcon />
                </CheckBadge>
              )}
            </TriggerCard>
          );
        })}
      </CardsRow>
    </Container>
  );
};

// Animations
const scaleIn = keyframes`
  0% { transform: scale(0.95); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
`;

const checkPop = keyframes`
  0% { transform: scale(0); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
`;

const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

// Styled Components
const Container = styled.div`
  width: 100%;
`;

const CardsRow = styled.div`
  display: flex;
  gap: 20px;

  @media (max-width: 900px) {
    flex-direction: column;
  }
`;

const TriggerCard = styled.div<{ $selected: boolean; $color: string; $index: number }>`
  position: relative;
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  padding: 28px 24px 24px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  animation: ${scaleIn} 0.4s ease-out backwards;
  animation-delay: ${({ $index }) => $index * 0.08}s;

  background: ${({ $selected, $color, theme }) =>
    $selected
      ? `linear-gradient(145deg, ${$color}08 0%, ${$color}15 100%)`
      : theme.colours.surface};

  border: 2px solid ${({ $selected, $color, theme }) =>
    $selected ? $color : theme.colours.border};

  box-shadow: ${({ $selected, $color }) =>
    $selected
      ? `0 8px 32px ${$color}25, 0 4px 12px ${$color}15, inset 0 1px 0 rgba(255,255,255,0.1)`
      : '0 2px 8px rgba(0, 0, 0, 0.04)'};

  &:hover {
    transform: translateY(-6px) scale(1.02);
    border-color: ${({ $color }) => $color};
    box-shadow: ${({ $selected, $color }) =>
      $selected
        ? `0 16px 48px ${$color}30, 0 8px 24px ${$color}20`
        : `0 12px 32px rgba(0, 0, 0, 0.1), 0 0 0 1px ${$color}30`};
  }

  &:active {
    transform: translateY(-3px) scale(1.01);
  }

  &:focus {
    outline: none;
    box-shadow: 0 0 0 3px ${({ $color }) => $color}40;
  }
`;

const SelectionRing = styled.div<{ $selected: boolean; $color: string }>`
  position: absolute;
  inset: -3px;
  border-radius: 22px;
  pointer-events: none;
  opacity: ${({ $selected }) => $selected ? 1 : 0};
  transition: opacity 0.3s ease;

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    padding: 2px;
    background: linear-gradient(135deg, ${({ $color }) => $color}, ${({ $color }) => $color}80);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
  }
`;

const IconContainer = styled.div<{ $selected: boolean; $color: string }>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 64px;
  height: 64px;
  border-radius: 16px;
  margin-bottom: 16px;
  transition: all 0.3s ease;

  background: ${({ $selected, $color }) =>
    $selected
      ? `linear-gradient(135deg, ${$color} 0%, ${$color}cc 100%)`
      : `linear-gradient(135deg, ${$color}15 0%, ${$color}08 100%)`};

  box-shadow: ${({ $selected, $color }) =>
    $selected
      ? `0 8px 24px ${$color}40, inset 0 1px 0 rgba(255,255,255,0.2)`
      : 'none'};

  svg {
    width: 28px;
    height: 28px;
    color: ${({ $selected, $color }) => $selected ? 'white' : $color};
    transition: all 0.3s ease;
  }
`;

const TriggerLabel = styled.div<{ $selected: boolean }>`
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 8px;
  color: ${({ theme }) => theme.colours.text};
  transition: color 0.3s ease;
`;

const TriggerDescription = styled.div<{ $selected: boolean }>`
  font-size: 13px;
  line-height: 1.5;
  color: ${({ theme }) => theme.colours.textMuted};
  margin-bottom: 16px;
  min-height: 40px;
  display: flex;
  align-items: center;
`;

const CheckBadge = styled.div<{ $color: string }>`
  position: absolute;
  top: 12px;
  right: 12px;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: ${({ $color }) => $color};
  animation: ${checkPop} 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow: 0 4px 12px ${({ $color }) => $color}50;

  svg {
    width: 16px;
    height: 16px;
    color: white;
  }
`;
```

---

## src/components/selectors/DeductibleTypeSelector.tsx

**Path:** `src/components/selectors/DeductibleTypeSelector.tsx`

```tsx
/**
 * DeductibleTypeSelector Component
 * Selector for coverage deductible types with conditional fields
 */

import React, { useEffect } from 'react';
import styled from 'styled-components';
import { CoverageDeductible, DeductibleType } from '../../types';

interface DeductibleTypeSelectorProps {
  value: Partial<CoverageDeductible>;
  onChange: (deductible: Partial<CoverageDeductible>) => void;
}

const DEDUCTIBLE_TYPES: { value: DeductibleType; label: string; description: string }[] = [
  { 
    value: 'flat', 
    label: 'Flat Dollar Amount', 
    description: 'Fixed dollar amount deducted from each claim' 
  },
  { 
    value: 'percentage', 
    label: 'Percentage', 
    description: 'Percentage of the loss or insured value' 
  },
  { 
    value: 'franchise', 
    label: 'Franchise', 
    description: 'No deductible if loss exceeds the franchise amount' 
  },
  { 
    value: 'disappearing', 
    label: 'Disappearing', 
    description: 'Deductible decreases as loss amount increases' 
  },
  { 
    value: 'perOccurrence', 
    label: 'Per Occurrence', 
    description: 'Applied to each separate occurrence' 
  },
  { 
    value: 'aggregate', 
    label: 'Aggregate', 
    description: 'Maximum deductible for all occurrences in policy period' 
  },
  { 
    value: 'waiting', 
    label: 'Waiting Period', 
    description: 'Time period before coverage begins (for time-based deductibles)' 
  },
];

export const DeductibleTypeSelector: React.FC<DeductibleTypeSelectorProps> = ({ value, onChange }) => {
  // Auto-generate display value when amount/percentage or type changes
  useEffect(() => {
    if (value.deductibleType) {
      let displayValue = '';

      if (value.deductibleType === 'percentage' && value.percentage) {
        displayValue = `${value.percentage}%`;
      } else if (value.amount) {
        const formattedAmount = new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
        }).format(value.amount);
        displayValue = formattedAmount;
      }

      const typeLabel = DEDUCTIBLE_TYPES.find(t => t.value === value.deductibleType)?.label || '';
      if (displayValue) {
        displayValue = `${displayValue} ${typeLabel}`;
      }

      if (displayValue) {
        onChange({ ...value, displayValue });
      }
    }
  }, [value.amount, value.percentage, value.deductibleType]);

  const handleTypeChange = (newType: DeductibleType) => {
    // Clear amount/percentage when switching types
    const updates: Partial<CoverageDeductible> = {
      ...value,
      deductibleType: newType,
    };

    if (newType === 'percentage') {
      updates.amount = undefined;
    } else {
      updates.percentage = undefined;
    }

    onChange(updates);
  };

  const handleAmountChange = (newAmount: string) => {
    const numericValue = parseFloat(newAmount.replace(/[^0-9.]/g, ''));
    if (!isNaN(numericValue)) {
      onChange({ ...value, amount: numericValue });
    } else if (newAmount === '') {
      onChange({ ...value, amount: undefined });
    }
  };

  const handlePercentageChange = (newPercentage: string) => {
    const numericValue = parseFloat(newPercentage);
    if (!isNaN(numericValue) && numericValue >= 0 && numericValue <= 100) {
      onChange({ ...value, percentage: numericValue });
    } else if (newPercentage === '') {
      onChange({ ...value, percentage: undefined });
    }
  };

  const selectedType = DEDUCTIBLE_TYPES.find(t => t.value === value.deductibleType);
  const isPercentageType = value.deductibleType === 'percentage';

  return (
    <Container>
      <FormGroup>
        <Label>Deductible Type *</Label>
        <Select
          value={value.deductibleType || 'flat'}
          onChange={(e) => handleTypeChange(e.target.value as DeductibleType)}
        >
          {DEDUCTIBLE_TYPES.map((type) => (
            <option key={type.value} value={type.value}>
              {type.label}
            </option>
          ))}
        </Select>
        {selectedType && (
          <HelpText>{selectedType.description}</HelpText>
        )}
      </FormGroup>

      {isPercentageType ? (
        <FormGroup>
          <Label>Percentage *</Label>
          <PercentageInputWrapper>
            <PercentageInput
              type="number"
              min="0"
              max="100"
              step="0.1"
              value={value.percentage || ''}
              onChange={(e) => handlePercentageChange(e.target.value)}
              placeholder="e.g., 10"
            />
            <PercentageSymbol>%</PercentageSymbol>
          </PercentageInputWrapper>
          <HelpText>Enter percentage (0-100)</HelpText>
        </FormGroup>
      ) : (
        <FormGroup>
          <Label>Deductible Amount *</Label>
          <AmountInput
            type="text"
            value={value.amount ? value.amount.toLocaleString() : ''}
            onChange={(e) => handleAmountChange(e.target.value)}
            placeholder="e.g., 1000"
          />
          <HelpText>Enter the dollar amount without $ or commas</HelpText>
        </FormGroup>
      )}

      <FormGroup>
        <Label>Display Value (Auto-generated)</Label>
        <DisplayValue>{value.displayValue || 'Will be generated automatically'}</DisplayValue>
      </FormGroup>

      <FormGrid>
        <FormGroup>
          <Label>Minimum Retained</Label>
          <Input
            type="number"
            value={value.minimumRetained || ''}
            onChange={(e) => onChange({ ...value, minimumRetained: parseFloat(e.target.value) || undefined })}
            placeholder="Optional"
          />
          <HelpText>Minimum amount insured must retain</HelpText>
        </FormGroup>

        <FormGroup>
          <Label>Maximum Retained</Label>
          <Input
            type="number"
            value={value.maximumRetained || ''}
            onChange={(e) => onChange({ ...value, maximumRetained: parseFloat(e.target.value) || undefined })}
            placeholder="Optional"
          />
          <HelpText>Maximum amount insured must retain</HelpText>
        </FormGroup>
      </FormGrid>

      <FormGroup>
        <Label>Applies To (Optional)</Label>
        <TextArea
          value={value.appliesTo?.join(', ') || ''}
          onChange={(e) => {
            const items = e.target.value.split(',').map(s => s.trim()).filter(s => s);
            onChange({ ...value, appliesTo: items.length > 0 ? items : undefined });
          }}
          placeholder="e.g., Wind, Hail, Earthquake (comma-separated)"
          rows={2}
        />
        <HelpText>Specify what types of losses this deductible applies to</HelpText>
      </FormGroup>

      <CheckboxGroup>
        <Checkbox
          type="checkbox"
          checked={value.isDefault || false}
          onChange={(e) => onChange({ ...value, isDefault: e.target.checked })}
        />
        <Label>Set as default deductible</Label>
      </CheckboxGroup>

      <CheckboxGroup>
        <Checkbox
          type="checkbox"
          checked={value.isRequired || false}
          onChange={(e) => onChange({ ...value, isRequired: e.target.checked })}
        />
        <Label>Required deductible (must be selected)</Label>
      </CheckboxGroup>

      {value.deductibleType === 'franchise' && (
        <InfoBox>
          <InfoTitle>Franchise Deductible Information</InfoTitle>
          <InfoText>
            A franchise deductible means the insured pays the full deductible amount if the loss is 
            below the franchise, but pays nothing if the loss exceeds the franchise. For example, 
            with a $1,000 franchise: a $900 loss pays $0, but a $1,100 loss pays the full $1,100.
          </InfoText>
        </InfoBox>
      )}

      {value.deductibleType === 'disappearing' && (
        <InfoBox>
          <InfoTitle>Disappearing Deductible Information</InfoTitle>
          <InfoText>
            A disappearing deductible decreases as the loss amount increases, eventually reaching 
            zero at a specified loss amount. This rewards insureds for larger losses while maintaining 
            a deductible for smaller claims.
          </InfoText>
        </InfoBox>
      )}

      {value.deductibleType === 'waiting' && (
        <InfoBox>
          <InfoTitle>Waiting Period Information</InfoTitle>
          <InfoText>
            A waiting period is a time-based deductible, commonly used in business interruption or 
            disability coverage. Coverage begins after the waiting period expires. For example, a 
            72-hour waiting period means no coverage for the first 72 hours of loss.
          </InfoText>
        </InfoBox>
      )}
    </Container>
  );
};

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 6px;
`;

const FormGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
`;

const Label = styled.label`
  font-size: 14px;
  font-weight: 500;
  color: #374151;
`;

const Select = styled.select`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  background: white;
  
  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const Input = styled.input`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  
  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const AmountInput = styled(Input)`
  font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 16px;
  font-weight: 500;
`;

const PercentageInputWrapper = styled.div`
  position: relative;
  display: flex;
  align-items: center;
`;

const PercentageInput = styled(Input)`
  font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 16px;
  font-weight: 500;
  padding-right: 40px;
`;

const PercentageSymbol = styled.span`
  position: absolute;
  right: 12px;
  font-size: 16px;
  font-weight: 600;
  color: #6b7280;
`;

const TextArea = styled.textarea`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  resize: vertical;
  
  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const DisplayValue = styled.div`
  padding: 10px 12px;
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 600;
  color: #111827;
`;

const HelpText = styled.span`
  font-size: 12px;
  color: #6b7280;
  font-style: italic;
`;

const CheckboxGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const Checkbox = styled.input`
  width: 16px;
  height: 16px;
  cursor: pointer;
`;

const InfoBox = styled.div`
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  border-radius: 6px;
  padding: 12px;
`;

const InfoTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #1e40af;
  margin-bottom: 4px;
`;

const InfoText = styled.div`
  font-size: 13px;
  color: #1e3a8a;
  line-height: 1.5;
`;

```

---

## src/components/selectors/DepreciationMethodSelector.tsx

**Path:** `src/components/selectors/DepreciationMethodSelector.tsx`

```tsx
/**
 * DepreciationMethodSelector Component
 * Selector for depreciation calculation methods
 */

import React from 'react';
import styled from 'styled-components';
import { DepreciationMethod } from '../../types';

interface DepreciationMethodSelectorProps {
  value?: DepreciationMethod;
  onChange: (method: DepreciationMethod) => void;
}

const DEPRECIATION_OPTIONS: { value: DepreciationMethod; label: string; description: string }[] = [
  {
    value: 'straightLine',
    label: 'Straight-Line',
    description: 'Equal depreciation each year over the useful life. Most common and simple method.'
  },
  {
    value: 'decliningBalance',
    label: 'Declining Balance',
    description: 'Higher depreciation in early years, decreasing over time. Common for vehicles and equipment.'
  },
  {
    value: 'unitsOfProduction',
    label: 'Units of Production',
    description: 'Depreciation based on actual usage (miles, hours, units produced). Common for machinery and vehicles.'
  },
  {
    value: 'sumOfYearsDigits',
    label: 'Sum of Years Digits',
    description: 'Accelerated depreciation method. Higher depreciation in early years using a fraction based on remaining life.'
  },
];

export const DepreciationMethodSelector: React.FC<DepreciationMethodSelectorProps> = ({
  value,
  onChange,
}) => {
  return (
    <Container>
      <Label>Depreciation Method</Label>
      <HelpText>
        Method used to calculate depreciation for Actual Cash Value (ACV) settlements
      </HelpText>

      <Select
        value={value || ''}
        onChange={(e) => onChange(e.target.value as DepreciationMethod)}
      >
        <option value="">Select depreciation method...</option>
        {DEPRECIATION_OPTIONS.map((option) => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </Select>

      {value && (
        <SelectedInfo>
          <InfoTitle>
            {DEPRECIATION_OPTIONS.find(o => o.value === value)?.label}
          </InfoTitle>
          <InfoDescription>
            {DEPRECIATION_OPTIONS.find(o => o.value === value)?.description}
          </InfoDescription>
        </SelectedInfo>
      )}

      {value === 'straightLine' && (
        <InfoBox>
          <InfoTitle>Straight-Line Depreciation Formula</InfoTitle>
          <InfoText>
            <strong>Annual Depreciation = (Cost - Salvage Value) Ã· Useful Life</strong>
            <br /><br />
            <strong>Example:</strong>
            <ul>
              <li>Original Cost: $10,000</li>
              <li>Salvage Value: $1,000</li>
              <li>Useful Life: 10 years</li>
              <li>Annual Depreciation: ($10,000 - $1,000) Ã· 10 = $900/year</li>
            </ul>
            <br />
            After 5 years: ACV = $10,000 - ($900 Ã— 5) = $5,500
          </InfoText>
        </InfoBox>
      )}

      {value === 'decliningBalance' && (
        <InfoBox>
          <InfoTitle>Declining Balance Depreciation Formula</InfoTitle>
          <InfoText>
            <strong>Annual Depreciation = Book Value Ã— Depreciation Rate</strong>
            <br /><br />
            Common rates: 150% (1.5Ã— straight-line) or 200% (double-declining)
            <br /><br />
            <strong>Example (Double-Declining, 10-year life):</strong>
            <ul>
              <li>Rate: 20% (2 Ã· 10 years)</li>
              <li>Year 1: $10,000 Ã— 20% = $2,000</li>
              <li>Year 2: $8,000 Ã— 20% = $1,600</li>
              <li>Year 3: $6,400 Ã— 20% = $1,280</li>
            </ul>
          </InfoText>
        </InfoBox>
      )}

      {value === 'unitsOfProduction' && (
        <InfoBox>
          <InfoTitle>Units of Production Depreciation Formula</InfoTitle>
          <InfoText>
            <strong>Depreciation per Unit = (Cost - Salvage Value) Ã· Total Expected Units</strong>
            <br /><br />
            <strong>Example (Vehicle with 100,000 mile life):</strong>
            <ul>
              <li>Cost: $30,000</li>
              <li>Salvage: $5,000</li>
              <li>Expected Miles: 100,000</li>
              <li>Per Mile: ($30,000 - $5,000) Ã· 100,000 = $0.25/mile</li>
            </ul>
            <br />
            After 40,000 miles: ACV = $30,000 - (40,000 Ã— $0.25) = $20,000
          </InfoText>
        </InfoBox>
      )}

      {value === 'sumOfYearsDigits' && (
        <InfoBox>
          <InfoTitle>Sum of Years Digits Depreciation Formula</InfoTitle>
          <InfoText>
            <strong>Depreciation = (Remaining Life Ã· Sum of Years) Ã— Depreciable Base</strong>
            <br /><br />
            <strong>Example (5-year life):</strong>
            <ul>
              <li>Sum of Years: 1+2+3+4+5 = 15</li>
              <li>Depreciable Base: $10,000 - $1,000 = $9,000</li>
              <li>Year 1: (5Ã·15) Ã— $9,000 = $3,000</li>
              <li>Year 2: (4Ã·15) Ã— $9,000 = $2,400</li>
              <li>Year 3: (3Ã·15) Ã— $9,000 = $1,800</li>
            </ul>
          </InfoText>
        </InfoBox>
      )}
    </Container>
  );
};

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const Label = styled.label`
  font-size: 14px;
  font-weight: 600;
  color: #374151;
`;

const HelpText = styled.span`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
`;

const Select = styled.select`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;
  background: white;
  cursor: pointer;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  option {
    padding: 8px;
  }
`;

const SelectedInfo = styled.div`
  background: #f3f4f6;
  border-radius: 6px;
  padding: 12px;
`;

const InfoTitle = styled.div`
  font-size: 14px;
  font-weight: 600;
  color: #111827;
  margin-bottom: 4px;
`;

const InfoDescription = styled.div`
  font-size: 13px;
  color: #6b7280;
  line-height: 1.5;
`;

const InfoBox = styled.div`
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  border-radius: 6px;
  padding: 12px;
  margin-top: 8px;
`;

const InfoText = styled.div`
  font-size: 13px;
  color: #1e3a8a;
  line-height: 1.6;

  strong {
    color: #1e40af;
    font-weight: 600;
  }

  ul {
    margin: 8px 0 0 0;
    padding-left: 20px;
  }

  li {
    margin: 4px 0;
  }
`;

```

---

## src/components/selectors/LimitTypeSelector.tsx

**Path:** `src/components/selectors/LimitTypeSelector.tsx`

```tsx
/**
 * LimitTypeSelector Component
 * Selector for coverage limit types with conditional fields
 */

import React, { useEffect } from 'react';
import styled from 'styled-components';
import { CoverageLimit, LimitType } from '../../types';

interface LimitTypeSelectorProps {
  value: Partial<CoverageLimit>;
  onChange: (limit: Partial<CoverageLimit>) => void;
}

const LIMIT_TYPES: { value: LimitType; label: string; description: string }[] = [
  { 
    value: 'perOccurrence', 
    label: 'Per Occurrence', 
    description: 'Maximum paid for each separate occurrence or event' 
  },
  { 
    value: 'aggregate', 
    label: 'Aggregate', 
    description: 'Maximum paid for all occurrences during the policy period' 
  },
  { 
    value: 'perPerson', 
    label: 'Per Person', 
    description: 'Maximum paid for each person injured in an occurrence' 
  },
  { 
    value: 'perLocation', 
    label: 'Per Location', 
    description: 'Maximum paid for each insured location' 
  },
  { 
    value: 'sublimit', 
    label: 'Sublimit', 
    description: 'Limit within a larger limit for specific types of losses' 
  },
  { 
    value: 'combined', 
    label: 'Combined Single Limit', 
    description: 'Single limit for all coverages combined' 
  },
  { 
    value: 'split', 
    label: 'Split Limit', 
    description: 'Separate limits for different types of losses' 
  },
];

export const LimitTypeSelector: React.FC<LimitTypeSelectorProps> = ({ value, onChange }) => {
  // Auto-generate display value when amount or type changes
  useEffect(() => {
    if (value.amount && value.limitType) {
      const formattedAmount = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0,
      }).format(value.amount);

      const typeLabel = LIMIT_TYPES.find(t => t.value === value.limitType)?.label || '';
      const displayValue = `${formattedAmount} ${typeLabel}`;

      onChange({ ...value, displayValue });
    }
  }, [value.amount, value.limitType]);

  const handleTypeChange = (newType: LimitType) => {
    onChange({ ...value, limitType: newType });
  };

  const handleAmountChange = (newAmount: string) => {
    const numericValue = parseFloat(newAmount.replace(/[^0-9.]/g, ''));
    if (!isNaN(numericValue)) {
      onChange({ ...value, amount: numericValue });
    } else if (newAmount === '') {
      onChange({ ...value, amount: undefined });
    }
  };

  const selectedType = LIMIT_TYPES.find(t => t.value === value.limitType);

  return (
    <Container>
      <FormGroup>
        <Label>Limit Type *</Label>
        <Select
          value={value.limitType || 'perOccurrence'}
          onChange={(e) => handleTypeChange(e.target.value as LimitType)}
        >
          {LIMIT_TYPES.map((type) => (
            <option key={type.value} value={type.value}>
              {type.label}
            </option>
          ))}
        </Select>
        {selectedType && (
          <HelpText>{selectedType.description}</HelpText>
        )}
      </FormGroup>

      <FormGroup>
        <Label>Limit Amount *</Label>
        <AmountInput
          type="text"
          value={value.amount ? value.amount.toLocaleString() : ''}
          onChange={(e) => handleAmountChange(e.target.value)}
          placeholder="e.g., 100000"
        />
        <HelpText>Enter the dollar amount without $ or commas</HelpText>
      </FormGroup>

      <FormGroup>
        <Label>Display Value (Auto-generated)</Label>
        <DisplayValue>{value.displayValue || 'Will be generated automatically'}</DisplayValue>
      </FormGroup>

      <FormGrid>
        <FormGroup>
          <Label>Minimum Amount</Label>
          <Input
            type="number"
            value={value.minAmount || ''}
            onChange={(e) => onChange({ ...value, minAmount: parseFloat(e.target.value) || undefined })}
            placeholder="Optional"
          />
        </FormGroup>

        <FormGroup>
          <Label>Maximum Amount</Label>
          <Input
            type="number"
            value={value.maxAmount || ''}
            onChange={(e) => onChange({ ...value, maxAmount: parseFloat(e.target.value) || undefined })}
            placeholder="Optional"
          />
        </FormGroup>
      </FormGrid>

      <FormGroup>
        <Label>Applies To (Optional)</Label>
        <TextArea
          value={value.appliesTo?.join(', ') || ''}
          onChange={(e) => {
            const items = e.target.value.split(',').map(s => s.trim()).filter(s => s);
            onChange({ ...value, appliesTo: items.length > 0 ? items : undefined });
          }}
          placeholder="e.g., Bodily Injury, Property Damage (comma-separated)"
          rows={2}
        />
        <HelpText>Specify what types of losses this limit applies to</HelpText>
      </FormGroup>

      <CheckboxGroup>
        <Checkbox
          type="checkbox"
          checked={value.isDefault || false}
          onChange={(e) => onChange({ ...value, isDefault: e.target.checked })}
        />
        <Label>Set as default limit</Label>
      </CheckboxGroup>

      <CheckboxGroup>
        <Checkbox
          type="checkbox"
          checked={value.isRequired || false}
          onChange={(e) => onChange({ ...value, isRequired: e.target.checked })}
        />
        <Label>Required limit (must be selected)</Label>
      </CheckboxGroup>

      {value.limitType === 'sublimit' && (
        <InfoBox>
          <InfoTitle>Sublimit Information</InfoTitle>
          <InfoText>
            Sublimits are limits within a larger limit. For example, a $50,000 sublimit for jewelry 
            within a $500,000 contents limit. The sublimit is the maximum that will be paid for that 
            specific type of loss, even if the overall limit is higher.
          </InfoText>
        </InfoBox>
      )}

      {value.limitType === 'split' && (
        <InfoBox>
          <InfoTitle>Split Limit Information</InfoTitle>
          <InfoText>
            Split limits provide separate limits for different types of losses. For example, in auto 
            liability: $100,000 per person / $300,000 per occurrence / $50,000 property damage. 
            You may want to create multiple limit entries to represent each component.
          </InfoText>
        </InfoBox>
      )}
    </Container>
  );
};

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 6px;
`;

const FormGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
`;

const Label = styled.label`
  font-size: 14px;
  font-weight: 500;
  color: #374151;
`;

const Select = styled.select`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  background: white;
  
  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const Input = styled.input`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  
  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const AmountInput = styled(Input)`
  font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 16px;
  font-weight: 500;
`;

const TextArea = styled.textarea`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  resize: vertical;
  
  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const DisplayValue = styled.div`
  padding: 10px 12px;
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 600;
  color: #111827;
`;

const HelpText = styled.span`
  font-size: 12px;
  color: #6b7280;
  font-style: italic;
`;

const CheckboxGroup = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const Checkbox = styled.input`
  width: 16px;
  height: 16px;
  cursor: pointer;
`;

const InfoBox = styled.div`
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  border-radius: 6px;
  padding: 12px;
`;

const InfoTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: #1e40af;
  margin-bottom: 4px;
`;

const InfoText = styled.div`
  font-size: 13px;
  color: #1e3a8a;
  line-height: 1.5;
`;

```

---

## src/components/selectors/TerritorySelector.tsx

**Path:** `src/components/selectors/TerritorySelector.tsx`

```tsx
/**
 * TerritorySelector Component
 * Selector for coverage territory with included/excluded territories
 */

import React, { useState } from 'react';
import styled from 'styled-components';
import { TerritoryType } from '../../types';
import { PlusIcon, TrashIcon } from '@heroicons/react/24/outline';

interface TerritorySelectorProps {
  territoryType?: TerritoryType;
  includedTerritories?: string[];
  excludedTerritories?: string[];
  onChange: (data: {
    territoryType?: TerritoryType;
    includedTerritories?: string[];
    excludedTerritories?: string[];
  }) => void;
}

const US_STATES = [
  'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
  'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
  'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
  'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
  'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'
];

export const TerritorySelector: React.FC<TerritorySelectorProps> = ({
  territoryType = 'USA',
  includedTerritories = [],
  excludedTerritories = [],
  onChange,
}) => {
  const [newIncluded, setNewIncluded] = useState('');
  const [newExcluded, setNewExcluded] = useState('');

  const handleTypeChange = (type: TerritoryType) => {
    onChange({
      territoryType: type,
      includedTerritories,
      excludedTerritories,
    });
  };

  const handleAddIncluded = () => {
    if (newIncluded.trim() && !includedTerritories.includes(newIncluded.trim())) {
      onChange({
        territoryType,
        includedTerritories: [...includedTerritories, newIncluded.trim()],
        excludedTerritories,
      });
      setNewIncluded('');
    }
  };

  const handleRemoveIncluded = (index: number) => {
    onChange({
      territoryType,
      includedTerritories: includedTerritories.filter((_, i) => i !== index),
      excludedTerritories,
    });
  };

  const handleAddExcluded = () => {
    if (newExcluded.trim() && !excludedTerritories.includes(newExcluded.trim())) {
      onChange({
        territoryType,
        includedTerritories,
        excludedTerritories: [...excludedTerritories, newExcluded.trim()],
      });
      setNewExcluded('');
    }
  };

  const handleRemoveExcluded = (index: number) => {
    onChange({
      territoryType,
      includedTerritories,
      excludedTerritories: excludedTerritories.filter((_, i) => i !== index),
    });
  };

  return (
    <Container>
      <Label>Coverage Territory</Label>
      <HelpText>
        Define the geographic scope of coverage
      </HelpText>

      <FormGroup>
        <Select value={territoryType} onChange={(e) => handleTypeChange(e.target.value as TerritoryType)}>
          <option value="worldwide">Worldwide</option>
          <option value="USA">United States</option>
          <option value="stateSpecific">State-Specific</option>
          <option value="custom">Custom Territory</option>
        </Select>
      </FormGroup>

      {territoryType === 'worldwide' && (
        <InfoBox>
          <InfoText>
            Coverage applies worldwide with no geographic restrictions.
          </InfoText>
        </InfoBox>
      )}

      {territoryType === 'USA' && (
        <InfoBox>
          <InfoText>
            Coverage applies to all 50 United States, District of Columbia, and U.S. territories.
          </InfoText>
        </InfoBox>
      )}

      {(territoryType === 'stateSpecific' || territoryType === 'custom') && (
        <>
          {/* Included Territories */}
          <SubSection>
            <SubTitle>Included Territories</SubTitle>
            <SubHelpText>
              Territories where coverage applies
            </SubHelpText>

            <TerritoryList>
              {includedTerritories.map((territory, index) => (
                <TerritoryItem key={index}>
                  <TerritoryName>{territory}</TerritoryName>
                  <RemoveButton onClick={() => handleRemoveIncluded(index)}>
                    <TrashIcon style={{ width: 16, height: 16 }} />
                  </RemoveButton>
                </TerritoryItem>
              ))}
            </TerritoryList>

            <AddRow>
              {territoryType === 'stateSpecific' ? (
                <StateSelect
                  value={newIncluded}
                  onChange={(e) => setNewIncluded(e.target.value)}
                >
                  <option value="">Select state...</option>
                  {US_STATES.filter(state => !includedTerritories.includes(state)).map(state => (
                    <option key={state} value={state}>{state}</option>
                  ))}
                </StateSelect>
              ) : (
                <AddInput
                  type="text"
                  placeholder="Enter territory (e.g., Canada, Mexico)"
                  value={newIncluded}
                  onChange={(e) => setNewIncluded(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleAddIncluded()}
                />
              )}
              <AddButton onClick={handleAddIncluded}>
                <PlusIcon style={{ width: 20, height: 20 }} />
                Add
              </AddButton>
            </AddRow>
          </SubSection>

          {/* Excluded Territories */}
          <SubSection>
            <SubTitle>Excluded Territories</SubTitle>
            <SubHelpText>
              Territories where coverage does not apply
            </SubHelpText>

            <TerritoryList>
              {excludedTerritories.map((territory, index) => (
                <TerritoryItem key={index} excluded>
                  <TerritoryName>{territory}</TerritoryName>
                  <RemoveButton onClick={() => handleRemoveExcluded(index)}>
                    <TrashIcon style={{ width: 16, height: 16 }} />
                  </RemoveButton>
                </TerritoryItem>
              ))}
            </TerritoryList>

            <AddRow>
              {territoryType === 'stateSpecific' ? (
                <StateSelect
                  value={newExcluded}
                  onChange={(e) => setNewExcluded(e.target.value)}
                >
                  <option value="">Select state...</option>
                  {US_STATES.filter(state => !excludedTerritories.includes(state)).map(state => (
                    <option key={state} value={state}>{state}</option>
                  ))}
                </StateSelect>
              ) : (
                <AddInput
                  type="text"
                  placeholder="Enter territory to exclude"
                  value={newExcluded}
                  onChange={(e) => setNewExcluded(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleAddExcluded()}
                />
              )}
              <AddButton onClick={handleAddExcluded}>
                <PlusIcon style={{ width: 20, height: 20 }} />
                Add
              </AddButton>
            </AddRow>
          </SubSection>
        </>
      )}
    </Container>
  );
};

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const Label = styled.label`
  font-size: 14px;
  font-weight: 600;
  color: #374151;
`;

const HelpText = styled.span`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
  margin-top: -8px;
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const Select = styled.select`
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;
  background: white;
  cursor: pointer;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const InfoBox = styled.div`
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  border-radius: 6px;
  padding: 12px;
`;

const InfoText = styled.div`
  font-size: 13px;
  color: #1e3a8a;
`;

const SubSection = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
`;

const SubTitle = styled.h4`
  font-size: 15px;
  font-weight: 600;
  color: #374151;
  margin: 0;
`;

const SubHelpText = styled.span`
  font-size: 13px;
  color: #6b7280;
  font-style: italic;
  margin-top: -8px;
`;

const TerritoryList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const TerritoryItem = styled.div<{ excluded?: boolean }>`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px;
  background: ${props => props.excluded ? '#fef2f2' : 'white'};
  border: 1px solid ${props => props.excluded ? '#fecaca' : '#e5e7eb'};
  border-radius: 6px;
`;

const TerritoryName = styled.div`
  font-size: 14px;
  color: #374151;
  font-weight: 500;
`;

const RemoveButton = styled.button`
  padding: 4px 8px;
  background: #fee2e2;
  color: #dc2626;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;

  &:hover {
    background: #fecaca;
  }
`;

const AddRow = styled.div`
  display: flex;
  gap: 8px;
`;

const AddInput = styled.input`
  flex: 1;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const StateSelect = styled.select`
  flex: 1;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  color: #111827;
  background: white;
  cursor: pointer;

  &:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const AddButton = styled.button`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 10px 16px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;

  &:hover {
    background: #2563eb;
  }
`;

```

---

## src/components/selectors/ValuationMethodSelector.tsx

**Path:** `src/components/selectors/ValuationMethodSelector.tsx`

```tsx
/**
 * ValuationMethodSelector Component
 * Multi-select checkboxes for available property valuation methods
 */

import React from 'react';
import styled from 'styled-components';
import { ValuationMethod } from '../../types';

interface ValuationMethodSelectorProps {
  values?: ValuationMethod[];
  onChange: (methods: ValuationMethod[]) => void;
}

const VALUATION_OPTIONS: { value: ValuationMethod; label: string; shortLabel: string; description: string }[] = [
  {
    value: 'RC',
    label: 'Replacement Cost (RC)',
    shortLabel: 'RC',
    description: 'Cost to replace with new property of like kind and quality, without depreciation.'
  },
  {
    value: 'ACV',
    label: 'Actual Cash Value (ACV)',
    shortLabel: 'ACV',
    description: 'Replacement cost minus depreciation.'
  },
  {
    value: 'agreedValue',
    label: 'Agreed Value',
    shortLabel: 'Agreed',
    description: 'Pre-agreed value. No depreciation or coinsurance penalty.'
  },
  {
    value: 'marketValue',
    label: 'Market Value',
    shortLabel: 'Market',
    description: 'Current market price for similar property.'
  },
  {
    value: 'functionalRC',
    label: 'Functional Replacement Cost',
    shortLabel: 'Functional RC',
    description: 'Replace with property serving same function, different materials.'
  },
  {
    value: 'statedAmount',
    label: 'Stated Amount',
    shortLabel: 'Stated',
    description: 'Maximum payable amount, actual loss valued separately.'
  },
];

export const ValuationMethodSelector: React.FC<ValuationMethodSelectorProps> = ({
  values = [],
  onChange,
}) => {
  const handleToggle = (method: ValuationMethod) => {
    if (values.includes(method)) {
      onChange(values.filter(v => v !== method));
    } else {
      onChange([...values, method]);
    }
  };

  return (
    <Container>
      <CheckboxGrid>
        {VALUATION_OPTIONS.map((option) => (
          <CheckboxItem
            key={option.value}
            $selected={values.includes(option.value)}
            onClick={() => handleToggle(option.value)}
          >
            <Checkbox
              type="checkbox"
              checked={values.includes(option.value)}
              onChange={() => handleToggle(option.value)}
            />
            <CheckboxContent>
              <CheckboxLabel>{option.label}</CheckboxLabel>
              <CheckboxDescription>{option.description}</CheckboxDescription>
            </CheckboxContent>
          </CheckboxItem>
        ))}
      </CheckboxGrid>
      {values.length > 0 && (
        <SelectedSummary>
          <SelectedCount>{values.length} method{values.length > 1 ? 's' : ''} selected</SelectedCount>
          <SelectedList>
            {values.map(v => VALUATION_OPTIONS.find(o => o.value === v)?.shortLabel).join(', ')}
          </SelectedList>
        </SelectedSummary>
      )}
    </Container>
  );
};

// Styled Components
const Container = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const CheckboxGrid = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const CheckboxItem = styled.div<{ $selected: boolean }>`
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px;
  background: ${({ $selected, theme }) => $selected ? 'rgba(99, 102, 241, 0.08)' : theme.colours?.surface || '#f9fafb'};
  border: 1px solid ${({ $selected }) => $selected ? '#6366f1' : '#e5e7eb'};
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.15s ease;

  &:hover {
    border-color: ${({ $selected }) => $selected ? '#6366f1' : '#d1d5db'};
    background: ${({ $selected }) => $selected ? 'rgba(99, 102, 241, 0.12)' : '#f3f4f6'};
  }
`;

const Checkbox = styled.input`
  width: 18px;
  height: 18px;
  margin-top: 2px;
  cursor: pointer;
  accent-color: #6366f1;
`;

const CheckboxContent = styled.div`
  flex: 1;
`;

const CheckboxLabel = styled.div`
  font-size: 14px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours?.text || '#111827'};
  margin-bottom: 2px;
`;

const CheckboxDescription = styled.div`
  font-size: 12px;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
  line-height: 1.4;
`;

const SelectedSummary = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: rgba(99, 102, 241, 0.08);
  border-radius: 6px;
`;

const SelectedCount = styled.span`
  font-size: 13px;
  font-weight: 600;
  color: #6366f1;
`;

const SelectedList = styled.span`
  font-size: 13px;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
`;
```

---

## src/components/selectors/index.ts

**Path:** `src/components/selectors/index.ts`

```typescript
/**
 * Selectors Index
 * Centralized exports for insurance-specific selector components
 */

export { default as CoverageTriggerSelector } from './CoverageTriggerSelector';
export { default as DeductibleTypeSelector } from './DeductibleTypeSelector';
export { default as DepreciationMethodSelector } from './DepreciationMethodSelector';
export { default as LimitTypeSelector } from './LimitTypeSelector';
export { default as TerritorySelector } from './TerritorySelector';
export { default as ValuationMethodSelector } from './ValuationMethodSelector';

```

---

## src/components/ui/Breadcrumb.tsx

**Path:** `src/components/ui/Breadcrumb.tsx`

```tsx
/**
 * Breadcrumb - Navigation breadcrumbs with proper accessibility
 *
 * Enhanced with theme tokens and automatic route detection hook.
 */

import React, { useMemo } from 'react';
import { Link, useLocation } from 'react-router-dom';
import styled from 'styled-components';
import { ChevronRightIcon, HomeIcon } from '@heroicons/react/24/outline';

export interface BreadcrumbItem {
  label: string;
  path?: string;
  icon?: React.ReactNode;
}

interface BreadcrumbProps {
  items: BreadcrumbItem[];
  showHome?: boolean;
  className?: string;
}

const BreadcrumbContainer = styled.nav`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 12px 0;
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textMuted};
  margin-bottom: 16px;
  flex-wrap: wrap;
`;

const BreadcrumbItemWrapper = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 6px;
`;

const BreadcrumbLink = styled(Link)`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  color: ${({ theme }) => theme.colours.primary};
  text-decoration: none;
  padding: 4px 8px;
  margin: -4px -8px;
  border-radius: ${({ theme }) => theme.radiusSm};
  transition: all 0.2s ease;

  &:hover {
    color: ${({ theme }) => theme.colours.primaryDark};
    background: ${({ theme }) => theme.colours.primaryLighter};
  }

  &:focus-visible {
    outline: 2px solid ${({ theme }) => theme.colours.primary};
    outline-offset: 2px;
  }

  svg {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
  }
`;

const BreadcrumbCurrent = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  color: ${({ theme }) => theme.colours.text};
  font-weight: 500;
  padding: 4px 0;

  svg {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
  }
`;

const Separator = styled(ChevronRightIcon)`
  width: 14px;
  height: 14px;
  color: ${({ theme }) => theme.colours.border};
  flex-shrink: 0;
`;

const HomeIconStyled = styled(HomeIcon)`
  width: 14px;
  height: 14px;
`;

export const Breadcrumb: React.FC<BreadcrumbProps> = ({
  items,
  showHome = true,
  className
}) => {
  const allItems = useMemo(() => {
    if (showHome && items.length > 0 && items[0].path !== '/') {
      return [{ label: 'Home', path: '/', icon: <HomeIconStyled /> }, ...items];
    }
    return items;
  }, [items, showHome]);

  return (
    <BreadcrumbContainer aria-label="Breadcrumb navigation" className={className}>
      <ol style={{ display: 'contents', listStyle: 'none', margin: 0, padding: 0 }}>
        {allItems.map((item, index) => (
          <li key={index} style={{ display: 'contents' }}>
            <BreadcrumbItemWrapper>
              {index > 0 && <Separator aria-hidden="true" />}
              {item.path && index < allItems.length - 1 ? (
                <BreadcrumbLink to={item.path}>
                  {item.icon}
                  {item.label}
                </BreadcrumbLink>
              ) : (
                <BreadcrumbCurrent aria-current="page">
                  {item.icon}
                  {item.label}
                </BreadcrumbCurrent>
              )}
            </BreadcrumbItemWrapper>
          </li>
        ))}
      </ol>
    </BreadcrumbContainer>
  );
};

// Route label mapping for automatic breadcrumbs
const routeLabels: Record<string, string> = {
  '': 'Home',
  'products': 'Products',
  'coverage': 'Coverage',
  'forms': 'Forms',
  'pricing': 'Pricing',
  'states': 'States',
  'rules': 'Rules',
  'builder': 'Builder',
  'ai-builder': 'AI Builder',
  'data-dictionary': 'Data Dictionary',
  'tasks': 'Tasks',
  'claims-analysis': 'Claims Analysis',
  'product-explorer': 'Product Explorer',
  'product-builder': 'Product Builder',
  'packages': 'Packages',
  'overview': 'Overview',
  'forms-mapper': 'Forms Mapper',
  'quote-sandbox': 'Quote Sandbox',
};

// Hook for automatic breadcrumb generation from current route
export const useBreadcrumbs = (customLabels?: Record<string, string>): BreadcrumbItem[] => {
  const location = useLocation();

  return useMemo(() => {
    const pathSegments = location.pathname.split('/').filter(Boolean);
    const breadcrumbs: BreadcrumbItem[] = [];
    let currentPath = '';

    pathSegments.forEach((segment, index) => {
      currentPath += `/${segment}`;

      // Check for custom label first, then route labels, then capitalize segment
      const labels = { ...routeLabels, ...customLabels };
      const label = labels[segment] || segment.charAt(0).toUpperCase() + segment.slice(1);

      // Skip ID-like segments (UUIDs, numbers) from label but include in path
      const isIdLike = /^[0-9a-f-]{20,}$/i.test(segment) || /^\d+$/.test(segment);

      if (!isIdLike) {
        breadcrumbs.push({
          label,
          path: index < pathSegments.length - 1 ? currentPath : undefined
        });
      }
    });

    return breadcrumbs;
  }, [location.pathname, customLabels]);
};

export default Breadcrumb;

```

---

## src/components/ui/Button.tsx

**Path:** `src/components/ui/Button.tsx`

```tsx
import styled, { css } from 'styled-components';
import { spin, pulse, shimmer } from '../../styles/animations';

// Re-export shimmer as shine for backward compatibility
const shine = shimmer;

/* ---------- Button Variants - Enhanced with micro-interactions ---------- */
const variants = {
  primary: css`
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    color: #fff;
    border: none;
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.2), 0 4px 16px rgba(99, 102, 241, 0.15);

    &:hover:not(:disabled) {
      background: linear-gradient(135deg, #5b5bf6 0%, #7c3aed 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25), 0 8px 24px rgba(99, 102, 241, 0.2);
    }

    &:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
      box-shadow: 0 1px 4px rgba(99, 102, 241, 0.2);
      transition: all 0.1s ease;
    }

    &:focus-visible {
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.35), 0 4px 12px rgba(99, 102, 241, 0.2);
    }
  `,
  secondary: css`
    background: rgba(255, 255, 255, 0.95);
    color: #6366f1;
    border: 1.5px solid rgba(99, 102, 241, 0.2);
    box-shadow: 0 1px 4px rgba(99, 102, 241, 0.08);

    &:hover:not(:disabled) {
      background: rgba(99, 102, 241, 0.06);
      border-color: rgba(99, 102, 241, 0.35);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.12);
    }

    &:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
      background: rgba(99, 102, 241, 0.1);
    }

    &:focus-visible {
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
      border-color: #6366f1;
    }
  `,
  success: css`
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: #fff;
    border: none;
    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.2);

    &:hover:not(:disabled) {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(16, 185, 129, 0.25);
    }

    &:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
    }

    &:focus-visible {
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.35);
    }
  `,
  danger: css`
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: #fff;
    border: none;
    box-shadow: 0 2px 8px rgba(220, 38, 38, 0.2);

    &:hover:not(:disabled) {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(220, 38, 38, 0.25);
    }

    &:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
    }

    &:focus-visible {
      box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.35);
    }
  `,
  warning: css`
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: #fff;
    border: none;
    box-shadow: 0 2px 8px rgba(245, 158, 11, 0.2);

    &:hover:not(:disabled) {
      background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(245, 158, 11, 0.25);
    }

    &:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
    }

    &:focus-visible {
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.35);
    }
  `,
  ghost: css`
    background: transparent;
    color: ${({ theme }) => theme.colours.primary};
    border: none;

    &:hover:not(:disabled) {
      background: rgba(99, 102, 241, 0.06);
      transform: translateY(-1px);
    }

    &:active:not(:disabled) {
      background: rgba(99, 102, 241, 0.1);
      transform: scale(0.98);
    }

    &:focus-visible {
      background: rgba(99, 102, 241, 0.06);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }
  `,
  outline: css`
    background: transparent;
    color: #6366f1;
    border: 1.5px solid rgba(99, 102, 241, 0.5);

    &:hover:not(:disabled) {
      background: rgba(99, 102, 241, 0.06);
      border-color: #6366f1;
      transform: translateY(-1px);
    }

    &:active:not(:disabled) {
      background: rgba(99, 102, 241, 0.1);
      transform: scale(0.98);
    }

    &:focus-visible {
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }
  `
};

/* ---------- Button Sizes ---------- */
const sizes = {
  xs: css`
    padding: 4px 8px;
    font-size: 12px;
    gap: 4px;
    border-radius: 6px;
    min-height: 28px;
  `,
  sm: css`
    padding: 6px 12px;
    font-size: 13px;
    gap: 6px;
    border-radius: 8px;
    min-height: 32px;
  `,
  md: css`
    padding: 10px 16px;
    font-size: 14px;
    gap: 8px;
    border-radius: 10px;
    min-height: 40px;
  `,
  lg: css`
    padding: 12px 24px;
    font-size: 16px;
    gap: 8px;
    border-radius: 12px;
    min-height: 48px;
  `,
  xl: css`
    padding: 16px 32px;
    font-size: 18px;
    gap: 10px;
    border-radius: 14px;
    min-height: 56px;
  `
};

/* ---------- Button Props Interface ---------- */
interface ButtonProps {
  variant?: keyof typeof variants;
  size?: keyof typeof sizes;
  fullWidth?: boolean;
  isLoading?: boolean;
  iconOnly?: boolean;
}

/* ---------- Loading Spinner Styled Component - Enhanced ---------- */
const LoadingSpinnerIcon = styled.span`
  display: inline-flex;
  width: 1.1em;
  height: 1.1em;
  border: 2px solid currentColor;
  border-right-color: transparent;
  border-top-color: transparent;
  border-radius: 50%;
  animation: ${spin} 0.65s cubic-bezier(0.4, 0, 0.2, 1) infinite;
`;

/* ---------- Main Button Component - Enhanced ---------- */
export const Button = styled.button.withConfig({
  shouldForwardProp: (prop) => !['variant', 'size', 'fullWidth', 'isLoading', 'iconOnly'].includes(prop),
})<ButtonProps>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: none;
  cursor: pointer;
  font-weight: 600;
  white-space: nowrap;
  user-select: none;
  text-decoration: none;
  vertical-align: middle;
  ${({ variant='primary' }) => variants[variant]}
  ${({ size='md' }) => sizes[size]}
  ${({ fullWidth }) => fullWidth && 'width: 100%;'}
  ${({ iconOnly, size='md' }) => iconOnly && css`
    padding: 0;
    width: ${size === 'xs' ? '28px' : size === 'sm' ? '32px' : size === 'lg' ? '48px' : size === 'xl' ? '56px' : '40px'};
    aspect-ratio: 1;
  `}
  transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
  overflow: hidden;
  font-family: ${({ theme }) => theme.font};
  letter-spacing: -0.01em;
  -webkit-tap-highlight-color: transparent;

  /* Loading state - enhanced */
  ${({ isLoading }) => isLoading && css`
    pointer-events: none;
    animation: ${pulse} 1.5s ease-in-out infinite;

    & > *:not(${LoadingSpinnerIcon}) {
      visibility: hidden;
    }
  `}

  &:disabled {
    opacity: 0.45;
    cursor: not-allowed;
    transform: none !important;
    box-shadow: none;
    filter: grayscale(0.2);
  }

  svg {
    flex-shrink: 0;
    width: 1.1em;
    height: 1.1em;
    transition: transform 0.15s ease;
  }

  &:hover:not(:disabled) svg {
    transform: scale(1.05);
  }

  /* Subtle shine effect on hover for primary buttons */
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 50%;
    height: 100%;
    background: linear-gradient(
      90deg,
      transparent,
      rgba(255, 255, 255, 0.15),
      transparent
    );
    transition: left 0.5s ease;
    pointer-events: none;
  }

  &:hover:not(:disabled)::before {
    left: 200%;
  }

  /* Ripple effect on click - refined */
  &::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.25);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: width 0.4s ease, height 0.4s ease, opacity 0.4s ease;
  }

  &:active:not(:disabled)::after {
    width: 250%;
    height: 250%;
    opacity: 0;
    transition: none;
  }
`;

/* ---------- Icon Button - Convenience wrapper ---------- */
export const IconButton = styled(Button).attrs<ButtonProps>({ iconOnly: true })`
  &::before {
    display: none;
  }
`;

/* ---------- Button with Loading State - Enhanced ---------- */
export const ButtonWithLoading = styled(Button)<{ isLoading?: boolean }>`
  ${({ isLoading }) => isLoading && css`
    color: transparent;

    &::before {
      content: '';
      position: absolute;
      width: 1.1em;
      height: 1.1em;
      border: 2px solid currentColor;
      border-right-color: transparent;
      border-top-color: transparent;
      border-radius: 50%;
      animation: ${spin} 0.65s cubic-bezier(0.4, 0, 0.2, 1) infinite;
      color: white;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
  `}
`;
```

---

## src/components/ui/Card.tsx

**Path:** `src/components/ui/Card.tsx`

```tsx
import styled, { css, keyframes } from 'styled-components';

/* ---------- Subtle entrance animation ---------- */
const fadeInUp = keyframes`
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

/* ---------- Card Types ---------- */
type CardVariant = 'default' | 'elevated' | 'outlined' | 'flat' | 'glass';
type CardSize = 'sm' | 'md' | 'lg';

interface CardProps {
  $variant?: CardVariant;
  $size?: CardSize;
  $interactive?: boolean;
  $selected?: boolean;
  $disabled?: boolean;
  $fullHeight?: boolean;
  $animate?: boolean;
}

/* ---------- Size Styles - Refined ---------- */
const sizeStyles = {
  sm: css`
    padding: 16px;
    border-radius: 10px;
  `,
  md: css`
    padding: 24px;
    border-radius: 14px;
  `,
  lg: css`
    padding: 32px;
    border-radius: 18px;
  `,
};

/* ---------- Variant Styles - Enhanced ---------- */
const variantStyles = {
  default: css`
    background: ${({ theme }) => theme.colours.background};
    border: 1px solid ${({ theme }) => theme.colours.border};
    box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 2px 8px rgba(0,0,0,0.03);
  `,
  elevated: css`
    background: ${({ theme }) => theme.colours.background};
    border: 1px solid rgba(226, 232, 240, 0.5);
    box-shadow: 0 4px 12px rgba(0,0,0,0.05), 0 2px 4px rgba(0,0,0,0.03);
  `,
  outlined: css`
    background: transparent;
    border: 1.5px solid ${({ theme }) => theme.colours.border};
    box-shadow: none;
  `,
  flat: css`
    background: ${({ theme }) => theme.colours.backgroundAlt};
    border: 1px solid transparent;
    box-shadow: none;
  `,
  glass: css`
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(24px) saturate(180%);
    -webkit-backdrop-filter: blur(24px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 16px rgba(0,0,0,0.06), 0 1px 4px rgba(0,0,0,0.04);
  `,
};

/* ---------- Main Card Component - Enhanced ---------- */
export const Card = styled.div.withConfig({
  shouldForwardProp: (prop) => !['$variant', '$size', '$interactive', '$selected', '$disabled', '$fullHeight', '$animate'].includes(prop as string),
})<CardProps>`
  position: relative;
  transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1),
              box-shadow 0.2s ease,
              border-color 0.2s ease,
              background 0.2s ease;

  ${({ $size = 'md' }) => sizeStyles[$size]}
  ${({ $variant = 'default' }) => variantStyles[$variant]}

  ${({ $animate }) => $animate && css`
    animation: ${fadeInUp} 0.35s ease forwards;
  `}

  ${({ $fullHeight }) => $fullHeight && css`
    height: 100%;
    display: flex;
    flex-direction: column;
  `}

  ${({ $interactive, $variant }) => $interactive && css`
    cursor: pointer;

    &:hover {
      transform: translateY(-3px);
      ${$variant === 'elevated' && css`
        box-shadow: 0 8px 24px rgba(0,0,0,0.08), 0 4px 12px rgba(0,0,0,0.04);
        border-color: rgba(99, 102, 241, 0.15);
      `}
      ${$variant === 'default' && css`
        box-shadow: 0 6px 20px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04);
        border-color: rgba(99, 102, 241, 0.25);
      `}
      ${$variant === 'outlined' && css`
        border-color: ${({ theme }) => theme.colours.primary};
        background: rgba(99, 102, 241, 0.03);
      `}
      ${$variant === 'flat' && css`
        background: ${({ theme }) => theme.colours.hover};
        box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      `}
      ${$variant === 'glass' && css`
        box-shadow: 0 8px 32px rgba(0,0,0,0.08), 0 4px 12px rgba(0,0,0,0.04);
        border-color: rgba(99, 102, 241, 0.2);
      `}
    }

    &:active {
      transform: translateY(-1px) scale(0.995);
      transition: transform 0.1s ease;
    }

    &:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.25);
      border-color: ${({ theme }) => theme.colours.primary};
    }
  `}

  ${({ $selected, theme }) => $selected && css`
    border-color: ${theme.colours.primary};
    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2), 0 4px 12px rgba(99, 102, 241, 0.1);
    background: rgba(99, 102, 241, 0.03);
  `}

  ${({ $disabled }) => $disabled && css`
    opacity: 0.5;
    pointer-events: none;
    cursor: not-allowed;
    filter: grayscale(0.1);
  `}
`;

/* ---------- Card Header - Enhanced ---------- */
export const CardHeader = styled.div<{ $noBorder?: boolean }>`
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 20px;
  padding-bottom: ${({ $noBorder }) => $noBorder ? '0' : '16px'};
  border-bottom: ${({ $noBorder, theme }) => $noBorder ? 'none' : `1px solid ${theme.colours.border}`};
`;

export const CardHeaderContent = styled.div`
  flex: 1;
  min-width: 0;
`;

export const CardTitle = styled.h3`
  margin: 0;
  font-size: 17px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  line-height: 1.35;
  letter-spacing: -0.01em;
`;

export const CardDescription = styled.p`
  margin: 6px 0 0 0;
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textSecondary};
  line-height: 1.55;
`;

export const CardActions = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
`;

/* ---------- Card Body ---------- */
export const CardBody = styled.div<{ $grow?: boolean }>`
  ${({ $grow }) => $grow && css`
    flex: 1;
  `}
`;

/* ---------- Card Footer ---------- */
export const CardFooter = styled.div<{ $noBorder?: boolean }>`
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 16px;
  padding-top: ${({ $noBorder }) => $noBorder ? '0' : '16px'};
  border-top: ${({ $noBorder, theme }) => $noBorder ? 'none' : `1px solid ${theme.colours.border}`};
`;

/* ---------- Card Media (for images) ---------- */
export const CardMedia = styled.div<{ $height?: string; $rounded?: boolean }>`
  width: calc(100% + 48px);
  margin: -24px -24px 16px -24px;
  height: ${({ $height }) => $height || '200px'};
  overflow: hidden;
  ${({ $rounded }) => $rounded && css`
    border-radius: ${({ theme }) => theme.radius} ${({ theme }) => theme.radius} 0 0;
  `}

  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
`;

/* ---------- Card Badge ---------- */
export const CardBadge = styled.span<{ $variant?: 'primary' | 'success' | 'warning' | 'error' | 'info' }>`
  position: absolute;
  top: 12px;
  right: 12px;
  padding: 4px 10px;
  font-size: 12px;
  font-weight: 600;
  border-radius: 20px;

  ${({ $variant = 'primary', theme }) => {
    const colors = {
      primary: { bg: theme.colours.primaryLight, color: theme.colours.primary },
      success: { bg: theme.colours.successLight, color: theme.colours.successDark || theme.colours.success },
      warning: { bg: theme.colours.warningLight, color: theme.colours.warningDark || theme.colours.warning },
      error: { bg: theme.colours.errorLight, color: theme.colours.errorDark || theme.colours.error },
      info: { bg: theme.colours.infoLight, color: theme.colours.infoDark || theme.colours.info },
    };
    return css`
      background: ${colors[$variant].bg};
      color: ${colors[$variant].color};
    `;
  }}
`;

/* ---------- Input component (kept for backwards compatibility) ---------- */
export const Input = styled.input`
  width: 100%;
  padding: 12px 16px;
  border: 1.5px solid ${({ theme }) => theme.colours.border};
  border-radius: ${({ theme }) => theme.radius};
  background: ${({ theme }) => theme.colours.background};
  color: ${({ theme }) => theme.colours.text};
  font-size: 14px;
  transition: all 0.2s ease;

  &:hover:not(:disabled):not(:focus) {
    border-color: ${({ theme }) => theme.colours.textSecondary};
  }

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colours.primary};
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colours.focusRing || 'rgba(99, 102, 241, 0.15)'};
  }

  &::placeholder {
    color: ${({ theme }) => theme.colours.textMuted || '#9ca3af'};
  }

  &:disabled {
    background: ${({ theme }) => theme.colours.backgroundAlt};
    cursor: not-allowed;
    opacity: 0.7;
  }
`;

/* ---------- Text components ---------- */
export const Title = styled.h1`
  color: ${({ theme }) => theme.colours.text};
  font-size: 2rem;
  font-weight: 700;
  margin: 0 0 16px 0;
  letter-spacing: -0.025em;
  line-height: 1.2;
`;

export const Subtitle = styled.p`
  color: ${({ theme }) => theme.colours.textSecondary || theme.colours.secondaryText};
  font-size: 1rem;
  margin: 0 0 24px 0;
  line-height: 1.6;
`;

/* ---------- Card Group for grid layouts ---------- */
export const CardGroup = styled.div<{ $columns?: number; $gap?: string }>`
  display: grid;
  grid-template-columns: repeat(${({ $columns = 3 }) => $columns}, 1fr);
  gap: ${({ $gap = '24px' }) => $gap};

  @media (max-width: 1024px) {
    grid-template-columns: repeat(2, 1fr);
  }

  @media (max-width: 640px) {
    grid-template-columns: 1fr;
  }
`;
```

---

## src/components/ui/ConfirmationModal.tsx

**Path:** `src/components/ui/ConfirmationModal.tsx`

```tsx
import React, { useEffect, useRef, useCallback } from 'react';
import styled, { keyframes, css } from 'styled-components';
import { XMarkIcon, ExclamationTriangleIcon, CheckCircleIcon, InformationCircleIcon, QuestionMarkCircleIcon } from '@heroicons/react/24/solid';

/* ---------- Animations ---------- */
const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const slideUp = keyframes`
  from {
    opacity: 0;
    transform: translateY(24px) scale(0.98);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
`;

const slideOut = keyframes`
  from {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
  to {
    opacity: 0;
    transform: translateY(16px) scale(0.98);
  }
`;

const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

const shake = keyframes`
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
  20%, 40%, 60%, 80% { transform: translateX(4px); }
`;

/* ---------- Types ---------- */
type ModalVariant = 'default' | 'danger' | 'warning' | 'success' | 'info';

interface ConfirmationModalProps {
  isOpen: boolean;
  title: string;
  message: string | React.ReactNode;
  confirmText?: string;
  cancelText?: string;
  variant?: ModalVariant;
  isDangerous?: boolean; // Legacy prop, maps to variant='danger'
  onConfirm: () => void | Promise<void>;
  onCancel: () => void;
  isLoading?: boolean;
  icon?: React.ReactNode;
  showCloseButton?: boolean;
  size?: 'sm' | 'md' | 'lg';
}

/* ---------- Styled Components ---------- */
const Overlay = styled.div<{ $isClosing?: boolean }>`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  backdrop-filter: blur(4px);
  animation: ${fadeIn} 0.2s ease-out;
  padding: 16px;

  ${({ $isClosing }) => $isClosing && css`
    animation: ${fadeIn} 0.15s ease-out reverse;
  `}
`;

const ModalContent = styled.div<{ $isClosing?: boolean; $hasShake?: boolean; $size?: 'sm' | 'md' | 'lg' }>`
  background: ${({ theme }) => theme.colours.background};
  border-radius: ${({ theme }) => theme.radiusLg};
  box-shadow: ${({ theme }) => theme.shadowElevated};
  width: 100%;
  max-height: 90vh;
  overflow: hidden;
  animation: ${slideUp} 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  flex-direction: column;

  ${({ $size }) => {
    switch ($size) {
      case 'sm':
        return css`max-width: 340px;`;
      case 'lg':
        return css`max-width: 520px;`;
      default:
        return css`max-width: 420px;`;
    }
  }}

  ${({ $isClosing }) => $isClosing && css`
    animation: ${slideOut} 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  `}

  ${({ $hasShake }) => $hasShake && css`
    animation: ${shake} 0.4s ease-in-out;
  `}

  &:focus {
    outline: none;
  }
`;

const ModalHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding: 20px 24px 0 24px;
`;

const HeaderContent = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 1;
`;

// Variant colors using theme tokens - accessed via theme prop in styled components
const getVariantColors = (theme: typeof import('../../styles/theme').theme) => ({
  default: { bg: theme.colours.primaryLight, color: theme.colours.primary },
  danger: { bg: theme.colours.errorLight, color: theme.colours.error },
  warning: { bg: theme.colours.warningLight, color: theme.colours.warning },
  success: { bg: theme.colours.successLight, color: theme.colours.success },
  info: { bg: theme.colours.infoLight, color: theme.colours.info },
});

const IconWrapper = styled.div<{ $variant: ModalVariant }>`
  width: 44px;
  height: 44px;
  border-radius: ${({ theme }) => theme.radiusMd};
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  background: ${({ $variant, theme }) => getVariantColors(theme)[$variant].bg};
  color: ${({ $variant, theme }) => getVariantColors(theme)[$variant].color};

  svg {
    width: 24px;
    height: 24px;
  }
`;

const ModalTitle = styled.h2`
  font-size: 18px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  margin: 0;
  line-height: 1.4;
  letter-spacing: -0.01em;
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  cursor: pointer;
  padding: 8px;
  margin: -4px -8px -4px 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${({ theme }) => theme.colours.textMuted};
  border-radius: ${({ theme }) => theme.radiusSm};
  transition: all 0.2s ease;
  flex-shrink: 0;

  &:hover:not(:disabled) {
    color: ${({ theme }) => theme.colours.text};
    background: ${({ theme }) => theme.colours.hover};
  }

  &:focus-visible {
    outline: none;
    box-shadow: ${({ theme }) => theme.shadowFocus};
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

const ModalBody = styled.div`
  padding: 16px 24px 24px;
  overflow-y: auto;
`;

const ModalMessage = styled.div`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textSecondary};
  line-height: 1.6;

  p {
    margin: 0;
  }

  p + p {
    margin-top: 12px;
  }
`;

const ModalFooter = styled.div`
  display: flex;
  gap: 12px;
  padding: 16px 24px 24px;
  justify-content: flex-end;
  border-top: 1px solid ${({ theme }) => theme.colours.borderLight};
  background: ${({ theme }) => theme.colours.backgroundAlt};
`;

// Button variant styles using theme tokens
const getButtonVariantStyles = (theme: typeof import('../../styles/theme').theme) => ({
  default: css`
    background: ${theme.colours.gradient};
    &:hover:not(:disabled) { filter: brightness(1.05); }
    &:focus-visible { box-shadow: 0 0 0 3px ${theme.colours.focusRing}; }
  `,
  danger: css`
    background: linear-gradient(135deg, ${theme.colours.error}, ${theme.colours.errorDark});
    &:hover:not(:disabled) { filter: brightness(0.95); }
    &:focus-visible { box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.4); }
  `,
  warning: css`
    background: linear-gradient(135deg, ${theme.colours.warning}, ${theme.colours.warningDark});
    &:hover:not(:disabled) { filter: brightness(0.95); }
    &:focus-visible { box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.4); }
  `,
  success: css`
    background: linear-gradient(135deg, ${theme.colours.success}, ${theme.colours.successDark});
    &:hover:not(:disabled) { filter: brightness(0.95); }
    &:focus-visible { box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.4); }
  `,
  info: css`
    background: linear-gradient(135deg, ${theme.colours.info}, ${theme.colours.infoDark});
    &:hover:not(:disabled) { filter: brightness(0.95); }
    &:focus-visible { box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.4); }
  `,
});

const ConfirmButton = styled.button<{ $variant: ModalVariant; $isLoading?: boolean }>`
  padding: 10px 20px;
  border-radius: ${({ theme }) => theme.radiusMd};
  border: none;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  min-width: 100px;
  color: ${({ theme }) => theme.colours.textInverse};
  position: relative;
  overflow: hidden;

  ${({ $variant, theme }) => getButtonVariantStyles(theme)[$variant]}

  &:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: ${({ theme }) => theme.shadowMd};
  }

  &:active:not(:disabled) {
    transform: translateY(0);
  }

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  ${({ $isLoading }) => $isLoading && css`
    color: transparent;
    pointer-events: none;
  `}
`;

const LoadingSpinner = styled.span`
  position: absolute;
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: white;
  border-radius: 50%;
  animation: ${spin} 0.6s linear infinite;
`;

const CancelButton = styled.button`
  padding: 10px 20px;
  border-radius: ${({ theme }) => theme.radiusMd};
  border: 1.5px solid ${({ theme }) => theme.colours.border};
  background: ${({ theme }) => theme.colours.background};
  color: ${({ theme }) => theme.colours.textSecondary};
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 90px;

  &:hover:not(:disabled) {
    background: ${({ theme }) => theme.colours.backgroundAlt};
    border-color: ${({ theme }) => theme.colours.border};
  }

  &:focus-visible {
    outline: none;
    box-shadow: ${({ theme }) => theme.shadowFocus};
    border-color: ${({ theme }) => theme.colours.primary};
  }

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
`;

/* ---------- Helper function to get default icon ---------- */
const getDefaultIcon = (variant: ModalVariant) => {
  switch (variant) {
    case 'danger':
      return <ExclamationTriangleIcon />;
    case 'warning':
      return <ExclamationTriangleIcon />;
    case 'success':
      return <CheckCircleIcon />;
    case 'info':
      return <InformationCircleIcon />;
    default:
      return <QuestionMarkCircleIcon />;
  }
};

/* ---------- Main Component ---------- */
const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isOpen,
  title,
  message,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  variant: propVariant,
  isDangerous = false,
  onConfirm,
  onCancel,
  isLoading = false,
  icon,
  showCloseButton = true,
  size = 'md'
}) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const cancelButtonRef = useRef<HTMLButtonElement>(null);
  const confirmButtonRef = useRef<HTMLButtonElement>(null);

  // Map legacy isDangerous prop to variant
  const variant = propVariant || (isDangerous ? 'danger' : 'default');

  // Handle escape key
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (e.key === 'Escape' && !isLoading) {
      e.preventDefault();
      onCancel();
    }
  }, [onCancel, isLoading]);

  // Focus trap
  const handleTabKey = useCallback((e: KeyboardEvent) => {
    if (e.key !== 'Tab' || !modalRef.current) return;

    const focusableElements = modalRef.current.querySelectorAll<HTMLElement>(
      'button:not(:disabled), [href], input:not(:disabled), select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"])'
    );
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    if (e.shiftKey && document.activeElement === firstElement) {
      e.preventDefault();
      lastElement?.focus();
    } else if (!e.shiftKey && document.activeElement === lastElement) {
      e.preventDefault();
      firstElement?.focus();
    }
  }, []);

  // Setup event listeners and initial focus
  useEffect(() => {
    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keydown', handleTabKey);

      // Focus cancel button by default (safer option)
      setTimeout(() => {
        cancelButtonRef.current?.focus();
      }, 50);

      // Prevent body scroll
      document.body.style.overflow = 'hidden';

      return () => {
        document.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('keydown', handleTabKey);
        document.body.style.overflow = '';
      };
    }
  }, [isOpen, handleKeyDown, handleTabKey]);

  const handleConfirm = async () => {
    await onConfirm();
  };

  const handleOverlayClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget && !isLoading) {
      onCancel();
    }
  };

  if (!isOpen) return null;

  return (
    <Overlay onClick={handleOverlayClick} role="dialog" aria-modal="true" aria-labelledby="modal-title">
      <ModalContent
        ref={modalRef}
        onClick={e => e.stopPropagation()}
        $size={size}
        tabIndex={-1}
      >
        <ModalHeader>
          <HeaderContent>
            <IconWrapper $variant={variant}>
              {icon || getDefaultIcon(variant)}
            </IconWrapper>
            <ModalTitle id="modal-title">{title}</ModalTitle>
          </HeaderContent>
          {showCloseButton && (
            <CloseButton
              onClick={onCancel}
              disabled={isLoading}
              aria-label="Close modal"
              type="button"
            >
              <XMarkIcon />
            </CloseButton>
          )}
        </ModalHeader>
        <ModalBody>
          <ModalMessage>
            {typeof message === 'string' ? <p>{message}</p> : message}
          </ModalMessage>
        </ModalBody>
        <ModalFooter>
          <CancelButton
            ref={cancelButtonRef}
            onClick={onCancel}
            disabled={isLoading}
            type="button"
          >
            {cancelText}
          </CancelButton>
          <ConfirmButton
            ref={confirmButtonRef}
            $variant={variant}
            $isLoading={isLoading}
            onClick={handleConfirm}
            disabled={isLoading}
            type="button"
          >
            {isLoading && <LoadingSpinner />}
            {confirmText}
          </ConfirmButton>
        </ModalFooter>
      </ModalContent>
    </Overlay>
  );
};

export default ConfirmationModal;
```

---

## src/components/ui/ConnectionStatus.tsx

**Path:** `src/components/ui/ConnectionStatus.tsx`

```tsx
// src/components/ui/ConnectionStatus.js
/**
 * Connection Status Indicator Component
 * Shows Firebase connection state with modern UI
 */

import React from 'react';
import styled, { keyframes } from 'styled-components';
import { useFirebaseConnection } from '../../hooks/useFirebaseConnection';

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
`;

const slideIn = keyframes`
  from {
    transform: translateY(-100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
`;

const StatusBar = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  padding: 12px 24px;
  background: ${props => {
    switch (props.$state) {
      case 'connected': return 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
      case 'disconnected': return 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
      case 'reconnecting': return 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
      default: return 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)';
    }
  }};
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  font-size: 14px;
  font-weight: 500;
  z-index: 10000;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  animation: ${slideIn} 0.3s ease-out;
`;

const StatusDot = styled.div`
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: white;
  animation: ${props => props.$pulse ? pulse : 'none'} 2s ease-in-out infinite;
`;

const StatusText = styled.span`
  flex: 1;
  text-align: center;
`;

const ReconnectButton = styled.button`
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: white;
  padding: 6px 16px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
  }

  &:active {
    transform: translateY(0);
  }
`;

const CloseButton = styled.button`
  background: transparent;
  border: none;
  color: white;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  opacity: 0.8;
  transition: opacity 0.2s ease;

  &:hover {
    opacity: 1;
  }
`;

/**
 * Connection Status Component
 */
export const ConnectionStatus = ({ showWhenConnected = false }) => {
  const { state, isConnected, reconnectAttempts, forceReconnect } = useFirebaseConnection();
  const [dismissed, setDismissed] = React.useState(false);

  // Don't show if connected and showWhenConnected is false
  if (isConnected && !showWhenConnected) {
    return null;
  }

  // Don't show if dismissed
  if (dismissed) {
    return null;
  }

  const getMessage = () => {
    switch (state) {
      case 'connected':
        return 'âœ“ Connected to Firebase';
      case 'disconnected':
        return 'âš  Connection lost - Using cached data';
      case 'reconnecting':
        return `ðŸ”„ Reconnecting... (Attempt ${reconnectAttempts})`;
      case 'reconnect-failed':
        return 'âŒ Unable to reconnect - Please check your internet connection';
      default:
        return 'Checking connection...';
    }
  };

  return (
    <StatusBar $state={state}>
      <StatusDot $pulse={state === 'reconnecting'} />
      <StatusText>{getMessage()}</StatusText>
      
      {!isConnected && (
        <ReconnectButton onClick={forceReconnect}>
          Retry Connection
        </ReconnectButton>
      )}
      
      <CloseButton onClick={() => setDismissed(true)} aria-label="Dismiss">
        Ã—
      </CloseButton>
    </StatusBar>
  );
};

/**
 * Compact connection indicator (for header/footer)
 */
export const ConnectionIndicator = () => {
  const { isConnected, state } = useFirebaseConnection();

  const IndicatorDot = styled.div`
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: ${props => props.$connected ? '#10b981' : '#ef4444'};
    animation: ${props => props.$pulse ? pulse : 'none'} 2s ease-in-out infinite;
    box-shadow: 0 0 0 2px ${props => props.$connected ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)'};
  `;

  const IndicatorContainer = styled.div`
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 12px;
    border-radius: 20px;
    background: ${props => props.$connected 
      ? 'rgba(16, 185, 129, 0.1)' 
      : 'rgba(239, 68, 68, 0.1)'};
    font-size: 12px;
    font-weight: 500;
    color: ${props => props.$connected ? '#059669' : '#dc2626'};
  `;

  return (
    <IndicatorContainer $connected={isConnected} title={isConnected ? 'Connected' : 'Disconnected'}>
      <IndicatorDot $connected={isConnected} $pulse={state === 'reconnecting'} />
      {isConnected ? 'Online' : 'Offline'}
    </IndicatorContainer>
  );
};

export default ConnectionStatus;

```

---

## src/components/ui/EmptyState.tsx

**Path:** `src/components/ui/EmptyState.tsx`

```tsx
import React from 'react';
import styled, { keyframes, css } from 'styled-components';

/* ---------- Animations ---------- */
const fadeInUp = keyframes`
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

const float = keyframes`
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-8px);
  }
`;

const pulse = keyframes`
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
`;

const shimmer = keyframes`
  0% {
    background-position: -200% center;
  }
  100% {
    background-position: 200% center;
  }
`;

/* ---------- Types ---------- */
interface EmptyStateProps {
  icon?: React.ReactNode;
  title: string;
  description: string;
  action?: {
    label: string;
    onClick: () => void;
    icon?: React.ReactNode;
    variant?: 'primary' | 'secondary';
  };
  secondaryAction?: {
    label: string;
    onClick: () => void;
    icon?: React.ReactNode;
  };
  variant?: 'default' | 'compact' | 'minimal' | 'card';
  isLoading?: boolean;
  illustration?: React.ReactNode;
}

/* ---------- Styled Components ---------- */
const Container = styled.div<{ $variant?: 'default' | 'compact' | 'minimal' | 'card'; $isLoading?: boolean }>`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  animation: ${fadeInUp} 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  transition: all 0.3s ease;

  ${({ $variant }) => {
    switch ($variant) {
      case 'compact':
        return css`
          padding: 32px 20px;
          background: rgba(255, 255, 255, 0.5);
          border-radius: 12px;
          border: 2px dashed rgba(226, 232, 240, 0.8);
          margin: 16px 0;
        `;
      case 'minimal':
        return css`
          padding: 48px 24px;
          background: transparent;
          border: none;
          margin: 24px 0;
        `;
      case 'card':
        return css`
          padding: 48px 32px;
          background: white;
          border-radius: 16px;
          border: 1px solid rgba(226, 232, 240, 0.8);
          box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06);
          margin: 24px 0;
        `;
      default:
        return css`
          padding: 64px 32px;
          background: rgba(255, 255, 255, 0.5);
          border-radius: 16px;
          border: 2px dashed rgba(226, 232, 240, 0.8);
          margin: 32px 0;
        `;
    }
  }}

  ${({ $variant }) => ($variant === 'default' || $variant === 'compact') && css`
    &:hover {
      border-color: rgba(99, 102, 241, 0.3);
      background: rgba(255, 255, 255, 0.7);
    }
  `}

  ${({ $isLoading }) => $isLoading && css`
    pointer-events: none;
    opacity: 0.7;
  `}

  @media (max-width: 768px) {
    padding: ${({ $variant }) => $variant === 'compact' ? '24px 16px' : '40px 20px'};
  }
`;

const IconWrapper = styled.div<{ $isLoading?: boolean; $size?: 'sm' | 'md' | 'lg' }>`
  display: flex;
  align-items: center;
  justify-content: center;
  background: ${({ theme }) => theme.colours.gradientSubtle};
  border-radius: 20px;
  margin-bottom: 20px;
  transition: all 0.3s ease;

  ${({ $size = 'md' }) => {
    switch ($size) {
      case 'sm':
        return css`
          width: 48px;
          height: 48px;
          border-radius: 14px;
          svg { width: 24px; height: 24px; }
        `;
      case 'lg':
        return css`
          width: 80px;
          height: 80px;
          border-radius: 24px;
          svg { width: 40px; height: 40px; }
        `;
      default:
        return css`
          width: 64px;
          height: 64px;
          border-radius: 18px;
          svg { width: 32px; height: 32px; }
        `;
    }
  }}

  svg {
    color: ${({ theme }) => theme.colours.primary};
    transition: all 0.3s ease;
  }

  &:hover svg {
    animation: ${float} 2s ease-in-out infinite;
  }

  ${({ $isLoading }) => $isLoading && css`
    animation: ${pulse} 1.5s ease-in-out infinite;
  `}
`;

const IllustrationWrapper = styled.div`
  margin-bottom: 24px;
  max-width: 200px;
  animation: ${float} 4s ease-in-out infinite;

  img, svg {
    width: 100%;
    height: auto;
  }
`;

const Title = styled.h3<{ $size?: 'sm' | 'md' | 'lg' }>`
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  margin: 0 0 8px 0;
  letter-spacing: -0.02em;

  ${({ $size = 'md' }) => {
    switch ($size) {
      case 'sm':
        return css`font-size: 16px;`;
      case 'lg':
        return css`font-size: 24px;`;
      default:
        return css`font-size: 20px;`;
    }
  }}
`;

const Description = styled.p<{ $size?: 'sm' | 'md' | 'lg' }>`
  color: ${({ theme }) => theme.colours.textSecondary};
  margin: 0 0 24px 0;
  max-width: 420px;
  line-height: 1.6;

  ${({ $size = 'md' }) => {
    switch ($size) {
      case 'sm':
        return css`font-size: 13px; max-width: 320px;`;
      case 'lg':
        return css`font-size: 16px; max-width: 500px;`;
      default:
        return css`font-size: 15px;`;
    }
  }}
`;

const ActionsContainer = styled.div`
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
  justify-content: center;
`;

const ActionButton = styled.button<{ $variant?: 'primary' | 'secondary' }>`
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 12px 24px;
  border-radius: ${({ theme }) => theme.radiusMd};
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;

  ${({ $variant, theme }) => $variant === 'secondary' ? css`
    background: ${theme.colours.background};
    color: ${theme.colours.primary};
    border: 1.5px solid ${theme.colours.focusRing};
    box-shadow: ${theme.shadowSm};

    &:hover {
      background: ${theme.colours.hoverSubtle};
      border-color: ${theme.colours.primary};
      transform: translateY(-2px);
      box-shadow: ${theme.shadowMd};
    }

    &:active {
      transform: translateY(0);
    }

    &:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px ${theme.colours.focusRing};
    }
  ` : css`
    background: ${theme.colours.gradient};
    color: ${theme.colours.textInverse};
    border: none;
    box-shadow: ${theme.shadowPrimary};

    &:hover {
      filter: brightness(1.05);
      transform: translateY(-2px);
      box-shadow: ${theme.shadowPrimaryHover};
    }

    &:active {
      transform: translateY(0);
      box-shadow: ${theme.shadowPrimary};
    }

    &:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px ${theme.colours.focusRing}, ${theme.shadowPrimary};
    }

    /* Shimmer effect */
    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent,
        ${theme.colours.shimmer},
        transparent
      );
      transition: left 0.5s ease;
    }

    &:hover::before {
      left: 100%;
    }
  `}

  svg {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
  }

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }
`;

const LoadingPlaceholder = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
`;

const LoadingBar = styled.div<{ $width: string }>`
  height: 12px;
  width: ${({ $width }) => $width};
  background: linear-gradient(
    90deg,
    ${({ theme }) => theme.colours.border} 0%,
    ${({ theme }) => theme.colours.backgroundSubtle} 50%,
    ${({ theme }) => theme.colours.border} 100%
  );
  background-size: 200% 100%;
  animation: ${shimmer} 1.5s infinite;
  border-radius: ${({ theme }) => theme.radiusSm};
`;

/* ---------- Main Component ---------- */
export const EmptyState: React.FC<EmptyStateProps> = ({
  icon,
  title,
  description,
  action,
  secondaryAction,
  variant = 'default',
  isLoading = false,
  illustration
}) => {
  const size = variant === 'compact' ? 'sm' : variant === 'minimal' ? 'md' : 'md';

  if (isLoading) {
    return (
      <Container $variant={variant} $isLoading>
        <IconWrapper $isLoading $size={size}>
          {icon}
        </IconWrapper>
        <LoadingPlaceholder>
          <LoadingBar $width="180px" />
          <LoadingBar $width="260px" />
          <LoadingBar $width="220px" />
        </LoadingPlaceholder>
      </Container>
    );
  }

  return (
    <Container $variant={variant}>
      {illustration && (
        <IllustrationWrapper>{illustration}</IllustrationWrapper>
      )}
      {icon && !illustration && (
        <IconWrapper $size={size}>{icon}</IconWrapper>
      )}
      <Title $size={size}>{title}</Title>
      <Description $size={size}>{description}</Description>
      {(action || secondaryAction) && (
        <ActionsContainer>
          {action && (
            <ActionButton
              onClick={action.onClick}
              $variant={action.variant || 'primary'}
              type="button"
            >
              {action.icon}
              {action.label}
            </ActionButton>
          )}
          {secondaryAction && (
            <ActionButton
              onClick={secondaryAction.onClick}
              $variant="secondary"
              type="button"
            >
              {secondaryAction.icon}
              {secondaryAction.label}
            </ActionButton>
          )}
        </ActionsContainer>
      )}
    </Container>
  );
};
```

---

## src/components/ui/EnhancedChatMessage.tsx

**Path:** `src/components/ui/EnhancedChatMessage.tsx`

```tsx
import React, { memo } from 'react';
import styled from 'styled-components';
import { UnifiedAIResponse } from './UnifiedAIResponse';

interface MessageMetadata {
  queryType?: string;
  confidence?: number;
  tokensUsed?: number;
  processingTime?: number;
  sources?: string[];
  isStructured?: boolean;
}

interface EnhancedChatMessageProps {
  content: string;
  metadata?: MessageMetadata;
  showMetadata?: boolean;
}

const MessageContainer = styled.div`
  width: 100%;
  font-size: 15px;
  line-height: 1.7;

  /* Clean ChatGPT-like typography */
  p {
    margin: 0 0 1em 0;

    &:last-child {
      margin-bottom: 0;
    }
  }

  ul, ol {
    margin: 0.5em 0 1em 0;
    padding-left: 1.5em;
  }

  li {
    margin: 0.35em 0;
  }

  code {
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.06)'};
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.9em;
    font-family: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  }

  pre {
    background: ${({ theme }) => theme.isDarkMode ? '#1e1e1e' : '#f6f6f6'};
    padding: 16px;
    border-radius: 8px;
    overflow-x: auto;
    margin: 1em 0;

    code {
      background: none;
      padding: 0;
    }
  }

  strong {
    font-weight: 600;
  }

  @media (max-width: 768px) {
    font-size: 14px;
  }
`;

export const EnhancedChatMessage = memo<EnhancedChatMessageProps>(({
  content
}) => {
  return (
    <MessageContainer>
      <UnifiedAIResponse content={content} />
    </MessageContainer>
  );
});

EnhancedChatMessage.displayName = 'EnhancedChatMessage';

```

---

## src/components/ui/EnhancedHeader.tsx

**Path:** `src/components/ui/EnhancedHeader.tsx`

```tsx
import React, { useCallback, useRef } from 'react';
import styled, { keyframes, css } from 'styled-components';
import { MagnifyingGlassIcon, ArrowUpIcon, ArrowLeftIcon, ChevronRightIcon, HomeIcon } from '@heroicons/react/24/outline';
import { Link } from 'react-router-dom';

/* ---------- Animations ---------- */
const spin = keyframes`
  to {
    transform: rotate(360deg);
  }
`;

const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(-8px); }
  to { opacity: 1; transform: translateY(0); }
`;

const shimmer = keyframes`
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
`;

/* ---------- Breadcrumb Components ---------- */
interface BreadcrumbItem {
  label: string;
  path?: string;
  icon?: React.ComponentType<{ className?: string }>;
}

const BreadcrumbNav = styled.nav`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
  animation: ${fadeIn} 0.3s ease-out;
`;

const BreadcrumbList = styled.ol`
  display: flex;
  align-items: center;
  gap: 4px;
  list-style: none;
  margin: 0;
  padding: 0;
  flex-wrap: wrap;
`;

const BreadcrumbItem = styled.li`
  display: flex;
  align-items: center;
  gap: 4px;
`;

const BreadcrumbLink = styled(Link)`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  font-size: 14px;
  font-weight: 500;
  color: #64748b;
  text-decoration: none;
  border-radius: 8px;
  transition: all 0.2s ease;

  &:hover {
    color: #6366f1;
    background: rgba(99, 102, 241, 0.08);
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }

  svg {
    width: 14px;
    height: 14px;
  }
`;

const BreadcrumbCurrent = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  font-size: 14px;
  font-weight: 600;
  color: #1f2937;
  background: rgba(99, 102, 241, 0.08);
  border-radius: 8px;

  svg {
    width: 14px;
    height: 14px;
    color: #6366f1;
  }
`;

const BreadcrumbSeparator = styled(ChevronRightIcon)`
  width: 14px;
  height: 14px;
  color: #cbd5e1;
  flex-shrink: 0;
`;

/* ---------- Enhanced Header Components ---------- */
const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.9);
  color: #64748b;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(12px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
  margin-bottom: 16px;
  align-self: flex-start;

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(99, 102, 241, 0.15);
    border-color: rgba(99, 102, 241, 0.2);
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }

  &:active {
    transform: translateY(0);
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const HeaderSection = styled.section`
  width: 100%;
  padding: 24px 32px;
  border-radius: 16px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.08) 0%, rgba(59, 130, 246, 0.08) 100%);
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(12px);
  margin-bottom: 32px;
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
  }

  @media (max-width: 768px) {
    padding: 20px 24px;
    margin-bottom: 24px;
  }
`;

const HeaderContent = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
  max-width: 1400px;
  margin: 0 auto;
  text-align: center;
`;

const TitleGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const PageTitle = styled.h1`
  font-size: 2.5rem;
  font-weight: 700;
  color: #1f2937;
  margin: 0;
  letter-spacing: -0.02em;
  line-height: 1.2;

  @media (max-width: 768px) {
    font-size: 2rem;
  }

  @media (max-width: 480px) {
    font-size: 1.75rem;
  }
`;

const PageSubtitle = styled.p`
  font-size: 1.125rem;
  color: #6b7280;
  margin: 0;
  font-weight: 500;
  line-height: 1.4;

  @media (max-width: 768px) {
    font-size: 1rem;
  }
`;

const float = keyframes`
  0%, 100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-6px);
  }
`;

const IconTitleGroup = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 8px;

  svg {
    width: 32px;
    height: 32px;
    color: #6366f1;
    transition: all 0.3s ease;

    &:hover {
      animation: ${float} 2s ease-in-out infinite;
      color: #8b5cf6;
    }

    @media (max-width: 768px) {
      width: 28px;
      height: 28px;
    }
  }
`;

const ContextInfo = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  margin-top: 12px;
  flex-wrap: wrap;

  @media (max-width: 768px) {
    gap: 12px;
  }
`;

const ContextBadge = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: rgba(59, 130, 246, 0.1);
  color: #1d4ed8;
  font-size: 0.875rem;
  font-weight: 600;
  padding: 6px 12px;
  border-radius: 20px;
  border: 1px solid rgba(59, 130, 246, 0.2);

  svg {
    width: 14px;
    height: 14px;
  }
`;

const CountBadge = styled.span`
  background: rgba(16, 185, 129, 0.1);
  color: #047857;
  font-size: 0.875rem;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 12px;
  border: 1px solid rgba(16, 185, 129, 0.2);
`;

/* ---------- Enhanced Search Components ---------- */
const SearchSection = styled.div`
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  position: relative;
`;

const SearchContainer = styled.div`
  position: relative;
  display: flex;
  align-items: center;
  background: white;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  border: 1px solid rgba(226, 232, 240, 0.8);
  transition: all 0.3s ease;
  overflow: hidden;

  &:focus-within {
    border-color: #6366f1;
    box-shadow: 0 4px 20px rgba(99, 102, 241, 0.15);
    transform: translateY(-1px);
  }
`;

const SearchInput = styled.input`
  flex: 1;
  padding: 16px 20px;
  border: none;
  outline: none;
  font-size: 1rem;
  color: #1f2937;
  background: transparent;

  &::placeholder {
    color: #9ca3af;
    font-weight: 500;
  }

  @media (max-width: 768px) {
    padding: 14px 16px;
    font-size: 0.95rem;
  }
`;

const SearchButton = styled.button<{ $isLoading?: boolean }>`
  background: linear-gradient(135deg, #6366f1, #8b5cf6);
  color: white;
  border: none;
  padding: 12px 20px;
  margin: 4px;
  border-radius: 8px;
  font-weight: 600;
  font-size: 0.875rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.3s ease;
  min-width: 80px;
  justify-content: center;
  position: relative;

  &:hover:not(:disabled) {
    background: linear-gradient(135deg, #5b5bf6, #7c3aed);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  ${({ $isLoading }) => $isLoading && css`
    background: linear-gradient(90deg, #6366f1, #8b5cf6, #6366f1);
    background-size: 200% auto;
    animation: ${shimmer} 1.5s linear infinite;
  `}

  svg {
    width: 16px;
    height: 16px;
  }

  @media (max-width: 768px) {
    padding: 10px 16px;
    min-width: 70px;
  }
`;

const SearchIcon = styled(MagnifyingGlassIcon)`
  width: 20px;
  height: 20px;
  color: #9ca3af;
  margin-left: 16px;
  flex-shrink: 0;
`;

const LoadingSpinner = styled.div`
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top: 2px solid white;
  border-radius: 50%;
  animation: ${spin} 1s linear infinite;
`;

const SearchHint = styled.span`
  position: absolute;
  bottom: -24px;
  left: 0;
  font-size: 12px;
  color: #64748b;
  display: flex;
  align-items: center;
  gap: 4px;

  kbd {
    background: rgba(0, 0, 0, 0.06);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: inherit;
    font-size: 11px;
    border: 1px solid rgba(0, 0, 0, 0.1);
  }

  @media (max-width: 768px) {
    display: none;
  }
`;

/* ---------- Main Component ---------- */
interface EnhancedHeaderProps {
  title: string;
  subtitle?: string;
  icon?: React.ComponentType;
  contextInfo?: Array<{type: 'badge' | 'count', text: string, icon?: React.ComponentType}>;
  searchProps?: {
    placeholder: string;
    value: string;
    onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    onKeyPress?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
    onSearch?: () => void;
    disabled?: boolean;
    isLoading?: boolean;
    showHint?: boolean;
    inputId?: string;
    ariaLabel?: string;
  } | null;
  breadcrumbs?: BreadcrumbItem[];
  showBackButton?: boolean;
  onBackClick?: () => void;
  backButtonLabel?: string;
  children?: React.ReactNode;
}

const EnhancedHeader: React.FC<EnhancedHeaderProps> = ({
  title,
  subtitle,
  icon: Icon,
  contextInfo = [],
  searchProps = null,
  breadcrumbs = [],
  showBackButton = false,
  onBackClick,
  backButtonLabel = 'Back',
  children
}) => {
  const searchInputRef = useRef<HTMLInputElement>(null);

  // Handle keyboard shortcut for search focus
  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && searchProps?.onSearch && searchProps.value?.trim()) {
      e.preventDefault();
      searchProps.onSearch();
    }
    // Call the original onKeyPress if provided
    searchProps?.onKeyPress?.(e);
  }, [searchProps]);

  return (
    <HeaderSection role="banner" aria-labelledby="page-title">
      <HeaderContent>
        {/* Breadcrumb Navigation */}
        {breadcrumbs.length > 0 && (
          <BreadcrumbNav aria-label="Breadcrumb">
            <BreadcrumbList>
              {breadcrumbs.map((crumb, index) => {
                const isLast = index === breadcrumbs.length - 1;
                const IconComponent = crumb.icon;

                return (
                  <BreadcrumbItem key={crumb.path || crumb.label}>
                    {!isLast && crumb.path ? (
                      <>
                        <BreadcrumbLink to={crumb.path}>
                          {IconComponent && <IconComponent />}
                          {crumb.label}
                        </BreadcrumbLink>
                        <BreadcrumbSeparator aria-hidden="true" />
                      </>
                    ) : (
                      <BreadcrumbCurrent aria-current="page">
                        {IconComponent && <IconComponent />}
                        {crumb.label}
                      </BreadcrumbCurrent>
                    )}
                  </BreadcrumbItem>
                );
              })}
            </BreadcrumbList>
          </BreadcrumbNav>
        )}

        {/* Back Button (alternative to breadcrumbs) */}
        {showBackButton && onBackClick && breadcrumbs.length === 0 && (
          <BackButton
            onClick={onBackClick}
            aria-label={`Go back: ${backButtonLabel}`}
          >
            <ArrowLeftIcon />
            {backButtonLabel}
          </BackButton>
        )}

        <TitleGroup>
          {Icon && (
            <IconTitleGroup>
              <Icon aria-hidden="true" />
              <PageTitle id="page-title">{title}</PageTitle>
            </IconTitleGroup>
          )}
          {!Icon && <PageTitle id="page-title">{title}</PageTitle>}
          {subtitle && <PageSubtitle>{subtitle}</PageSubtitle>}
        </TitleGroup>

        {contextInfo.length > 0 && (
          <ContextInfo role="status" aria-label="Page context information">
            {contextInfo.map((info, index) => (
              <React.Fragment key={index}>
                {info.type === 'badge' && (
                  <ContextBadge>
                    {info.icon && <info.icon aria-hidden="true" />}
                    {info.text}
                  </ContextBadge>
                )}
                {info.type === 'count' && (
                  <CountBadge>{info.text}</CountBadge>
                )}
              </React.Fragment>
            ))}
          </ContextInfo>
        )}

        {searchProps && (
          <SearchSection role="search" aria-label={searchProps.ariaLabel || 'Search'}>
            <SearchContainer>
              <SearchIcon aria-hidden="true" />
              <SearchInput
                ref={searchInputRef}
                id={searchProps.inputId}
                placeholder={searchProps.placeholder}
                value={searchProps.value}
                onChange={searchProps.onChange}
                onKeyDown={handleKeyDown}
                disabled={searchProps.disabled || searchProps.isLoading}
                aria-label={searchProps.ariaLabel || searchProps.placeholder}
                aria-busy={searchProps.isLoading}
              />
              {searchProps.onSearch && (
                <SearchButton
                  onClick={searchProps.onSearch}
                  disabled={searchProps.disabled || searchProps.isLoading || !searchProps.value?.trim()}
                  $isLoading={searchProps.isLoading}
                  aria-label={searchProps.isLoading ? 'Searching...' : 'Search'}
                >
                  {searchProps.isLoading ? (
                    <>
                      <LoadingSpinner aria-hidden="true" />
                      <span className="sr-only">Searching...</span>
                    </>
                  ) : (
                    <>
                      <ArrowUpIcon aria-hidden="true" />
                      Search
                    </>
                  )}
                </SearchButton>
              )}
            </SearchContainer>
            {searchProps.showHint && !searchProps.isLoading && (
              <SearchHint>
                Press <kbd>Enter</kbd> to search
              </SearchHint>
            )}
          </SearchSection>
        )}

        {children}
      </HeaderContent>
    </HeaderSection>
  );
};

export default EnhancedHeader;

// Export breadcrumb type for consumers
export type { BreadcrumbItem };
```

---

## src/components/ui/EnhancedSummary.tsx

**Path:** `src/components/ui/EnhancedSummary.tsx`

```tsx
/**
 * Enhanced Summary Component
 *
 * Modern, innovative UI for displaying AI-generated summaries with:
 * - Expandable sections with smooth animations
 * - Source citations with relevance indicators
 * - Confidence scoring with visual feedback
 * - Key points with importance badges
 * - Entity extraction display
 * - Processing metrics
 */

import React, { useState, memo } from 'react';
import styled, { keyframes } from 'styled-components';
import {
  SparklesIcon,
  ChevronDownIcon,
  ChevronUpIcon,
  DocumentTextIcon,
  CheckBadgeIcon,
  ClockIcon,
  CpuChipIcon,
  BookmarkIcon,
  TagIcon,
  ArrowTrendingUpIcon,
  ExclamationCircleIcon,
  InformationCircleIcon
} from '@heroicons/react/24/outline';
import { SparklesIcon as SparklesSolid } from '@heroicons/react/24/solid';
import type { SummaryResult, KeyPoint, SourceCitation, ExtractedEntity } from '@/services/advancedRAGService';
import { UnifiedAIResponse } from './UnifiedAIResponse';

// ============================================================================
// Animations
// ============================================================================

const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
`;

const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
`;

// ============================================================================
// Styled Components
// ============================================================================

const Container = styled.div`
  background: ${({ theme }) => theme.isDarkMode
    ? 'rgba(30, 41, 59, 0.95)'
    : 'rgba(255, 255, 255, 0.98)'};
  border-radius: 16px;
  border: 1px solid ${({ theme }) => theme.isDarkMode ? '#334155' : '#e2e8f0'};
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  animation: ${fadeIn} 0.4s ease-out;
`;

const Header = styled.div`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%);
  padding: 20px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    background-size: 200% 100%;
    animation: ${shimmer} 3s infinite;
  }
`;

const HeaderTitle = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  color: white;
  z-index: 1;

  h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    letter-spacing: -0.01em;
  }

  svg {
    width: 24px;
    height: 24px;
  }
`;

const ConfidenceBadge = styled.div<{ $confidence: number }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 14px;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(8px);
  border-radius: 20px;
  color: white;
  font-size: 13px;
  font-weight: 600;
  z-index: 1;

  .bar {
    width: 50px;
    height: 4px;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 2px;
    overflow: hidden;

    .fill {
      height: 100%;
      width: ${({ $confidence }) => $confidence * 100}%;
      background: ${({ $confidence }) =>
        $confidence >= 0.8 ? '#10b981' :
        $confidence >= 0.6 ? '#f59e0b' : '#ef4444'};
      transition: width 0.5s ease;
    }
  }
`;

const Content = styled.div`
  padding: 24px;
`;

const SummaryText = styled.div`
  font-size: 15px;
  line-height: 1.7;
  color: ${({ theme }) => theme.isDarkMode ? '#e2e8f0' : '#374151'};
  margin-bottom: 24px;
`;

const Section = styled.div<{ $isOpen?: boolean }>`
  border: 1px solid ${({ theme }) => theme.isDarkMode ? '#334155' : '#e2e8f0'};
  border-radius: 12px;
  margin-bottom: 16px;
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    border-color: ${({ theme }) => theme.isDarkMode ? '#475569' : '#cbd5e1'};
  }
`;

const SectionHeader = styled.button`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 18px;
  background: ${({ theme }) => theme.isDarkMode ? 'rgba(51, 65, 85, 0.3)' : 'rgba(248, 250, 252, 0.8)'};
  border: none;
  cursor: pointer;
  transition: background 0.2s ease;

  &:hover {
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(51, 65, 85, 0.5)' : 'rgba(241, 245, 249, 1)'};
  }

  .title {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 14px;
    font-weight: 600;
    color: ${({ theme }) => theme.isDarkMode ? '#e2e8f0' : '#1e293b'};

    svg {
      width: 18px;
      height: 18px;
      color: #6366f1;
    }
  }

  .count {
    display: flex;
    align-items: center;
    gap: 8px;

    span {
      font-size: 12px;
      color: ${({ theme }) => theme.isDarkMode ? '#94a3b8' : '#64748b'};
      background: ${({ theme }) => theme.isDarkMode ? '#1e293b' : '#e2e8f0'};
      padding: 4px 10px;
      border-radius: 12px;
      font-weight: 500;
    }

    svg {
      width: 18px;
      height: 18px;
      color: ${({ theme }) => theme.isDarkMode ? '#94a3b8' : '#64748b'};
      transition: transform 0.3s ease;
    }
  }
`;

const SectionContent = styled.div<{ $isOpen: boolean }>`
  max-height: ${({ $isOpen }) => $isOpen ? '500px' : '0'};
  overflow: hidden;
  transition: max-height 0.4s ease;
  padding: ${({ $isOpen }) => $isOpen ? '16px 18px' : '0 18px'};
  background: ${({ theme }) => theme.isDarkMode ? 'transparent' : '#ffffff'};
`;

const KeyPointsList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 10px;
`;

const KeyPointItem = styled.div<{ $importance: string }>`
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px 14px;
  background: ${({ theme, $importance }) => {
    const alpha = theme.isDarkMode ? '0.1' : '0.05';
    const colors: Record<string, string> = {
      critical: `rgba(239, 68, 68, ${alpha})`,
      high: `rgba(245, 158, 11, ${alpha})`,
      medium: `rgba(59, 130, 246, ${alpha})`,
      low: `rgba(107, 114, 128, ${alpha})`
    };
    return colors[$importance] || colors.low;
  }};
  border-radius: 10px;
  border-left: 3px solid ${({ $importance }) => {
    const colors: Record<string, string> = {
      critical: '#ef4444',
      high: '#f59e0b',
      medium: '#3b82f6',
      low: '#6b7280'
    };
    return colors[$importance] || colors.low;
  }};

  .badge {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    flex-shrink: 0;
    background: ${({ $importance }) => {
      const colors: Record<string, string> = {
        critical: '#ef4444',
        high: '#f59e0b',
        medium: '#3b82f6',
        low: '#6b7280'
      };
      return colors[$importance] || colors.low;
    }};
    color: white;

    svg {
      width: 10px;
      height: 10px;
    }
  }

  .text {
    flex: 1;
    font-size: 14px;
    line-height: 1.5;
    color: ${({ theme }) => theme.isDarkMode ? '#e2e8f0' : '#374151'};
  }

  .category {
    font-size: 11px;
    padding: 3px 8px;
    border-radius: 4px;
    background: ${({ theme }) => theme.isDarkMode ? '#334155' : '#e2e8f0'};
    color: ${({ theme }) => theme.isDarkMode ? '#94a3b8' : '#64748b'};
    flex-shrink: 0;
  }
`;


const CitationsList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 10px;
`;

const CitationItem = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 14px;
  background: ${({ theme }) => theme.isDarkMode ? 'rgba(51, 65, 85, 0.3)' : 'rgba(248, 250, 252, 0.8)'};
  border-radius: 10px;
  border: 1px solid ${({ theme }) => theme.isDarkMode ? '#334155' : '#e2e8f0'};

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;

    .title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 600;
      color: ${({ theme }) => theme.isDarkMode ? '#e2e8f0' : '#1e293b'};

      svg {
        width: 16px;
        height: 16px;
        color: #6366f1;
      }
    }

    .relevance {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 6px;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: white;
      font-weight: 600;
    }
  }

  .excerpt {
    font-size: 13px;
    line-height: 1.5;
    color: ${({ theme }) => theme.isDarkMode ? '#94a3b8' : '#64748b'};
    font-style: italic;
  }

  .section {
    font-size: 11px;
    color: ${({ theme }) => theme.isDarkMode ? '#64748b' : '#94a3b8'};
  }
`;

const EntitiesGrid = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
`;

const EntityTag = styled.div<{ $type: string }>`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  background: ${({ $type, theme }) => {
    const alpha = theme.isDarkMode ? '0.2' : '0.1';
    const colors: Record<string, string> = {
      amount: `rgba(16, 185, 129, ${alpha})`,
      date: `rgba(59, 130, 246, ${alpha})`,
      state: `rgba(139, 92, 246, ${alpha})`,
      coverage: `rgba(245, 158, 11, ${alpha})`,
      limit: `rgba(239, 68, 68, ${alpha})`,
      deductible: `rgba(6, 182, 212, ${alpha})`,
      form: `rgba(236, 72, 153, ${alpha})`,
      rule: `rgba(99, 102, 241, ${alpha})`
    };
    return colors[$type] || colors.coverage;
  }};
  color: ${({ $type }) => {
    const colors: Record<string, string> = {
      amount: '#10b981',
      date: '#3b82f6',
      state: '#8b5cf6',
      coverage: '#f59e0b',
      limit: '#ef4444',
      deductible: '#06b6d4',
      form: '#ec4899',
      rule: '#6366f1'
    };
    return colors[$type] || colors.coverage;
  }};

  svg {
    width: 12px;
    height: 12px;
  }

  .frequency {
    font-size: 10px;
    padding: 2px 5px;
    border-radius: 6px;
    background: currentColor;
    color: white;
  }
`;

const MetricsBar = styled.div`
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 16px 24px;
  background: ${({ theme }) => theme.isDarkMode ? 'rgba(51, 65, 85, 0.3)' : 'rgba(248, 250, 252, 0.8)'};
  border-top: 1px solid ${({ theme }) => theme.isDarkMode ? '#334155' : '#e2e8f0'};
  flex-wrap: wrap;
`;

const MetricItem = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: ${({ theme }) => theme.isDarkMode ? '#94a3b8' : '#64748b'};

  svg {
    width: 14px;
    height: 14px;
    opacity: 0.7;
  }

  .value {
    font-weight: 600;
    color: ${({ theme }) => theme.isDarkMode ? '#e2e8f0' : '#1e293b'};
  }
`;

const MethodologyTag = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 600;
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
  color: #6366f1;

  svg {
    width: 12px;
    height: 12px;
  }
`;


// ============================================================================
// Component Props
// ============================================================================

interface EnhancedSummaryProps {
  result: SummaryResult;
  title?: string;
  showMetrics?: boolean;
  defaultExpanded?: boolean;
  onCitationClick?: (citation: SourceCitation) => void;
}

// ============================================================================
// Sub-Components
// ============================================================================

const KeyPointsSection = memo(({
  keyPoints,
  isOpen,
  onToggle
}: {
  keyPoints: KeyPoint[];
  isOpen: boolean;
  onToggle: () => void;
}) => (
  <Section $isOpen={isOpen}>
    <SectionHeader onClick={onToggle}>
      <div className="title">
        <BookmarkIcon />
        Key Points
      </div>
      <div className="count">
        <span>{keyPoints.length} points</span>
        {isOpen ? <ChevronUpIcon /> : <ChevronDownIcon />}
      </div>
    </SectionHeader>
    <SectionContent $isOpen={isOpen}>
      <KeyPointsList>
        {keyPoints.map((point, idx) => (
          <KeyPointItem key={idx} $importance={point.importance}>
            <div className="badge">
              {point.importance === 'critical' && <ExclamationCircleIcon />}
              {point.importance === 'high' && <ArrowTrendingUpIcon />}
              {point.importance === 'medium' && <InformationCircleIcon />}
              {point.importance}
            </div>
            <div className="text">{point.text}</div>
            <div className="category">{point.category}</div>
          </KeyPointItem>
        ))}
      </KeyPointsList>
    </SectionContent>
  </Section>
));

KeyPointsSection.displayName = 'KeyPointsSection';

const CitationsSection = memo(({
  citations,
  isOpen,
  onToggle,
  onCitationClick
}: {
  citations: SourceCitation[];
  isOpen: boolean;
  onToggle: () => void;
  onCitationClick?: (citation: SourceCitation) => void;
}) => (
  <Section $isOpen={isOpen}>
    <SectionHeader onClick={onToggle}>
      <div className="title">
        <DocumentTextIcon />
        Source Citations
      </div>
      <div className="count">
        <span>{citations.length} sources</span>
        {isOpen ? <ChevronUpIcon /> : <ChevronDownIcon />}
      </div>
    </SectionHeader>
    <SectionContent $isOpen={isOpen}>
      <CitationsList>
        {citations.map((citation) => (
          <CitationItem
            key={citation.id}
            onClick={() => onCitationClick?.(citation)}
            style={{ cursor: onCitationClick ? 'pointer' : 'default' }}
          >
            <div className="header">
              <div className="title">
                <DocumentTextIcon />
                {citation.documentTitle}
              </div>
              <div className="relevance">{Math.round(citation.relevance * 100)}% match</div>
            </div>
            {citation.section && <div className="section">Section: {citation.section}</div>}
            <div className="excerpt">"{citation.excerpt}"</div>
          </CitationItem>
        ))}
      </CitationsList>
    </SectionContent>
  </Section>
));

CitationsSection.displayName = 'CitationsSection';

const EntitiesSection = memo(({
  entities,
  isOpen,
  onToggle
}: {
  entities: ExtractedEntity[];
  isOpen: boolean;
  onToggle: () => void;
}) => (
  <Section $isOpen={isOpen}>
    <SectionHeader onClick={onToggle}>
      <div className="title">
        <TagIcon />
        Extracted Entities
      </div>
      <div className="count">
        <span>{entities.length} entities</span>
        {isOpen ? <ChevronUpIcon /> : <ChevronDownIcon />}
      </div>
    </SectionHeader>
    <SectionContent $isOpen={isOpen}>
      <EntitiesGrid>
        {entities.map((entity, idx) => (
          <EntityTag key={idx} $type={entity.type}>
            {entity.name}
            {entity.frequency > 1 && (
              <span className="frequency">Ã—{entity.frequency}</span>
            )}
          </EntityTag>
        ))}
      </EntitiesGrid>
    </SectionContent>
  </Section>
));

EntitiesSection.displayName = 'EntitiesSection';


// ============================================================================
// Main Component
// ============================================================================

export const EnhancedSummary: React.FC<EnhancedSummaryProps> = memo(({
  result,
  title = 'AI Summary',
  showMetrics = true,
  defaultExpanded = false,
  onCitationClick
}) => {
  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>({
    keyPoints: defaultExpanded,
    citations: false,
    entities: false
  });

  const toggleSection = (section: string) => {
    setExpandedSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };

  const { summary, keyPoints, entities, sourceCitations, confidence, methodology, processingMetrics } = result;

  return (
    <Container>
      <Header>
        <HeaderTitle>
          <SparklesSolid />
          <h3>{title}</h3>
        </HeaderTitle>
        <ConfidenceBadge $confidence={confidence}>
          <CheckBadgeIcon style={{ width: 16, height: 16 }} />
          {Math.round(confidence * 100)}% Confidence
          <div className="bar">
            <div className="fill" />
          </div>
        </ConfidenceBadge>
      </Header>

      <Content>
        <SummaryText>
          <UnifiedAIResponse content={summary} />
        </SummaryText>

        {keyPoints.length > 0 && (
          <KeyPointsSection
            keyPoints={keyPoints}
            isOpen={expandedSections.keyPoints}
            onToggle={() => toggleSection('keyPoints')}
          />
        )}

        {sourceCitations.length > 0 && (
          <CitationsSection
            citations={sourceCitations}
            isOpen={expandedSections.citations}
            onToggle={() => toggleSection('citations')}
            onCitationClick={onCitationClick}
          />
        )}

        {entities.length > 0 && (
          <EntitiesSection
            entities={entities}
            isOpen={expandedSections.entities}
            onToggle={() => toggleSection('entities')}
          />
        )}
      </Content>

      {showMetrics && (
        <MetricsBar>
          <MethodologyTag>
            <CpuChipIcon />
            {methodology}
          </MethodologyTag>
          <MetricItem>
            <DocumentTextIcon />
            <span className="value">{processingMetrics.totalDocuments}</span> documents
          </MetricItem>
          <MetricItem>
            <SparklesIcon />
            <span className="value">{processingMetrics.totalChunks}</span> chunks
          </MetricItem>
          <MetricItem>
            <ClockIcon />
            <span className="value">{(processingMetrics.processingTimeMs / 1000).toFixed(1)}s</span>
          </MetricItem>
          <MetricItem>
            Compression: <span className="value">{Math.round(processingMetrics.compressionRatio * 100)}%</span>
          </MetricItem>
        </MetricsBar>
      )}
    </Container>
  );
});

EnhancedSummary.displayName = 'EnhancedSummary';

export default EnhancedSummary;
```

---

## src/components/ui/Icon.tsx

**Path:** `src/components/ui/Icon.tsx`

```tsx
/**
 * Icon - Unified icon component with accessibility and consistent sizing
 * 
 * Provides a wrapper for Heroicons (or any SVG icon) with:
 * - Consistent sizing scale
 * - Accessibility support (aria-label, aria-hidden)
 * - Color theming
 * - Optional animation
 */

import React from 'react';
import styled, { css, keyframes } from 'styled-components';

// Icon size scale
const sizeMap = {
  xs: 12,
  sm: 16,
  md: 20,
  lg: 24,
  xl: 32,
  '2xl': 40,
} as const;

type IconSize = keyof typeof sizeMap;

interface IconProps {
  /** The icon component to render (e.g., PlusIcon from Heroicons) */
  icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
  /** Size of the icon */
  size?: IconSize;
  /** Custom size in pixels (overrides size prop) */
  customSize?: number;
  /** Color of the icon (theme color key or CSS color) */
  color?: string;
  /** Accessible label - required when icon is standalone (not decorative) */
  label?: string;
  /** Additional CSS class */
  className?: string;
  /** Animation variant */
  animation?: 'spin' | 'pulse' | 'bounce' | 'none';
  /** Click handler */
  onClick?: () => void;
}

// Animations
const spin = keyframes`
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
`;

const bounce = keyframes`
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-2px); }
`;

const getAnimation = (animation: IconProps['animation']) => {
  switch (animation) {
    case 'spin':
      return css`animation: ${spin} 1s linear infinite;`;
    case 'pulse':
      return css`animation: ${pulse} 1.5s ease-in-out infinite;`;
    case 'bounce':
      return css`animation: ${bounce} 1s ease-in-out infinite;`;
    default:
      return '';
  }
};

const IconWrapper = styled.span<{
  $size: number;
  $color?: string;
  $animation?: IconProps['animation'];
  $clickable?: boolean;
}>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: ${({ $size }) => $size}px;
  height: ${({ $size }) => $size}px;
  flex-shrink: 0;
  color: ${({ $color, theme }) => {
    if (!$color) return 'currentColor';
    // Check if it's a theme color key
    if ($color in (theme.colours || {})) {
      return (theme.colours as Record<string, string>)[$color];
    }
    return $color;
  }};
  ${({ $animation }) => $animation && getAnimation($animation)}
  ${({ $clickable }) => $clickable && css`
    cursor: pointer;
    transition: opacity 0.2s ease, transform 0.2s ease;
    
    &:hover {
      opacity: 0.8;
    }
    
    &:active {
      transform: scale(0.95);
    }
  `}

  svg {
    width: 100%;
    height: 100%;
  }
`;

/**
 * Icon component for rendering icons with consistent sizing and accessibility
 * 
 * @example
 * // Decorative icon (aria-hidden automatically applied)
 * <Icon icon={CheckIcon} size="md" color="success" />
 * 
 * @example
 * // Accessible standalone icon
 * <Icon icon={PlusIcon} size="lg" label="Add item" onClick={handleAdd} />
 */
export const Icon: React.FC<IconProps> = ({
  icon: IconComponent,
  size = 'md',
  customSize,
  color,
  label,
  className,
  animation = 'none',
  onClick,
}) => {
  const pixelSize = customSize ?? sizeMap[size];
  const isInteractive = !!onClick;
  const isDecorative = !label;

  return (
    <IconWrapper
      $size={pixelSize}
      $color={color}
      $animation={animation}
      $clickable={isInteractive}
      className={className}
      onClick={onClick}
      role={isInteractive ? 'button' : undefined}
      tabIndex={isInteractive ? 0 : undefined}
      aria-label={label}
      aria-hidden={isDecorative}
      onKeyDown={isInteractive ? (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onClick?.();
        }
      } : undefined}
    >
      <IconComponent />
    </IconWrapper>
  );
};

export default Icon;
export { sizeMap as iconSizes };
export type { IconSize, IconProps };

```

---

## src/components/ui/Input.tsx

**Path:** `src/components/ui/Input.tsx`

```tsx
import React from 'react';
import styled, { css } from 'styled-components';

/* ---------- Input State Types ---------- */
type InputState = 'default' | 'error' | 'success' | 'warning';
type InputSize = 'sm' | 'md' | 'lg';

/* ---------- Input Wrapper for Labels & Helper Text ---------- */
const InputWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 6px;
  width: 100%;
`;

const Label = styled.label<{ $required?: boolean; $disabled?: boolean }>`
  font-size: 14px;
  font-weight: 500;
  color: ${({ theme, $disabled }) => $disabled ? theme.colours.textMuted : theme.colours.text};
  display: flex;
  align-items: center;
  gap: 4px;

  ${({ $required }) => $required && css`
    &::after {
      content: '*';
      color: #ef4444;
      font-weight: 600;
    }
  `}
`;

const HelperText = styled.span<{ $state?: InputState }>`
  font-size: 13px;
  line-height: 1.4;
  display: flex;
  align-items: center;
  gap: 6px;

  ${({ $state, theme }) => {
    switch ($state) {
      case 'error':
        return css`color: ${theme.colours.error};`;
      case 'success':
        return css`color: ${theme.colours.success};`;
      case 'warning':
        return css`color: ${theme.colours.warning};`;
      default:
        return css`color: ${theme.colours.textSecondary};`;
    }
  }}

  svg {
    width: 14px;
    height: 14px;
    flex-shrink: 0;
  }
`;

const CharacterCount = styled.span<{ $isNearLimit?: boolean; $isOverLimit?: boolean }>`
  font-size: 12px;
  color: ${({ theme, $isOverLimit, $isNearLimit }) =>
    $isOverLimit ? theme.colours.error :
    $isNearLimit ? theme.colours.warning :
    theme.colours.textMuted};
  margin-left: auto;
  transition: color 0.2s ease;
`;

/* ---------- Input Container for Icons ---------- */
const InputContainer = styled.div<{ $hasLeftIcon?: boolean; $hasRightIcon?: boolean }>`
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;

  ${({ $hasLeftIcon }) => $hasLeftIcon && css`
    input {
      padding-left: 44px;
    }
  `}

  ${({ $hasRightIcon }) => $hasRightIcon && css`
    input {
      padding-right: 44px;
    }
  `}
`;

const IconWrapper = styled.span<{ $position: 'left' | 'right'; $size?: InputSize }>`
  position: absolute;
  ${({ $position }) => $position === 'left' ? 'left: 14px;' : 'right: 14px;'}
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${({ theme }) => theme.colours.textSecondary};
  pointer-events: none;
  transition: color 0.2s ease;

  svg {
    width: ${({ $size }) => $size === 'sm' ? '16px' : $size === 'lg' ? '20px' : '18px'};
    height: ${({ $size }) => $size === 'sm' ? '16px' : $size === 'lg' ? '20px' : '18px'};
  }
`;

/* ---------- Size Styles ---------- */
const sizeStyles = {
  sm: css`
    padding: 8px 12px;
    font-size: 13px;
    border-radius: 6px;
    min-height: 36px;
  `,
  md: css`
    padding: 12px 16px;
    font-size: 14px;
    border-radius: 8px;
    min-height: 44px;
  `,
  lg: css`
    padding: 14px 18px;
    font-size: 16px;
    border-radius: 10px;
    min-height: 52px;
  `,
};

/* ---------- State Styles ---------- */
const stateStyles = {
  default: css`
    border-color: ${({ theme }) => theme.colours.border};

    &:hover:not(:disabled):not(:focus) {
      border-color: ${({ theme }) => theme.colours.textSecondary};
    }

    &:focus {
      border-color: ${({ theme }) => theme.colours.primary};
      box-shadow: 0 0 0 3px ${({ theme }) => theme.colours.focusRing};
    }
  `,
  error: css`
    border-color: ${({ theme }) => theme.colours.error};
    background-color: ${({ theme }) => theme.colours.errorLight}20;

    &:focus {
      border-color: ${({ theme }) => theme.colours.error};
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.15);
    }
  `,
  success: css`
    border-color: ${({ theme }) => theme.colours.success};
    background-color: ${({ theme }) => theme.colours.successLight}20;

    &:focus {
      border-color: ${({ theme }) => theme.colours.success};
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.15);
    }
  `,
  warning: css`
    border-color: ${({ theme }) => theme.colours.warning};
    background-color: ${({ theme }) => theme.colours.warningLight}20;

    &:focus {
      border-color: ${({ theme }) => theme.colours.warning};
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.15);
    }
  `,
};

/* ---------- Base Text Input ---------- */
export const TextInput = styled.input.withConfig({
  shouldForwardProp: (prop) => !['$state', '$size'].includes(prop),
})<{ $state?: InputState; $size?: InputSize }>`
  width: 100%;
  font-family: ${({ theme }) => theme.font};
  color: ${({ theme }) => theme.colours.text};
  background-color: ${({ theme }) => theme.colours.background};
  border: 1.5px solid ${({ theme }) => theme.colours.border};
  outline: none;
  transition: all 0.2s ease;

  ${({ $size = 'md' }) => sizeStyles[$size]}
  ${({ $state = 'default' }) => stateStyles[$state]}

  &::placeholder {
    color: ${({ theme }) => theme.colours.textMuted};
  }

  &:disabled {
    background-color: ${({ theme }) => theme.colours.backgroundAlt};
    color: ${({ theme }) => theme.colours.textMuted};
    cursor: not-allowed;
    opacity: 0.7;
  }

  &:read-only {
    background-color: ${({ theme }) => theme.colours.backgroundAlt};
    cursor: default;
  }

  /* Remove default browser styling for autofill */
  &:-webkit-autofill,
  &:-webkit-autofill:hover,
  &:-webkit-autofill:focus {
    -webkit-box-shadow: 0 0 0px 1000px ${({ theme }) => theme.colours.background} inset;
    -webkit-text-fill-color: ${({ theme }) => theme.colours.text};
    transition: background-color 5000s ease-in-out 0s;
  }
`;

/* ---------- Textarea Component ---------- */
export const TextArea = styled.textarea.withConfig({
  shouldForwardProp: (prop) => !['$state', '$size'].includes(prop),
})<{ $state?: InputState; $size?: InputSize; $resize?: 'none' | 'vertical' | 'horizontal' | 'both' }>`
  width: 100%;
  font-family: ${({ theme }) => theme.font};
  color: ${({ theme }) => theme.colours.text};
  background-color: ${({ theme }) => theme.colours.background};
  border: 1.5px solid ${({ theme }) => theme.colours.border};
  outline: none;
  transition: all 0.2s ease;
  resize: ${({ $resize = 'vertical' }) => $resize};
  min-height: 100px;

  ${({ $size = 'md' }) => sizeStyles[$size]}
  ${({ $state = 'default' }) => stateStyles[$state]}

  &::placeholder {
    color: ${({ theme }) => theme.colours.textMuted};
  }

  &:disabled {
    background-color: ${({ theme }) => theme.colours.backgroundAlt};
    color: ${({ theme }) => theme.colours.textMuted};
    cursor: not-allowed;
    opacity: 0.7;
  }
`;

/* ---------- Select Component ---------- */
export const Select = styled.select.withConfig({
  shouldForwardProp: (prop) => !['$state', '$size'].includes(prop),
})<{ $state?: InputState; $size?: InputSize }>`
  width: 100%;
  font-family: ${({ theme }) => theme.font};
  color: ${({ theme }) => theme.colours.text};
  background-color: ${({ theme }) => theme.colours.background};
  border: 1.5px solid ${({ theme }) => theme.colours.border};
  outline: none;
  transition: all 0.2s ease;
  cursor: pointer;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 14px center;
  padding-right: 40px;

  ${({ $size = 'md' }) => sizeStyles[$size]}
  ${({ $state = 'default' }) => stateStyles[$state]}

  &:disabled {
    background-color: ${({ theme }) => theme.colours.backgroundAlt};
    color: ${({ theme }) => theme.colours.textMuted};
    cursor: not-allowed;
    opacity: 0.7;
  }

  option {
    padding: 8px;
  }
`;

/* ---------- Checkbox Component ---------- */
export const Checkbox = styled.input.attrs({ type: 'checkbox' })`
  appearance: none;
  width: 18px;
  height: 18px;
  border: 1.5px solid ${({ theme }) => theme.colours.border};
  border-radius: 4px;
  background-color: ${({ theme }) => theme.colours.background};
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;

  &:hover:not(:disabled) {
    border-color: ${({ theme }) => theme.colours.primary};
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colours.focusRing};
  }

  &:checked {
    background-color: ${({ theme }) => theme.colours.primary};
    border-color: ${({ theme }) => theme.colours.primary};
  }

  &:checked::after {
    content: '';
    position: absolute;
    left: 5px;
    top: 2px;
    width: 5px;
    height: 10px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

/* ---------- Radio Component ---------- */
export const Radio = styled.input.attrs({ type: 'radio' })`
  appearance: none;
  width: 18px;
  height: 18px;
  border: 1.5px solid ${({ theme }) => theme.colours.border};
  border-radius: 50%;
  background-color: ${({ theme }) => theme.colours.background};
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;

  &:hover:not(:disabled) {
    border-color: ${({ theme }) => theme.colours.primary};
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colours.focusRing};
  }

  &:checked {
    border-color: ${({ theme }) => theme.colours.primary};
  }

  &:checked::after {
    content: '';
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: ${({ theme }) => theme.colours.primary};
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

/* ---------- Export Helper Components ---------- */
export { InputWrapper, Label, HelperText, CharacterCount, InputContainer, IconWrapper };
```

---

## src/components/ui/Layout.tsx

**Path:** `src/components/ui/Layout.tsx`

```tsx
import styled from 'styled-components';

export const Page = styled.div`
  min-height:100vh;
  padding:24px;
`;

export const Container = styled.div`
  max-width:1400px;
  margin:0 auto;
  width:100%;
`;

export const PageHeader = styled.header`
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:32px;
`;

export const Title = styled.h1`
  font-size:32px;
  font-weight:600;
  background:${({ theme }) => theme.colours.gradient};
  -webkit-background-clip:text;
  color:transparent;
`;
```

---

## src/components/ui/LoadingSpinner.tsx

**Path:** `src/components/ui/LoadingSpinner.tsx`

```tsx
import React from 'react';
import styled, { keyframes, css } from 'styled-components';

/* ---------- Animations ---------- */
const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

const pulse = keyframes`
  0%, 80%, 100% {
    transform: scale(0);
    opacity: 0.5;
  }
  40% {
    transform: scale(1);
    opacity: 1;
  }
`;

const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

/* ---------- Types ---------- */
type SpinnerType = 'circular' | 'dots' | 'bars' | 'ring';
type SpinnerSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | string;

interface LoadingSpinnerProps {
  type?: SpinnerType;
  size?: SpinnerSize;
  color?: string;
  className?: string;
  label?: string;
  overlay?: boolean;
  fullScreen?: boolean;
  centered?: boolean;
}

/* ---------- Size Presets ---------- */
const sizePresets: Record<string, { size: string; borderWidth: string; dotSize: string; gap: string }> = {
  xs: { size: '12px', borderWidth: '1.5px', dotSize: '3px', gap: '2px' },
  sm: { size: '16px', borderWidth: '2px', dotSize: '4px', gap: '2px' },
  md: { size: '24px', borderWidth: '2.5px', dotSize: '5px', gap: '3px' },
  lg: { size: '32px', borderWidth: '3px', dotSize: '6px', gap: '4px' },
  xl: { size: '48px', borderWidth: '4px', dotSize: '8px', gap: '5px' },
};

const getSizeConfig = (size: SpinnerSize) => {
  if (typeof size === 'string' && sizePresets[size]) {
    return sizePresets[size];
  }
  // Custom size - calculate proportional values
  const numericSize = parseInt(size as string, 10) || 16;
  return {
    size: typeof size === 'string' && size.includes('px') ? size : `${numericSize}px`,
    borderWidth: `${Math.max(1.5, numericSize / 8)}px`,
    dotSize: `${Math.max(3, numericSize / 4)}px`,
    gap: `${Math.max(2, numericSize / 8)}px`,
  };
};

/* ---------- Styled Components ---------- */
const SpinnerContainer = styled.div<{ $centered?: boolean }>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 12px;

  ${({ $centered }) => $centered && css`
    width: 100%;
    height: 100%;
    min-height: 120px;
  `}
`;

const OverlayContainer = styled.div<{ $fullScreen?: boolean }>`
  position: ${({ $fullScreen }) => $fullScreen ? 'fixed' : 'absolute'};
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 16px;
  background: rgba(255, 255, 255, 0.85);
  backdrop-filter: blur(4px);
  z-index: ${({ theme }) => theme.zIndex?.overlay || 300};
  animation: ${fadeIn} 0.2s ease-out;
`;

const CircularSpinner = styled.div.withConfig({
  shouldForwardProp: (prop) => !['$size', '$color', '$borderWidth'].includes(prop),
})<{ $size: string; $color: string; $borderWidth: string }>`
  width: ${props => props.$size};
  height: ${props => props.$size};
  border: ${props => props.$borderWidth} solid rgba(0, 0, 0, 0.1);
  border-top-color: ${props => props.$color};
  border-radius: 50%;
  animation: ${spin} 0.8s linear infinite;
`;

const RingSpinner = styled.div.withConfig({
  shouldForwardProp: (prop) => !['$size', '$color', '$borderWidth'].includes(prop),
})<{ $size: string; $color: string; $borderWidth: string }>`
  width: ${props => props.$size};
  height: ${props => props.$size};
  border: ${props => props.$borderWidth} solid transparent;
  border-top-color: ${props => props.$color};
  border-bottom-color: ${props => props.$color};
  border-radius: 50%;
  animation: ${spin} 1s linear infinite;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    right: 2px;
    bottom: 2px;
    border: ${props => props.$borderWidth} solid transparent;
    border-left-color: ${props => props.$color};
    border-right-color: ${props => props.$color};
    border-radius: 50%;
    animation: ${spin} 0.5s linear infinite reverse;
    opacity: 0.6;
  }
`;

const DotsContainer = styled.div<{ $gap: string }>`
  display: inline-flex;
  align-items: center;
  gap: ${props => props.$gap};
`;

const Dot = styled.div.withConfig({
  shouldForwardProp: (prop) => !['$color', '$delay', '$size'].includes(prop),
})<{ $color: string; $delay: string; $size: string }>`
  width: ${props => props.$size};
  height: ${props => props.$size};
  background-color: ${props => props.$color};
  border-radius: 50%;
  animation: ${pulse} 1.4s ease-in-out infinite both;
  animation-delay: ${props => props.$delay};
`;

const BarsContainer = styled.div.withConfig({
  shouldForwardProp: (prop) => !['$size', '$gap'].includes(prop),
})<{ $size: string; $gap: string }>`
  display: inline-flex;
  align-items: center;
  gap: ${props => props.$gap};
  height: ${props => props.$size};
`;

const Bar = styled.div.withConfig({
  shouldForwardProp: (prop) => !['$color', '$delay', '$width'].includes(prop),
})<{ $color: string; $delay: string; $width: string }>`
  width: ${props => props.$width};
  height: 100%;
  background-color: ${props => props.$color};
  border-radius: 2px;
  animation: ${pulse} 1.2s ease-in-out infinite;
  animation-delay: ${props => props.$delay};
`;

const Label = styled.span`
  font-size: 14px;
  font-weight: 500;
  color: #6b7280;
  text-align: center;
`;

/* ---------- Main Component ---------- */
const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  type = 'circular',
  size = 'md',
  color = '#6366f1',
  className = '',
  label,
  overlay = false,
  fullScreen = false,
  centered = false,
}) => {
  const sizeConfig = getSizeConfig(size);

  const renderSpinner = () => {
    switch (type) {
      case 'dots':
        return (
          <DotsContainer $gap={sizeConfig.gap}>
            <Dot $color={color} $delay="0s" $size={sizeConfig.dotSize} />
            <Dot $color={color} $delay="0.16s" $size={sizeConfig.dotSize} />
            <Dot $color={color} $delay="0.32s" $size={sizeConfig.dotSize} />
          </DotsContainer>
        );

      case 'bars':
        return (
          <BarsContainer $size={sizeConfig.size} $gap={sizeConfig.gap}>
            <Bar $color={color} $delay="0s" $width={sizeConfig.gap} />
            <Bar $color={color} $delay="0.1s" $width={sizeConfig.gap} />
            <Bar $color={color} $delay="0.2s" $width={sizeConfig.gap} />
            <Bar $color={color} $delay="0.3s" $width={sizeConfig.gap} />
          </BarsContainer>
        );

      case 'ring':
        return (
          <RingSpinner
            $size={sizeConfig.size}
            $color={color}
            $borderWidth={sizeConfig.borderWidth}
          />
        );

      case 'circular':
      default:
        return (
          <CircularSpinner
            $size={sizeConfig.size}
            $color={color}
            $borderWidth={sizeConfig.borderWidth}
          />
        );
    }
  };

  const spinnerContent = (
    <>
      {renderSpinner()}
      {label && <Label>{label}</Label>}
    </>
  );

  // Overlay variant
  if (overlay || fullScreen) {
    return (
      <OverlayContainer
        $fullScreen={fullScreen}
        role="status"
        aria-live="polite"
        aria-label={label || 'Loading'}
      >
        {spinnerContent}
      </OverlayContainer>
    );
  }

  return (
    <SpinnerContainer
      className={className}
      $centered={centered}
      role="status"
      aria-live="polite"
      aria-label={label || 'Loading'}
    >
      {spinnerContent}
    </SpinnerContainer>
  );
};

/* ---------- Page Loading Spinner - Full page overlay ---------- */
export const PageLoadingSpinner: React.FC<{ label?: string }> = ({ label = 'Loading...' }) => (
  <LoadingSpinner
    type="ring"
    size="lg"
    fullScreen
    label={label}
  />
);

/* ---------- Inline Loading Spinner - For buttons and inline content ---------- */
export const InlineSpinner: React.FC<{ size?: SpinnerSize; color?: string }> = ({
  size = 'sm',
  color = 'currentColor'
}) => (
  <LoadingSpinner type="circular" size={size} color={color} />
);

/* ---------- Content Loading Spinner - For content areas ---------- */
export const ContentLoadingSpinner: React.FC<{ label?: string }> = ({ label }) => (
  <LoadingSpinner type="dots" size="md" centered label={label} />
);

export default LoadingSpinner;
```

---

## src/components/ui/Navigation.tsx

**Path:** `src/components/ui/Navigation.tsx`

```tsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Link, useLocation, useNavigate } from 'react-router-dom';
import styled, { keyframes, css } from 'styled-components';
import { signOut } from 'firebase/auth';
import { auth } from '../../firebase';
import { UserIcon, Cog6ToothIcon, ArrowLeftOnRectangleIcon, Bars3Icon, XMarkIcon, SparklesIcon } from '@heroicons/react/24/outline';
import logger, { LOG_CATEGORIES } from '../../utils/logger';
import { Tooltip } from './Tooltip';

/* ---------- animations ---------- */
const slideDown = keyframes`
  from {
    opacity: 0;
    transform: translateY(-8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

const slideIn = keyframes`
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
`;

const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
`;

const gradientFlow = keyframes`
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
`;

/* ---------- styled components ---------- */
const NavigationWrapper = styled.div<{ $scrolled?: boolean }>`
  position: sticky;
  top: 0;
  z-index: 100;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.95));
  backdrop-filter: blur(20px) saturate(180%);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);

  ${props => props.$scrolled && css`
    box-shadow:
      0 1px 0 rgba(0, 0, 0, 0.04),
      0 4px 24px rgba(0, 0, 0, 0.06);
    background: rgba(255, 255, 255, 0.92);
  `}

  &::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(99, 102, 241, 0.15) 20%,
      rgba(139, 92, 246, 0.2) 50%,
      rgba(99, 102, 241, 0.15) 80%,
      transparent 100%
    );
    opacity: ${props => props.$scrolled ? 1 : 0.5};
    transition: opacity 0.3s ease;
  }
`;

const Navigation = styled.nav`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 40px;
  position: relative;
  z-index: 10;
  max-width: 1600px;
  margin: 0 auto;
  gap: 32px;

  @media (max-width: 1200px) {
    padding: 8px 24px;
    gap: 20px;
  }

  @media (max-width: 768px) {
    padding: 8px 16px;
  }
`;

/* ---------- Logo & Brand ---------- */
const LogoSection = styled(Link)`
  display: flex;
  align-items: center;
  gap: 10px;
  text-decoration: none;
  padding: 6px 8px;
  margin: -6px -8px;
  border-radius: 12px;
  transition: all 0.2s ease;
  flex-shrink: 0;

  &:hover {
    background: rgba(99, 102, 241, 0.04);
  }

  &:active {
    transform: scale(0.98);
  }
`;

const LogoIcon = styled.div`
  width: 36px;
  height: 36px;
  border-radius: 10px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%);
  background-size: 200% 200%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  box-shadow:
    0 2px 8px rgba(99, 102, 241, 0.3),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
  transition: all 0.3s ease;

  ${LogoSection}:hover & {
    animation: ${gradientFlow} 3s ease infinite;
    box-shadow:
      0 4px 16px rgba(99, 102, 241, 0.4),
      inset 0 1px 0 rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
  }

  svg {
    width: 20px;
    height: 20px;
  }

  @media (max-width: 768px) {
    width: 32px;
    height: 32px;

    svg {
      width: 18px;
      height: 18px;
    }
  }
`;

const LogoText = styled.div`
  display: flex;
  flex-direction: column;
  line-height: 1.1;

  @media (max-width: 640px) {
    display: none;
  }
`;

const LogoBrand = styled.span`
  font-weight: 600;
  font-size: 15px;
  background: linear-gradient(135deg, #0f172a 0%, #334155 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  letter-spacing: -0.015em;
  white-space: nowrap;

  @media (max-width: 900px) {
    font-size: 14px;
  }
`;

const LogoTagline = styled.span`
  font-size: 9px;
  font-weight: 600;
  color: #94a3b8;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  margin-top: 1px;
`;

/* ---------- Nav List ---------- */
const NavList = styled.ul`
  display: flex;
  list-style: none;
  margin: 0;
  padding: 5px 6px;
  gap: 2px;
  background: rgba(241, 245, 249, 0.7);
  border-radius: 14px;
  border: 1px solid rgba(226, 232, 240, 0.6);
  flex: 1;
  justify-content: center;
  max-width: 800px;

  @media (max-width: 1200px) {
    max-width: 680px;
  }

  @media (max-width: 1024px) {
    gap: 0;
    padding: 4px;
    max-width: 580px;
  }

  @media (max-width: 768px) {
    display: none;
  }
`;

const NavItem = styled.li``;

/* ---------- Mobile Menu Components ---------- */
const MobileMenuButton = styled.button`
  display: none;
  background: rgba(241, 245, 249, 0.8);
  border: 1px solid rgba(226, 232, 240, 0.6);
  padding: 8px;
  cursor: pointer;
  color: #64748b;
  border-radius: 10px;
  transition: all 0.2s ease;

  @media (max-width: 768px) {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    border-color: rgba(99, 102, 241, 0.2);
    color: #6366f1;
    transform: scale(1.02);
  }

  &:active {
    transform: scale(0.98);
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }

  svg {
    width: 22px;
    height: 22px;
  }
`;

const MobileMenuOverlay = styled.div<{ $isOpen: boolean }>`
  display: none;

  @media (max-width: 768px) {
    display: ${({ $isOpen }) => $isOpen ? 'block' : 'none'};
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(15, 23, 42, 0.5);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    z-index: 998;
    animation: ${fadeIn} 0.25s ease-out;
  }
`;

const MobileMenu = styled.div<{ $isOpen: boolean }>`
  display: none;

  @media (max-width: 768px) {
    display: ${({ $isOpen }) => $isOpen ? 'flex' : 'none'};
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    width: 300px;
    max-width: 85vw;
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    flex-direction: column;
    z-index: 999;
    animation: ${slideIn} 0.35s cubic-bezier(0.22, 1, 0.36, 1);
    box-shadow:
      -16px 0 48px rgba(0, 0, 0, 0.12),
      -4px 0 16px rgba(0, 0, 0, 0.06);
    overflow-y: auto;
  }
`;

const MobileMenuHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(to bottom, white, rgba(248, 250, 252, 0.5));
`;

const MobileMenuTitle = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
`;

const MobileLogoIcon = styled.div`
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);

  svg {
    width: 18px;
    height: 18px;
  }
`;

const MobileMenuBrand = styled.span`
  font-weight: 700;
  font-size: 15px;
  color: #1e293b;
  letter-spacing: -0.01em;
`;

const MobileCloseButton = styled.button`
  background: rgba(241, 245, 249, 0.8);
  border: 1px solid rgba(226, 232, 240, 0.6);
  padding: 8px;
  cursor: pointer;
  color: #64748b;
  border-radius: 10px;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(239, 68, 68, 0.1);
    border-color: rgba(239, 68, 68, 0.2);
    color: #ef4444;
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }

  svg {
    width: 18px;
    height: 18px;
  }
`;

const MobileNavList = styled.ul`
  list-style: none;
  margin: 0;
  padding: 16px 12px;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
`;

const MobileNavItem = styled.li``;

const MobileNavLink = styled(Link)<{ $isActive?: boolean }>`
  display: flex;
  align-items: center;
  padding: 14px 16px;
  text-decoration: none;
  color: ${({ $isActive }) => $isActive ? '#6366f1' : '#374151'};
  font-weight: ${({ $isActive }) => $isActive ? '600' : '500'};
  font-size: 15px;
  border-radius: 12px;
  transition: all 0.2s ease;
  background: ${({ $isActive }) => $isActive ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.12) 0%, rgba(139, 92, 246, 0.08) 100%)' : 'transparent'};
  position: relative;

  ${({ $isActive }) => $isActive && css`
    &::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 24px;
      background: linear-gradient(180deg, #6366f1, #8b5cf6);
      border-radius: 0 4px 4px 0;
    }
  `}

  &:hover {
    background: rgba(99, 102, 241, 0.08);
    color: #6366f1;
    transform: translateX(4px);
  }

  &:active {
    transform: translateX(2px) scale(0.99);
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }
`;

const MobileMenuFooter = styled.div`
  padding: 20px 24px;
  border-top: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(to top, rgba(248, 250, 252, 0.9), white);
`;

const NavLink = styled(Link)`
  text-decoration: none;
  color: #6b7280;
  font-weight: 500;
  font-size: 14px;
  padding: 9px 16px;
  border-radius: 10px;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  letter-spacing: -0.01em;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;

  &:hover {
    color: #1f2937;
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
  }

  &:active {
    transform: scale(0.98);
  }

  &.active {
    color: #111827;
    background: white;
    font-weight: 600;
    box-shadow:
      0 1px 3px rgba(0, 0, 0, 0.08),
      0 2px 8px rgba(0, 0, 0, 0.04);

    &::before {
      content: '';
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      width: 18px;
      height: 3px;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
    }

    &:hover {
      box-shadow:
        0 2px 6px rgba(0, 0, 0, 0.1),
        0 4px 12px rgba(0, 0, 0, 0.05);
    }
  }

  @media (max-width: 1200px) {
    font-size: 13px;
    padding: 8px 12px;
  }

  @media (max-width: 1024px) {
    padding: 7px 10px;
    font-size: 12px;
  }
`;

/* ---------- Profile Components ---------- */
const ProfileSection = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  position: relative;
  flex-shrink: 0;

  @media (max-width: 768px) {
    gap: 8px;
  }
`;

const ProfileButton = styled.button<{ $isOpen?: boolean }>`
  display: flex;
  align-items: center;
  gap: 10px;
  background: ${props => props.$isOpen ? 'rgba(99, 102, 241, 0.08)' : 'rgba(241, 245, 249, 0.6)'};
  border: 1px solid ${props => props.$isOpen ? 'rgba(99, 102, 241, 0.2)' : 'rgba(226, 232, 240, 0.6)'};
  padding: 5px 12px 5px 5px;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: #475569;

  &:hover {
    background: rgba(99, 102, 241, 0.08);
    border-color: rgba(99, 102, 241, 0.2);
    color: #1e293b;
  }

  &:active {
    transform: scale(0.98);
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }

  @media (max-width: 768px) {
    padding: 4px;
    border-radius: 12px;

    span {
      display: none;
    }
  }
`;

const UserAvatar = styled.div`
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%);
  background-size: 200% 200%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 600;
  font-size: 12px;
  letter-spacing: 0.02em;
  box-shadow:
    0 2px 6px rgba(99, 102, 241, 0.25),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
  transition: all 0.2s ease;
  position: relative;

  &::after {
    content: '';
    position: absolute;
    inset: -2px;
    border-radius: 50%;
    border: 2px solid transparent;
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(139, 92, 246, 0.3)) border-box;
    -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  ${ProfileButton}:hover &::after {
    opacity: 1;
  }
`;

const ProfileName = styled.span`
  font-size: 13px;
  font-weight: 500;
  max-width: 100px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const ProfileDropdown = styled.div`
  position: absolute;
  top: calc(100% + 8px);
  right: 0;
  min-width: 240px;
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: blur(24px) saturate(180%);
  -webkit-backdrop-filter: blur(24px) saturate(180%);
  border: 1px solid rgba(226, 232, 240, 0.6);
  border-radius: 16px;
  box-shadow:
    0 20px 60px rgba(0, 0, 0, 0.12),
    0 8px 24px rgba(0, 0, 0, 0.06),
    0 0 0 1px rgba(255, 255, 255, 0.5) inset;
  z-index: 1000;
  animation: ${slideDown} 0.25s cubic-bezier(0.22, 1, 0.36, 1);
  overflow: hidden;
`;

const DropdownHeader = styled.div`
  padding: 16px 20px;
  border-bottom: 1px solid rgba(226, 232, 240, 0.6);
  background: linear-gradient(180deg, rgba(248, 250, 252, 0.8), white);
`;

const UserInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const UserDetails = styled.div`
  flex: 1;
  min-width: 0;
`;

const UserName = styled.div`
  font-weight: 600;
  color: #1e293b;
  font-size: 14px;
  line-height: 1.3;
`;

const UserEmail = styled.div`
  font-size: 12px;
  color: #64748b;
  margin-top: 2px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const DropdownSection = styled.div`
  padding: 8px;
`;

const DropdownItem = styled.button`
  width: 100%;
  background: none;
  border: none;
  padding: 10px 12px;
  text-align: left;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 10px;
  color: #475569;
  border-radius: 10px;
  transition: all 0.15s ease;
  position: relative;

  &:hover {
    background: rgba(99, 102, 241, 0.08);
    color: #1e293b;

    svg {
      color: #6366f1;
      transform: scale(1.1);
    }
  }

  &:active {
    background: rgba(99, 102, 241, 0.12);
    transform: scale(0.98);
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);
  }

  svg {
    width: 18px;
    height: 18px;
    color: #94a3b8;
    transition: all 0.15s ease;
    flex-shrink: 0;
  }
`;

const DropdownItemLabel = styled.span`
  flex: 1;
`;

const DropdownItemHint = styled.span`
  font-size: 11px;
  color: #94a3b8;
  font-weight: 500;
`;

const Divider = styled.div`
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(226, 232, 240, 0.8), transparent);
  margin: 4px 16px;
`;

/* ---------- Navigation Items Config ---------- */
const navItems = [
  { path: '/', label: 'Home', tooltip: 'AI-powered product assistant and insights dashboard' },
  { path: '/products', label: 'Products', tooltip: 'Manage insurance products, coverages, and forms' },
  { path: '/ai-builder', label: 'AI Builder', tooltip: 'AI-powered product builder' },
  { path: '/builder', label: 'Builder', tooltip: 'Build new insurance products' },
  { path: '/product-explorer', label: 'Explorer', tooltip: 'Explore product hierarchies and relationships', matchPrefix: true },
  { path: '/tasks', label: 'Tasks', tooltip: 'Manage workflow tasks and assignments' },
  { path: '/data-dictionary', label: 'Data Dictionary', tooltip: 'Browse insurance terminology and definitions' },
  { path: '/claims-analysis', label: 'Claims Analysis', tooltip: 'Analyze claims data and policy coverage' },
];

/* ---------- component ---------- */
export default function MainNavigation() {
  const location = useLocation();
  const navigate = useNavigate();
  const [profileOpen, setProfileOpen] = useState(false);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [scrolled, setScrolled] = useState(false);
  const mobileMenuRef = useRef<HTMLDivElement>(null);
  const mobileMenuButtonRef = useRef<HTMLButtonElement>(null);

  // Handle scroll effect for sticky nav
  useEffect(() => {
    const handleScroll = () => {
      setScrolled(window.scrollY > 10);
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  // Close mobile menu on route change
  useEffect(() => {
    setMobileMenuOpen(false);
  }, [location.pathname]);

  // Handle escape key for mobile menu
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (mobileMenuOpen) {
          setMobileMenuOpen(false);
          mobileMenuButtonRef.current?.focus();
        }
        if (profileOpen) {
          setProfileOpen(false);
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [mobileMenuOpen, profileOpen]);

  // Prevent body scroll when mobile menu is open
  useEffect(() => {
    if (mobileMenuOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
    return () => {
      document.body.style.overflow = '';
    };
  }, [mobileMenuOpen]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (profileOpen && !(event.target as Element).closest('[data-profile-menu]')) {
        setProfileOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [profileOpen]);

  // Check if nav item is active
  const isNavItemActive = useCallback((item: typeof navItems[0]) => {
    if (item.matchPrefix) {
      return location.pathname.startsWith(item.path);
    }
    return location.pathname === item.path;
  }, [location.pathname]);

  // Get user initials for avatar
  const getUserInitials = () => {
    // Check for admin or guest session first
    const sessionStatus = sessionStorage.getItem('ph-authed');
    const storedUsername = sessionStorage.getItem('ph-username');

    if (sessionStatus === 'admin' && storedUsername) {
      return storedUsername.substring(0, 2).toUpperCase();
    }

    if (sessionStatus === 'guest') {
      return 'GU';
    }

    const user = auth.currentUser;
    if (user?.displayName) {
      return user.displayName.split(' ').map(n => n[0]).join('').toUpperCase();
    }
    if (user?.email) {
      return user.email.substring(0, 2).toUpperCase();
    }
    return 'U';
  };

  const getUserEmail = () => {
    // Check for admin or guest session first
    const sessionStatus = sessionStorage.getItem('ph-authed');
    const storedUsername = sessionStorage.getItem('ph-username');

    if (sessionStatus === 'admin' && storedUsername) {
      return `${storedUsername}@admin.local`;
    }

    if (sessionStatus === 'guest') {
      return 'guest@temporary.local';
    }

    const user = auth.currentUser;
    return user?.email || 'Guest User';
  };

  const getUserName = () => {
    // Check for admin or guest session first
    const sessionStatus = sessionStorage.getItem('ph-authed');
    const storedUsername = sessionStorage.getItem('ph-username');

    if (sessionStatus === 'admin' && storedUsername) {
      return storedUsername;
    }

    if (sessionStatus === 'guest') {
      return 'Guest User';
    }

    const user = auth.currentUser;
    return user?.displayName || user?.email?.split('@')[0] || 'Guest User';
  };

  const handleSignOut = async () => {
    const startTime = Date.now();
    const sessionStatus = sessionStorage.getItem('ph-authed');
    const username = sessionStorage.getItem('ph-username');

    logger.logUserAction('Logout attempt started', {
      sessionType: sessionStatus,
      username: username,
      timestamp: new Date().toISOString()
    });

    try {
      // Check if this is an admin or guest session
      if (sessionStatus === 'admin' || sessionStatus === 'guest') {
        logger.info(LOG_CATEGORIES.AUTH, 'Session logout', {
          sessionType: sessionStatus,
          username: username
        });

        // Admin/Guest logout - just clear session storage
        sessionStorage.removeItem('ph-authed');
        sessionStorage.removeItem('ph-username');

        logger.info(LOG_CATEGORIES.AUTH, 'Session logout successful', {
          sessionType: sessionStatus
        });

        logger.logNavigation(location.pathname, '/login', { reason: 'logout' });
        navigate('/login', { replace: true });
      } else {
        logger.info(LOG_CATEGORIES.AUTH, 'Firebase logout', {
          userEmail: auth.currentUser?.email
        });

        // Firebase logout
        await signOut(auth);

        logger.info(LOG_CATEGORIES.AUTH, 'Firebase logout successful');

        logger.logNavigation(location.pathname, '/login', { reason: 'firebase_logout' });
        navigate('/login', { replace: true });
      }
    } catch (error) {
      logger.error(LOG_CATEGORIES.AUTH, 'Logout failed', {
        sessionType: sessionStatus,
        duration
      }, error);
    }
  };

  return (
    <>
      <NavigationWrapper $scrolled={scrolled}>
        <Navigation role="navigation" aria-label="Main navigation">
          {/* Logo & Brand */}
          <LogoSection to="/" aria-label="Home">
            <LogoIcon>
              <SparklesIcon />
            </LogoIcon>
            <LogoText>
              <LogoBrand>Product Reinvention Hub</LogoBrand>
              <LogoTagline>P&C Insurance</LogoTagline>
            </LogoText>
          </LogoSection>

          {/* Desktop Navigation */}
          <NavList>
            {navItems.map((item) => (
              <NavItem key={item.path}>
                <Tooltip content={item.tooltip} position="bottom">
                  <NavLink
                    to={item.path}
                    className={isNavItemActive(item) ? 'active' : ''}
                    aria-current={isNavItemActive(item) ? 'page' : undefined}
                  >
                    {item.label}
                  </NavLink>
                </Tooltip>
              </NavItem>
            ))}
          </NavList>

          {/* Mobile Menu Button */}
          <MobileMenuButton
            ref={mobileMenuButtonRef}
            onClick={() => setMobileMenuOpen(true)}
            aria-label="Open navigation menu"
            aria-expanded={mobileMenuOpen}
            aria-controls="mobile-menu"
          >
            <Bars3Icon />
          </MobileMenuButton>

          <ProfileSection data-profile-menu>
            <ProfileButton
              onClick={() => setProfileOpen(!profileOpen)}
              $isOpen={profileOpen}
              aria-expanded={profileOpen}
              aria-haspopup="true"
            >
              <UserAvatar>{getUserInitials()}</UserAvatar>
              <ProfileName>{getUserName()}</ProfileName>
            </ProfileButton>

            {profileOpen && (
              <ProfileDropdown role="menu" aria-label="User menu">
                <DropdownHeader>
                  <UserInfo>
                    <UserAvatar>{getUserInitials()}</UserAvatar>
                    <UserDetails>
                      <UserName>{getUserName()}</UserName>
                      <UserEmail>{getUserEmail()}</UserEmail>
                    </UserDetails>
                  </UserInfo>
                </DropdownHeader>

                <DropdownSection>
                  <DropdownItem
                    onClick={() => console.info('Profile view - Coming soon')}
                    role="menuitem"
                  >
                    <UserIcon />
                    <DropdownItemLabel>View Profile</DropdownItemLabel>
                  </DropdownItem>
                  <DropdownItem
                    onClick={() => console.info('Account settings - Coming soon')}
                    role="menuitem"
                  >
                    <Cog6ToothIcon />
                    <DropdownItemLabel>Account Settings</DropdownItemLabel>
                  </DropdownItem>
                </DropdownSection>

                <Divider />

                <DropdownSection>
                  <DropdownItem onClick={handleSignOut} role="menuitem">
                    <ArrowLeftOnRectangleIcon />
                    <DropdownItemLabel>Sign Out</DropdownItemLabel>
                  </DropdownItem>
                </DropdownSection>
              </ProfileDropdown>
            )}
          </ProfileSection>
        </Navigation>
      </NavigationWrapper>

      {/* Mobile Menu Overlay */}
      <MobileMenuOverlay
        $isOpen={mobileMenuOpen}
        onClick={() => setMobileMenuOpen(false)}
        aria-hidden="true"
      />

      {/* Mobile Menu */}
      <MobileMenu
        ref={mobileMenuRef}
        $isOpen={mobileMenuOpen}
        id="mobile-menu"
        role="dialog"
        aria-modal="true"
        aria-label="Navigation menu"
      >
        <MobileMenuHeader>
          <MobileMenuTitle>
            <MobileLogoIcon>
              <SparklesIcon />
            </MobileLogoIcon>
            <MobileMenuBrand>Reinvention Hub</MobileMenuBrand>
          </MobileMenuTitle>
          <MobileCloseButton
            onClick={() => setMobileMenuOpen(false)}
            aria-label="Close navigation menu"
          >
            <XMarkIcon />
          </MobileCloseButton>
        </MobileMenuHeader>

        <MobileNavList role="menu">
          {navItems.map((item) => (
            <MobileNavItem key={item.path} role="none">
              <MobileNavLink
                to={item.path}
                $isActive={isNavItemActive(item)}
                role="menuitem"
                aria-current={isNavItemActive(item) ? 'page' : undefined}
                onClick={() => setMobileMenuOpen(false)}
              >
                {item.label}
              </MobileNavLink>
            </MobileNavItem>
          ))}
        </MobileNavList>

        <MobileMenuFooter>
          <UserInfo>
            <UserAvatar>{getUserInitials()}</UserAvatar>
            <UserDetails>
              <UserName>{getUserName()}</UserName>
              <UserEmail>{getUserEmail()}</UserEmail>
            </UserDetails>
          </UserInfo>
        </MobileMenuFooter>
      </MobileMenu>
    </>
  );
}
```

---

## src/components/ui/NotificationBadge.tsx

**Path:** `src/components/ui/NotificationBadge.tsx`

```tsx
/**
 * NotificationBadge - Unread count indicator component
 * 
 * Displays a badge with count for notifications, messages, or other
 * countable items. Supports various positions and sizes.
 */

import React from 'react';
import styled, { keyframes, css } from 'styled-components';

// ============ Animations ============
const pulse = keyframes`
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
`;

const pop = keyframes`
  0% { transform: scale(0); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
`;

// ============ Types ============
interface NotificationBadgeProps {
  /** The count to display */
  count?: number;
  /** Maximum count before showing "+" */
  maxCount?: number;
  /** Show dot instead of count */
  dot?: boolean;
  /** Badge color variant */
  variant?: 'primary' | 'error' | 'warning' | 'success';
  /** Badge size */
  size?: 'sm' | 'md' | 'lg';
  /** Position relative to parent */
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
  /** Show pulse animation */
  pulse?: boolean;
  /** Offset from corner */
  offset?: number;
  /** Children to wrap */
  children?: React.ReactNode;
  /** Additional class name */
  className?: string;
}

// ============ Styled Components ============
const BadgeWrapper = styled.div`
  position: relative;
  display: inline-flex;
`;

const Badge = styled.span<{
  $variant: string;
  $size: string;
  $position: string;
  $isDot: boolean;
  $pulse: boolean;
  $offset: number;
  $hasCount: boolean;
}>`
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-family: ${({ theme }) => theme.font};
  border-radius: ${({ theme }) => theme.radiusFull};
  border: 2px solid ${({ theme }) => theme.colours.background};
  animation: ${pop} 0.3s ease;
  z-index: 1;
  
  /* Variant colors */
  ${({ $variant, theme }) => {
    switch ($variant) {
      case 'error': return css`background: ${theme.colours.error}; color: ${theme.colours.textInverse};`;
      case 'warning': return css`background: ${theme.colours.warning}; color: ${theme.colours.text};`;
      case 'success': return css`background: ${theme.colours.success}; color: ${theme.colours.textInverse};`;
      default: return css`background: ${theme.colours.primary}; color: ${theme.colours.textInverse};`;
    }
  }}
  
  /* Size */
  ${({ $size, $isDot }) => {
    if ($isDot) {
      switch ($size) {
        case 'sm': return css`width: 8px; height: 8px;`;
        case 'lg': return css`width: 14px; height: 14px;`;
        default: return css`width: 10px; height: 10px;`;
      }
    }
    switch ($size) {
      case 'sm': return css`min-width: 16px; height: 16px; font-size: 10px; padding: 0 4px;`;
      case 'lg': return css`min-width: 24px; height: 24px; font-size: 13px; padding: 0 6px;`;
      default: return css`min-width: 20px; height: 20px; font-size: 11px; padding: 0 5px;`;
    }
  }}
  
  /* Position */
  ${({ $position, $offset }) => {
    const o = $offset;
    switch ($position) {
      case 'top-left': return css`top: -${o}px; left: -${o}px;`;
      case 'bottom-right': return css`bottom: -${o}px; right: -${o}px;`;
      case 'bottom-left': return css`bottom: -${o}px; left: -${o}px;`;
      default: return css`top: -${o}px; right: -${o}px;`;
    }
  }}
  
  /* Pulse animation */
  ${({ $pulse }) => $pulse && css`
    animation: ${pulse} 2s ease-in-out infinite;
  `}
  
  /* Hide when no count and not dot */
  ${({ $hasCount, $isDot }) => !$hasCount && !$isDot && css`
    display: none;
  `}
`;

const StandaloneBadge = styled(Badge)`
  position: relative;
  top: auto;
  right: auto;
  bottom: auto;
  left: auto;
`;

// ============ Component ============
export const NotificationBadge: React.FC<NotificationBadgeProps> = ({
  count = 0,
  maxCount = 99,
  dot = false,
  variant = 'error',
  size = 'md',
  position = 'top-right',
  pulse: shouldPulse = false,
  offset = 4,
  children,
  className,
}) => {
  const displayCount = count > maxCount ? `${maxCount}+` : count.toString();
  const hasCount = count > 0;
  
  // Standalone badge (no children)
  if (!children) {
    return (
      <StandaloneBadge
        $variant={variant}
        $size={size}
        $position={position}
        $isDot={dot}
        $pulse={shouldPulse && hasCount}
        $offset={offset}
        $hasCount={hasCount}
        className={className}
        role="status"
        aria-label={dot ? 'New notification' : `${count} notifications`}
      >
        {!dot && displayCount}
      </StandaloneBadge>
    );
  }
  
  return (
    <BadgeWrapper className={className}>
      {children}
      <Badge
        $variant={variant}
        $size={size}
        $position={position}
        $isDot={dot}
        $pulse={shouldPulse && hasCount}
        $offset={offset}
        $hasCount={hasCount}
        role="status"
        aria-label={dot ? 'New notification' : `${count} notifications`}
      >
        {!dot && displayCount}
      </Badge>
    </BadgeWrapper>
  );
};

export default NotificationBadge;

```

---

## src/components/ui/PageContainer.tsx

**Path:** `src/components/ui/PageContainer.tsx`

```tsx
import React from 'react';
import styled from 'styled-components';

interface PageContainerProps {
  withOverlay?: boolean;
  children: React.ReactNode;
}

const StyledPageContainer = styled.div<{ $withOverlay: boolean }>`
  min-height: 100vh;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
  display: flex;
  flex-direction: column;
  position: relative;

  ${props => props.$withOverlay && `
    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 300px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #06b6d4 100%);
      opacity: 0.08;
      z-index: 0;
    }
  `}
`;

const MainContent = styled.main.attrs({
  id: 'main-content',
})`
  flex: 1;
  padding: 32px 32px 80px;
  max-width: 1400px;
  margin: 0 auto;
  width: 100%;
  position: relative;
  z-index: 1;

  @media (max-width: 768px) {
    padding: 24px 20px 60px;
  }
`;

export const PageContainer: React.FC<PageContainerProps> = ({
  withOverlay = true,
  children
}) => {
  return (
    <StyledPageContainer $withOverlay={withOverlay}>
      {children}
    </StyledPageContainer>
  );
};

export const PageContent = MainContent;

```

---

## src/components/ui/ProductCard.tsx

**Path:** `src/components/ui/ProductCard.tsx`

```tsx
// src/components/ui/ProductCard.tsx
import React, { memo, useCallback, useState } from 'react';
import { Link } from 'react-router-dom';
import styled, { keyframes, css } from 'styled-components';
import {
  PencilIcon,
  ChevronRightIcon,
  ShieldCheckIcon,
  CurrencyDollarIcon,
  DocumentDuplicateIcon,
  MapPinIcon,
  Cog6ToothIcon,
  ArchiveBoxIcon,
  EyeIcon
} from '@heroicons/react/24/outline';
import { SparklesIcon, ChatBubbleLeftEllipsisIcon } from '@heroicons/react/24/solid';
import LoadingSpinner from './LoadingSpinner';
import { formatFirestoreDate } from '../../utils/firestoreHelpers';

/* ---------- Animations ---------- */
const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(0.95); }
`;

const float = keyframes`
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-3px); }
`;

const glow = keyframes`
  0%, 100% { box-shadow: 0 0 20px rgba(99, 102, 241, 0.15); }
  50% { box-shadow: 0 0 30px rgba(99, 102, 241, 0.25); }
`;

const gradientShift = keyframes`
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
`;

/* ---------- Card Container ---------- */
const Card = styled.article<{ $isHovered?: boolean; $archived?: boolean }>`
  background: ${({ $archived }) => $archived
    ? 'linear-gradient(165deg, #f5f5f5 0%, #efefef 100%)'
    : 'linear-gradient(165deg, #ffffff 0%, #fafbff 100%)'};
  border: 1px solid ${({ $archived }) => $archived
    ? 'rgba(100, 100, 100, 0.15)'
    : 'rgba(99, 102, 241, 0.08)'};
  border-radius: 20px;
  padding: 0;
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.02),
    0 4px 12px ${({ $archived }) => $archived
      ? 'rgba(0, 0, 0, 0.04)'
      : 'rgba(99, 102, 241, 0.04)'},
    0 8px 24px rgba(0, 0, 0, 0.02);
  transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transform-style: preserve-3d;
  will-change: transform, box-shadow;
  opacity: ${({ $archived }) => $archived ? 0.7 : 1};

  /* Subtle top accent line */
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 24px;
    right: 24px;
    height: 3px;
    background: linear-gradient(90deg, #6366f1, #8b5cf6, #a855f7);
    background-size: 200% 100%;
    border-radius: 0 0 4px 4px;
    opacity: 0;
    transform: scaleX(0.3);
    transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  /* Glass reflection effect */
  &::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(
      180deg,
      rgba(255, 255, 255, 0.4) 0%,
      rgba(255, 255, 255, 0) 100%
    );
    pointer-events: none;
    border-radius: 20px 20px 0 0;
  }

  &:hover {
    ${({ $archived }) => !$archived && css`
      transform: translateY(-4px) scale(1.01);
      box-shadow:
        0 8px 24px rgba(99, 102, 241, 0.12),
        0 16px 48px rgba(99, 102, 241, 0.08),
        0 24px 64px rgba(0, 0, 0, 0.04);
      border-color: rgba(99, 102, 241, 0.2);

      &::before {
        opacity: 1;
        transform: scaleX(1);
        animation: ${gradientShift} 3s ease infinite;
      }
    `}
  }

  &:focus-within {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }

  @media (prefers-reduced-motion: reduce) {
    transition: none;
    &:hover {
      transform: none;
    }
  }
`;

/* ---------- Card Header ---------- */
const CardHeader = styled.div`
  padding: 24px 24px 20px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
  position: relative;
  z-index: 1;
`;

const HeaderLeft = styled.div`
  flex: 1;
  min-width: 0;
`;

const ProductName = styled.h3`
  font-size: 18px;
  font-weight: 650;
  color: #0f172a;
  margin: 0 0 12px 0;
  line-height: 1.4;
  letter-spacing: -0.025em;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  transition: color 0.2s ease;

  ${Card}:hover & {
    color: #4f46e5;
  }
`;

const MetaChips = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
`;

const MetaChip = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 5px 12px;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  border: 1px solid rgba(99, 102, 241, 0.06);
  border-radius: 8px;
  font-size: 11.5px;
  font-weight: 550;
  color: #475569;
  letter-spacing: -0.01em;
  transition: all 0.2s ease;

  svg {
    width: 12px;
    height: 12px;
    color: #94a3b8;
  }

  ${Card}:hover & {
    background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
    border-color: rgba(99, 102, 241, 0.12);
    color: #4338ca;

    svg {
      color: #6366f1;
    }
  }
`;

const StatusIndicator = styled.span<{ $status?: string }>`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 12px;
  background: ${({ $status }) =>
    $status === 'active'
      ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.12) 0%, rgba(22, 163, 74, 0.08) 100%)'
      : 'linear-gradient(135deg, rgba(245, 158, 11, 0.12) 0%, rgba(217, 119, 6, 0.08) 100%)'
  };
  border: 1px solid ${({ $status }) =>
    $status === 'active' ? 'rgba(34, 197, 94, 0.2)' : 'rgba(245, 158, 11, 0.2)'
  };
  border-radius: 20px;
  font-size: 11.5px;
  font-weight: 600;
  color: ${({ $status }) => $status === 'active' ? '#15803d' : '#b45309'};
  text-transform: uppercase;
  letter-spacing: 0.03em;

  &::before {
    content: '';
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: ${({ $status }) => $status === 'active' ? '#22c55e' : '#f59e0b'};
    box-shadow: 0 0 8px ${({ $status }) => $status === 'active' ? '#22c55e' : '#f59e0b'};
    animation: ${pulse} 2s ease-in-out infinite;
  }
`;

const CardActions = styled.div`
  display: flex;
  gap: 6px;
  opacity: 0.6;
  transition: opacity 0.2s ease;

  ${Card}:hover & {
    opacity: 1;
  }
`;

const IconButton = styled.button`
  width: 34px;
  height: 34px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(0, 0, 0, 0.04);
  border-radius: 10px;
  cursor: pointer;
  color: #94a3b8;
  transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);

  &:hover {
    background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
    border-color: rgba(99, 102, 241, 0.2);
    color: #6366f1;
    transform: scale(1.08);
  }

  &.danger:hover {
    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    border-color: rgba(239, 68, 68, 0.2);
    color: #dc2626;
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }

  svg {
    width: 15px;
    height: 15px;
  }
`;

/* ---------- Quick Links Section ---------- */
const QuickLinksContainer = styled.div`
  padding: 0 16px;
  margin-bottom: 4px;
`;

const QuickLinks = styled.div`
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 6px;
  padding: 12px;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  border-radius: 14px;
  border: 1px solid rgba(99, 102, 241, 0.04);
`;

const QuickLink = styled(Link)`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 12px 6px;
  font-size: 10.5px;
  font-weight: 550;
  color: #64748b;
  text-decoration: none;
  transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
  border-radius: 10px;
  text-align: center;
  letter-spacing: -0.01em;
  position: relative;

  .icon-wrapper {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #ffffff;
    border-radius: 8px;
    border: 1px solid rgba(99, 102, 241, 0.06);
    transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
  }

  svg {
    width: 15px;
    height: 15px;
    color: #94a3b8;
    transition: all 0.2s ease;
  }

  .arrow {
    position: absolute;
    right: 4px;
    top: 50%;
    transform: translateY(-50%) translateX(-4px);
    width: 10px;
    height: 10px;
    opacity: 0;
    color: #6366f1;
    transition: all 0.2s ease;
  }

  &:hover {
    background: #ffffff;
    color: #4f46e5;
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
    transform: translateY(-2px);

    .icon-wrapper {
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-color: transparent;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
    }

    svg {
      color: #ffffff;
    }

    .arrow {
      opacity: 1;
      transform: translateY(-50%) translateX(0);
    }
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }
`;

/* ---------- Card Footer / AI Actions ---------- */
const CardFooter = styled.div`
  padding: 16px 16px 20px;
  display: flex;
  gap: 10px;
  position: relative;
`;

const AIButton = styled.button<{ $primary?: boolean }>`
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 16px;
  background: ${({ $primary }) => $primary
    ? 'linear-gradient(135deg, #6366f1 0%, #7c3aed 50%, #8b5cf6 100%)'
    : 'linear-gradient(135deg, #ffffff 0%, #f8fafc 100%)'};
  background-size: 200% 200%;
  color: ${({ $primary }) => $primary ? '#ffffff' : '#475569'};
  border: ${({ $primary }) => $primary
    ? 'none'
    : '1px solid rgba(99, 102, 241, 0.12)'};
  border-radius: 12px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
  overflow: hidden;
  letter-spacing: -0.01em;

  svg {
    width: 16px;
    height: 16px;
    transition: transform 0.2s ease;
  }

  ${({ $primary }) => $primary && css`
    box-shadow:
      0 2px 8px rgba(99, 102, 241, 0.25),
      0 4px 16px rgba(139, 92, 246, 0.15),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  `}

  &:hover:not(:disabled) {
    ${({ $primary }) => $primary
      ? css`
          background-position: 100% 100%;
          box-shadow:
            0 4px 16px rgba(99, 102, 241, 0.35),
            0 8px 32px rgba(139, 92, 246, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.15);
          transform: translateY(-2px);
          animation: ${glow} 2s ease infinite;
        `
      : css`
          background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
          border-color: rgba(99, 102, 241, 0.2);
          color: #4338ca;
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(99, 102, 241, 0.1);
        `}

    svg {
      transform: scale(1.1);
      ${({ $primary }) => $primary && css`
        animation: ${float} 1.5s ease infinite;
      `}
    }
  }

  &:active:not(:disabled) {
    transform: translateY(0);
  }

  &:disabled {
    opacity: 0.65;
    cursor: not-allowed;
    filter: grayscale(0.2);
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }

  /* Enhanced shimmer effect for AI button */
  ${({ $primary }) => $primary && css`
    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.15) 50%,
        transparent 100%
      );
      transition: left 0.4s ease;
    }

    &:hover::before {
      left: 100%;
    }
  `}
`;

/* ---------- Product Interface ---------- */
interface Product {
  id: string;
  name: string;
  formNumber?: string;
  productCode?: string;
  effectiveDate?: unknown;
  formDownloadUrl?: string;
  archived?: boolean;
}

interface ProductCardProps {
  product: Product;
  onEdit: (product: Product) => void;
  onArchive: (productId: string) => void;
  onOpenDetails: (product: Product) => void;
  onSummary: (productId: string, formDownloadUrl?: string) => void;
  onChat: (product: Product) => void;
  loadingSummary?: boolean;
}

/* ---------- Quick Link Config ---------- */
const quickLinkConfig = [
  { path: 'coverage', label: 'Coverages', Icon: ShieldCheckIcon },
  { path: 'pricing', label: 'Pricing', Icon: CurrencyDollarIcon },
  { path: 'forms', label: 'Forms', Icon: DocumentDuplicateIcon },
  { path: 'states', label: 'States', Icon: MapPinIcon },
  { path: 'rules', label: 'Rules', Icon: Cog6ToothIcon },
];

/* ---------- Memoized ProductCard Component ---------- */
const ProductCard = memo(({
  product,
  onEdit,
  onArchive,
  onSummary,
  onChat,
  loadingSummary = false
}: ProductCardProps) => {
  const [isHovered, setIsHovered] = useState(false);

  // Memoized event handlers
  const handleEdit = useCallback(() => onEdit(product), [onEdit, product]);
  const handleArchive = useCallback(() => onArchive(product.id), [onArchive, product.id]);
  const handleSummary = useCallback(() => onSummary(product.id, product.formDownloadUrl), [onSummary, product.id, product.formDownloadUrl]);
  const handleChat = useCallback(() => onChat(product), [onChat, product]);
  const handleViewPDF = useCallback(() => {
    if (product.formDownloadUrl) {
      window.open(product.formDownloadUrl, '_blank');
    }
  }, [product.formDownloadUrl]);

  return (
    <Card
      aria-label={`Product: ${product.name}`}
      $isHovered={isHovered}
      $archived={product.archived}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      {/* Header: Product info + Actions */}
      <CardHeader>
        <HeaderLeft>
          <ProductName>{product.name}</ProductName>
          <MetaChips>
            <StatusIndicator $status={product.archived ? "inactive" : "active"}>
              {product.archived ? 'Archived' : 'Active'}
            </StatusIndicator>
            {product.formNumber && (
              <MetaChip>
                <DocumentDuplicateIcon />
                {product.formNumber}
              </MetaChip>
            )}
            {product.productCode && (
              <MetaChip>
                <ShieldCheckIcon />
                {product.productCode}
              </MetaChip>
            )}
            {product.effectiveDate && (
              <MetaChip>{formatFirestoreDate(product.effectiveDate)}</MetaChip>
            )}
          </MetaChips>
        </HeaderLeft>
        <CardActions>
          {!product.archived && (
            <IconButton onClick={handleEdit} aria-label="Edit product" title="Edit">
              <PencilIcon />
            </IconButton>
          )}
          {product.formDownloadUrl && (
            <IconButton onClick={handleViewPDF} aria-label="View PDF form" title="View PDF">
              <EyeIcon />
            </IconButton>
          )}
          <IconButton className="danger" onClick={handleArchive} aria-label={product.archived ? "Unarchive product" : "Archive product"} title={product.archived ? "Unarchive" : "Archive"}>
            <ArchiveBoxIcon />
          </IconButton>
        </CardActions>
      </CardHeader>

      {/* Quick Links: Navigation to sub-pages */}
      {!product.archived && (
        <QuickLinksContainer>
          <QuickLinks>
            {quickLinkConfig.map(({ path, label, Icon }) => (
              <QuickLink key={path} to={`/${path}/${product.id}`}>
                <span className="icon-wrapper">
                  <Icon />
                </span>
                {label}
                <ChevronRightIcon className="arrow" />
              </QuickLink>
            ))}
          </QuickLinks>
        </QuickLinksContainer>
      )}

      {/* Footer: AI Actions */}
      {!product.archived && (
        <CardFooter>
          <AIButton
            $primary
            onClick={handleSummary}
            disabled={loadingSummary}
            aria-label={loadingSummary ? 'Generating summary' : 'Generate AI summary'}
          >
            {loadingSummary ? (
              <LoadingSpinner type="circular" size="15px" color="#ffffff" />
            ) : (
              <SparklesIcon />
            )}
            {loadingSummary ? 'Analyzing...' : 'AI Summary'}
          </AIButton>
          <AIButton onClick={handleChat} aria-label="Chat about this product">
            <ChatBubbleLeftEllipsisIcon />
            Chat
          </AIButton>
        </CardFooter>
      )}
    </Card>
  );
});

ProductCard.displayName = 'ProductCard';

export default ProductCard;
```

---

## src/components/ui/ProductContextBar.tsx

**Path:** `src/components/ui/ProductContextBar.tsx`

```tsx
// src/components/ui/ProductContextBar.tsx
import React, { memo, useMemo } from 'react';
import { NavLink, useLocation, useParams } from 'react-router-dom';
import styled, { keyframes, css } from 'styled-components';
import {
  ShieldCheckIcon,
  CurrencyDollarIcon,
  DocumentDuplicateIcon,
  MapPinIcon,
  Cog6ToothIcon,
  ChevronRightIcon,
  HomeIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  ClockIcon
} from '@heroicons/react/24/outline';
import { SparklesIcon } from '@heroicons/react/24/solid';

/* ---------- Animations ---------- */
const slideIn = keyframes`
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
`;

const shimmer = keyframes`
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
`;

/* ---------- Container ---------- */
const ContextBarWrapper = styled.div`
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid rgba(226, 232, 240, 0.8);
  border-radius: 16px;
  padding: 16px 20px;
  margin-bottom: 24px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.04), 0 1px 3px rgba(0, 0, 0, 0.02);
  animation: ${slideIn} 0.3s ease-out;
  position: relative;
  overflow: hidden;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, #6366f1, #8b5cf6, #06b6d4);
    opacity: 0.8;
  }
`;

const ContextBarContent = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 24px;
  flex-wrap: wrap;

  @media (max-width: 1024px) {
    flex-direction: column;
    align-items: stretch;
    gap: 16px;
  }
`;

/* ---------- Product Info Section ---------- */
const ProductInfoSection = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
  flex-shrink: 0;
`;

const ProductIcon = styled.div`
  width: 48px;
  height: 48px;
  border-radius: 12px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);

  svg {
    width: 24px;
    height: 24px;
  }
`;

const ProductDetails = styled.div`
  display: flex;
  flex-direction: column;
  gap: 4px;
`;

const ProductName = styled.h2`
  font-size: 18px;
  font-weight: 700;
  color: #0f172a;
  margin: 0;
  letter-spacing: -0.02em;
  display: flex;
  align-items: center;
  gap: 8px;
`;

const ProductMeta = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
`;

const MetaBadge = styled.span<{ $variant?: 'default' | 'success' | 'warning' | 'info' }>`
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  
  ${({ $variant = 'default' }) => {
    switch ($variant) {
      case 'success':
        return css`
          background: rgba(16, 185, 129, 0.1);
          color: #059669;
          border: 1px solid rgba(16, 185, 129, 0.2);
        `;
      case 'warning':
        return css`
          background: rgba(245, 158, 11, 0.1);
          color: #d97706;
          border: 1px solid rgba(245, 158, 11, 0.2);
        `;
      case 'info':
        return css`
          background: rgba(99, 102, 241, 0.1);
          color: #6366f1;
          border: 1px solid rgba(99, 102, 241, 0.2);
        `;
      default:
        return css`
          background: rgba(100, 116, 139, 0.1);
          color: #475569;
          border: 1px solid rgba(100, 116, 139, 0.2);
        `;
    }
  }}

  svg {
    width: 12px;
    height: 12px;
  }
`;

const UnsavedIndicator = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  background: rgba(245, 158, 11, 0.15);
  color: #b45309;
  border: 1px solid rgba(245, 158, 11, 0.3);
  animation: ${pulse} 2s ease-in-out infinite;

  svg {
    width: 12px;
    height: 12px;
  }
`;

/* ---------- Navigation Tabs ---------- */
const NavTabs = styled.nav`
  display: flex;
  align-items: center;
  gap: 4px;
  background: rgba(241, 245, 249, 0.8);
  padding: 4px;
  border-radius: 12px;
  flex-wrap: wrap;

  @media (max-width: 768px) {
    width: 100%;
    justify-content: center;
  }
`;

const NavTab = styled(NavLink)<{ $isActive?: boolean }>`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  text-decoration: none;
  color: #64748b;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  white-space: nowrap;

  svg {
    width: 16px;
    height: 16px;
    transition: transform 0.2s ease;
  }

  &:hover {
    color: #6366f1;
    background: rgba(99, 102, 241, 0.08);

    svg {
      transform: scale(1.1);
    }
  }

  &.active {
    color: #6366f1;
    background: white;
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.15);

    &::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 3px;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
    }
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }
`;

const TabBadge = styled.span<{ $variant?: 'default' | 'warning' | 'success' }>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  padding: 0 6px;
  border-radius: 10px;
  font-size: 11px;
  font-weight: 700;

  ${({ $variant = 'default' }) => {
    switch ($variant) {
      case 'warning':
        return css`
          background: rgba(245, 158, 11, 0.2);
          color: #b45309;
        `;
      case 'success':
        return css`
          background: rgba(16, 185, 129, 0.2);
          color: #059669;
        `;
      default:
        return css`
          background: rgba(99, 102, 241, 0.15);
          color: #6366f1;
        `;
    }
  }}
`;

/* ---------- Quick Actions ---------- */
const QuickActionsSection = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const QuickActionButton = styled.button<{ $variant?: 'primary' | 'secondary' }>`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 10px 16px;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  ${({ $variant = 'secondary' }) =>
    $variant === 'primary'
      ? css`
          background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
          color: white;
          border: none;
          box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);

          &:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(99, 102, 241, 0.4);
          }

          &:active {
            transform: translateY(0);
          }
        `
      : css`
          background: white;
          color: #475569;
          border: 1px solid rgba(226, 232, 240, 0.8);

          &:hover {
            border-color: #6366f1;
            color: #6366f1;
            background: rgba(99, 102, 241, 0.04);
          }
        `}

  svg {
    width: 16px;
    height: 16px;
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }
`;

/* ---------- Health Score Ring ---------- */
const HealthScoreRing = styled.div<{ $score: number }>`
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: conic-gradient(
    ${({ $score }) => $score >= 80 ? '#10b981' : $score >= 60 ? '#f59e0b' : '#ef4444'} ${({ $score }) => $score * 3.6}deg,
    rgba(226, 232, 240, 0.5) 0deg
  );
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  cursor: pointer;
  transition: all 0.3s ease;

  &::before {
    content: '';
    position: absolute;
    width: 34px;
    height: 34px;
    border-radius: 50%;
    background: white;
  }

  &:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
`;

const HealthScoreValue = styled.span<{ $score: number }>`
  position: relative;
  z-index: 1;
  font-size: 12px;
  font-weight: 700;
  color: ${({ $score }) => $score >= 80 ? '#10b981' : $score >= 60 ? '#f59e0b' : '#ef4444'};
`;

const HealthScoreTooltip = styled.div`
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-top: 8px;
  padding: 12px 16px;
  background: #1e293b;
  border-radius: 10px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  z-index: 100;
  min-width: 200px;
  opacity: 0;
  visibility: hidden;
  transition: all 0.2s ease;

  ${HealthScoreRing}:hover & {
    opacity: 1;
    visibility: visible;
  }

  &::before {
    content: '';
    position: absolute;
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-bottom-color: #1e293b;
  }
`;

const TooltipTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: white;
  margin-bottom: 8px;
`;

const TooltipItem = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.8);
  margin-bottom: 4px;

  &:last-child { margin-bottom: 0; }

  svg { width: 12px; height: 12px; }
`;

/* ---------- Quick Insight Pill ---------- */
const InsightPill = styled.div<{ $type: 'success' | 'warning' | 'info' }>`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 600;
  animation: ${slideIn} 0.3s ease-out;
  cursor: pointer;
  transition: all 0.2s ease;

  ${({ $type }) => {
    switch ($type) {
      case 'success':
        return css`
          background: rgba(16, 185, 129, 0.1);
          color: #059669;
          border: 1px solid rgba(16, 185, 129, 0.2);
        `;
      case 'warning':
        return css`
          background: rgba(245, 158, 11, 0.1);
          color: #d97706;
          border: 1px solid rgba(245, 158, 11, 0.2);
        `;
      default:
        return css`
          background: rgba(99, 102, 241, 0.1);
          color: #6366f1;
          border: 1px solid rgba(99, 102, 241, 0.2);
        `;
    }
  }}

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  svg { width: 14px; height: 14px; }
`;

/* ---------- Dashboard Link ---------- */
const DashboardLink = styled(NavLink)`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  text-decoration: none;
  color: #6366f1;
  background: rgba(99, 102, 241, 0.08);
  border: 1px solid rgba(99, 102, 241, 0.2);
  transition: all 0.2s ease;
  margin-right: 8px;

  &:hover {
    background: rgba(99, 102, 241, 0.15);
    transform: translateY(-1px);
  }

  svg { width: 16px; height: 16px; }
`;

/* ---------- Navigation Config ---------- */
const navConfig = [
  { path: 'coverage', label: 'Coverages', Icon: ShieldCheckIcon },
  { path: 'pricing', label: 'Pricing', Icon: CurrencyDollarIcon },
  { path: 'forms', label: 'Forms', Icon: DocumentDuplicateIcon },
  { path: 'states', label: 'States', Icon: MapPinIcon },
  { path: 'rules', label: 'Rules', Icon: Cog6ToothIcon },
];

/* ---------- Component Props ---------- */
interface ProductContextBarProps {
  productId: string;
  productName: string;
  productCode?: string;
  formNumber?: string;
  effectiveDate?: string;
  status?: 'active' | 'pending' | 'archived';
  hasUnsavedChanges?: boolean;
  counts?: {
    coverages?: number;
    pricing?: number;
    forms?: number;
    states?: number;
    rules?: number;
  };
  healthScore?: number;
  quickInsight?: {
    type: 'success' | 'warning' | 'info';
    text: string;
  };
  onAISummary?: () => void;
  isLoadingSummary?: boolean;
  showDashboardLink?: boolean;
}

/* ---------- Main Component ---------- */
const ProductContextBar: React.FC<ProductContextBarProps> = memo(({
  productId,
  productName,
  productCode,
  formNumber,
  effectiveDate,
  status = 'active',
  hasUnsavedChanges = false,
  counts = {},
  healthScore,
  quickInsight,
  onAISummary,
  isLoadingSummary = false,
  showDashboardLink = true,
}) => {
  const location = useLocation();

  const getStatusVariant = (s: string): 'success' | 'warning' | 'default' => {
    switch (s) {
      case 'active': return 'success';
      case 'pending': return 'warning';
      default: return 'default';
    }
  };

  const getStatusIcon = (s: string) => {
    switch (s) {
      case 'active': return CheckCircleIcon;
      case 'pending': return ClockIcon;
      default: return ExclamationTriangleIcon;
    }
  };

  // Calculate health score from counts if not provided
  const calculatedHealthScore = useMemo(() => {
    if (healthScore !== undefined) return healthScore;
    let score = 0;
    if (counts.coverages && counts.coverages > 0) score += 25;
    if (counts.forms && counts.forms > 0) score += 20;
    if (counts.pricing && counts.pricing > 0) score += 20;
    if (counts.states && counts.states > 0) score += 20;
    if (counts.rules && counts.rules > 0) score += 15;
    return score;
  }, [healthScore, counts]);

  // Generate quick insight if not provided
  const displayInsight = useMemo(() => {
    if (quickInsight) return quickInsight;
    if (!counts.coverages || counts.coverages === 0) {
      return { type: 'warning' as const, text: 'Add coverages to get started' };
    }
    if (!counts.forms || counts.forms === 0) {
      return { type: 'info' as const, text: 'Upload policy forms' };
    }
    if (calculatedHealthScore >= 80) {
      return { type: 'success' as const, text: 'Product ready for market' };
    }
    return null;
  }, [quickInsight, counts, calculatedHealthScore]);

  const StatusIcon = getStatusIcon(status);

  return (
    <ContextBarWrapper>
      <ContextBarContent>
        <ProductInfoSection>
          {/* Health Score Ring */}
          <HealthScoreRing $score={calculatedHealthScore}>
            <HealthScoreValue $score={calculatedHealthScore}>
              {calculatedHealthScore}
            </HealthScoreValue>
            <HealthScoreTooltip>
              <TooltipTitle>Product Health Score</TooltipTitle>
              <TooltipItem>
                <CheckCircleIcon style={{ color: counts.coverages ? '#10b981' : '#64748b' }} />
                Coverages: {counts.coverages || 0}
              </TooltipItem>
              <TooltipItem>
                <CheckCircleIcon style={{ color: counts.forms ? '#10b981' : '#64748b' }} />
                Forms: {counts.forms || 0}
              </TooltipItem>
              <TooltipItem>
                <CheckCircleIcon style={{ color: counts.pricing ? '#10b981' : '#64748b' }} />
                Pricing Rules: {counts.pricing || 0}
              </TooltipItem>
              <TooltipItem>
                <CheckCircleIcon style={{ color: counts.states ? '#10b981' : '#64748b' }} />
                States: {counts.states || 0}
              </TooltipItem>
            </HealthScoreTooltip>
          </HealthScoreRing>

          <ProductDetails>
            <ProductName>
              {productName}
              {hasUnsavedChanges && (
                <UnsavedIndicator>
                  <ExclamationTriangleIcon />
                  Unsaved
                </UnsavedIndicator>
              )}
            </ProductName>
            <ProductMeta>
              <MetaBadge $variant={getStatusVariant(status)}>
                <StatusIcon />
                {status.charAt(0).toUpperCase() + status.slice(1)}
              </MetaBadge>
              {productCode && (
                <MetaBadge $variant="info">
                  {productCode}
                </MetaBadge>
              )}
              {formNumber && (
                <MetaBadge>
                  {formNumber}
                </MetaBadge>
              )}
              {effectiveDate && (
                <MetaBadge>
                  <ClockIcon />
                  {effectiveDate}
                </MetaBadge>
              )}
              {/* Quick Insight Pill */}
              {displayInsight && (
                <InsightPill $type={displayInsight.type}>
                  <SparklesIcon />
                  {displayInsight.text}
                </InsightPill>
              )}
            </ProductMeta>
          </ProductDetails>
        </ProductInfoSection>

        <NavTabs aria-label="Product navigation">
          {/* Dashboard Link */}
          {showDashboardLink && (
            <DashboardLink to={`/products/${productId}/overview`}>
              <HomeIcon />
              Dashboard
            </DashboardLink>
          )}
          {navConfig.map(({ path, label, Icon }) => (
            <NavTab
              key={path}
              to={`/${path}/${productId}`}
              aria-current={location.pathname.includes(`/${path}/`) ? 'page' : undefined}
            >
              <Icon />
              {label}
              {counts[path as keyof typeof counts] !== undefined && (
                <TabBadge
                  $variant={counts[path as keyof typeof counts] === 0 ? 'warning' : 'default'}
                >
                  {counts[path as keyof typeof counts]}
                </TabBadge>
              )}
            </NavTab>
          ))}
        </NavTabs>

        {onAISummary && (
          <QuickActionsSection>
            <QuickActionButton
              $variant="primary"
              onClick={onAISummary}
              disabled={isLoadingSummary}
              aria-label="Generate AI Summary"
            >
              <SparklesIcon />
              {isLoadingSummary ? 'Analyzing...' : 'AI Summary'}
            </QuickActionButton>
          </QuickActionsSection>
        )}
      </ContextBarContent>
    </ContextBarWrapper>
  );
});

ProductContextBar.displayName = 'ProductContextBar';

export default ProductContextBar;

```

---

## src/components/ui/ProductQuickActionsBar.tsx

**Path:** `src/components/ui/ProductQuickActionsBar.tsx`

```tsx
/**
 * ProductQuickActionsBar - Unified floating quick actions for product pages
 * 
 * Provides context-aware quick actions that appear on all product-related pages
 * for common operations like navigation, AI assistance, and data management.
 */

import React, { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import styled, { keyframes } from 'styled-components';
import {
  HomeIcon,
  ShieldCheckIcon,
  DocumentTextIcon,
  CurrencyDollarIcon,
  MapIcon,
  Cog6ToothIcon,
  ChartBarIcon,
  SparklesIcon,
  ArrowPathIcon,
  ChevronUpIcon,
  ChevronDownIcon,
} from '@heroicons/react/24/solid';

// ============ Animations ============
const slideIn = keyframes`
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
`;

const pulse = keyframes`
  0%, 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); }
  50% { box-shadow: 0 0 0 8px rgba(99, 102, 241, 0); }
`;

// ============ Styled Components ============
const BarContainer = styled.div<{ $isExpanded: boolean }>`
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  animation: ${slideIn} 0.4s ease-out;
`;

const BarWrapper = styled.div<{ $isExpanded: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: ${({ $isExpanded }) => $isExpanded ? '12px 20px' : '8px 12px'};
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
`;

const ActionButton = styled.button<{ $active?: boolean; $color?: string }>`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 10px 16px;
  border: none;
  border-radius: 12px;
  background: ${({ $active, $color }) => 
    $active 
      ? ($color || 'linear-gradient(135deg, #6366f1, #8b5cf6)') 
      : 'rgba(248, 250, 252, 0.8)'};
  color: ${({ $active }) => $active ? 'white' : '#64748b'};
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;

  &:hover {
    background: ${({ $active, $color }) => 
      $active 
        ? ($color || 'linear-gradient(135deg, #4f46e5, #7c3aed)') 
        : 'rgba(99, 102, 241, 0.1)'};
    color: ${({ $active }) => $active ? 'white' : '#6366f1'};
    transform: translateY(-2px);
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const AIButton = styled(ActionButton)`
  background: linear-gradient(135deg, #8b5cf6, #a855f7);
  color: white;
  animation: ${pulse} 2s infinite;

  &:hover {
    background: linear-gradient(135deg, #7c3aed, #9333ea);
  }
`;

const ToggleButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 8px;
  background: rgba(248, 250, 252, 0.8);
  color: #64748b;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const Divider = styled.div`
  width: 1px;
  height: 24px;
  background: rgba(226, 232, 240, 0.8);
  margin: 0 4px;
`;

// ============ Types ============
interface ProductQuickActionsBarProps {
  productId: string;
  currentPage?: 'dashboard' | 'coverage' | 'forms' | 'pricing' | 'states' | 'rules';
  onAIAssist?: () => void;
  onRefresh?: () => void;
}

// ============ Component ============
export const ProductQuickActionsBar: React.FC<ProductQuickActionsBarProps> = ({
  productId,
  currentPage,
  onAIAssist,
  onRefresh,
}) => {
  const navigate = useNavigate();
  const [isExpanded, setIsExpanded] = useState(true);

  const handleNavigate = useCallback((path: string) => {
    navigate(path);
  }, [navigate]);

  return (
    <BarContainer $isExpanded={isExpanded}>
      <BarWrapper $isExpanded={isExpanded}>
        <ToggleButton onClick={() => setIsExpanded(!isExpanded)}>
          {isExpanded ? <ChevronDownIcon /> : <ChevronUpIcon />}
        </ToggleButton>

        {isExpanded && (
          <>
            <Divider />
            <ActionButton $active={currentPage === 'dashboard'} onClick={() => handleNavigate(`/product360/${productId}`)}>
              <ChartBarIcon /> Dashboard
            </ActionButton>
            <ActionButton $active={currentPage === 'coverage'} onClick={() => handleNavigate(`/coverage/${productId}`)}>
              <ShieldCheckIcon /> Coverage
            </ActionButton>
            <ActionButton $active={currentPage === 'forms'} onClick={() => handleNavigate(`/forms/${productId}`)}>
              <DocumentTextIcon /> Forms
            </ActionButton>
            <ActionButton $active={currentPage === 'pricing'} onClick={() => handleNavigate(`/pricing/${productId}`)}>
              <CurrencyDollarIcon /> Pricing
            </ActionButton>
            <ActionButton $active={currentPage === 'states'} onClick={() => handleNavigate(`/states/${productId}`)}>
              <MapIcon /> States
            </ActionButton>
            <ActionButton $active={currentPage === 'rules'} onClick={() => handleNavigate(`/rules/${productId}`)}>
              <Cog6ToothIcon /> Rules
            </ActionButton>
            <Divider />
            {onRefresh && (
              <ActionButton onClick={onRefresh}>
                <ArrowPathIcon /> Refresh
              </ActionButton>
            )}
            {onAIAssist && (
              <AIButton onClick={onAIAssist}>
                <SparklesIcon /> AI Assist
              </AIButton>
            )}
          </>
        )}
      </BarWrapper>
    </BarContainer>
  );
};

export default ProductQuickActionsBar;

```

---

## src/components/ui/QuickActionMenu.tsx

**Path:** `src/components/ui/QuickActionMenu.tsx`

```tsx
// src/components/ui/QuickActionMenu.tsx
import React, { memo, useState, useRef, useEffect, useCallback } from 'react';
import styled, { keyframes, css } from 'styled-components';
import {
  EllipsisVerticalIcon,
  PencilIcon,
  DocumentDuplicateIcon,
  TrashIcon,
  EyeIcon,
  ArrowDownTrayIcon,
  LinkIcon,
  CheckIcon,
  StarIcon,
  ArchiveBoxIcon,
} from '@heroicons/react/24/outline';

/* ---------- Animations ---------- */
const fadeIn = keyframes`
  from { opacity: 0; transform: scale(0.95) translateY(-4px); }
  to { opacity: 1; transform: scale(1) translateY(0); }
`;

const fadeOut = keyframes`
  from { opacity: 1; transform: scale(1) translateY(0); }
  to { opacity: 0; transform: scale(0.95) translateY(-4px); }
`;

/* ---------- Container ---------- */
const MenuContainer = styled.div`
  position: relative;
  display: inline-flex;
`;

const TriggerButton = styled.button<{ $isOpen?: boolean }>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  border: none;
  background: ${({ $isOpen }) => $isOpen ? 'rgba(99, 102, 241, 0.1)' : 'transparent'};
  color: ${({ $isOpen }) => $isOpen ? '#6366f1' : '#64748b'};
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: 2px;
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

/* ---------- Dropdown ---------- */
const DropdownWrapper = styled.div<{ $isOpen: boolean; $position?: 'left' | 'right' }>`
  position: absolute;
  top: calc(100% + 4px);
  ${({ $position }) => $position === 'left' ? 'left: 0;' : 'right: 0;'}
  min-width: 200px;
  background: white;
  border-radius: 12px;
  border: 1px solid rgba(226, 232, 240, 0.8);
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12), 0 4px 12px rgba(0, 0, 0, 0.08);
  z-index: 1000;
  overflow: hidden;
  animation: ${({ $isOpen }) => $isOpen ? fadeIn : fadeOut} 0.15s ease-out forwards;
  pointer-events: ${({ $isOpen }) => $isOpen ? 'auto' : 'none'};
`;

const MenuSection = styled.div`
  padding: 6px;

  &:not(:last-child) {
    border-bottom: 1px solid rgba(226, 232, 240, 0.8);
  }
`;

const SectionLabel = styled.div`
  padding: 8px 12px 4px;
  font-size: 11px;
  font-weight: 600;
  color: #94a3b8;
  text-transform: uppercase;
  letter-spacing: 0.05em;
`;

const MenuItem = styled.button<{ $variant?: 'default' | 'danger' | 'success' }>`
  display: flex;
  align-items: center;
  gap: 10px;
  width: 100%;
  padding: 10px 12px;
  border: none;
  background: transparent;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
  text-align: left;

  ${({ $variant = 'default' }) => {
    switch ($variant) {
      case 'danger':
        return css`
          color: #ef4444;

          &:hover {
            background: rgba(239, 68, 68, 0.1);
          }
        `;
      case 'success':
        return css`
          color: #10b981;

          &:hover {
            background: rgba(16, 185, 129, 0.1);
          }
        `;
      default:
        return css`
          color: #374151;

          &:hover {
            background: rgba(99, 102, 241, 0.08);
            color: #6366f1;
          }
        `;
    }
  }}

  svg {
    width: 18px;
    height: 18px;
    flex-shrink: 0;
  }

  &:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.4);
    outline-offset: -2px;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;

    &:hover {
      background: transparent;
      color: inherit;
    }
  }
`;

const MenuItemLabel = styled.span`
  flex: 1;
`;

const MenuItemShortcut = styled.span`
  font-size: 12px;
  color: #94a3b8;
  font-weight: 400;
`;

/* ---------- Preset Action Types ---------- */
export interface ActionItem {
  id: string;
  label: string;
  icon?: React.ComponentType<{ className?: string }>;
  onClick: () => void;
  variant?: 'default' | 'danger' | 'success';
  shortcut?: string;
  disabled?: boolean;
}

export interface ActionSection {
  label?: string;
  items: ActionItem[];
}

/* ---------- Common Action Presets ---------- */
export const commonActions = {
  view: (onClick: () => void): ActionItem => ({
    id: 'view',
    label: 'View Details',
    icon: EyeIcon,
    onClick,
    shortcut: 'Enter',
  }),
  edit: (onClick: () => void): ActionItem => ({
    id: 'edit',
    label: 'Edit',
    icon: PencilIcon,
    onClick,
    shortcut: 'E',
  }),
  duplicate: (onClick: () => void): ActionItem => ({
    id: 'duplicate',
    label: 'Duplicate',
    icon: DocumentDuplicateIcon,
    onClick,
    shortcut: 'âŒ˜D',
  }),
  delete: (onClick: () => void): ActionItem => ({
    id: 'delete',
    label: 'Delete',
    icon: TrashIcon,
    onClick,
    variant: 'danger' as const,
  }),
  download: (onClick: () => void): ActionItem => ({
    id: 'download',
    label: 'Download',
    icon: ArrowDownTrayIcon,
    onClick,
  }),
  copyLink: (onClick: () => void): ActionItem => ({
    id: 'copyLink',
    label: 'Copy Link',
    icon: LinkIcon,
    onClick,
    shortcut: 'âŒ˜L',
  }),
  archive: (onClick: () => void): ActionItem => ({
    id: 'archive',
    label: 'Archive',
    icon: ArchiveBoxIcon,
    onClick,
  }),
  favorite: (onClick: () => void, isFavorite = false): ActionItem => ({
    id: 'favorite',
    label: isFavorite ? 'Remove from Favorites' : 'Add to Favorites',
    icon: StarIcon,
    onClick,
    variant: isFavorite ? 'success' : 'default',
  }),
  markComplete: (onClick: () => void, isComplete = false): ActionItem => ({
    id: 'markComplete',
    label: isComplete ? 'Mark Incomplete' : 'Mark Complete',
    icon: CheckIcon,
    onClick,
    variant: isComplete ? 'default' : 'success',
  }),
};

/* ---------- Component Props ---------- */
interface QuickActionMenuProps {
  sections: ActionSection[];
  position?: 'left' | 'right';
  triggerIcon?: React.ComponentType<{ className?: string }>;
  onOpenChange?: (isOpen: boolean) => void;
}

/* ---------- Main Component ---------- */
const QuickActionMenu: React.FC<QuickActionMenuProps> = memo(({
  sections,
  position = 'right',
  triggerIcon: TriggerIcon = EllipsisVerticalIcon,
  onOpenChange,
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const menuRef = useRef<HTMLDivElement>(null);

  const handleToggle = useCallback(() => {
    const newState = !isOpen;
    setIsOpen(newState);
    onOpenChange?.(newState);
  }, [isOpen, onOpenChange]);

  const handleClose = useCallback(() => {
    setIsOpen(false);
    onOpenChange?.(false);
  }, [onOpenChange]);

  const handleItemClick = useCallback((action: () => void) => {
    action();
    handleClose();
  }, [handleClose]);

  // Close on click outside
  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        handleClose();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isOpen, handleClose]);

  // Close on escape
  useEffect(() => {
    if (!isOpen) return;

    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        handleClose();
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [isOpen, handleClose]);

  // Keyboard navigation
  useEffect(() => {
    if (!isOpen || !menuRef.current) return;

    const buttons = menuRef.current.querySelectorAll('button:not(:disabled)');
    if (buttons.length > 0) {
      (buttons[0] as HTMLButtonElement).focus();
    }
  }, [isOpen]);

  return (
    <MenuContainer ref={containerRef}>
      <TriggerButton
        $isOpen={isOpen}
        onClick={handleToggle}
        aria-haspopup="menu"
        aria-expanded={isOpen}
        aria-label="Actions menu"
      >
        <TriggerIcon />
      </TriggerButton>

      {isOpen && (
        <DropdownWrapper
          ref={menuRef}
          $isOpen={isOpen}
          $position={position}
          role="menu"
          aria-orientation="vertical"
        >
          {sections.map((section, sectionIndex) => (
            <MenuSection key={sectionIndex}>
              {section.label && <SectionLabel>{section.label}</SectionLabel>}
              {section.items.map((item) => (
                <MenuItem
                  key={item.id}
                  $variant={item.variant}
                  onClick={() => handleItemClick(item.onClick)}
                  disabled={item.disabled}
                  role="menuitem"
                >
                  {item.icon && <item.icon />}
                  <MenuItemLabel>{item.label}</MenuItemLabel>
                  {item.shortcut && <MenuItemShortcut>{item.shortcut}</MenuItemShortcut>}
                </MenuItem>
              ))}
            </MenuSection>
          ))}
        </DropdownWrapper>
      )}
    </MenuContainer>
  );
});

QuickActionMenu.displayName = 'QuickActionMenu';

export default QuickActionMenu;

```

---

## src/components/ui/RouteProgress.tsx

**Path:** `src/components/ui/RouteProgress.tsx`

```tsx
/**
 * RouteProgress - Visual progress indicator for route transitions
 * 
 * Shows a progress bar at the top of the screen during lazy-loaded
 * route transitions to provide feedback on loading state.
 */

import React, { createContext, useContext, useState, useCallback, useEffect, useRef } from 'react';
import styled, { keyframes, css } from 'styled-components';

// ============ Animations ============
const progressIndeterminate = keyframes`
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
`;

const fadeOut = keyframes`
  from { opacity: 1; }
  to { opacity: 0; }
`;

// ============ Styled Components ============
const ProgressContainer = styled.div<{ $isVisible: boolean; $isCompleting: boolean }>`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  z-index: 10000;
  pointer-events: none;
  overflow: hidden;
  background: rgba(99, 102, 241, 0.1);
  
  ${({ $isVisible }) => !$isVisible && css`
    opacity: 0;
    visibility: hidden;
  `}
  
  ${({ $isCompleting }) => $isCompleting && css`
    animation: ${fadeOut} 0.3s ease-out forwards;
  `}
`;

const ProgressBar = styled.div<{ $progress: number; $isIndeterminate: boolean }>`
  height: 100%;
  background: linear-gradient(90deg, #6366f1, #8b5cf6, #06b6d4);
  background-size: 200% 100%;
  border-radius: 0 2px 2px 0;
  transition: width 0.2s ease-out;
  
  ${({ $isIndeterminate, $progress }) => $isIndeterminate ? css`
    width: 30%;
    animation: ${progressIndeterminate} 1s ease-in-out infinite;
  ` : css`
    width: ${$progress}%;
  `}
  
  /* Shimmer effect */
  &::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(255, 255, 255, 0.4) 50%,
      transparent 100%
    );
    animation: ${progressIndeterminate} 1.5s ease-in-out infinite;
  }
`;

const Glow = styled.div`
  position: absolute;
  top: 0;
  right: 0;
  width: 100px;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.5));
  filter: blur(4px);
`;

// ============ Context & Hook ============
interface RouteProgressContextType {
  start: () => void;
  done: () => void;
  set: (progress: number) => void;
  isLoading: boolean;
}

const RouteProgressContext = createContext<RouteProgressContextType | null>(null);

export const useRouteProgress = (): RouteProgressContextType => {
  const context = useContext(RouteProgressContext);
  if (!context) {
    throw new Error('useRouteProgress must be used within RouteProgressProvider');
  }
  return context;
};

// ============ Provider Component ============
interface RouteProgressProviderProps {
  children: React.ReactNode;
  /** Minimum time to show progress (prevents flash) */
  minimumDuration?: number;
  /** Delay before showing progress (prevents flash for fast loads) */
  showDelay?: number;
}

export const RouteProgressProvider: React.FC<RouteProgressProviderProps> = ({
  children,
  minimumDuration = 300,
  showDelay = 100,
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [isVisible, setIsVisible] = useState(false);
  const [isCompleting, setIsCompleting] = useState(false);
  const [progress, setProgress] = useState(0);
  
  const startTimeRef = useRef<number>(0);
  const showTimeoutRef = useRef<NodeJS.Timeout>();
  const progressIntervalRef = useRef<NodeJS.Timeout>();

  const start = useCallback(() => {
    // Clear any existing timers
    if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);
    if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
    
    setIsLoading(true);
    setIsCompleting(false);
    setProgress(0);
    startTimeRef.current = Date.now();
    
    // Delay showing to prevent flash for fast loads
    showTimeoutRef.current = setTimeout(() => {
      setIsVisible(true);
      
      // Simulate progress
      let currentProgress = 0;
      progressIntervalRef.current = setInterval(() => {
        currentProgress += Math.random() * 15;
        if (currentProgress > 90) currentProgress = 90;
        setProgress(currentProgress);
      }, 200);
    }, showDelay);
  }, [showDelay]);

  const done = useCallback(() => {
    if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);
    if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
    
    const elapsed = Date.now() - startTimeRef.current;
    const remaining = Math.max(0, minimumDuration - elapsed);
    
    // Complete the progress bar
    setProgress(100);
    
    setTimeout(() => {
      setIsCompleting(true);
      setTimeout(() => {
        setIsLoading(false);
        setIsVisible(false);
        setIsCompleting(false);
        setProgress(0);
      }, 300);
    }, remaining);
  }, [minimumDuration]);

  const set = useCallback((value: number) => {
    setProgress(Math.min(100, Math.max(0, value)));
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (showTimeoutRef.current) clearTimeout(showTimeoutRef.current);
      if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
    };
  }, []);

  return (
    <RouteProgressContext.Provider value={{ start, done, set, isLoading }}>
      {children}
      <ProgressContainer $isVisible={isVisible} $isCompleting={isCompleting}>
        <ProgressBar $progress={progress} $isIndeterminate={false} />
        {isVisible && <Glow />}
      </ProgressContainer>
    </RouteProgressContext.Provider>
  );
};

export default RouteProgressProvider;

```

---

## src/components/ui/Select.tsx

**Path:** `src/components/ui/Select.tsx`

```tsx
/**
 * Select - Accessible dropdown select component
 */

import React, { useState, useRef, useCallback, useEffect, KeyboardEvent } from 'react';
import styled, { css } from 'styled-components';
import { ChevronDownIcon, CheckIcon } from '@heroicons/react/24/solid';

export interface SelectOption {
  value: string;
  label: string;
  disabled?: boolean;
  icon?: React.ReactNode;
}

interface SelectProps {
  options: SelectOption[];
  value?: string;
  onChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  error?: boolean;
  errorMessage?: string;
  label?: string;
  id?: string;
  className?: string;
}

const SelectContainer = styled.div`position: relative; width: 100%;`;

const Label = styled.label`
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
  margin-bottom: 6px;
`;

const SelectButton = styled.button<{ $isOpen: boolean; $hasError: boolean; $hasValue: boolean }>`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  font-size: 15px;
  font-family: inherit;
  text-align: left;
  color: ${({ theme, $hasValue }) => $hasValue ? theme.colours.text : theme.colours.textMuted};
  background: ${({ theme }) => theme.colours.background};
  border: 1.5px solid ${({ theme, $hasError, $isOpen }) => 
    $hasError ? theme.colours.error : $isOpen ? theme.colours.primary : theme.colours.border};
  border-radius: ${({ theme }) => theme.radiusMd};
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover:not(:disabled) { border-color: ${({ theme, $hasError }) => $hasError ? theme.colours.error : theme.colours.primary}; }
  &:focus { outline: none; border-color: ${({ theme }) => theme.colours.primary}; box-shadow: ${({ theme }) => theme.shadowFocus}; }
  &:disabled { opacity: 0.6; cursor: not-allowed; background: ${({ theme }) => theme.colours.backgroundSubtle}; }
  
  svg { width: 20px; height: 20px; color: ${({ theme }) => theme.colours.textMuted}; transition: transform 0.2s ease;
    ${({ $isOpen }) => $isOpen && css`transform: rotate(180deg);`} }
`;

const SelectedContent = styled.span`display: flex; align-items: center; gap: 8px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;`;

const Dropdown = styled.ul<{ $isOpen: boolean }>`
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  max-height: 280px;
  overflow-y: auto;
  background: ${({ theme }) => theme.colours.background};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: ${({ theme }) => theme.radiusMd};
  box-shadow: ${({ theme }) => theme.shadowLg};
  z-index: 1000;
  list-style: none;
  margin: 0;
  padding: 4px;
  opacity: ${({ $isOpen }) => $isOpen ? 1 : 0};
  visibility: ${({ $isOpen }) => $isOpen ? 'visible' : 'hidden'};
  transform: ${({ $isOpen }) => $isOpen ? 'translateY(0)' : 'translateY(-8px)'};
  transition: all 0.2s ease;
`;

const Option = styled.li<{ $isSelected: boolean; $isFocused: boolean; $isDisabled: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  font-size: 14px;
  border-radius: ${({ theme }) => theme.radiusSm};
  cursor: ${({ $isDisabled }) => $isDisabled ? 'not-allowed' : 'pointer'};
  color: ${({ theme, $isDisabled }) => $isDisabled ? theme.colours.textMuted : theme.colours.text};
  background: ${({ theme, $isSelected, $isFocused }) => 
    $isSelected ? theme.colours.primaryLight : $isFocused ? theme.colours.hover : 'transparent'};
  transition: background 0.15s ease;
  
  &:hover:not([aria-disabled="true"]) { background: ${({ theme, $isSelected }) => $isSelected ? theme.colours.primaryLight : theme.colours.hover}; }
`;

const OptionIcon = styled.span`display: flex; align-items: center; flex-shrink: 0; svg { width: 16px; height: 16px; }`;
const CheckMark = styled.span`margin-left: auto; color: ${({ theme }) => theme.colours.primary}; svg { width: 16px; height: 16px; }`;
const ErrorMessage = styled.span`display: block; font-size: 13px; color: ${({ theme }) => theme.colours.error}; margin-top: 4px;`;

export const Select: React.FC<SelectProps> = ({ options, value, onChange, placeholder = 'Select an option', disabled = false, error = false, errorMessage, label, id, className }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const containerRef = useRef<HTMLDivElement>(null);
  const buttonRef = useRef<HTMLButtonElement>(null);
  
  const selectedOption = options.find(opt => opt.value === value);
  const selectId = id || `select-${Math.random().toString(36).substr(2, 9)}`;
  
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) setIsOpen(false);
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);
  
  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLButtonElement>) => {
    switch (e.key) {
      case 'Enter': case ' ': e.preventDefault();
        if (!isOpen) { setIsOpen(true); setFocusedIndex(options.findIndex(opt => opt.value === value)); }
        else if (focusedIndex >= 0 && !options[focusedIndex]?.disabled) { onChange(options[focusedIndex].value); setIsOpen(false); }
        break;
      case 'ArrowDown': e.preventDefault();
        if (!isOpen) setIsOpen(true);
        else setFocusedIndex(prev => { let next = prev + 1; while (next < options.length && options[next]?.disabled) next++; return next < options.length ? next : prev; });
        break;
      case 'ArrowUp': e.preventDefault();
        if (isOpen) setFocusedIndex(prev => { let next = prev - 1; while (next >= 0 && options[next]?.disabled) next--; return next >= 0 ? next : prev; });
        break;
      case 'Escape': setIsOpen(false); buttonRef.current?.focus(); break;
      case 'Tab': setIsOpen(false); break;
    }
  }, [isOpen, focusedIndex, options, value, onChange]);
  
  const handleOptionClick = useCallback((optionValue: string, isDisabled?: boolean) => {
    if (isDisabled) return;
    onChange(optionValue); setIsOpen(false); buttonRef.current?.focus();
  }, [onChange]);
  
  return (
    <SelectContainer ref={containerRef} className={className}>
      {label && <Label htmlFor={selectId}>{label}</Label>}
      <SelectButton ref={buttonRef} id={selectId} type="button" role="combobox" aria-expanded={isOpen} aria-haspopup="listbox" aria-controls={`${selectId}-listbox`} aria-invalid={error} disabled={disabled} $isOpen={isOpen} $hasError={error} $hasValue={!!selectedOption} onClick={() => !disabled && setIsOpen(!isOpen)} onKeyDown={handleKeyDown}>
        <SelectedContent>{selectedOption?.icon && <OptionIcon>{selectedOption.icon}</OptionIcon>}{selectedOption?.label || placeholder}</SelectedContent>
        <ChevronDownIcon />
      </SelectButton>
      <Dropdown id={`${selectId}-listbox`} role="listbox" aria-labelledby={selectId} $isOpen={isOpen}>
        {options.map((option, index) => (
          <Option key={option.value} role="option" aria-selected={option.value === value} aria-disabled={option.disabled} $isSelected={option.value === value} $isFocused={index === focusedIndex} $isDisabled={!!option.disabled} onClick={() => handleOptionClick(option.value, option.disabled)} onMouseEnter={() => !option.disabled && setFocusedIndex(index)}>
            {option.icon && <OptionIcon>{option.icon}</OptionIcon>}{option.label}{option.value === value && <CheckMark><CheckIcon /></CheckMark>}
          </Option>
        ))}
      </Dropdown>
      {error && errorMessage && <ErrorMessage id={`${selectId}-error`} role="alert">{errorMessage}</ErrorMessage>}
    </SelectContainer>
  );
};

export default Select;

```

---

## src/components/ui/StatusBadge.tsx

**Path:** `src/components/ui/StatusBadge.tsx`

```tsx
import React from 'react';
import styled from 'styled-components';

type StatusType = 
  | 'active' 
  | 'inactive' 
  | 'pending' 
  | 'approved' 
  | 'rejected' 
  | 'draft' 
  | 'published'
  | 'archived'
  | 'in-review'
  | 'success'
  | 'warning'
  | 'error'
  | 'info';

interface StatusBadgeProps {
  status: StatusType;
  label?: string;
  size?: 'sm' | 'md' | 'lg';
  showDot?: boolean;
}

const statusConfig: Record<StatusType, { color: string; background: string; border: string }> = {
  active: {
    color: '#047857',
    background: 'rgba(16, 185, 129, 0.1)',
    border: 'rgba(16, 185, 129, 0.2)',
  },
  inactive: {
    color: '#6b7280',
    background: 'rgba(107, 114, 128, 0.1)',
    border: 'rgba(107, 114, 128, 0.2)',
  },
  pending: {
    color: '#d97706',
    background: 'rgba(245, 158, 11, 0.1)',
    border: 'rgba(245, 158, 11, 0.2)',
  },
  approved: {
    color: '#047857',
    background: 'rgba(16, 185, 129, 0.1)',
    border: 'rgba(16, 185, 129, 0.2)',
  },
  rejected: {
    color: '#dc2626',
    background: 'rgba(220, 38, 38, 0.1)',
    border: 'rgba(220, 38, 38, 0.2)',
  },
  draft: {
    color: '#6b7280',
    background: 'rgba(107, 114, 128, 0.1)',
    border: 'rgba(107, 114, 128, 0.2)',
  },
  published: {
    color: '#1d4ed8',
    background: 'rgba(59, 130, 246, 0.1)',
    border: 'rgba(59, 130, 246, 0.2)',
  },
  archived: {
    color: '#78716c',
    background: 'rgba(120, 113, 108, 0.1)',
    border: 'rgba(120, 113, 108, 0.2)',
  },
  'in-review': {
    color: '#7c3aed',
    background: 'rgba(139, 92, 246, 0.1)',
    border: 'rgba(139, 92, 246, 0.2)',
  },
  success: {
    color: '#047857',
    background: 'rgba(16, 185, 129, 0.1)',
    border: 'rgba(16, 185, 129, 0.2)',
  },
  warning: {
    color: '#d97706',
    background: 'rgba(245, 158, 11, 0.1)',
    border: 'rgba(245, 158, 11, 0.2)',
  },
  error: {
    color: '#dc2626',
    background: 'rgba(220, 38, 38, 0.1)',
    border: 'rgba(220, 38, 38, 0.2)',
  },
  info: {
    color: '#1d4ed8',
    background: 'rgba(59, 130, 246, 0.1)',
    border: 'rgba(59, 130, 246, 0.2)',
  },
};

const sizeConfig = {
  sm: {
    padding: '4px 8px',
    fontSize: '11px',
    dotSize: '6px',
  },
  md: {
    padding: '6px 12px',
    fontSize: '13px',
    dotSize: '8px',
  },
  lg: {
    padding: '8px 16px',
    fontSize: '14px',
    dotSize: '10px',
  },
};

const Badge = styled.span<{ 
  $status: StatusType; 
  $size: 'sm' | 'md' | 'lg';
}>`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: ${props => sizeConfig[props.$size].padding};
  font-size: ${props => sizeConfig[props.$size].fontSize};
  font-weight: 600;
  border-radius: 12px;
  border: 1px solid ${props => statusConfig[props.$status].border};
  background: ${props => statusConfig[props.$status].background};
  color: ${props => statusConfig[props.$status].color};
  text-transform: capitalize;
  white-space: nowrap;
  transition: all 0.2s ease;

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px ${props => statusConfig[props.$status].border};
  }
`;

const StatusDot = styled.span<{ 
  $status: StatusType; 
  $size: 'sm' | 'md' | 'lg';
}>`
  width: ${props => sizeConfig[props.$size].dotSize};
  height: ${props => sizeConfig[props.$size].dotSize};
  border-radius: 50%;
  background: ${props => statusConfig[props.$status].color};
  flex-shrink: 0;
`;

export const StatusBadge: React.FC<StatusBadgeProps> = ({ 
  status, 
  label,
  size = 'md',
  showDot = true 
}) => {
  const displayLabel = label || status.replace('-', ' ');
  
  return (
    <Badge $status={status} $size={size}>
      {showDot && <StatusDot $status={status} $size={size} />}
      {displayLabel}
    </Badge>
  );
};

// Convenience components for common insurance statuses
export const ActiveBadge: React.FC<{ size?: 'sm' | 'md' | 'lg' }> = ({ size }) => (
  <StatusBadge status="active" label="Active" size={size} />
);

export const InactiveBadge: React.FC<{ size?: 'sm' | 'md' | 'lg' }> = ({ size }) => (
  <StatusBadge status="inactive" label="Inactive" size={size} />
);

export const PendingBadge: React.FC<{ size?: 'sm' | 'md' | 'lg' }> = ({ size }) => (
  <StatusBadge status="pending" label="Pending" size={size} />
);

export const ApprovedBadge: React.FC<{ size?: 'sm' | 'md' | 'lg' }> = ({ size }) => (
  <StatusBadge status="approved" label="Approved" size={size} />
);

export const DraftBadge: React.FC<{ size?: 'sm' | 'md' | 'lg' }> = ({ size }) => (
  <StatusBadge status="draft" label="Draft" size={size} />
);

export const PublishedBadge: React.FC<{ size?: 'sm' | 'md' | 'lg' }> = ({ size }) => (
  <StatusBadge status="published" label="Published" size={size} />
);

```

---

## src/components/ui/Table.tsx

**Path:** `src/components/ui/Table.tsx`

```tsx
import styled, { css, keyframes } from 'styled-components';

/* ---------- Animations ---------- */
const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const slideUp = keyframes`
  from {
    opacity: 0;
    transform: translateY(16px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

/* ---------- Table Types ---------- */
type TableVariant = 'default' | 'striped' | 'bordered' | 'compact';
type TableSize = 'sm' | 'md' | 'lg';

interface TableProps {
  $variant?: TableVariant;
  $size?: TableSize;
  $hoverable?: boolean;
  $stickyHeader?: boolean;
}

interface ThProps {
  align?: 'left' | 'center' | 'right';
  $sortable?: boolean;
  $sortDirection?: 'asc' | 'desc' | null;
  $width?: string;
}

interface TdProps {
  align?: 'left' | 'center' | 'right';
  $truncate?: boolean;
  $maxWidth?: string;
}

/* ---------- Size Styles ---------- */
const sizeStyles = {
  sm: css`
    th, td { padding: 8px 12px; font-size: 13px; }
  `,
  md: css`
    th, td { padding: 12px 16px; font-size: 14px; }
  `,
  lg: css`
    th, td { padding: 16px 20px; font-size: 15px; }
  `,
};

/* ---------- Variant Styles ---------- */
const variantStyles = {
  default: css`
    tr { border-bottom: 1px solid ${({ theme }) => theme.colours.border}; }
    tbody tr:last-child { border-bottom: none; }
  `,
  striped: css`
    tr { border-bottom: 1px solid ${({ theme }) => theme.colours.border}; }
    tbody tr:nth-child(even) { background: ${({ theme }) => theme.colours.backgroundAlt}; }
    tbody tr:last-child { border-bottom: none; }
  `,
  bordered: css`
    border: 1px solid ${({ theme }) => theme.colours.border};
    th, td { border: 1px solid ${({ theme }) => theme.colours.border}; }
  `,
  compact: css`
    th, td { padding: 6px 10px; font-size: 13px; }
    tr { border-bottom: 1px solid ${({ theme }) => theme.colours.borderLight}; }
  `,
};

/* ---------- Table Wrapper for Responsive ---------- */
export const TableWrapper = styled.div<{ $maxHeight?: string }>`
  width: 100%;
  overflow-x: auto;
  overflow-y: ${({ $maxHeight }) => $maxHeight ? 'auto' : 'visible'};
  max-height: ${({ $maxHeight }) => $maxHeight || 'none'};
  border-radius: ${({ theme }) => theme.radius};
  background: ${({ theme }) => theme.colours.background};
  box-shadow: ${({ theme }) => theme.shadow};

  /* Custom scrollbar for table */
  &::-webkit-scrollbar {
    height: 8px;
    width: 8px;
  }

  &::-webkit-scrollbar-track {
    background: ${({ theme }) => theme.colours.backgroundAlt};
    border-radius: 4px;
  }

  &::-webkit-scrollbar-thumb {
    background: ${({ theme }) => theme.colours.border};
    border-radius: 4px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background: ${({ theme }) => theme.colours.textSecondary};
  }

  @media (max-width: 768px) {
    border-radius: 0;
    margin: 0 -16px;
    width: calc(100% + 32px);
  }
`;

/* ---------- Main Table ---------- */
export const Table = styled.table<TableProps>`
  width: 100%;
  background: ${({ theme }) => theme.colours.background};
  border-radius: ${({ theme }) => theme.radius};
  border-collapse: collapse;
  border-spacing: 0;

  ${({ $size = 'md' }) => sizeStyles[$size]}
  ${({ $variant = 'default' }) => variantStyles[$variant]}

  ${({ $hoverable }) => $hoverable && css`
    tbody tr {
      transition: background-color 0.15s ease;
      cursor: pointer;

      &:hover {
        background: ${({ theme }) => theme.colours.hover};
      }

      &:active {
        background: ${({ theme }) => theme.colours.backgroundAlt};
      }
    }
  `}

  ${({ $stickyHeader }) => $stickyHeader && css`
    thead {
      position: sticky;
      top: 0;
      z-index: 10;
    }
  `}
`;

/* ---------- Table Head ---------- */
export const THead = styled.thead`
  background: ${({ theme }) => theme.colours.tableHeader};
  border-bottom: 2px solid ${({ theme }) => theme.colours.border};
`;

/* ---------- Table Body ---------- */
export const TBody = styled.tbody`
  /* Animation for rows */
  tr {
    animation: ${fadeIn} 0.2s ease-out;
  }
`;

/* ---------- Table Row ---------- */
export const Tr = styled.tr<{ $selected?: boolean; $disabled?: boolean }>`
  transition: background-color 0.15s ease;

  ${({ $selected, theme }) => $selected && css`
    background: ${theme.colours.primaryLight} !important;
    border-left: 3px solid ${theme.colours.primary};
  `}

  ${({ $disabled }) => $disabled && css`
    opacity: 0.5;
    pointer-events: none;
  `}

  &:focus-within {
    outline: 2px solid ${({ theme }) => theme.colours.primary};
    outline-offset: -2px;
  }
`;

/* ---------- Table Header Cell ---------- */
export const Th = styled.th.withConfig({
  shouldForwardProp: (prop) => !['align', '$sortable', '$sortDirection', '$width'].includes(prop as string),
})<ThProps>`
  text-align: ${({ align = 'left' }) => align};
  font-weight: 600;
  color: ${({ theme }) => theme.colours.textSecondary};
  white-space: nowrap;
  position: relative;
  user-select: none;
  width: ${({ $width }) => $width || 'auto'};

  ${({ $sortable }) => $sortable && css`
    cursor: pointer;
    padding-right: 28px;
    transition: color 0.15s ease, background-color 0.15s ease;

    &:hover {
      color: ${({ theme }) => theme.colours.text};
      background: rgba(0, 0, 0, 0.02);
    }

    &:focus-visible {
      outline: 2px solid ${({ theme }) => theme.colours.primary};
      outline-offset: -2px;
    }
  `}

  ${({ $sortDirection }) => $sortDirection && css`
    color: ${({ theme }) => theme.colours.primary};
    font-weight: 700;
  `}
`;

/* ---------- Sort Indicator ---------- */
export const SortIndicator = styled.span<{ $direction: 'asc' | 'desc' | null; $active?: boolean }>`
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  display: inline-flex;
  flex-direction: column;
  gap: 2px;
  opacity: ${({ $active }) => $active ? 1 : 0.3};
  transition: opacity 0.15s ease;

  &::before,
  &::after {
    content: '';
    width: 0;
    height: 0;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
  }

  &::before {
    border-bottom: 4px solid ${({ $direction, $active, theme }) =>
      $active && $direction === 'asc' ? theme.colours.primary : 'currentColor'};
    opacity: ${({ $direction }) => $direction === 'asc' ? 1 : 0.4};
  }

  &::after {
    border-top: 4px solid ${({ $direction, $active, theme }) =>
      $active && $direction === 'desc' ? theme.colours.primary : 'currentColor'};
    opacity: ${({ $direction }) => $direction === 'desc' ? 1 : 0.4};
  }
`;

/* ---------- Table Data Cell ---------- */
export const Td = styled.td.withConfig({
  shouldForwardProp: (prop) => !['align', '$truncate', '$maxWidth'].includes(prop as string),
})<TdProps>`
  text-align: ${({ align = 'left' }) => align};
  color: ${({ theme }) => theme.colours.text};
  vertical-align: middle;

  ${({ $truncate, $maxWidth }) => $truncate && css`
    max-width: ${$maxWidth || '200px'};
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  `}
`;

/* ---------- Empty State for Table ---------- */
export const TableEmptyState = styled.td`
  text-align: center;
  padding: 48px 24px !important;
  color: ${({ theme }) => theme.colours.textSecondary};
  font-size: 14px;
`;

/* ---------- Loading State for Table ---------- */
export const TableLoadingState = styled.td`
  text-align: center;
  padding: 48px 24px !important;
`;

/* ---------- Modal & Overlay ---------- */
export const Overlay = styled.div`
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: ${({ theme }) => theme.zIndex?.overlay || 300};
  animation: ${fadeIn} 0.2s ease-out;
  padding: 16px;
`;

export const Modal = styled.div<{ $size?: 'sm' | 'md' | 'lg' | 'xl' }>`
  position: relative;
  z-index: ${({ theme }) => theme.zIndex?.modal || 400};
  background: #ffffff;
  border-radius: ${({ theme }) => theme.radiusLg};
  padding: 24px;
  width: 100%;
  max-height: 85vh;
  overflow-y: auto;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  animation: ${slideUp} 0.3s cubic-bezier(0.4, 0, 0.2, 1);

  max-width: ${({ $size }) => {
    switch ($size) {
      case 'sm': return '400px';
      case 'lg': return '800px';
      case 'xl': return '1000px';
      default: return '600px';
    }
  }};

  &:focus {
    outline: none;
  }
`;

export const ModalHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 20px;
  gap: 16px;
`;

export const ModalTitle = styled.h3`
  margin: 0;
  font-size: 20px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  line-height: 1.3;
`;

export const ModalBody = styled.div`
  margin-bottom: 24px;
`;

export const ModalFooter = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding-top: 16px;
  border-top: 1px solid ${({ theme }) => theme.colours.border};
`;

export const CloseBtn = styled.button`
  background: none;
  border: none;
  padding: 8px;
  cursor: pointer;
  color: ${({ theme }) => theme.colours.textSecondary};
  border-radius: 8px;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    background: ${({ theme }) => theme.colours.hover};
    color: ${({ theme }) => theme.colours.text};
  }

  &:focus-visible {
    outline: 2px solid ${({ theme }) => theme.colours.primary};
    outline-offset: 2px;
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;
```

---

## src/components/ui/Tooltip.tsx

**Path:** `src/components/ui/Tooltip.tsx`

```tsx
import React, { useState, useRef, useEffect, useCallback } from 'react';
import styled, { css, keyframes } from 'styled-components';

/* ---------- Animations ---------- */
const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const arrowBounce = keyframes`
  0%, 100% { transform: translateX(-50%) scale(1); }
  50% { transform: translateX(-50%) scale(1.1); }
`;

/* ---------- Types ---------- */
type TooltipPosition = 'top' | 'bottom' | 'left' | 'right';
type TooltipVariant = 'dark' | 'light' | 'primary';
type TooltipSize = 'sm' | 'md' | 'lg';

interface TooltipProps {
  content: React.ReactNode;
  children: React.ReactNode;
  position?: TooltipPosition;
  delay?: number;
  variant?: TooltipVariant;
  size?: TooltipSize;
  maxWidth?: number;
  disabled?: boolean;
  showArrow?: boolean;
  interactive?: boolean;
}

/* ---------- Variant Styles ---------- */
const variantStyles = {
  dark: css`
    background: #1f2937;
    color: white;
    --arrow-color: #1f2937;
  `,
  light: css`
    background: white;
    color: #374151;
    border: 1px solid #e5e7eb;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    --arrow-color: white;
  `,
  primary: css`
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    --arrow-color: #6366f1;
  `,
};

/* ---------- Size Styles ---------- */
const sizeStyles = {
  sm: css`
    padding: 6px 10px;
    font-size: 12px;
    border-radius: 6px;
  `,
  md: css`
    padding: 8px 12px;
    font-size: 13px;
    border-radius: 8px;
  `,
  lg: css`
    padding: 10px 16px;
    font-size: 14px;
    border-radius: 10px;
  `,
};

/* ---------- Styled Components ---------- */
const TooltipWrapper = styled.div<{ $interactive?: boolean }>`
  position: relative;
  display: inline-flex;
  align-items: center;

  ${({ $interactive }) => $interactive && css`
    &:hover > div[data-tooltip] {
      pointer-events: auto;
    }
  `}
`;

const TooltipContent = styled.div<{
  $visible: boolean;
  $position: TooltipPosition;
  $variant: TooltipVariant;
  $size: TooltipSize;
  $maxWidth: number;
  $showArrow: boolean;
}>`
  position: absolute;
  font-weight: 500;
  pointer-events: none;
  z-index: ${({ theme }) => theme.zIndex?.tooltip || 600};
  opacity: ${props => props.$visible ? 1 : 0};
  visibility: ${props => props.$visible ? 'visible' : 'hidden'};
  transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  max-width: ${props => props.$maxWidth}px;
  white-space: ${props => props.$maxWidth > 200 ? 'normal' : 'nowrap'};
  word-wrap: break-word;
  line-height: 1.4;
  text-align: left;

  ${({ $variant }) => variantStyles[$variant]}
  ${({ $size }) => sizeStyles[$size]}

  ${props => props.$visible && css`
    animation: ${fadeIn} 0.15s ease-out;
  `}

  ${props => {
    const arrowSize = props.$size === 'sm' ? '5px' : props.$size === 'lg' ? '7px' : '6px';
    const offset = props.$size === 'sm' ? '6px' : props.$size === 'lg' ? '10px' : '8px';

    switch (props.$position) {
      case 'top':
        return css`
          bottom: calc(100% + ${offset});
          left: 50%;
          transform: translateX(-50%) ${props.$visible ? 'translateY(0)' : 'translateY(4px)'};

          ${props.$showArrow && css`
            &::after {
              content: '';
              position: absolute;
              top: 100%;
              left: 50%;
              transform: translateX(-50%);
              border: ${arrowSize} solid transparent;
              border-top-color: var(--arrow-color);
              ${props.$visible && css`
                animation: ${arrowBounce} 0.3s ease-out;
              `}
            }
          `}
        `;
      case 'bottom':
        return css`
          top: calc(100% + ${offset});
          left: 50%;
          transform: translateX(-50%) ${props.$visible ? 'translateY(0)' : 'translateY(-4px)'};

          ${props.$showArrow && css`
            &::after {
              content: '';
              position: absolute;
              bottom: 100%;
              left: 50%;
              transform: translateX(-50%);
              border: ${arrowSize} solid transparent;
              border-bottom-color: var(--arrow-color);
            }
          `}
        `;
      case 'left':
        return css`
          right: calc(100% + ${offset});
          top: 50%;
          transform: translateY(-50%) ${props.$visible ? 'translateX(0)' : 'translateX(4px)'};

          ${props.$showArrow && css`
            &::after {
              content: '';
              position: absolute;
              left: 100%;
              top: 50%;
              transform: translateY(-50%);
              border: ${arrowSize} solid transparent;
              border-left-color: var(--arrow-color);
            }
          `}
        `;
      case 'right':
        return css`
          left: calc(100% + ${offset});
          top: 50%;
          transform: translateY(-50%) ${props.$visible ? 'translateX(0)' : 'translateX(-4px)'};

          ${props.$showArrow && css`
            &::after {
              content: '';
              position: absolute;
              right: 100%;
              top: 50%;
              transform: translateY(-50%);
              border: ${arrowSize} solid transparent;
              border-right-color: var(--arrow-color);
            }
          `}
        `;
    }
  }}
`;

/* ---------- Main Component ---------- */
export const Tooltip: React.FC<TooltipProps> = ({
  content,
  children,
  position = 'top',
  delay = 300,
  variant = 'dark',
  size = 'md',
  maxWidth = 280,
  disabled = false,
  showArrow = true,
  interactive = false,
}) => {
  const [visible, setVisible] = useState(false);
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);

  const showTooltip = useCallback(() => {
    if (disabled) return;
    timeoutRef.current = setTimeout(() => {
      setVisible(true);
    }, delay);
  }, [delay, disabled]);

  const hideTooltip = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    setVisible(false);
  }, []);

  // Handle escape key to close tooltip
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && visible) {
        hideTooltip();
      }
    };

    if (visible) {
      document.addEventListener('keydown', handleKeyDown);
      return () => document.removeEventListener('keydown', handleKeyDown);
    }
  }, [visible, hideTooltip]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  // Don't render tooltip if disabled or no content
  if (disabled || !content) {
    return <>{children}</>;
  }

  return (
    <TooltipWrapper
      ref={wrapperRef}
      onMouseEnter={showTooltip}
      onMouseLeave={hideTooltip}
      onFocus={showTooltip}
      onBlur={hideTooltip}
      $interactive={interactive}
    >
      {children}
      <TooltipContent
        $visible={visible}
        $position={position}
        $variant={variant}
        $size={size}
        $maxWidth={maxWidth}
        $showArrow={showArrow}
        data-tooltip
        role="tooltip"
        aria-hidden={!visible}
      >
        {content}
      </TooltipContent>
    </TooltipWrapper>
  );
};

/* ---------- InfoTooltip - Convenience component with info icon ---------- */
export const InfoTooltip: React.FC<Omit<TooltipProps, 'children'>> = (props) => {
  return (
    <Tooltip {...props}>
      <InfoIcon aria-label="More information">
        <svg viewBox="0 0 20 20" fill="currentColor">
          <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
        </svg>
      </InfoIcon>
    </Tooltip>
  );
};

const InfoIcon = styled.span`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  color: #9ca3af;
  cursor: help;
  transition: color 0.2s ease;

  &:hover {
    color: #6b7280;
  }

  svg {
    width: 100%;
    height: 100%;
  }
`;
```

---

## src/components/ui/UnifiedAIResponse.tsx

**Path:** `src/components/ui/UnifiedAIResponse.tsx`

```tsx
/**
 * Unified AI Response Component
 *
 * Professional, ChatGPT-style response formatter that handles any AI response
 * with robust markdown support, syntax highlighting, and clean typography.
 */

import { memo, useCallback } from 'react';
import styled from 'styled-components';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { Components } from 'react-markdown';

// ============================================================================
// Styled Components - Clean, ChatGPT-inspired design
// ============================================================================

const ResponseContainer = styled.div`
  width: 100%;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.6;
  color: ${({ theme }) => theme.isDarkMode ? '#e4e4e7' : '#18181b'};

  /* Paragraphs */
  p {
    margin: 0 0 1em 0;
    font-size: 15px;
    line-height: 1.7;

    &:last-child {
      margin-bottom: 0;
    }
  }

  /* Headings */
  h1, h2, h3, h4, h5, h6 {
    margin: 1.5em 0 0.75em 0;
    font-weight: 600;
    line-height: 1.3;
    color: ${({ theme }) => theme.isDarkMode ? '#fafafa' : '#09090b'};

    &:first-child {
      margin-top: 0;
    }
  }

  h1 { font-size: 1.5em; }
  h2 { font-size: 1.35em; }
  h3 { font-size: 1.2em; }
  h4 { font-size: 1.1em; }
  h5, h6 { font-size: 1em; }

  /* Lists */
  ul, ol {
    margin: 0.75em 0;
    padding-left: 1.5em;
  }

  li {
    margin: 0.4em 0;
    line-height: 1.6;

    > ul, > ol {
      margin: 0.25em 0;
    }

    > p {
      margin: 0.25em 0;
    }
  }

  ul {
    list-style-type: disc;

    ul {
      list-style-type: circle;

      ul {
        list-style-type: square;
      }
    }
  }

  ol {
    list-style-type: decimal;
  }

  /* Inline code */
  code {
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.06)'};
    color: ${({ theme }) => theme.isDarkMode ? '#f472b6' : '#be185d'};
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'SF Mono', 'Fira Code', 'Monaco', 'Menlo', monospace;
    font-size: 0.875em;
    font-weight: 500;
  }

  /* Code blocks */
  pre {
    background: ${({ theme }) => theme.isDarkMode ? '#1e1e1e' : '#f4f4f5'};
    border-radius: 8px;
    padding: 16px;
    margin: 1em 0;
    overflow-x: auto;
    border: 1px solid ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)'};

    code {
      background: none;
      color: ${({ theme }) => theme.isDarkMode ? '#d4d4d8' : '#3f3f46'};
      padding: 0;
      font-size: 0.85em;
      line-height: 1.6;
      white-space: pre;
      display: block;
    }
  }

  /* Tables */
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 1em 0;
    font-size: 14px;
    border: 1px solid ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)'};
    border-radius: 8px;
    overflow: hidden;

    th, td {
      padding: 10px 14px;
      text-align: left;
      border-bottom: 1px solid ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)'};
    }

    th {
      font-weight: 600;
      background: ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.03)'};
      color: ${({ theme }) => theme.isDarkMode ? '#fafafa' : '#09090b'};
    }

    tr:last-child td {
      border-bottom: none;
    }

    tbody tr:hover {
      background: ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.02)'};
    }
  }

  /* Blockquotes */
  blockquote {
    border-left: 3px solid ${({ theme }) => theme.isDarkMode ? '#6366f1' : '#6366f1'};
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(99,102,241,0.08)' : 'rgba(99,102,241,0.05)'};
    padding: 12px 16px;
    margin: 1em 0;
    border-radius: 0 6px 6px 0;
    color: ${({ theme }) => theme.isDarkMode ? '#a1a1aa' : '#52525b'};

    p {
      margin: 0;
    }
  }

  /* Links */
  a {
    color: #6366f1;
    text-decoration: none;
    font-weight: 500;
    transition: opacity 0.15s ease;

    &:hover {
      text-decoration: underline;
      opacity: 0.85;
    }
  }

  /* Strong and emphasis */
  strong {
    font-weight: 600;
    color: ${({ theme }) => theme.isDarkMode ? '#fafafa' : '#09090b'};
  }

  em {
    font-style: italic;
  }

  /* Horizontal rules */
  hr {
    border: none;
    height: 1px;
    background: ${({ theme }) => theme.isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)'};
    margin: 1.5em 0;
  }

  /* Task lists (checkboxes) */
  input[type="checkbox"] {
    margin-right: 8px;
    accent-color: #6366f1;
  }

  /* Images */
  img {
    max-width: 100%;
    height: auto;
    border-radius: 8px;
    margin: 1em 0;
  }

  @media (max-width: 768px) {
    p, li {
      font-size: 14px;
    }

    pre {
      padding: 12px;
      font-size: 13px;
    }

    table {
      font-size: 13px;

      th, td {
        padding: 8px 10px;
      }
    }
  }
`;

// ============================================================================
// Types
// ============================================================================

interface ResponseData {
  answer?: string;
  [key: string]: unknown;
}

interface UnifiedAIResponseProps {
  content?: string;
  data?: ResponseData;
}

// ============================================================================
// Custom Components for ReactMarkdown
// ============================================================================

const createMarkdownComponents = (): Components => ({
  // Ensure proper paragraph rendering
  p: ({ children }) => <p>{children}</p>,

  // Ensure proper list rendering
  ul: ({ children }) => <ul>{children}</ul>,
  ol: ({ children }) => <ol>{children}</ol>,
  li: ({ children }) => <li>{children}</li>,

  // Code blocks with language detection
  code: ({ className, children, ...props }) => {
    const match = /language-(\w+)/.exec(className || '');
    const isInline = !className;

    if (isInline) {
      return <code {...props}>{children}</code>;
    }

    return (
      <code className={className} data-language={match?.[1]} {...props}>
        {children}
      </code>
    );
  },

  // Tables
  table: ({ children }) => <table>{children}</table>,
  thead: ({ children }) => <thead>{children}</thead>,
  tbody: ({ children }) => <tbody>{children}</tbody>,
  tr: ({ children }) => <tr>{children}</tr>,
  th: ({ children }) => <th>{children}</th>,
  td: ({ children }) => <td>{children}</td>,

  // Links open in new tab for external URLs
  a: ({ href, children }) => {
    const isExternal = href?.startsWith('http');
    return (
      <a
        href={href}
        target={isExternal ? '_blank' : undefined}
        rel={isExternal ? 'noopener noreferrer' : undefined}
      >
        {children}
      </a>
    );
  },
});

// ============================================================================
// Main Component
// ============================================================================

export const UnifiedAIResponse = memo(({ content, data }: UnifiedAIResponseProps) => {
  const contentToRender = content || data?.answer || '';

  // Memoize components to prevent re-creation on each render
  const components = useCallback(() => createMarkdownComponents(), [])();

  // Clean and normalize content
  const normalizedContent = contentToRender
    .replace(/\n{3,}/g, '\n\n') // Collapse multiple newlines
    .trim();

  return (
    <ResponseContainer>
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        components={components}
      >
        {normalizedContent}
      </ReactMarkdown>
    </ResponseContainer>
  );
});

UnifiedAIResponse.displayName = 'UnifiedAIResponse';
```

---

## src/components/ui/VirtualizedGrid.tsx

**Path:** `src/components/ui/VirtualizedGrid.tsx`

```tsx
// src/components/ui/VirtualizedGrid.js
import React, { memo, useMemo } from 'react';
import { Grid } from 'react-window';
import styled from 'styled-components';

const GridContainer = styled.div`
  width: 100%;
  height: ${props => props.height || '600px'};
  margin-bottom: 60px;
`;

const GridItem = styled.div`
  padding: 16px;
  display: flex;
  justify-content: center;
  align-items: flex-start;
`;

// Memoized cell renderer to prevent unnecessary re-renders
const Cell = memo(({ columnIndex, rowIndex, style, data }) => {
  const { items, columnCount, renderItem } = data;
  const index = rowIndex * columnCount + columnIndex;
  
  if (index >= items.length) {
    return <div style={style} />;
  }

  const item = items[index];
  
  return (
    <div style={style}>
      <GridItem>
        {renderItem(item, index)}
      </GridItem>
    </div>
  );
});

Cell.displayName = 'VirtualizedGridCell';

// Main VirtualizedGrid component
const VirtualizedGrid = memo(({ 
  items = [], 
  renderItem, 
  columnCount = 2, 
  rowHeight = 350, 
  height = 600,
  overscanRowCount = 2,
  className 
}) => {
  // Calculate grid dimensions
  const rowCount = Math.ceil(items.length / columnCount);
  const columnWidth = useMemo(() => {
    // Assuming container width, adjust based on your layout
    return Math.floor(1400 / columnCount);
  }, [columnCount]);

  // Memoized item data to prevent unnecessary re-renders
  const itemData = useMemo(() => ({
    items,
    columnCount,
    renderItem
  }), [items, columnCount, renderItem]);

  // Handle empty state
  if (items.length === 0) {
    return null;
  }

  return (
    <GridContainer height={height} className={className}>
      <Grid
        columnCount={columnCount}
        columnWidth={columnWidth}
        height={height}
        rowCount={rowCount}
        rowHeight={rowHeight}
        itemData={itemData}
        overscanRowCount={overscanRowCount}
        overscanColumnCount={1}
      >
        {(props) => <Cell {...props} />}
      </Grid>
    </GridContainer>
  );
});

VirtualizedGrid.displayName = 'VirtualizedGrid';

export default VirtualizedGrid;
```

---

## src/components/ui/index.ts

**Path:** `src/components/ui/index.ts`

```typescript
/**
 * UI Components Index
 * Centralized exports for all UI components
 */

// Layout & Navigation
export { default as Breadcrumb } from './Breadcrumb';
export { default as Layout } from './Layout';
export { default as MainNavigation } from './Navigation';
export { default as PageContainer } from './PageContainer';
export { RouteProgressProvider, useRouteProgress } from './RouteProgress';

// Buttons & Inputs
export { default as Button } from './Button';
export { default as Input } from './Input';
export { default as Select } from './Select';

// Cards
export { default as Card } from './Card';
export { default as ProductCard } from './ProductCard';

// Feedback & Status
export { EmptyState } from './EmptyState';
export { default as LoadingSpinner, PageLoadingSpinner } from './LoadingSpinner';
export { ConnectionStatus } from './ConnectionStatus';
export { default as StatusBadge } from './StatusBadge';
export { default as NotificationBadge } from './NotificationBadge';

// Tooltips & Helpers
export { default as Tooltip } from './Tooltip';
export { default as Icon } from './Icon';

// Modals & Dialogs
export { default as ConfirmationModal } from './ConfirmationModal';

// Data Display
export { default as Table, TableEmptyState } from './Table';
export { default as VirtualizedGrid } from './VirtualizedGrid';

// Headers & Context
export { default as EnhancedHeader } from './EnhancedHeader';
export { default as ProductContextBar } from './ProductContextBar';
export { default as ProductQuickActionsBar } from './ProductQuickActionsBar';
export { default as QuickActionMenu } from './QuickActionMenu';

// AI & Chat Components
export { EnhancedChatMessage } from './EnhancedChatMessage';
export { default as EnhancedSummary } from './EnhancedSummary';
export { UnifiedAIResponse } from './UnifiedAIResponse';

```

---

## src/components/wizard/AIAssistedField.tsx

**Path:** `src/components/wizard/AIAssistedField.tsx`

```tsx
/**
 * AIAssistedField - Wrapper component for form fields with AI assistance
 * Provides inline AI suggestions, auto-complete, and field explanations
 */

import React, { useState } from 'react';
import styled, { css, keyframes } from 'styled-components';
import { SparklesIcon, CheckIcon, XMarkIcon } from '@heroicons/react/24/outline';

interface AIAssistedFieldProps {
  label: string;
  fieldName: string;
  isAISuggested?: boolean;
  aiConfidence?: number;
  aiExplanation?: string;
  isAIUpdating?: boolean;
  onAcceptSuggestion?: () => void;
  onRejectSuggestion?: () => void;
  onRequestSuggestion?: () => void;
  showAIButton?: boolean;
  required?: boolean;
  hideActions?: boolean; // Hide Keep/Clear buttons when suggestion is applied
  children: React.ReactNode;
}

export const AIAssistedField: React.FC<AIAssistedFieldProps> = ({
  label,
  fieldName,
  isAISuggested = false,
  aiConfidence = 85,
  aiExplanation,
  isAIUpdating = false,
  onAcceptSuggestion,
  onRejectSuggestion,
  onRequestSuggestion,
  showAIButton = true,
  required = false,
  hideActions = false,
  children,
}) => {
  return (
    <Container>
      <LabelRow>
        <Label>
          {label}
          {required && <Required>*</Required>}
        </Label>

        <LabelActions>
          {/* AI Updating Indicator */}
          {isAIUpdating && (
            <UpdatingBadge>
              <UpdatingSpinner />
              <span>AI thinking...</span>
            </UpdatingBadge>
          )}

          {/* Request AI Suggestion Button */}
          {showAIButton && !isAISuggested && !isAIUpdating && onRequestSuggestion && (
            <AIButton onClick={onRequestSuggestion} title="Get AI suggestion">
              <SparklesIcon />
            </AIButton>
          )}
        </LabelActions>
      </LabelRow>

      {/* Field Content */}
      <FieldWrapper $isUpdating={isAIUpdating}>
        {children}
        {isAIUpdating && <UpdatingOverlay />}
      </FieldWrapper>

      {/* Accept/Reject Actions - hidden once applied */}
      {isAISuggested && !hideActions && (onAcceptSuggestion || onRejectSuggestion) && (
        <ActionRow>
          {onAcceptSuggestion && (
            <AcceptButton onClick={onAcceptSuggestion}>
              <CheckIcon />
              <span>Keep</span>
            </AcceptButton>
          )}
          {onRejectSuggestion && (
            <RejectButton onClick={onRejectSuggestion}>
              <XMarkIcon />
              <span>Clear</span>
            </RejectButton>
          )}
        </ActionRow>
      )}
    </Container>
  );
};

// Premium Animations
const glowPulse = keyframes`
  0%, 100% { box-shadow: 0 0 8px rgba(139, 92, 246, 0.2), 0 0 16px rgba(99, 102, 241, 0.1); }
  50% { box-shadow: 0 0 16px rgba(139, 92, 246, 0.4), 0 0 32px rgba(99, 102, 241, 0.2); }
`;

const spin = keyframes`
  to { transform: rotate(360deg); }
`;

// Styled Components
const Container = styled.div`
  margin-bottom: 20px;
`;

const LabelRow = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
`;

const Label = styled.label`
  font-size: 14px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
`;

const Required = styled.span`
  color: #ef4444;
  margin-left: 4px;
`;

const LabelActions = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const UpdatingBadge = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 12px;
  background: linear-gradient(135deg, #6366f1, #8b5cf6);
  border-radius: 14px;
  animation: ${glowPulse} 1.5s ease-in-out infinite;
  span {
    font-size: 11px;
    font-weight: 600;
    color: white;
  }
`;

const UpdatingSpinner = styled.div`
  width: 12px;
  height: 12px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: white;
  border-radius: 50%;
  animation: ${spin} 0.8s linear infinite;
`;

const AIButton = styled.button`
  display: flex;
  padding: 4px;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
  svg { width: 16px; height: 16px; color: #8b5cf6; opacity: 0.6; }
  &:hover {
    background: rgba(139, 92, 246, 0.1);
    border-color: rgba(139, 92, 246, 0.2);
    svg { opacity: 1; }
  }
`;

// Shimmer animation for updating overlay
const shimmerMove = keyframes`
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
`;

const UpdatingOverlay = styled.div`
  position: absolute;
  inset: 0;
  border-radius: 8px;
  background: rgba(139, 92, 246, 0.05);
  overflow: hidden;
  pointer-events: none;
  z-index: 2;

  &::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(139, 92, 246, 0.15) 50%,
      transparent 100%
    );
    animation: ${shimmerMove} 1.2s ease-in-out infinite;
  }
`;

const FieldWrapper = styled.div<{ $isUpdating?: boolean }>`
  position: relative;
  transition: all 0.3s ease;

  /* AI Updating shimmer border */
  ${({ $isUpdating }) => $isUpdating && css`
    &::before {
      content: '';
      position: absolute;
      inset: -3px;
      border-radius: 12px;
      border: 2px dashed rgba(139, 92, 246, 0.5);
      pointer-events: none;
      animation: ${glowPulse} 1s ease-in-out infinite;
    }
  `}
`;

const ActionRow = styled.div`
  display: flex;
  gap: 8px;
  margin-top: 8px;
`;

const ActionButton = styled.button`
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 5px 10px;
  font-size: 12px;
  font-weight: 500;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  transition: all 0.2s;
  svg { width: 14px; height: 14px; }
`;

const AcceptButton = styled(ActionButton)`
  background: #10b981;
  color: white;
  &:hover { background: #059669; }
`;

const RejectButton = styled(ActionButton)`
  background: #f1f5f9;
  color: #64748b;
  &:hover { background: #e2e8f0; }
`;

export default AIAssistedField;

```

---

## src/components/wizard/AIFieldIndicator.tsx

**Path:** `src/components/wizard/AIFieldIndicator.tsx`

```tsx
/**
 * AIFieldIndicator - Visual indicator for AI-populated fields
 * Shows AI source, confidence, and allows accept/reject of suggestions
 */

import React, { useState, useEffect } from 'react';
import styled, { css } from 'styled-components';
import { SparklesIcon, CheckIcon, XMarkIcon, ArrowPathIcon } from '@heroicons/react/24/solid';
import { InformationCircleIcon } from '@heroicons/react/24/outline';
import { aiFieldUpdate, aiSparkle, aiPulse } from '../../styles/copilotAnimations';

export type AIFieldStatus = 'manual' | 'ai-suggested' | 'ai-accepted' | 'ai-rejected' | 'ai-updating';

interface AIFieldIndicatorProps {
  status: AIFieldStatus;
  confidence?: number; // 0-100
  explanation?: string;
  onAccept?: () => void;
  onReject?: () => void;
  onRegenerate?: () => void;
  showActions?: boolean;
  children: React.ReactNode;
}

const getConfidenceColor = (confidence: number) => {
  if (confidence >= 80) return '#10b981'; // green
  if (confidence >= 60) return '#f59e0b'; // amber
  return '#ef4444'; // red
};

const getConfidenceLabel = (confidence: number) => {
  if (confidence >= 80) return 'High';
  if (confidence >= 60) return 'Medium';
  return 'Low';
};

export const AIFieldIndicator: React.FC<AIFieldIndicatorProps> = ({
  status,
  confidence = 85,
  explanation,
  onAccept,
  onReject,
  onRegenerate,
  showActions = true,
  children,
}) => {
  const [showTooltip, setShowTooltip] = useState(false);
  const [wasJustUpdated, setWasJustUpdated] = useState(false);

  useEffect(() => {
    if (status === 'ai-suggested') {
      setWasJustUpdated(true);
      const timer = setTimeout(() => setWasJustUpdated(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [status]);

  const isAIInvolved = status !== 'manual';

  return (
    <Container $status={status} $wasJustUpdated={wasJustUpdated}>
      {/* AI Badge */}
      {isAIInvolved && status !== 'ai-rejected' && (
        <AIBadge $status={status}>
          {status === 'ai-updating' ? (
            <UpdatingIcon><ArrowPathIcon /></UpdatingIcon>
          ) : (
            <SparkleIcon $status={status}><SparklesIcon /></SparkleIcon>
          )}
          <BadgeText>
            {status === 'ai-updating' ? 'AI thinking...' : 'AI Suggested'}
          </BadgeText>
          {status === 'ai-suggested' && confidence && (
            <ConfidenceBadge $color={getConfidenceColor(confidence)}>
              {getConfidenceLabel(confidence)}
            </ConfidenceBadge>
          )}
          {explanation && (
            <InfoButton
              onMouseEnter={() => setShowTooltip(true)}
              onMouseLeave={() => setShowTooltip(false)}
            >
              <InformationCircleIcon />
              {showTooltip && (
                <Tooltip>{explanation}</Tooltip>
              )}
            </InfoButton>
          )}
        </AIBadge>
      )}

      {/* Field Content */}
      <FieldWrapper $status={status} $wasJustUpdated={wasJustUpdated}>
        {children}
      </FieldWrapper>

      {/* Action Buttons */}
      {showActions && status === 'ai-suggested' && (
        <ActionBar>
          <AcceptButton onClick={onAccept}>
            <CheckIcon />
            <span>Accept</span>
          </AcceptButton>
          <RejectButton onClick={onReject}>
            <XMarkIcon />
            <span>Reject</span>
          </RejectButton>
          {onRegenerate && (
            <RegenerateButton onClick={onRegenerate}>
              <ArrowPathIcon />
            </RegenerateButton>
          )}
        </ActionBar>
      )}

      {/* Accepted indicator */}
      {status === 'ai-accepted' && (
        <AcceptedIndicator>
          <CheckIcon />
          <span>AI suggestion accepted</span>
        </AcceptedIndicator>
      )}
    </Container>
  );
};

// Styled Components
const Container = styled.div<{ $status: AIFieldStatus; $wasJustUpdated: boolean }>`
  position: relative;
  ${({ $wasJustUpdated }) => $wasJustUpdated && css`animation: ${aiFieldUpdate} 1.5s ease-out;`}
`;

const AIBadge = styled.div<{ $status: AIFieldStatus }>`
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
  padding: 4px 10px;
  background: ${({ $status }) => 
    $status === 'ai-updating' 
      ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1))'
      : 'linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(168, 85, 247, 0.08))'
  };
  border-radius: 20px;
  width: fit-content;
  border: 1px solid rgba(139, 92, 246, 0.2);
`;

const SparkleIcon = styled.span<{ $status: AIFieldStatus }>`
  display: flex;
  svg {
    width: 14px;
    height: 14px;
    color: #8b5cf6;
    ${({ $status }) => $status === 'ai-suggested' && css`animation: ${aiSparkle} 2s ease-in-out infinite;`}
  }
`;

const UpdatingIcon = styled.span`
  display: flex;
  svg {
    width: 14px;
    height: 14px;
    color: #6366f1;
    animation: ${aiPulse} 1s ease-in-out infinite;
  }
`;

const BadgeText = styled.span`
  font-size: 12px;
  font-weight: 500;
  color: #7c3aed;
`;

const ConfidenceBadge = styled.span<{ $color: string }>`
  font-size: 10px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 10px;
  background: ${({ $color }) => `${$color}15`};
  color: ${({ $color }) => $color};
`;

const InfoButton = styled.button`
  position: relative;
  display: flex;
  padding: 2px;
  background: none;
  border: none;
  cursor: pointer;
  svg {
    width: 14px;
    height: 14px;
    color: #8b5cf6;
    opacity: 0.7;
    transition: opacity 0.2s;
  }
  &:hover svg { opacity: 1; }
`;

const Tooltip = styled.div`
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  z-index: 100;
  padding: 10px 14px;
  background: #1e1b4b;
  color: white;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 8px;
  white-space: nowrap;
  max-width: 280px;
  white-space: normal;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  &::before {
    content: '';
    position: absolute;
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-bottom: 6px solid #1e1b4b;
  }
`;

const FieldWrapper = styled.div<{ $status: AIFieldStatus; $wasJustUpdated: boolean }>`
  position: relative;
  border-radius: 10px;
  transition: all 0.3s ease;
  ${({ $status }) => $status === 'ai-suggested' && css`
    &::after {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 12px;
      border: 2px solid rgba(139, 92, 246, 0.3);
      pointer-events: none;
    }
  `}
`;

const ActionBar = styled.div`
  display: flex;
  gap: 8px;
  margin-top: 10px;
`;

const ActionButton = styled.button`
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  font-size: 12px;
  font-weight: 500;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  transition: all 0.2s;
  svg { width: 14px; height: 14px; }
`;

const AcceptButton = styled(ActionButton)`
  background: #10b981;
  color: white;
  &:hover { background: #059669; transform: translateY(-1px); }
`;

const RejectButton = styled(ActionButton)`
  background: #f1f5f9;
  color: #64748b;
  &:hover { background: #e2e8f0; }
`;

const RegenerateButton = styled(ActionButton)`
  background: transparent;
  color: #8b5cf6;
  padding: 6px;
  &:hover { background: rgba(139, 92, 246, 0.1); }
`;

const AcceptedIndicator = styled.div`
  display: flex;
  align-items: center;
  gap: 4px;
  margin-top: 6px;
  font-size: 11px;
  color: #10b981;
  svg { width: 12px; height: 12px; }
`;

export default AIFieldIndicator;

```

---

## src/components/wizard/AIInsightsCard.tsx

**Path:** `src/components/wizard/AIInsightsCard.tsx`

```tsx
/**
 * AIInsightsCard - Contextual AI insights for each wizard step
 *
 * Provides:
 * - Step-specific tips and recommendations
 * - Completeness indicators
 * - Industry benchmarks
 * - Warnings for potential issues
 * - ENHANCED: Streaming text effect for AI suggestions
 */

import React, { useMemo, useState, useEffect } from 'react';
import styled, { keyframes, css } from 'styled-components';
import {
  SparklesIcon,
  LightBulbIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  InformationCircleIcon,
  ChartBarIcon,
  ArrowTrendingUpIcon,
  CommandLineIcon,
} from '@heroicons/react/24/outline';
import { SparklesIcon as SparklesSolid } from '@heroicons/react/24/solid';
import { Coverage } from '../../types';

interface StepInsight {
  type: 'tip' | 'warning' | 'success' | 'info';
  message: string;
  action?: { label: string; onClick: () => void };
}

interface AIInsightsCardProps {
  stepId: string;
  draft: Partial<Coverage>;
  onApplyRecommendation?: (field: string, value: unknown) => void;
  className?: string;
}

// P&C Industry Benchmark Data
const PC_BENCHMARKS = {
  occurrence: { usage: 85, label: 'Property & Auto' },
  claimsMade: { usage: 90, label: 'Professional Liability' },
  coinsurance80: { usage: 75, label: 'Commercial Property' },
  coinsurance90: { usage: 15, label: 'High-value Properties' },
  rcValuation: { usage: 65, label: 'Buildings' },
  acvValuation: { usage: 30, label: 'Auto & Contents' },
};

// Step-specific insights configuration with P&C optimization
const getStepInsights = (stepId: string, draft: Partial<Coverage>): StepInsight[] => {
  const insights: StepInsight[] = [];
  const coverageLower = (draft.name || '').toLowerCase();
  const isPropertyCoverage = coverageLower.includes('building') || coverageLower.includes('property') || coverageLower.includes('contents');
  const isLiabilityCoverage = coverageLower.includes('liability') || coverageLower.includes('professional');
  const isAutoCoverage = coverageLower.includes('auto') || coverageLower.includes('collision') || coverageLower.includes('comprehensive');

  switch (stepId) {
    case 'basics':
      if (!draft.name) {
        insights.push({ type: 'tip', message: 'Enter a coverage name to unlock AI-powered field suggestions' });
      }
      if (draft.name && draft.name.length > 5) {
        insights.push({ type: 'success', message: `AI detected "${draft.name}" - recommendations loaded` });
      }
      break;

    case 'triggers':
      if (!draft.coverageTrigger) {
        if (isPropertyCoverage || isAutoCoverage) {
          insights.push({ type: 'tip', message: `${PC_BENCHMARKS.occurrence.usage}% of ${PC_BENCHMARKS.occurrence.label} coverages use Occurrence trigger` });
        } else if (isLiabilityCoverage) {
          insights.push({ type: 'tip', message: `${PC_BENCHMARKS.claimsMade.usage}% of ${PC_BENCHMARKS.claimsMade.label} uses Claims-Made trigger` });
        } else {
          insights.push({ type: 'tip', message: 'Occurrence covers incidents during policy period; Claims-Made covers when reported' });
        }
      }
      if (draft.coverageTrigger === 'claimsMade') {
        insights.push({ type: 'info', message: 'Claims-Made requires tail coverage and retroactive date consideration' });
        if (!draft.waitingPeriod) {
          insights.push({ type: 'warning', message: 'Consider adding a waiting period for Claims-Made triggers' });
        }
      }
      if (draft.coverageTrigger === 'occurrence') {
        insights.push({ type: 'success', message: 'âœ“ Occurrence trigger selected - standard for this coverage type' });
      }
      break;

    case 'valuation':
      if (!draft.valuationMethods || draft.valuationMethods.length === 0) {
        if (isPropertyCoverage) {
          insights.push({ type: 'tip', message: `${PC_BENCHMARKS.rcValuation.usage}% of ${PC_BENCHMARKS.rcValuation.label} use Replacement Cost (RC)` });
        } else if (isAutoCoverage) {
          insights.push({ type: 'tip', message: `${PC_BENCHMARKS.acvValuation.usage}% of ${PC_BENCHMARKS.acvValuation.label} use Actual Cash Value (ACV)` });
        }
      }
      if (!draft.coinsuranceOptions || draft.coinsuranceOptions.length === 0) {
        insights.push({ type: 'info', message: `${PC_BENCHMARKS.coinsurance80.usage}% of commercial property uses 80% coinsurance` });
      }
      if (draft.valuationMethods && draft.valuationMethods.length > 0 && draft.coinsuranceOptions && draft.coinsuranceOptions.length > 0) {
        insights.push({ type: 'success', message: 'âœ“ Valuation configuration complete' });
      }
      break;

    case 'underwriting':
      insights.push({ type: 'tip', message: 'Clear eligibility rules reduce adverse selection and improve loss ratios' });
      if (!draft.eligibilityCriteria || draft.eligibilityCriteria.length === 0) {
        insights.push({ type: 'info', message: 'Common criteria: Years in business, loss history, safety certifications' });
      }
      if (draft.requiresUnderwriterApproval === undefined) {
        insights.push({ type: 'warning', message: 'Set approval requirements to define when underwriter review is needed' });
      }
      break;

    case 'review':
      const missingFields = [];
      if (!draft.name) missingFields.push('Coverage Name');
      if (!draft.coverageCode) missingFields.push('Coverage Code');
      if (!draft.coverageTrigger) missingFields.push('Coverage Trigger');

      if (missingFields.length > 0) {
        insights.push({ type: 'warning', message: `Complete required fields: ${missingFields.join(', ')}` });
      } else {
        insights.push({ type: 'success', message: 'âœ“ Coverage is ready to publish' });
        insights.push({ type: 'info', message: 'Tip: Review all settings before publishing to production' });
      }
      break;
  }

  return insights;
};

const STEP_TIPS: Record<string, { title: string; description: string; pcTip?: string }> = {
  basics: {
    title: 'Coverage Foundation',
    description: 'Define the core identity of your coverage',
    pcTip: 'ISO Insight: Use standardized coverage names (e.g., "Building Coverage", "Business Personal Property") for regulatory compliance and industry consistency.'
  },
  triggers: {
    title: 'Coverage Trigger',
    description: 'When does coverage apply to a loss?',
    pcTip: 'Industry Standard: 85% of property coverages use Occurrence trigger. Claims-Made is standard for E&O, D&O, and professional liability lines.'
  },
  valuation: {
    title: 'Loss Valuation',
    description: 'How will covered losses be valued?',
    pcTip: 'Market Data: Replacement Cost (RC) is used in 65% of commercial property policies. 80% coinsurance is the industry standard for commercial lines.'
  },
  underwriting: {
    title: 'Risk Selection',
    description: 'Define eligibility and approval rules',
    pcTip: 'Best Practice: Clear eligibility criteria reduce adverse selection by 15-25% and improve combined ratios. Consider loss history, years in business, and safety certifications.'
  },
  claims: {
    title: 'Claims Handling',
    description: 'Configure claims procedures',
    pcTip: 'Performance Metric: Streamlined claims procedures can reduce cycle time by 30% and improve customer retention by 20%.'
  },
  forms: {
    title: 'Policy Forms',
    description: 'Link required forms and endorsements',
    pcTip: 'Compliance Note: Ensure all ISO forms, state-mandated endorsements, and bureau filings are properly linked to this coverage.'
  },
  review: {
    title: 'Final Review',
    description: 'Verify all settings before publishing',
    pcTip: 'Quality Check: Verify coverage aligns with your rate manual, state filings, and underwriting guidelines before publishing to production.'
  },
};

// Streaming text hook for AI-like typing effect
const useStreamingText = (text: string, speed: number = 30) => {
  const [displayedText, setDisplayedText] = useState('');
  const [isComplete, setIsComplete] = useState(false);

  useEffect(() => {
    setDisplayedText('');
    setIsComplete(false);
    let i = 0;
    const interval = setInterval(() => {
      if (i < text.length) {
        setDisplayedText(text.slice(0, i + 1));
        i++;
      } else {
        setIsComplete(true);
        clearInterval(interval);
      }
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  return { displayedText, isComplete };
};

export const AIInsightsCard: React.FC<AIInsightsCardProps> = ({ stepId, draft, onApplyRecommendation, className = '' }) => {
  const insights = useMemo(() => getStepInsights(stepId, draft), [stepId, draft]);
  const stepInfo = STEP_TIPS[stepId] || { title: 'Step', description: 'Configure this step' };

  // Use streaming effect for P&C tips
  const { displayedText: streamingTip, isComplete: tipComplete } = useStreamingText(
    stepInfo.pcTip || '',
    25
  );

  const getIcon = (type: string) => {
    switch (type) {
      case 'tip': return <LightBulbIcon />;
      case 'warning': return <ExclamationTriangleIcon />;
      case 'success': return <CheckCircleIcon />;
      default: return <InformationCircleIcon />;
    }
  };

  return (
    <Container className={className}>
      <Header>
        <HeaderIcon><SparklesSolid /></HeaderIcon>
        <HeaderText><h4>{stepInfo.title}</h4><p>{stepInfo.description}</p></HeaderText>
      </Header>

      {/* Streaming P&C Tip */}
      {stepInfo.pcTip && (
        <PCTipSection>
          <PCTipIcon $isComplete={tipComplete}>
            <CommandLineIcon />
          </PCTipIcon>
          <PCTipText>
            {streamingTip}
            {!tipComplete && <Cursor />}
          </PCTipText>
        </PCTipSection>
      )}

      <InsightsList>
        {insights.map((insight, idx) => (
          <InsightItem key={idx} $type={insight.type} $delay={idx}>
            <InsightIcon $type={insight.type}>{getIcon(insight.type)}</InsightIcon>
            <InsightText>{insight.message}</InsightText>
            {insight.action && (
              <InsightAction onClick={insight.action.onClick}>{insight.action.label}</InsightAction>
            )}
          </InsightItem>
        ))}
      </InsightsList>
    </Container>
  );
};

// Animations
const fadeIn = keyframes`from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); }`;
const pulse = keyframes`0%, 100% { opacity: 1; } 50% { opacity: 0.7; }`;
const cursorBlink = keyframes`0%, 100% { opacity: 1; } 50% { opacity: 0; }`;

// Styled Components
const Container = styled.div`
  background: ${({ theme }) => theme.colours.surface};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 14px; overflow: hidden;
`;

const Header = styled.div`
  display: flex; align-items: center; gap: 12px; padding: 14px 16px;
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.06), rgba(99, 102, 241, 0.06));
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
`;

// P&C Tip Section with streaming text effect
const PCTipSection = styled.div`
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 12px 16px;
  background: linear-gradient(135deg, rgba(16, 185, 129, 0.06), rgba(5, 150, 105, 0.04));
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
`;

const PCTipIcon = styled.div<{ $isComplete: boolean }>`
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  background: ${({ $isComplete }) => $isComplete ? '#10b981' : 'linear-gradient(135deg, #10b981, #059669)'};
  border-radius: 6px;
  animation: ${({ $isComplete }) => !$isComplete ? pulse : 'none'} 1s ease-in-out infinite;

  svg {
    width: 12px;
    height: 12px;
    color: white;
  }
`;

const PCTipText = styled.div`
  flex: 1;
  font-size: 12px;
  color: #059669;
  line-height: 1.5;
  font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
  min-height: 36px;
`;

const Cursor = styled.span`
  display: inline-block;
  width: 2px;
  height: 14px;
  background: #10b981;
  margin-left: 2px;
  vertical-align: text-bottom;
  animation: ${cursorBlink} 0.8s ease-in-out infinite;
`;

const HeaderIcon = styled.div`
  display: flex; padding: 8px; background: linear-gradient(135deg, #6366f1, #8b5cf6);
  border-radius: 10px;
  svg { width: 14px; height: 14px; color: white; }
`;

const HeaderText = styled.div`
  h4 { font-size: 14px; font-weight: 600; color: ${({ theme }) => theme.colours.text}; margin: 0; }
  p { font-size: 12px; color: ${({ theme }) => theme.colours.textMuted}; margin: 2px 0 0; }
`;

const InsightsList = styled.div`padding: 12px;`;

const InsightItem = styled.div<{ $type: string; $delay: number }>`
  display: flex; align-items: flex-start; gap: 10px; padding: 10px 12px;
  background: ${({ $type }) => {
    switch ($type) {
      case 'tip': return 'rgba(245, 158, 11, 0.08)';
      case 'warning': return 'rgba(239, 68, 68, 0.08)';
      case 'success': return 'rgba(16, 185, 129, 0.08)';
      default: return 'rgba(99, 102, 241, 0.08)';
    }
  }};
  border-radius: 10px; margin-bottom: 8px;
  animation: ${fadeIn} 0.25s ease-out; animation-delay: ${({ $delay }) => $delay * 60}ms; animation-fill-mode: both;
  &:last-child { margin-bottom: 0; }
`;

const InsightIcon = styled.div<{ $type: string }>`
  flex-shrink: 0; margin-top: 1px;
  svg { width: 16px; height: 16px; color: ${({ $type }) => {
    switch ($type) {
      case 'tip': return '#f59e0b';
      case 'warning': return '#ef4444';
      case 'success': return '#10b981';
      default: return '#6366f1';
    }
  }}; }
`;

const InsightText = styled.span`flex: 1; font-size: 13px; color: ${({ theme }) => theme.colours.text}; line-height: 1.4;`;

const InsightAction = styled.button`
  padding: 4px 10px; background: ${({ theme }) => theme.colours.primary};
  border: none; border-radius: 6px; font-size: 11px; font-weight: 600;
  color: white; cursor: pointer; transition: opacity 0.2s;
  &:hover { opacity: 0.9; }
`;

export default AIInsightsCard;

```

---

## src/components/wizard/AIReviewSummary.tsx

**Path:** `src/components/wizard/AIReviewSummary.tsx`

```tsx
/**
 * AIReviewSummary - Premium review step with AI-generated summary
 * 
 * Features:
 * - AI-generated coverage summary
 * - Quality score with breakdown
 * - Recommendations for improvement
 * - Visual completeness indicators
 */

import React, { useMemo } from 'react';
import styled, { keyframes, css } from 'styled-components';
import {
  SparklesIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  InformationCircleIcon,
  DocumentTextIcon,
  ShieldCheckIcon,
  ChartBarIcon,
  ArrowRightIcon,
  LightBulbIcon,
} from '@heroicons/react/24/outline';
import { SparklesIcon as SparklesSolid, CheckCircleIcon as CheckSolid } from '@heroicons/react/24/solid';
import { Coverage } from '../../types';

interface QualityMetric {
  name: string;
  score: number;
  status: 'complete' | 'partial' | 'missing';
  recommendation?: string;
}

interface AIReviewSummaryProps {
  draft: Partial<Coverage>;
  onEditStep: (stepId: string) => void;
  className?: string;
}

// Calculate quality metrics for the coverage
const calculateQualityMetrics = (draft: Partial<Coverage>): QualityMetric[] => {
  const metrics: QualityMetric[] = [];

  // Basic Info
  const hasBasics = !!(draft.name && draft.coverageCode);
  metrics.push({
    name: 'Basic Information',
    score: hasBasics ? 100 : draft.name ? 50 : 0,
    status: hasBasics ? 'complete' : draft.name ? 'partial' : 'missing',
    recommendation: !hasBasics ? 'Add coverage name and code' : undefined,
  });

  // Coverage Trigger
  const hasTrigger = !!draft.coverageTrigger;
  metrics.push({
    name: 'Coverage Trigger',
    score: hasTrigger ? 100 : 0,
    status: hasTrigger ? 'complete' : 'missing',
    recommendation: !hasTrigger ? 'Define when coverage applies' : undefined,
  });

  // Valuation
  const hasValuation = !!(draft.valuationMethod && draft.coinsurancePercentage);
  metrics.push({
    name: 'Valuation Settings',
    score: hasValuation ? 100 : draft.valuationMethod ? 50 : 0,
    status: hasValuation ? 'complete' : draft.valuationMethod ? 'partial' : 'missing',
    recommendation: !hasValuation ? 'Set valuation method and coinsurance' : undefined,
  });

  // Underwriting
  const hasUnderwriting = !!(draft.eligibilityCriteria || draft.underwritingGuidelines);
  metrics.push({
    name: 'Underwriting Rules',
    score: hasUnderwriting ? 100 : 0,
    status: hasUnderwriting ? 'complete' : 'missing',
    recommendation: !hasUnderwriting ? 'Add eligibility criteria' : undefined,
  });

  // Claims
  const hasClaims = !!draft.claimsProcedure;
  metrics.push({
    name: 'Claims Procedure',
    score: hasClaims ? 100 : 0,
    status: hasClaims ? 'complete' : 'missing',
    recommendation: !hasClaims ? 'Define claims handling process' : undefined,
  });

  return metrics;
};

// Generate AI summary text
const generateAISummary = (draft: Partial<Coverage>): string => {
  const parts: string[] = [];
  
  if (draft.name) {
    parts.push(`${draft.name} is a ${draft.coverageTrigger || 'standard'} coverage`);
  }
  
  if (draft.valuationMethod) {
    parts.push(`valued using ${draft.valuationMethod.replace(/([A-Z])/g, ' $1').toLowerCase()}`);
  }
  
  if (draft.coinsurancePercentage) {
    parts.push(`with ${draft.coinsurancePercentage}% coinsurance`);
  }
  
  if (parts.length === 0) {
    return 'Start by adding basic coverage information to generate a summary.';
  }
  
  return parts.join(' ') + '.';
};

export const AIReviewSummary: React.FC<AIReviewSummaryProps> = ({ draft, onEditStep, className = '' }) => {
  const metrics = useMemo(() => calculateQualityMetrics(draft), [draft]);
  const overallScore = useMemo(() => {
    const total = metrics.reduce((sum, m) => sum + m.score, 0);
    return Math.round(total / metrics.length);
  }, [metrics]);
  const summary = useMemo(() => generateAISummary(draft), [draft]);
  const incompleteMetrics = metrics.filter(m => m.status !== 'complete');

  return (
    <Container className={className}>
      {/* AI Summary Header */}
      <SummaryHeader>
        <SummaryIcon><SparklesSolid /></SummaryIcon>
        <SummaryContent>
          <SummaryTitle>AI Coverage Summary</SummaryTitle>
          <SummaryText>{summary}</SummaryText>
        </SummaryContent>
      </SummaryHeader>

      {/* Quality Score */}
      <ScoreSection>
        <ScoreRing $score={overallScore}>
          <ScoreValue>{overallScore}</ScoreValue>
          <ScoreLabel>Quality</ScoreLabel>
        </ScoreRing>
        <ScoreDetails>
          <ScoreTitle>Coverage Quality Score</ScoreTitle>
          <ScoreDescription>
            {overallScore >= 80 ? 'Excellent! Your coverage is well-defined.' :
             overallScore >= 60 ? 'Good progress. A few areas need attention.' :
             'More information needed for a complete coverage.'}
          </ScoreDescription>
          <MetricsList>
            {metrics.map((metric, idx) => (
              <MetricItem key={metric.name} $status={metric.status} $delay={idx}>
                {metric.status === 'complete' ? <CheckSolid /> : 
                 metric.status === 'partial' ? <InformationCircleIcon /> : <ExclamationTriangleIcon />}
                <span>{metric.name}</span>
                <MetricScore $status={metric.status}>{metric.score}%</MetricScore>
              </MetricItem>
            ))}
          </MetricsList>
        </ScoreDetails>
      </ScoreSection>

      {/* Publish Confidence Meter */}
      <PublishConfidenceSection $score={overallScore}>
        <PublishConfidenceHeader>
          <ShieldCheckIcon />
          <span>Publish Readiness</span>
        </PublishConfidenceHeader>
        <PublishConfidenceBar>
          <PublishConfidenceFill $score={overallScore} />
        </PublishConfidenceBar>
        <PublishConfidenceText $score={overallScore}>
          {overallScore >= 80
            ? 'âœ“ Ready to publish - all key fields are complete'
            : overallScore >= 60
              ? 'âš  Almost ready - complete recommended fields for best results'
              : 'â—‹ Not ready - complete required fields before publishing'}
        </PublishConfidenceText>
      </PublishConfidenceSection>

      {/* Recommendations */}
      {incompleteMetrics.length > 0 && (
        <RecommendationsSection>
          <RecommendationsHeader><LightBulbIcon />AI Recommendations</RecommendationsHeader>
          {incompleteMetrics.map((metric, idx) => (
            <RecommendationCard key={metric.name} $delay={idx}>
              <RecommendationText>{metric.recommendation}</RecommendationText>
              <RecommendationAction onClick={() => onEditStep(metric.name.toLowerCase().replace(/\s+/g, '-'))}>
                Fix <ArrowRightIcon />
              </RecommendationAction>
            </RecommendationCard>
          ))}
        </RecommendationsSection>
      )}
    </Container>
  );
};

// Premium Animations
const fadeIn = keyframes`from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); }`;
const pulse = keyframes`0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); }`;
const ringFill = keyframes`from { transform: rotate(-90deg); } to { transform: rotate(calc(var(--score) * 3.6deg - 90deg)); }`;
const countUp = keyframes`from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); }`;
const shimmer = keyframes`0% { background-position: -200% 0; } 100% { background-position: 200% 0; }`;
const glowPulse = keyframes`
  0%, 100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.2); }
  50% { box-shadow: 0 0 40px rgba(16, 185, 129, 0.4); }
`;
const sparkle = keyframes`
  0%, 100% { transform: scale(1) rotate(0deg); }
  50% { transform: scale(1.1) rotate(5deg); }
`;

// Styled Components
const Container = styled.div`
  background: ${({ theme }) => theme.colours.surface};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 16px;
  overflow: hidden;
  animation: ${fadeIn} 0.4s ease-out;
`;

const SummaryHeader = styled.div`
  display: flex; gap: 14px; padding: 20px;
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(99, 102, 241, 0.08));
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
`;

const SummaryIcon = styled.div`
  display: flex; padding: 12px; background: linear-gradient(135deg, #6366f1, #8b5cf6);
  border-radius: 12px; height: fit-content;
  svg { width: 20px; height: 20px; color: white; }
`;

const SummaryContent = styled.div`flex: 1;`;
const SummaryTitle = styled.h3`font-size: 16px; font-weight: 600; color: ${({ theme }) => theme.colours.text}; margin: 0 0 6px;`;
const SummaryText = styled.p`font-size: 14px; color: ${({ theme }) => theme.colours.textMuted}; margin: 0; line-height: 1.5;`;

const ScoreSection = styled.div`
  display: flex;
  gap: 24px;
  padding: 24px;
  animation: ${fadeIn} 0.5s ease-out 0.2s both;
`;

// Premium animated score ring
const ScoreRing = styled.div<{ $score: number }>`
  position: relative;
  width: 110px;
  height: 110px;
  flex-shrink: 0;
  background: conic-gradient(
    ${({ $score }) => $score >= 80 ? '#10b981' : $score >= 60 ? '#f59e0b' : '#ef4444'} ${({ $score }) => $score * 3.6}deg,
    ${({ theme }) => theme.colours.border} 0deg
  );
  border-radius: 50%;
  transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);

  ${({ $score }) => $score >= 80 && css`
    animation: ${glowPulse} 2s ease-in-out infinite;
  `}

  &::before {
    content: '';
    position: absolute;
    inset: 10px;
    background: ${({ theme }) => theme.colours.surface};
    border-radius: 50%;
    box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.05);
  }
`;

const ScoreValue = styled.span<{ $score?: number }>`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -60%);
  font-size: 32px;
  font-weight: 700;
  color: ${({ theme }) => theme.colours.text};
  animation: ${countUp} 0.6s ease-out 0.3s both;
`;

const ScoreLabel = styled.span`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, 50%);
  font-size: 11px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.textMuted};
  text-transform: uppercase;
  letter-spacing: 0.5px;
`;

const ScoreDetails = styled.div`flex: 1;`;
const ScoreTitle = styled.h4`font-size: 15px; font-weight: 600; color: ${({ theme }) => theme.colours.text}; margin: 0 0 4px;`;
const ScoreDescription = styled.p`font-size: 13px; color: ${({ theme }) => theme.colours.textMuted}; margin: 0 0 16px;`;

const MetricsList = styled.div`display: flex; flex-direction: column; gap: 8px;`;

const MetricItem = styled.div<{ $status: string; $delay: number }>`
  display: flex; align-items: center; gap: 10px; padding: 10px 12px;
  background: ${({ $status }) =>
    $status === 'complete' ? 'rgba(16, 185, 129, 0.08)' :
    $status === 'partial' ? 'rgba(245, 158, 11, 0.08)' : 'rgba(239, 68, 68, 0.08)'};
  border-radius: 10px;
  animation: ${fadeIn} 0.2s ease-out; animation-delay: ${({ $delay }) => $delay * 50}ms; animation-fill-mode: both;
  svg { width: 16px; height: 16px; flex-shrink: 0;
    color: ${({ $status }) => $status === 'complete' ? '#10b981' : $status === 'partial' ? '#f59e0b' : '#ef4444'};
  }
  span { flex: 1; font-size: 13px; color: ${({ theme }) => theme.colours.text}; }
`;

const MetricScore = styled.span<{ $status: string }>`
  font-size: 12px; font-weight: 600;
  color: ${({ $status }) => $status === 'complete' ? '#10b981' : $status === 'partial' ? '#f59e0b' : '#ef4444'} !important;
`;

const RecommendationsSection = styled.div`
  padding: 20px; border-top: 1px solid ${({ theme }) => theme.colours.border};
  background: ${({ theme }) => theme.colours.backgroundAlt};
`;

const RecommendationsHeader = styled.div`
  display: flex; align-items: center; gap: 8px; margin-bottom: 14px;
  font-size: 13px; font-weight: 600; color: ${({ theme }) => theme.colours.text};
  svg { width: 16px; height: 16px; color: #f59e0b; }
`;

const RecommendationCard = styled.div<{ $delay: number }>`
  display: flex; align-items: center; justify-content: space-between; padding: 12px 14px;
  background: ${({ theme }) => theme.colours.surface}; border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 10px; margin-bottom: 8px;
  animation: ${fadeIn} 0.2s ease-out; animation-delay: ${({ $delay }) => $delay * 60}ms; animation-fill-mode: both;
  &:last-child { margin-bottom: 0; }
`;

const RecommendationText = styled.span`font-size: 13px; color: ${({ theme }) => theme.colours.text};`;

const RecommendationAction = styled.button`
  display: flex; align-items: center; gap: 4px; padding: 6px 12px;
  background: ${({ theme }) => theme.colours.primary}; border: none; border-radius: 6px;
  font-size: 12px; font-weight: 600; color: white; cursor: pointer; transition: opacity 0.2s;
  svg { width: 12px; height: 12px; }
  &:hover { opacity: 0.9; }
`;

// Publish Confidence Meter Styles
const PublishConfidenceSection = styled.div<{ $score: number }>`
  padding: 20px 24px;
  background: ${({ $score }) =>
    $score >= 80
      ? 'linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.05))'
      : $score >= 60
        ? 'linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(217, 119, 6, 0.05))'
        : 'linear-gradient(135deg, rgba(239, 68, 68, 0.08), rgba(220, 38, 38, 0.05))'
  };
  border-top: 1px solid ${({ theme }) => theme.colours.border};
  animation: ${fadeIn} 0.4s ease-out 0.4s both;
`;

const PublishConfidenceHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 13px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};

  svg {
    width: 18px;
    height: 18px;
    color: #10b981;
  }
`;

const PublishConfidenceBar = styled.div`
  height: 8px;
  background: ${({ theme }) => theme.colours.border};
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 10px;
`;

const PublishConfidenceFill = styled.div<{ $score: number }>`
  height: 100%;
  width: ${({ $score }) => $score}%;
  background: ${({ $score }) =>
    $score >= 80
      ? 'linear-gradient(90deg, #10b981, #059669)'
      : $score >= 60
        ? 'linear-gradient(90deg, #f59e0b, #d97706)'
        : 'linear-gradient(90deg, #ef4444, #dc2626)'
  };
  border-radius: 4px;
  transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);

  ${({ $score }) => $score >= 80 && css`
    box-shadow: 0 0 12px rgba(16, 185, 129, 0.4);
  `}
`;

const PublishConfidenceText = styled.div<{ $score: number }>`
  font-size: 13px;
  font-weight: 500;
  color: ${({ $score }) =>
    $score >= 80 ? '#059669' : $score >= 60 ? '#d97706' : '#dc2626'
  };
`;

export default AIReviewSummary;

```

---

## src/components/wizard/AISuggestionsSidebar.tsx

**Path:** `src/components/wizard/AISuggestionsSidebar.tsx`

```tsx
/**
 * AISuggestionsSidebar - Proactive AI suggestions panel
 * Shows templates, similar coverages, and industry recommendations
 */

import React, { useState, useMemo } from 'react';
import styled, { keyframes } from 'styled-components';
import {
  SparklesIcon,
  LightBulbIcon,
  DocumentDuplicateIcon,
  ChartBarIcon,
  CheckIcon,
  ChevronRightIcon,
  ExclamationTriangleIcon,
} from '@heroicons/react/24/outline';
import { SparklesIcon as SparklesSolid } from '@heroicons/react/24/solid';
import { Coverage, CoverageSimilarityMatch } from '../../types';
import { slideInRight, fadeInScale } from '../../styles/copilotAnimations';

interface CoverageTemplate {
  id: string;
  name: string;
  description: string;
  matchScore: number;
  fieldCount: number;
  category: string;
}

interface IndustryBenchmark {
  field: string;
  label: string;
  commonValue: string;
  currentValue?: string;
  isAligned: boolean;
}

interface ProactiveSuggestion {
  id: string;
  type: 'tip' | 'warning' | 'recommendation';
  message: string;
  action?: () => void;
  actionLabel?: string;
}

interface AISuggestionsSidebarProps {
  draft: Partial<Coverage>;
  templates?: CoverageTemplate[];
  similarCoverages?: CoverageSimilarityMatch[];
  benchmarks?: IndustryBenchmark[];
  suggestions?: ProactiveSuggestion[];
  onApplyTemplate?: (templateId: string) => void;
  onViewSimilar?: (coverageId: string) => void;
  onApplyBenchmark?: (field: string, value: string) => void;
  isLoading?: boolean;
}

// Default industry benchmarks for P&C
const DEFAULT_BENCHMARKS: IndustryBenchmark[] = [
  { field: 'coinsurancePercentage', label: 'Coinsurance', commonValue: '80%', isAligned: false },
  { field: 'valuationMethod', label: 'Valuation', commonValue: 'RC', isAligned: false },
  { field: 'coverageTrigger', label: 'Trigger', commonValue: 'occurrence', isAligned: false },
];

export const AISuggestionsSidebar: React.FC<AISuggestionsSidebarProps> = ({
  draft,
  templates = [],
  similarCoverages = [],
  benchmarks = DEFAULT_BENCHMARKS,
  suggestions = [],
  onApplyTemplate,
  onViewSimilar,
  onApplyBenchmark,
  isLoading = false,
}) => {
  const [expandedSection, setExpandedSection] = useState<string | null>('suggestions');

  // Calculate benchmark alignment
  const alignedBenchmarks = useMemo(() => {
    return benchmarks.map(b => ({
      ...b,
      currentValue: draft[b.field as keyof Coverage]?.toString(),
      isAligned: draft[b.field as keyof Coverage]?.toString() === b.commonValue,
    }));
  }, [benchmarks, draft]);

  const alignedCount = alignedBenchmarks.filter(b => b.isAligned).length;

  // Generate proactive suggestions based on draft state
  const autoSuggestions = useMemo((): ProactiveSuggestion[] => {
    const result: ProactiveSuggestion[] = [];
    
    if (!draft.coinsurancePercentage) {
      result.push({
        id: 'coinsurance',
        type: 'recommendation',
        message: 'Consider adding 80% coinsurance (industry standard)',
        actionLabel: 'Apply',
      });
    }
    
    if (!draft.valuationMethod) {
      result.push({
        id: 'valuation',
        type: 'tip',
        message: 'Replacement Cost (RC) is the most common valuation method',
        actionLabel: 'Apply RC',
      });
    }
    
    if (draft.coverageTrigger === 'claimsMade' && !draft.waitingPeriod) {
      result.push({
        id: 'waiting',
        type: 'warning',
        message: 'Claims-made coverage typically requires a waiting period',
      });
    }

    if (!draft.coverageTrigger) {
      result.push({
        id: 'trigger',
        type: 'tip',
        message: 'Occurrence trigger is standard for most property coverages',
        actionLabel: 'Apply',
      });
    }

    return [...suggestions, ...result];
  }, [draft, suggestions]);

  const toggleSection = (section: string) => {
    setExpandedSection(expandedSection === section ? null : section);
  };

  return (
    <Container>
      <Header>
        <HeaderIcon>
          <SparklesSolid />
        </HeaderIcon>
        <HeaderText>
          <h3>AI Insights</h3>
          <p>Proactive recommendations</p>
        </HeaderText>
      </Header>

      {isLoading ? (
        <LoadingState>
          <LoadingSpinner />
          <span>Analyzing coverage...</span>
        </LoadingState>
      ) : (
        <Content>
          {/* Proactive Suggestions */}
          {autoSuggestions.length > 0 && (
            <Section>
              <SectionHeader onClick={() => toggleSection('suggestions')}>
                <SectionIcon $color="#8b5cf6"><LightBulbIcon /></SectionIcon>
                <SectionTitle>Smart Suggestions</SectionTitle>
                <Badge>{autoSuggestions.length}</Badge>
                <ChevronIcon $expanded={expandedSection === 'suggestions'}>
                  <ChevronRightIcon />
                </ChevronIcon>
              </SectionHeader>
              {expandedSection === 'suggestions' && (
                <SectionContent>
                  {autoSuggestions.map((suggestion, index) => (
                    <SuggestionCard key={suggestion.id} $type={suggestion.type} $delay={index}>
                      <SuggestionIcon $type={suggestion.type}>
                        {suggestion.type === 'warning' ? <ExclamationTriangleIcon /> : <LightBulbIcon />}
                      </SuggestionIcon>
                      <SuggestionText>{suggestion.message}</SuggestionText>
                      {suggestion.actionLabel && (
                        <SuggestionAction onClick={suggestion.action}>
                          {suggestion.actionLabel}
                        </SuggestionAction>
                      )}
                    </SuggestionCard>
                  ))}
                </SectionContent>
              )}
            </Section>
          )}

          {/* Similar Coverages Warning */}
          {similarCoverages.length > 0 && (
            <Section>
              <SectionHeader onClick={() => toggleSection('similar')}>
                <SectionIcon $color="#f59e0b"><DocumentDuplicateIcon /></SectionIcon>
                <SectionTitle>Similar Coverages</SectionTitle>
                <WarningBadge>{similarCoverages.length}</WarningBadge>
                <ChevronIcon $expanded={expandedSection === 'similar'}>
                  <ChevronRightIcon />
                </ChevronIcon>
              </SectionHeader>
              {expandedSection === 'similar' && (
                <SectionContent>
                  {similarCoverages.slice(0, 3).map((match, index) => (
                    <SimilarCard key={match.coverageId} $delay={index}>
                      <SimilarInfo>
                        <SimilarName>{match.name}</SimilarName>
                        <SimilarMatch>{match.similarity}% match</SimilarMatch>
                      </SimilarInfo>
                      <ViewButton onClick={() => onViewSimilar?.(match.coverageId)}>
                        View
                      </ViewButton>
                    </SimilarCard>
                  ))}
                </SectionContent>
              )}
            </Section>
          )}

          {/* Industry Benchmarks */}
          <Section>
            <SectionHeader onClick={() => toggleSection('benchmarks')}>
              <SectionIcon $color="#10b981"><ChartBarIcon /></SectionIcon>
              <SectionTitle>Industry Standards</SectionTitle>
              <AlignmentBadge $aligned={alignedCount === alignedBenchmarks.length}>
                {alignedCount}/{alignedBenchmarks.length}
              </AlignmentBadge>
              <ChevronIcon $expanded={expandedSection === 'benchmarks'}>
                <ChevronRightIcon />
              </ChevronIcon>
            </SectionHeader>
            {expandedSection === 'benchmarks' && (
              <SectionContent>
                {alignedBenchmarks.map((benchmark, index) => (
                  <BenchmarkCard key={benchmark.field} $delay={index}>
                    <BenchmarkInfo>
                      <BenchmarkLabel>{benchmark.label}</BenchmarkLabel>
                      <BenchmarkValue>
                        Standard: <strong>{benchmark.commonValue}</strong>
                        {benchmark.currentValue && (
                          <CurrentValue $aligned={benchmark.isAligned}>
                            (Current: {benchmark.currentValue})
                          </CurrentValue>
                        )}
                      </BenchmarkValue>
                    </BenchmarkInfo>
                    {benchmark.isAligned ? (
                      <AlignedCheck><CheckIcon /></AlignedCheck>
                    ) : (
                      <ApplyButton onClick={() => onApplyBenchmark?.(benchmark.field, benchmark.commonValue)}>
                        Apply
                      </ApplyButton>
                    )}
                  </BenchmarkCard>
                ))}
              </SectionContent>
            )}
          </Section>

          {/* Templates */}
          {templates.length > 0 && (
            <Section>
              <SectionHeader onClick={() => toggleSection('templates')}>
                <SectionIcon $color="#6366f1"><SparklesIcon /></SectionIcon>
                <SectionTitle>Matching Templates</SectionTitle>
                <Badge>{templates.length}</Badge>
                <ChevronIcon $expanded={expandedSection === 'templates'}>
                  <ChevronRightIcon />
                </ChevronIcon>
              </SectionHeader>
              {expandedSection === 'templates' && (
                <SectionContent>
                  {templates.slice(0, 3).map((template, index) => (
                    <TemplateCard key={template.id} $delay={index}>
                      <TemplateInfo>
                        <TemplateName>{template.name}</TemplateName>
                        <TemplateDetails>
                          {template.matchScore}% match â€¢ {template.fieldCount} fields
                        </TemplateDetails>
                      </TemplateInfo>
                      <UseTemplateButton onClick={() => onApplyTemplate?.(template.id)}>
                        Use
                      </UseTemplateButton>
                    </TemplateCard>
                  ))}
                </SectionContent>
              )}
            </Section>
          )}
        </Content>
      )}
    </Container>
  );
};

// Styled Components
const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
`;

const Container = styled.div`
  display: flex;
  flex-direction: column;
  height: 100%;
  background: ${({ theme }) => theme.colours.surface};
  animation: ${slideInRight} 0.3s ease-out;
`;

const Header = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 20px;
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
`;

const HeaderIcon = styled.div`
  display: flex;
  padding: 10px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 12px;
  svg { width: 20px; height: 20px; color: white; }
`;

const HeaderText = styled.div`
  h3 { font-size: 16px; font-weight: 600; color: ${({ theme }) => theme.colours.text}; margin: 0; }
  p { font-size: 12px; color: ${({ theme }) => theme.colours.textMuted}; margin: 4px 0 0; }
`;

const LoadingState = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 40px 20px;
  color: ${({ theme }) => theme.colours.textMuted};
  font-size: 14px;
`;

const LoadingSpinner = styled.div`
  width: 32px;
  height: 32px;
  border: 3px solid ${({ theme }) => theme.colours.border};
  border-top-color: #8b5cf6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  @keyframes spin { to { transform: rotate(360deg); } }
`;

const Content = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 16px;
`;

const Section = styled.div`
  margin-bottom: 16px;
  background: ${({ theme }) => theme.colours.backgroundAlt};
  border-radius: 12px;
  overflow: hidden;
`;

const SectionHeader = styled.button`
  display: flex;
  align-items: center;
  gap: 10px;
  width: 100%;
  padding: 14px 16px;
  background: none;
  border: none;
  cursor: pointer;
  text-align: left;
  transition: background 0.2s;
  &:hover { background: rgba(0, 0, 0, 0.02); }
`;

const SectionIcon = styled.div<{ $color: string }>`
  display: flex;
  padding: 6px;
  background: ${({ $color }) => `${$color}15`};
  border-radius: 8px;
  svg { width: 16px; height: 16px; color: ${({ $color }) => $color}; }
`;

const SectionTitle = styled.span`
  flex: 1;
  font-size: 14px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
`;

const Badge = styled.span`
  padding: 2px 8px;
  background: ${({ theme }) => theme.colours.primary}15;
  color: ${({ theme }) => theme.colours.primary};
  font-size: 11px;
  font-weight: 600;
  border-radius: 10px;
`;

const WarningBadge = styled(Badge)`
  background: #fef3c7;
  color: #d97706;
`;

const AlignmentBadge = styled.span<{ $aligned: boolean }>`
  padding: 2px 8px;
  background: ${({ $aligned }) => $aligned ? '#d1fae5' : '#fee2e2'};
  color: ${({ $aligned }) => $aligned ? '#059669' : '#dc2626'};
  font-size: 11px;
  font-weight: 600;
  border-radius: 10px;
`;

const ChevronIcon = styled.span<{ $expanded: boolean }>`
  display: flex;
  transition: transform 0.2s;
  transform: rotate(${({ $expanded }) => $expanded ? '90deg' : '0'});
  svg { width: 16px; height: 16px; color: ${({ theme }) => theme.colours.textMuted}; }
`;

const SectionContent = styled.div`
  padding: 0 16px 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const SuggestionCard = styled.div<{ $type: string; $delay: number }>`
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 12px;
  background: ${({ $type }) =>
    $type === 'warning' ? '#fef3c7' :
    $type === 'recommendation' ? '#eff6ff' : '#f0fdf4'};
  border-radius: 10px;
  animation: ${fadeInScale} 0.3s ease-out;
  animation-delay: ${({ $delay }) => $delay * 50}ms;
  animation-fill-mode: both;
`;

const SuggestionIcon = styled.div<{ $type: string }>`
  flex-shrink: 0;
  svg {
    width: 16px; height: 16px;
    color: ${({ $type }) => $type === 'warning' ? '#d97706' : '#2563eb'};
  }
`;

const SuggestionText = styled.span`
  flex: 1;
  font-size: 13px;
  line-height: 1.4;
  color: ${({ theme }) => theme.colours.text};
`;

const SuggestionAction = styled.button`
  padding: 4px 10px;
  background: #3b82f6;
  color: white;
  font-size: 11px;
  font-weight: 500;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s;
  &:hover { background: #2563eb; }
`;

const SimilarCard = styled.div<{ $delay: number }>`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px;
  background: white;
  border: 1px solid #fcd34d;
  border-radius: 10px;
  animation: ${fadeInScale} 0.3s ease-out;
  animation-delay: ${({ $delay }) => $delay * 50}ms;
  animation-fill-mode: both;
`;

const SimilarInfo = styled.div`
  display: flex;
  flex-direction: column;
  gap: 2px;
`;

const SimilarName = styled.span`
  font-size: 13px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
`;

const SimilarMatch = styled.span`
  font-size: 11px;
  color: #d97706;
`;

const ViewButton = styled.button`
  padding: 4px 10px;
  background: transparent;
  color: #d97706;
  font-size: 11px;
  font-weight: 500;
  border: 1px solid #fcd34d;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
  &:hover { background: #fef3c7; }
`;

const BenchmarkCard = styled.div<{ $delay: number }>`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px;
  background: white;
  border-radius: 10px;
  animation: ${fadeInScale} 0.3s ease-out;
  animation-delay: ${({ $delay }) => $delay * 50}ms;
  animation-fill-mode: both;
`;

const BenchmarkInfo = styled.div`
  display: flex;
  flex-direction: column;
  gap: 2px;
`;

const BenchmarkLabel = styled.span`
  font-size: 13px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
`;

const BenchmarkValue = styled.span`
  font-size: 11px;
  color: ${({ theme }) => theme.colours.textMuted};
  strong { color: #10b981; }
`;

const CurrentValue = styled.span<{ $aligned: boolean }>`
  margin-left: 4px;
  color: ${({ $aligned }) => $aligned ? '#10b981' : '#64748b'};
`;

const AlignedCheck = styled.div`
  display: flex;
  padding: 4px;
  background: #d1fae5;
  border-radius: 50%;
  svg { width: 14px; height: 14px; color: #10b981; }
`;

const ApplyButton = styled.button`
  padding: 4px 10px;
  background: #10b981;
  color: white;
  font-size: 11px;
  font-weight: 500;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s;
  &:hover { background: #059669; }
`;

const TemplateCard = styled.div<{ $delay: number }>`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px;
  background: white;
  border-radius: 10px;
  animation: ${fadeInScale} 0.3s ease-out;
  animation-delay: ${({ $delay }) => $delay * 50}ms;
  animation-fill-mode: both;
`;

const TemplateInfo = styled.div`
  display: flex;
  flex-direction: column;
  gap: 2px;
`;

const TemplateName = styled.span`
  font-size: 13px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
`;

const TemplateDetails = styled.span`
  font-size: 11px;
  color: ${({ theme }) => theme.colours.textMuted};
`;

const UseTemplateButton = styled.button`
  padding: 4px 10px;
  background: #6366f1;
  color: white;
  font-size: 11px;
  font-weight: 500;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s;
  &:hover { background: #4f46e5; }
`;

export default AISuggestionsSidebar;


```

---

## src/components/wizard/CompletionCelebration.tsx

**Path:** `src/components/wizard/CompletionCelebration.tsx`

```tsx
/**
 * CompletionCelebration - Confetti celebration when coverage is published
 */

import React, { useEffect, useState } from 'react';
import styled, { keyframes, css } from 'styled-components';
import { CheckCircleIcon, SparklesIcon } from '@heroicons/react/24/solid';

interface CompletionCelebrationProps {
  isVisible: boolean;
  onComplete?: () => void;
}

const CONFETTI_COUNT = 50;
const CONFETTI_COLORS = ['#8b5cf6', '#6366f1', '#10b981', '#f59e0b', '#ef4444', '#3b82f6', '#ec4899'];

export const CompletionCelebration: React.FC<CompletionCelebrationProps> = ({
  isVisible,
  onComplete,
}) => {
  const [confetti, setConfetti] = useState<Array<{
    id: number;
    x: number;
    delay: number;
    color: string;
    size: number;
    rotation: number;
  }>>([]);

  useEffect(() => {
    if (isVisible) {
      // Generate confetti particles
      const particles = Array.from({ length: CONFETTI_COUNT }, (_, i) => ({
        id: i,
        x: Math.random() * 100,
        delay: Math.random() * 500,
        color: CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)],
        size: 6 + Math.random() * 6,
        rotation: Math.random() * 360,
      }));
      setConfetti(particles);

      // Auto-complete after animation
      const timer = setTimeout(() => {
        onComplete?.();
      }, 3000);

      return () => clearTimeout(timer);
    } else {
      setConfetti([]);
    }
  }, [isVisible, onComplete]);

  if (!isVisible) return null;

  return (
    <Overlay>
      {/* Confetti particles */}
      {confetti.map((particle) => (
        <ConfettiParticle
          key={particle.id}
          $x={particle.x}
          $delay={particle.delay}
          $color={particle.color}
          $size={particle.size}
          $rotation={particle.rotation}
        />
      ))}

      {/* Success message */}
      <SuccessCard>
        <IconWrapper>
          <CheckCircleIcon />
        </IconWrapper>
        <Title>Coverage Published!</Title>
        <Subtitle>
          <SparklesIcon />
          <span>AI-assisted coverage created successfully</span>
        </Subtitle>
      </SuccessCard>
    </Overlay>
  );
};

// Animations
const fadeIn = keyframes`
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
`;

const fall = keyframes`
  0% {
    opacity: 1;
    transform: translateY(-100vh) rotate(0deg);
  }
  100% {
    opacity: 0;
    transform: translateY(100vh) rotate(720deg);
  }
`;

const pulse = keyframes`
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
`;

const checkmark = keyframes`
  0% { stroke-dashoffset: 100; opacity: 0; }
  50% { opacity: 1; }
  100% { stroke-dashoffset: 0; opacity: 1; }
`;

// Styled Components
const Overlay = styled.div`
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
  animation: ${fadeIn} 0.3s ease-out;
`;

const ConfettiParticle = styled.div<{
  $x: number;
  $delay: number;
  $color: string;
  $size: number;
  $rotation: number;
}>`
  position: absolute;
  top: 0;
  left: ${({ $x }) => $x}%;
  width: ${({ $size }) => $size}px;
  height: ${({ $size }) => $size}px;
  background: ${({ $color }) => $color};
  border-radius: 2px;
  animation: ${fall} 3s ease-in forwards;
  animation-delay: ${({ $delay }) => $delay}ms;
  transform: rotate(${({ $rotation }) => $rotation}deg);
`;

const SuccessCard = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 48px 64px;
  background: white;
  border-radius: 24px;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  animation: ${fadeIn} 0.4s ease-out, ${pulse} 2s ease-in-out infinite;
  animation-delay: 0s, 0.4s;
`;

const IconWrapper = styled.div`
  display: flex;
  padding: 16px;
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  border-radius: 50%;
  margin-bottom: 24px;
  svg { width: 48px; height: 48px; color: white; }
`;

const Title = styled.h2`
  font-size: 28px;
  font-weight: 700;
  color: #1f2937;
  margin: 0 0 12px;
`;

const Subtitle = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  color: #6b7280;
  svg { width: 18px; height: 18px; color: #8b5cf6; }
`;

export default CompletionCelebration;

```

---

## src/components/wizard/CoverageCopilotWizard.tsx

**Path:** `src/components/wizard/CoverageCopilotWizard.tsx`

```tsx
/**
 * CoverageCopilotWizard - Full-screen wizard for AI-assisted coverage creation
 *
 * PREMIUM VERSION - Enhanced with:
 * - Glassmorphism design elements
 * - Smooth step transitions with direction awareness
 * - AI status indicators with streaming effects
 * - Premium animations and micro-interactions
 * - Ambient AI that proactively assists
 * - Draft persistence & completeness tracking
 */

import React, { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import styled, { keyframes, css } from 'styled-components';
import {
  XMarkIcon,
  ArrowLeftIcon,
  SparklesIcon as SparklesOutline,
  ChevronRightIcon as ChevronRightSmall,
  CloudArrowUpIcon,
  CommandLineIcon,
  QuestionMarkCircleIcon,
  ShieldCheckIcon,
  InformationCircleIcon,
  DocumentTextIcon,
  ExclamationTriangleIcon,
  ExclamationCircleIcon,
} from '@heroicons/react/24/outline';
import { SparklesIcon, CheckCircleIcon as CheckCircleSolid } from '@heroicons/react/24/solid';
import { Coverage, CoverageSimilarityMatch, CoverageTrigger, ValuationMethod } from '../../types';
import { useCoverageDraft, useCoverages, useProduct } from '../../hooks';
import { useAutoDraftCoverage } from '../../hooks/useAutoDraftCoverage';
import { WizardProgress, WizardStep } from './WizardProgress';
import { WizardFooter } from './WizardFooter';
import { AIAssistedField } from './AIAssistedField';
import { CompletionCelebration } from './CompletionCelebration';

// Premium AI Components
import { SmartCoverageNameInput } from './SmartCoverageNameInput';
import { AIInsightsCard } from './AIInsightsCard';
import { AIReviewSummary } from './AIReviewSummary';

// Premium Animations
import {
  gradientFlow,
  aiPulse,
  shimmer,
  sparkle,
  slideUpFadeIn,
  slideInRight,
  slideInLeft,
  fadeInScale,
  glowPulse,
  aiGradientBg,
  aiSolidGradient,
  premiumShadow,
  smoothSpin,
  ANIMATION_TIMING,
  EASING
} from './PremiumAnimations';

// Import form sections from existing modal
import { CoverageTriggerSelector } from '../selectors/CoverageTriggerSelector';
import { WaitingPeriodInput } from '../inputs/WaitingPeriodInput';
import { ValuationMethodSelector } from '../selectors/ValuationMethodSelector';
import { CoinsuranceInput } from '../inputs/CoinsuranceInput';
import { DepreciationMethodSelector } from '../selectors/DepreciationMethodSelector';
import { UnderwritingSection } from '../sections/UnderwritingSection';
import { ClaimsSection } from '../sections/ClaimsSection';
import { TerritorySelector } from '../selectors/TerritorySelector';
import { FormsStep } from './FormsStep';
import { useForms } from '../../hooks';

// ========== Premium Keyframe Animations ==========
const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const slideUp = keyframes`
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
`;

const contentSlideLeft = keyframes`
  from { opacity: 0; transform: translateX(40px); }
  to { opacity: 1; transform: translateX(0); }
`;

const contentSlideRight = keyframes`
  from { opacity: 0; transform: translateX(-40px); }
  to { opacity: 1; transform: translateX(0); }
`;

const subtleFloat = keyframes`
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-2px); }
`;

const ModalOverlay = styled.div`
  position: fixed;
  inset: 0;
  z-index: 9998;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(8px);
  animation: ${fadeIn} 0.25s ${EASING.smooth};
`;

const ModalContainer = styled.div`
  position: fixed;
  top: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colours.background};
  animation: ${slideUp} 0.35s ${EASING.spring};

  /* Take up most of the available space with elegant margins */
  width: calc(100% - 32px);
  max-width: 1400px;
  height: calc(100vh - 48px); /* viewport - top and bottom padding */
  max-height: 900px;

  /* Premium rounded corners and shadow */
  border-radius: 20px;
  box-shadow:
    0 25px 50px -12px rgba(0, 0, 0, 0.35),
    0 12px 24px -8px rgba(0, 0, 0, 0.2),
    0 0 0 1px rgba(255, 255, 255, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);

  /* Subtle gradient border effect */
  &::before {
    content: '';
    position: absolute;
    inset: -1px;
    border-radius: 21px;
    padding: 1px;
    background: linear-gradient(
      135deg,
      rgba(99, 102, 241, 0.3) 0%,
      rgba(139, 92, 246, 0.2) 50%,
      rgba(99, 102, 241, 0.1) 100%
    );
    -webkit-mask:
      linear-gradient(#fff 0 0) content-box,
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    pointer-events: none;
  }

  overflow: hidden;

  /* Mobile Responsiveness */
  @media (max-width: 768px) {
    top: 0;
    width: 100%;
    height: 100vh;
    max-height: none;
    border-radius: 0;

    &::before {
      display: none;
    }
  }

  @media (max-width: 480px) {
    top: 0;
  }
`;

// Premium Header with AI Branding
const Header = styled.div`
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 18px 28px;
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
  background: linear-gradient(180deg,
    ${({ theme }) => theme.colours.surface} 0%,
    ${({ theme }) => theme.colours.background} 100%
  );
  position: relative;
  border-radius: 20px 20px 0 0;

  &::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg,
      transparent 0%,
      rgba(99, 102, 241, 0.3) 20%,
      rgba(139, 92, 246, 0.5) 50%,
      rgba(99, 102, 241, 0.3) 80%,
      transparent 100%
    );
  }

  /* Mobile: Reduce padding and adjust layout */
  @media (max-width: 768px) {
    padding: 14px 16px;
    border-radius: 0;
    flex-wrap: wrap;
    gap: 12px;
  }

  @media (max-width: 480px) {
    padding: 12px;
  }
`;

const HeaderLeft = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
`;

// Breadcrumb navigation for better context awareness
const Breadcrumb = styled.nav`
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: ${({ theme }) => theme.colours.textMuted};
  margin-bottom: 2px;

  span {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  svg {
    width: 12px;
    height: 12px;
  }
`;

const BreadcrumbLink = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colours.textMuted};
  cursor: pointer;
  padding: 0;
  font-size: 12px;
  transition: color 0.2s;

  &:hover {
    color: ${({ theme }) => theme.colours.primary};
  }
`;

const BreadcrumbCurrent = styled.span`
  color: ${({ theme }) => theme.colours.text};
  font-weight: 500;
`;

// Compact progress indicator for header
const HeaderProgress = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  margin-left: auto;
  margin-right: 16px;

  /* Mobile: Hide progress label, show only ring */
  @media (max-width: 768px) {
    margin-right: 8px;
    gap: 8px;
  }

  @media (max-width: 480px) {
    display: none;
  }
`;

const ProgressRing = styled.div<{ $percentage: number }>`
  position: relative;
  width: 36px;
  height: 36px;

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background: conic-gradient(
      #6366f1 ${({ $percentage }) => $percentage * 3.6}deg,
      ${({ theme }) => theme.colours.border} 0deg
    );
    mask: radial-gradient(farthest-side, transparent calc(100% - 4px), #fff calc(100% - 4px));
    -webkit-mask: radial-gradient(farthest-side, transparent calc(100% - 4px), #fff calc(100% - 4px));
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  }
`;

const ProgressRingText = styled.span`
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 700;
  color: ${({ theme }) => theme.colours.text};
`;

const ProgressLabel = styled.div`
  display: flex;
  flex-direction: column;

  span:first-child {
    font-size: 12px;
    font-weight: 600;
    color: ${({ theme }) => theme.colours.text};
  }

  span:last-child {
    font-size: 11px;
    color: ${({ theme }) => theme.colours.textMuted};
  }
`;

// AI Status Badge in Header
const AIStatusBadge = styled.div<{ $isActive: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 14px;
  background: ${({ $isActive }) =>
    $isActive
      ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.2) 100%)'
      : 'rgba(99, 102, 241, 0.08)'
  };
  border: 1px solid ${({ $isActive }) =>
    $isActive ? 'rgba(139, 92, 246, 0.4)' : 'rgba(99, 102, 241, 0.15)'
  };
  border-radius: 20px;
  transition: all 0.3s ${EASING.smooth};

  ${({ $isActive }) => $isActive && css`
    animation: ${glowPulse} 2s ease-in-out infinite;
  `}
`;

const AIStatusIcon = styled.div<{ $isActive: boolean }>`
  display: flex;
  padding: 4px;
  border-radius: 6px;
  background: ${({ $isActive }) =>
    $isActive
      ? 'linear-gradient(135deg, #6366f1, #8b5cf6)'
      : 'rgba(99, 102, 241, 0.2)'
  };

  svg {
    width: 12px;
    height: 12px;
    color: ${({ $isActive }) => $isActive ? 'white' : '#8b5cf6'};
    ${({ $isActive }) => $isActive && css`
      animation: ${sparkle} 1.5s ease-in-out infinite;
    `}
  }
`;

const AIStatusText = styled.span<{ $isActive: boolean }>`
  font-size: 12px;
  font-weight: 500;
  color: ${({ $isActive }) => $isActive ? '#8b5cf6' : '#6b7280'};

  ${({ $isActive }) => $isActive && css`
    background: linear-gradient(90deg, #6366f1, #8b5cf6, #a855f7);
    background-size: 200% 100%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: ${gradientFlow} 3s ease infinite;
  `}
`;

const HeaderTitle = styled.div`
  h1 {
    font-size: 20px;
    font-weight: 600;
    color: ${({ theme }) => theme.colours.text};
    margin: 0;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  p {
    font-size: 14px;
    color: ${({ theme }) => theme.colours.textMuted};
    margin: 4px 0 0 0;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const IconButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px;
  border: none;
  border-radius: 10px;
  background: transparent;
  color: ${({ theme }) => theme.colours.textMuted};
  cursor: pointer;
  transition: all 0.2s ${EASING.smooth};

  &:hover {
    background: ${({ theme }) => theme.colours.backgroundAlt};
    color: ${({ theme }) => theme.colours.text};
    transform: scale(1.05);
  }

  &:active {
    transform: scale(0.95);
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

const MainContent = styled.div`
  flex: 1;
  display: flex;
  overflow: hidden;
  background: ${({ theme }) => theme.colours.background};

  /* Mobile: Stack vertically */
  @media (max-width: 768px) {
    flex-direction: column;
  }
`;

const FormPane = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 32px 24px;
  background: ${({ theme }) => theme.colours.background};

  /* Subtle grid pattern */
  background-image: radial-gradient(
    circle at 1px 1px,
    ${({ theme }) => theme.colours.border}15 1px,
    transparent 0
  );
  background-size: 24px 24px;

  /* Mobile: Reduce padding */
  @media (max-width: 768px) {
    padding: 20px 16px;
  }

  @media (max-width: 480px) {
    padding: 16px 12px;
  }
`;

const FormContent = styled.div`
  max-width: 800px;
  margin: 0 auto;

  @media (max-width: 768px) {
    max-width: 100%;
  }
`;

// Premium AI Sidebar with glass effect
const AISidebar = styled.div`
  width: 340px;
  flex-shrink: 0;
  overflow-y: auto;
  padding: 20px;
  background: linear-gradient(180deg,
    ${({ theme }) => theme.colours.backgroundAlt} 0%,
    ${({ theme }) => `${theme.colours.backgroundAlt}f5`} 100%
  );
  border-left: 1px solid ${({ theme }) => theme.colours.border};
  display: flex;
  flex-direction: column;
  gap: 16px;
  position: relative;

  /* AI accent line */
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 1px;
    height: 100%;
    background: linear-gradient(180deg,
      rgba(99, 102, 241, 0.5) 0%,
      rgba(139, 92, 246, 0.3) 50%,
      transparent 100%
    );
  }

  animation: ${slideInRight} 0.4s ${EASING.smooth};

  /* Tablet: Narrower sidebar */
  @media (max-width: 1024px) {
    width: 280px;
    padding: 16px;
  }

  /* Mobile: Hide sidebar, show floating button instead */
  @media (max-width: 768px) {
    display: none;
  }
`;

const AISidebarHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  padding-bottom: 16px;
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
  margin-bottom: 4px;
`;

const AISidebarTitle = styled.h3`
  font-size: 14px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  margin: 0;
  display: flex;
  align-items: center;
  gap: 8px;

  svg {
    width: 16px;
    height: 16px;
    color: #8b5cf6;
  }
`;

// AI Working Card - shows when AI is auto-populating fields in sidebar
const AIWorkingCard = styled.div`
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 14px;
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(99, 102, 241, 0.08));
  border: 1px solid rgba(139, 92, 246, 0.2);
  border-radius: 12px;
  margin-bottom: 16px;
  animation: ${fadeInScale} 0.3s ${EASING.smooth};
`;

const AIWorkingIcon = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  background: ${aiSolidGradient};
  border-radius: 10px;
  flex-shrink: 0;
  animation: ${aiPulse} 1.5s ease-in-out infinite;

  svg {
    width: 18px;
    height: 18px;
    color: white;
  }
`;

const AIWorkingContent = styled.div`
  flex: 1;
  min-width: 0;
`;

const AIWorkingTitle = styled.div`
  font-size: 13px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  margin-bottom: 2px;
`;

const AIWorkingMessage = styled.div`
  font-size: 12px;
  color: ${({ theme }) => theme.colours.textMuted};
`;

const CloseButton = styled.button`
  position: absolute;
  top: 12px;
  right: 12px;
  z-index: 10;
  padding: 6px;
  border: none;
  border-radius: 8px;
  background: transparent;
  color: ${({ theme }) => theme.colours.textMuted};
  cursor: pointer;
  transition: all 0.2s ${EASING.smooth};

  &:hover {
    background: ${({ theme }) => theme.colours.backgroundAlt};
    transform: scale(1.1);
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

// Auto-save indicator
const AutoSaveIndicator = styled.div<{ $status: 'idle' | 'saving' | 'saved' | 'error' }>`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 8px;
  font-size: 11px;
  font-weight: 500;
  transition: all 0.3s ${EASING.smooth};

  ${({ $status }) => {
    switch ($status) {
      case 'saving':
        return css`
          background: rgba(99, 102, 241, 0.1);
          color: #6366f1;
        `;
      case 'saved':
        return css`
          background: rgba(16, 185, 129, 0.1);
          color: #10b981;
        `;
      case 'error':
        return css`
          background: rgba(239, 68, 68, 0.1);
          color: #ef4444;
        `;
      default:
        return css`
          background: transparent;
          color: ${({ theme }: { theme: any }) => theme.colours.textMuted};
        `;
    }
  }}

  svg {
    width: 14px;
    height: 14px;
    ${({ $status }) => $status === 'saving' && css`
      animation: ${smoothSpin} 1s linear infinite;
    `}
  }
`;

// Floating AI Help Button
const FloatingAIButton = styled.button<{ $isActive?: boolean }>`
  position: fixed;
  bottom: 24px;
  right: 24px;
  z-index: 10001;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 14px 20px;
  background: ${({ $isActive }) =>
    $isActive
      ? 'linear-gradient(135deg, #6366f1, #8b5cf6)'
      : 'linear-gradient(135deg, #6366f1, #8b5cf6)'
  };
  border: none;
  border-radius: 50px;
  color: white;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(99, 102, 241, 0.4);
  transition: all 0.3s ${EASING.smooth};

  &:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 12px 32px rgba(99, 102, 241, 0.5);
  }

  &:active {
    transform: translateY(0) scale(0.98);
  }

  svg {
    width: 18px;
    height: 18px;
  }
`;

// Keyboard shortcut hint
const ShortcutHint = styled.div`
  position: absolute;
  bottom: calc(100% + 8px);
  right: 0;
  padding: 8px 12px;
  background: ${({ theme }) => theme.colours.surface};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  font-size: 12px;
  color: ${({ theme }) => theme.colours.textMuted};
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  transition: all 0.2s ${EASING.smooth};

  ${FloatingAIButton}:hover & {
    opacity: 1;
    visibility: visible;
  }

  kbd {
    padding: 2px 6px;
    background: ${({ theme }) => theme.colours.backgroundAlt};
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
    margin-left: 4px;
  }
`;

// Mobile AI Panel - Slide-up panel for AI insights on mobile
const MobileAIPanelOverlay = styled.div<{ $isOpen: boolean }>`
  display: none;

  @media (max-width: 768px) {
    display: ${({ $isOpen }) => $isOpen ? 'block' : 'none'};
    position: fixed;
    inset: 0;
    z-index: 10002;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
    animation: ${fadeIn} 0.2s ease;
  }
`;

const MobileAIPanel = styled.div<{ $isOpen: boolean }>`
  display: none;

  @media (max-width: 768px) {
    display: flex;
    flex-direction: column;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10003;
    max-height: 70vh;
    background: ${({ theme }) => theme.colours.background};
    border-radius: 20px 20px 0 0;
    box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.2);
    transform: ${({ $isOpen }) => $isOpen ? 'translateY(0)' : 'translateY(100%)'};
    transition: transform 0.3s ${EASING.spring};
  }
`;

const MobileAIPanelHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};

  h3 {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: ${({ theme }) => theme.colours.text};

    svg {
      width: 20px;
      height: 20px;
      color: #8b5cf6;
    }
  }
`;

const MobileAIPanelContent = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 16px 20px;
`;

const MobileAIPanelClose = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  background: ${({ theme }) => theme.colours.surface};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 8px;
  cursor: pointer;

  svg {
    width: 18px;
    height: 18px;
    color: ${({ theme }) => theme.colours.textMuted};
  }
`;

// Mobile Floating AI Button - visible on all steps on mobile
const MobileFloatingAIButton = styled.button`
  display: none;

  @media (max-width: 768px) {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    bottom: 100px;
    right: 16px;
    z-index: 10001;
    width: 56px;
    height: 56px;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    border: none;
    border-radius: 50%;
    color: white;
    box-shadow: 0 4px 16px rgba(99, 102, 241, 0.4);
    cursor: pointer;

    svg {
      width: 24px;
      height: 24px;
    }

    &:active {
      transform: scale(0.95);
    }
  }
`;

// Premium Footer with gradient
const Footer = styled.div`
  flex-shrink: 0;
  border-top: 1px solid ${({ theme }) => theme.colours.border};
  background: linear-gradient(180deg,
    ${({ theme }) => theme.colours.surface} 0%,
    ${({ theme }) => theme.colours.background} 100%
  );
  padding: 18px 28px;
  position: relative;
  border-radius: 0 0 20px 20px;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg,
      transparent 0%,
      rgba(99, 102, 241, 0.2) 50%,
      transparent 100%
    );
  }
`;

// Step container with directional animation support
const StepContainer = styled.div<{ $direction?: 'left' | 'right' }>`
  animation: ${({ $direction }) =>
    $direction === 'left' ? contentSlideRight : contentSlideLeft
  } 0.35s ${EASING.smooth};
  animation-fill-mode: both;
`;

// Premium step title with AI indicator
const StepTitle = styled.h2`
  font-size: 20px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  margin: 0 0 8px 0;
  display: flex;
  align-items: center;
  gap: 10px;
`;

const StepSubtitle = styled.p`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textMuted};
  margin: 0 0 28px 0;
`;

const StepHeader = styled.div`
  margin-bottom: 24px;
`;

// Skeleton loading components for smooth transitions
const SkeletonPulse = keyframes`
  0% { opacity: 0.6; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
`;

const SkeletonLine = styled.div<{ $width?: string; $height?: string }>`
  width: ${({ $width }) => $width || '100%'};
  height: ${({ $height }) => $height || '16px'};
  background: linear-gradient(
    90deg,
    ${({ theme }) => theme.colours.border} 0%,
    ${({ theme }) => theme.colours.backgroundAlt} 50%,
    ${({ theme }) => theme.colours.border} 100%
  );
  background-size: 200% 100%;
  border-radius: 4px;
  animation: ${shimmer} 1.5s ease-in-out infinite, ${SkeletonPulse} 2s ease-in-out infinite;
`;

const SkeletonField = styled.div`
  margin-bottom: 20px;

  ${SkeletonLine}:first-child {
    width: 30%;
    height: 14px;
    margin-bottom: 8px;
  }

  ${SkeletonLine}:last-child {
    height: 44px;
    border-radius: 8px;
  }
`;

const SkeletonCard = styled.div`
  padding: 24px;
  background: ${({ theme }) => theme.colours.surface};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 12px;
  margin-bottom: 16px;
`;

const FormGroup = styled.div`
  margin-bottom: 20px;
`;

const Label = styled.label`
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
  margin-bottom: 8px;
`;

const Input = styled.input`
  width: 100%;
  padding: 12px 16px;
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 8px;
  background: ${({ theme }) => theme.colours.surface};
  color: ${({ theme }) => theme.colours.text};
  font-size: 14px;
  transition: border-color 0.2s, box-shadow 0.2s;

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colours.primary};
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colours.primary}20;
  }

  &::placeholder {
    color: ${({ theme }) => theme.colours.textMuted};
  }
`;

// AI Working Banner - prominent indicator when AI is populating fields
const AIFillingBanner = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 14px 18px;
  margin-bottom: 20px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 12px;
  color: white;
  animation: ${fadeInScale} 0.3s ${EASING.smooth};

  svg {
    width: 22px;
    height: 22px;
    animation: ${sparkle} 1s ease-in-out infinite;
  }
`;

const AIFillingText = styled.div`
  flex: 1;

  strong {
    display: block;
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 2px;
  }

  span {
    font-size: 12px;
    opacity: 0.9;
  }
`;

const AIFillingDots = styled.div`
  display: flex;
  gap: 4px;

  span {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: white;
    animation: ${aiPulse} 1.4s ease-in-out infinite;

    &:nth-child(2) { animation-delay: 0.2s; }
    &:nth-child(3) { animation-delay: 0.4s; }
  }
`;

// ========== Enhanced Review Step Styles ==========
const ReviewContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 20px;
`;

const ReviewHeaderCard = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 20px 24px;
  background: linear-gradient(135deg,
    ${({ theme }) => theme.colours.primary}08,
    ${({ theme }) => theme.colours.primary}15
  );
  border: 1px solid ${({ theme }) => theme.colours.primary}30;
  border-radius: 16px;
  animation: ${slideUpFadeIn} 0.4s ${EASING.spring};
`;

const ReviewHeaderIcon = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 48px;
  height: 48px;
  background: linear-gradient(135deg, #6366f1, #8b5cf6);
  border-radius: 12px;
  svg { width: 24px; height: 24px; color: white; }
`;

const ReviewHeaderContent = styled.div`
  flex: 1;
`;

const ReviewCoverageName = styled.h3`
  font-size: 18px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  margin: 0 0 4px 0;
`;

const ReviewCoverageCode = styled.span`
  font-size: 13px;
  color: ${({ theme }) => theme.colours.textMuted};
  font-family: 'SF Mono', monospace;
`;

const ReviewCompleteness = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  span:last-child { font-size: 11px; color: ${({ theme }) => theme.colours.textMuted}; }
`;

const CompletenessRing = styled.div<{ $percentage: number }>`
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: conic-gradient(
    #10b981 ${({ $percentage }) => $percentage * 3.6}deg,
    ${({ theme }) => theme.colours.border} 0deg
  );
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;

  &::before {
    content: '';
    position: absolute;
    width: 38px;
    height: 38px;
    background: ${({ theme }) => theme.colours.surface};
    border-radius: 50%;
  }

  span {
    position: relative;
    font-size: 12px;
    font-weight: 600;
    color: ${({ theme }) => theme.colours.text};
  }
`;

const ReviewSectionsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;

  /* Tablet: 2 columns */
  @media (max-width: 768px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
  }

  /* Mobile: 2 columns, smaller */
  @media (max-width: 480px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
`;

const ReviewSectionCard = styled.div<{ $complete: boolean; $delay: number }>`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 16px;
  background: ${({ theme, $complete }) =>
    $complete ? 'rgba(16, 185, 129, 0.08)' : theme.colours.surface};
  border: 1px solid ${({ $complete }) =>
    $complete ? 'rgba(16, 185, 129, 0.3)' : 'rgba(156, 163, 175, 0.2)'};
  border-radius: 12px;
  animation: ${slideUpFadeIn} 0.3s ${EASING.spring};
  animation-delay: ${({ $delay }) => $delay * 50}ms;
  animation-fill-mode: both;
  transition: all 0.2s ease;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  }
`;

const SectionIcon = styled.div<{ $complete: boolean }>`
  font-size: 20px;
  opacity: ${({ $complete }) => $complete ? 1 : 0.5};
`;

const SectionName = styled.span`
  font-size: 12px;
  font-weight: 500;
  color: ${({ theme }) => theme.colours.text};
`;

const SectionStatus = styled.div<{ $complete: boolean }>`
  svg {
    width: 16px;
    height: 16px;
    color: ${({ $complete }) => $complete ? '#10b981' : '#9ca3af'};
  }
`;

const ReviewCard = styled.div`
  background: ${({ theme }) => theme.colours.surface};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 16px;
  padding: 24px;
  animation: ${slideUpFadeIn} 0.4s ${EASING.spring} 0.2s both;
`;

const ReviewCardHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};

  svg { width: 18px; height: 18px; color: ${({ theme }) => theme.colours.primary}; }
  span { font-size: 14px; font-weight: 600; color: ${({ theme }) => theme.colours.text}; }
`;

const ReviewGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
`;

const ReviewItem = styled.div`
  span:first-child {
    color: ${({ theme }) => theme.colours.textMuted};
    font-size: 13px;
  }
  span:last-child {
    font-weight: 500;
    color: ${({ theme }) => theme.colours.text};
    margin-left: 8px;
  }
`;

const FormsList = styled.div`
  margin-top: 20px;
  padding-top: 16px;
  border-top: 1px solid ${({ theme }) => theme.colours.border};
`;

const FormsListHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;

  svg { width: 16px; height: 16px; color: ${({ theme }) => theme.colours.textMuted}; }
  span { font-size: 13px; font-weight: 500; color: ${({ theme }) => theme.colours.text}; }
`;

const FormsListContent = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
`;

const NoFormsMessage = styled.span`
  font-size: 13px;
  color: ${({ theme }) => theme.colours.textMuted};
  font-style: italic;
`;

const WarningBox = styled.div`
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(217, 119, 6, 0.05));
  border: 1px solid rgba(245, 158, 11, 0.3);
  border-radius: 12px;
  padding: 16px;
  animation: ${slideUpFadeIn} 0.3s ${EASING.spring} 0.3s both;
`;

const WarningHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;

  svg { width: 18px; height: 18px; color: #d97706; }
  span { font-size: 14px; font-weight: 600; color: #b45309; }
`;

const WarningList = styled.ul`
  margin: 0;
  padding-left: 24px;
  color: #d97706;
  font-size: 13px;

  li { margin-bottom: 4px; }
`;

const FormBadge = styled.span`
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  background: linear-gradient(135deg,
    ${({ theme }) => theme.colours.primary}10,
    ${({ theme }) => theme.colours.primary}20
  );
  color: ${({ theme }) => theme.colours.primary};
  border: 1px solid ${({ theme }) => theme.colours.primary}30;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 500;
`;

// ========== Toggle Switch Component ==========
const ToggleSwitchContainer = styled.label`
  display: flex;
  align-items: center;
  gap: 12px;
  cursor: pointer;
`;

const ToggleSwitchTrack = styled.div<{ $checked: boolean }>`
  position: relative;
  width: 48px;
  height: 26px;
  background: ${({ $checked }) => $checked ? 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)' : '#e5e7eb'};
  border-radius: 13px;
  transition: all 0.2s ease;
`;

const ToggleSwitchKnob = styled.div<{ $checked: boolean }>`
  position: absolute;
  top: 3px;
  left: ${({ $checked }) => $checked ? '25px' : '3px'};
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
`;

const ToggleSwitchLabel = styled.span`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.text};
`;

interface ToggleSwitchProps {
  checked: boolean;
  onChange: (checked: boolean) => void;
  label?: string;
}

const ToggleSwitch: React.FC<ToggleSwitchProps> = ({ checked, onChange, label }) => (
  <ToggleSwitchContainer onClick={() => onChange(!checked)}>
    <ToggleSwitchTrack $checked={checked}>
      <ToggleSwitchKnob $checked={checked} />
    </ToggleSwitchTrack>
    {label && <ToggleSwitchLabel>{label}</ToggleSwitchLabel>}
  </ToggleSwitchContainer>
);

// ========== Number Input Component ==========
const NumberInputContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const NumberInputField = styled.input`
  width: 100px;
  padding: 10px 12px;
  font-size: 15px;
  border: 1.5px solid ${({ theme }) => theme.colours.border};
  border-radius: 8px;
  background: ${({ theme }) => theme.colours.background};
  color: ${({ theme }) => theme.colours.text};
  transition: all 0.2s ease;

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colours.primary};
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colours.primary}20;
  }

  &::placeholder {
    color: ${({ theme }) => theme.colours.textMuted};
  }
`;

const NumberInputSuffix = styled.span`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textMuted};
`;

interface NumberInputProps {
  value: number;
  onChange: (value: number) => void;
  min?: number;
  max?: number;
  suffix?: string;
  placeholder?: string;
}

const NumberInput: React.FC<NumberInputProps> = ({ value, onChange, min, max, suffix, placeholder }) => (
  <NumberInputContainer>
    <NumberInputField
      type="number"
      value={value || ''}
      onChange={(e) => {
        const val = parseInt(e.target.value, 10);
        if (!isNaN(val)) {
          if (min !== undefined && val < min) return;
          if (max !== undefined && val > max) return;
          onChange(val);
        } else if (e.target.value === '') {
          onChange(0);
        }
      }}
      min={min}
      max={max}
      placeholder={placeholder}
    />
    {suffix && <NumberInputSuffix>{suffix}</NumberInputSuffix>}
  </NumberInputContainer>
);



interface CoverageCopilotWizardProps {
  isOpen: boolean;
  onClose: () => void;
  productId: string;
  existingCoverage?: Partial<Coverage>;
  onSave: (coverage: Partial<Coverage>) => Promise<void>;
}

const WIZARD_STEPS: WizardStep[] = [
  { id: 'basics', label: 'Basics', description: 'Name and code' },
  { id: 'triggers', label: 'Trigger & Periods', description: 'Coverage triggers' },
  { id: 'valuation', label: 'Valuation & Coinsurance', description: 'Value settings' },
  { id: 'underwriting', label: 'Underwriting', description: 'Eligibility & requirements' },
  { id: 'review', label: 'Review', description: 'Review and publish' }
];

export const CoverageCopilotWizard: React.FC<CoverageCopilotWizardProps> = ({
  isOpen,
  onClose,
  productId,
  existingCoverage,
  onSave
}) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [stepDirection, setStepDirection] = useState<'left' | 'right'>('right');
  const [isPublishing, setIsPublishing] = useState(false);
  const [showCelebration, setShowCelebration] = useState(false);
  const [selectedFormIds, setSelectedFormIds] = useState<string[]>([]);
  const [suggestedFormIds] = useState<string[]>([]);
  const [aiSuggestedFields, setAISuggestedFields] = useState<Set<string>>(new Set());
  const [showMobileAIPanel, setShowMobileAIPanel] = useState(false);
  const prevStepRef = useRef(0);

  // Get product for line of business info
  const { product } = useProduct(productId);

  // Get existing coverages for duplicate detection
  const { coverages: existingCoverages } = useCoverages(productId);

  // Get forms for the product
  const { forms, loading: formsLoading } = useForms(productId);

  // Draft management
  const {
    draft,
    completenessScore,
    missingRequiredFields,
    validation,
    isDirty,
    isSaving,
    updateDraft,
    saveDraft,
    publishDraft,
  } = useCoverageDraft({
    productId,
    initialDraft: existingCoverage,
    source: existingCoverage?.id ? 'clone' : 'manual'
  });

  // Auto-draft hook for AI-generated field suggestions
  const {
    generateFieldsForStep,
    isGenerating: isAutoDrafting,
  } = useAutoDraftCoverage({
    productId,
    onFieldsGenerated: (fields) => {
      // Apply auto-generated fields to draft (only if not already set)
      const fieldsToApply: Partial<Coverage> = {};
      const newAISuggestedFields = new Set(aiSuggestedFields);
      Object.entries(fields).forEach(([key, value]) => {
        if (draft[key as keyof Coverage] === undefined || draft[key as keyof Coverage] === null || draft[key as keyof Coverage] === '') {
          fieldsToApply[key as keyof Coverage] = value;
          newAISuggestedFields.add(key);
        }
      });
      if (Object.keys(fieldsToApply).length > 0) {
        updateDraft(fieldsToApply);
        setAISuggestedFields(newAISuggestedFields);
      }
    }
  });

  // Detect similar coverages for duplicate warning (kept for future use)
  useMemo((): CoverageSimilarityMatch[] => {
    if (!draft.name || !existingCoverages) return [];
    const draftNameLower = draft.name.toLowerCase();
    return existingCoverages
      .filter(c => c.id !== existingCoverage?.id)
      .map(c => {
        const nameLower = c.name?.toLowerCase() || '';
        // Simple similarity check
        const similarity = nameLower.includes(draftNameLower) || draftNameLower.includes(nameLower)
          ? 85
          : nameLower.split(' ').some(word => draftNameLower.includes(word))
            ? 60
            : 0;
        return { coverageId: c.id!, name: c.name || '', similarity };
      })
      .filter(m => m.similarity > 50)
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, 3);
  }, [draft.name, existingCoverages, existingCoverage?.id]);

  // Track which steps have been auto-drafted
  const autoDraftedStepsRef = useRef<Set<string>>(new Set());

  // Reset when modal opens
  useEffect(() => {
    if (isOpen) {
      setCurrentStep(0);
      setAISuggestedFields(new Set());
      autoDraftedStepsRef.current.clear();
    }
  }, [isOpen]);

  // Auto-draft fields when entering details step
  useEffect(() => {
    const stepId = WIZARD_STEPS[currentStep]?.id;
    if (
      stepId === 'details' &&
      !autoDraftedStepsRef.current.has(stepId) &&
      draft.name // Only auto-draft if we have a coverage name
    ) {
      autoDraftedStepsRef.current.add(stepId);
      generateFieldsForStep(stepId, draft);
    }
  }, [currentStep, draft.name, generateFieldsForStep, draft]);

  // Generate AI activity message based on current state
  const aiActivityMessage = useMemo(() => {
    if (isAutoDrafting) {
      return 'Generating coverage details...';
    }
    return 'Ready to assist';
  }, [isAutoDrafting]);

  // Calculate step field counts for progress indicator
  const stepsWithFieldCounts = useMemo((): WizardStep[] => {
    const fieldMap: Record<string, { fields: (keyof Coverage)[]; }> = {
      basics: { fields: ['name', 'coverageCode'] },
      triggers: { fields: ['coverageTrigger', 'waitingPeriod'] },
      valuation: { fields: ['valuationMethod', 'coinsurancePercentage'] },
      underwriting: { fields: ['requiresUnderwriterApproval', 'eligibilityCriteria', 'prohibitedClasses'] },
      review: { fields: [] },
    };

    return WIZARD_STEPS.map(step => {
      const config = fieldMap[step.id];
      if (!config) return step;
      const filledCount = config.fields.filter(f =>
        draft[f] !== undefined && draft[f] !== null && draft[f] !== ''
      ).length;
      return {
        ...step,
        fieldCount: config.fields.length,
        filledFieldCount: filledCount,
      };
    });
  }, [draft]);

  const handleNext = useCallback(() => {
    if (currentStep < WIZARD_STEPS.length - 1) {
      prevStepRef.current = currentStep;
      setStepDirection('right');
      setCurrentStep(prev => prev + 1);
    }
  }, [currentStep]);

  const handlePrevious = useCallback(() => {
    if (currentStep > 0) {
      prevStepRef.current = currentStep;
      setStepDirection('left');
      setCurrentStep(prev => prev - 1);
    }
  }, [currentStep]);

  const handlePublish = useCallback(async () => {
    setIsPublishing(true);
    try {
      const published = await publishDraft();
      if (published) {
        await onSave(published);
        // Show celebration before closing
        setShowCelebration(true);
      }
    } catch (err) {
      console.error('Publish error:', err);
      setIsPublishing(false);
    }
  }, [publishDraft, onSave]);

  const handleCelebrationComplete = useCallback(() => {
    setShowCelebration(false);
    setIsPublishing(false);
    onClose();
  }, [onClose]);

  // Handle AI suggestion acceptance for a field
  const handleAcceptAISuggestion = useCallback((fieldName: string) => {
    // Just remove from suggested set - the value is already there
    setAISuggestedFields(prev => {
      const next = new Set(prev);
      next.delete(fieldName);
      return next;
    });
  }, []);

  // Handle AI suggestion rejection for a field
  const handleRejectAISuggestion = useCallback((fieldName: string) => {
    // Clear the field value and remove from suggested set
    updateDraft({ [fieldName]: null } as Partial<Coverage>);
    setAISuggestedFields(prev => {
      const next = new Set(prev);
      next.delete(fieldName);
      return next;
    });
  }, [updateDraft]);

  if (!isOpen) return null;

  const canPublish = validation?.readyToPublish ?? false;

  // Auto-save status
  const autoSaveStatus = useMemo((): 'idle' | 'saving' | 'saved' | 'error' => {
    if (isSaving) return 'saving';
    if (!isDirty && draft.name) return 'saved';
    return 'idle';
  }, [isSaving, isDirty, draft.name]);

  return (
    <>
      <ModalOverlay onClick={onClose} />
      <ModalContainer
        role="dialog"
        aria-modal="true"
        aria-label="Coverage Copilot Wizard"
        tabIndex={-1}
        onKeyDown={(e) => {
          // Escape - Close wizard
          if (e.key === 'Escape') onClose();
          // Cmd/Ctrl + Arrow Right - Next step
          if (e.key === 'ArrowRight' && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            handleNext();
          }
          // Cmd/Ctrl + Arrow Left - Previous step
          if (e.key === 'ArrowLeft' && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            handlePrevious();
          }
          // Cmd/Ctrl + S - Save draft
          if (e.key === 's' && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            saveDraft();
          }
          // Cmd/Ctrl + Enter - Publish (on review step)
          if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && currentStep === WIZARD_STEPS.length - 1 && canPublish) {
            e.preventDefault();
            handlePublish();
          }
          // Cmd/Ctrl + ? - Toggle mobile AI panel
          if (e.key === '?' && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            setShowMobileAIPanel(prev => !prev);
          }
          // Number keys 1-5 - Jump to step
          if (['1', '2', '3', '4', '5'].includes(e.key) && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            const stepIndex = parseInt(e.key) - 1;
            if (stepIndex < WIZARD_STEPS.length) {
              setCurrentStep(stepIndex);
            }
          }
        }}
      >
        {/* Premium Header with Breadcrumb & AI Status */}
        <Header>
          <HeaderLeft>
            <IconButton onClick={onClose} title="Back to coverages" aria-label="Back to coverages">
              <ArrowLeftIcon />
            </IconButton>
            <HeaderTitle>
              <Breadcrumb aria-label="Wizard navigation">
                <BreadcrumbLink onClick={onClose}>Coverages</BreadcrumbLink>
                <ChevronRightSmall />
                <BreadcrumbCurrent>
                  {existingCoverage?.id ? 'Edit' : 'New Coverage'}
                </BreadcrumbCurrent>
                <ChevronRightSmall />
                <BreadcrumbCurrent>{WIZARD_STEPS[currentStep]?.label}</BreadcrumbCurrent>
              </Breadcrumb>
              <h1>
                {existingCoverage?.id ? 'Edit Coverage' : 'Coverage Copilot'}
              </h1>
            </HeaderTitle>
          </HeaderLeft>

          {/* Auto-save indicator */}
          <HeaderProgress>
            <ProgressLabel>
              <span>{draft.name || 'New Coverage'}</span>
            </ProgressLabel>
            <AutoSaveIndicator $status={autoSaveStatus} aria-live="polite">
              {autoSaveStatus === 'saving' && (
                <>
                  <CloudArrowUpIcon />
                  <span>Saving...</span>
                </>
              )}
              {autoSaveStatus === 'saved' && (
                <>
                  <CheckCircleSolid />
                  <span>Saved</span>
                </>
              )}
            </AutoSaveIndicator>
          </HeaderProgress>

          <IconButton onClick={onClose} title="Close wizard (Esc)" aria-label="Close wizard">
            <XMarkIcon />
          </IconButton>
        </Header>

        {/* Progress with AI Activity */}
        <WizardProgress
          steps={stepsWithFieldCounts}
          currentStepIndex={currentStep}
          onStepClick={setCurrentStep}
          completenessScore={completenessScore}
          isAIActive={isAutoDrafting}
          aiActivityMessage={aiActivityMessage}
        />

        {/* Main content area */}
        <MainContent>
          {/* Form pane */}
          <FormPane>
            <FormContent>
              <StepContainer key={currentStep} $direction={stepDirection}>
                {currentStep === 0 && (
                  <BasicInfoStep
                    draft={draft}
                    updateDraft={updateDraft}
                    existingCoverageNames={existingCoverages?.map(c => c.name || '').filter(Boolean) || []}
                    productLineOfBusiness={product?.lineOfBusiness || 'property'}
                  />
                )}
                {currentStep === 1 && (
                  <TriggersStepWithAI
                    draft={draft}
                    updateDraft={updateDraft}
                    aiSuggestedFields={aiSuggestedFields}
                    onAcceptField={handleAcceptAISuggestion}
                    onRejectField={handleRejectAISuggestion}
                    isAIUpdating={isAutoDrafting}
                    productName={product?.name}
                    productLineOfBusiness={product?.lineOfBusiness}
                  />
                )}
                {currentStep === 2 && (
                  <ValuationStepWithAI
                    draft={draft}
                    updateDraft={updateDraft}
                    aiSuggestedFields={aiSuggestedFields}
                    onAcceptField={handleAcceptAISuggestion}
                    onRejectField={handleRejectAISuggestion}
                    isAIUpdating={isAutoDrafting}
                    productName={product?.name}
                    productLineOfBusiness={product?.lineOfBusiness}
                  />
                )}
                {currentStep === 3 && (
                  <UnderwritingStepWithAI
                    draft={draft}
                    updateDraft={updateDraft}
                    aiSuggestedFields={aiSuggestedFields}
                    onAcceptField={handleAcceptAISuggestion}
                    onRejectField={handleRejectAISuggestion}
                    isAIUpdating={isAutoDrafting}
                    productName={product?.name}
                    productLineOfBusiness={product?.lineOfBusiness}
                  />
                )}
                {currentStep === 4 && (
                  <EnhancedReviewStep
                    draft={draft}
                    validation={validation}
                    aiSuggestedFields={aiSuggestedFields}
                  />
                )}
              </StepContainer>
            </FormContent>
          </FormPane>
        </MainContent>

        {/* Footer */}
        <Footer>
          <WizardFooter
            currentStep={currentStep}
            totalSteps={WIZARD_STEPS.length}
            onPrevious={handlePrevious}
            onNext={handleNext}
            onSaveDraft={saveDraft}
            onPublish={handlePublish}
            canPublish={canPublish}
            isSaving={isSaving}
            isPublishing={isPublishing}
            isDirty={isDirty}
            missingRequiredCount={missingRequiredFields.length}
          />
        </Footer>
      </ModalContainer>

      {/* Floating AI Help Button (visible on review step - desktop) */}
      {currentStep === 4 && (
        <FloatingAIButton
          onClick={() => setCurrentStep(0)}
          aria-label="Get AI assistance"
          title="Get AI assistance (âŒ˜?)"
        >
          <SparklesIcon />
          <span>AI Help</span>
          <ShortcutHint>
            Press <kbd>âŒ˜</kbd><kbd>?</kbd> for help
          </ShortcutHint>
        </FloatingAIButton>
      )}

      {/* Mobile Floating AI Button - visible on all steps */}
      <MobileFloatingAIButton
        onClick={() => setShowMobileAIPanel(true)}
        aria-label="View AI insights"
      >
        <SparklesIcon />
      </MobileFloatingAIButton>

      {/* Mobile AI Panel - Slide-up panel */}
      <MobileAIPanelOverlay $isOpen={showMobileAIPanel} onClick={() => setShowMobileAIPanel(false)} />
      <MobileAIPanel $isOpen={showMobileAIPanel}>
        <MobileAIPanelHeader>
          <h3><SparklesIcon /> AI Insights</h3>
          <MobileAIPanelClose onClick={() => setShowMobileAIPanel(false)}>
            <XMarkIcon />
          </MobileAIPanelClose>
        </MobileAIPanelHeader>
        <MobileAIPanelContent>
          <AIInsightsCard
            stepId={WIZARD_STEPS[currentStep]?.id || 'basics'}
            draft={draft}
          />
        </MobileAIPanelContent>
      </MobileAIPanel>

      {/* Celebration overlay */}
      <CompletionCelebration
        isVisible={showCelebration}
        onComplete={handleCelebrationComplete}
      />
    </>
  );
};

// Step Components with AI Assistance
interface StepProps {
  draft: Partial<Coverage>;
  updateDraft: (p: Partial<Coverage>) => void;
  aiSuggestedFields?: Set<string>;
  onAcceptField?: (field: string) => void;
  onRejectField?: (field: string) => void;
  isAIUpdating?: boolean;
  existingCoverageNames?: string[];
  productLineOfBusiness?: string;
}

const BasicInfoStep: React.FC<StepProps> = ({
  draft,
  updateDraft,
  existingCoverageNames = [],
  productLineOfBusiness = 'property'
}) => (
  <div>
    <StepTitle>What coverage are you creating?</StepTitle>
    <SmartCoverageNameInput
      value={draft.name || ''}
      coverageCode={draft.coverageCode || ''}
      onChange={(name) => updateDraft({ name })}
      onCodeChange={(code) => updateDraft({ coverageCode: code })}
      existingCoverageNames={existingCoverageNames}
      productLineOfBusiness={productLineOfBusiness}
      isAutoCodeEnabled={true}
    />
  </div>
);

// AI Trigger Suggestions based on coverage name
const TRIGGER_SUGGESTIONS: Record<string, { trigger: CoverageTrigger; confidence: number; reason: string }> = {
  // Property coverages - typically occurrence-based
  'building': { trigger: 'occurrence', confidence: 95, reason: 'Property coverages use occurrence triggers for physical damage claims' },
  'contents': { trigger: 'occurrence', confidence: 95, reason: 'Contents coverage triggers when loss occurs during policy period' },
  'business personal property': { trigger: 'occurrence', confidence: 95, reason: 'BPP coverage applies to losses during policy period' },
  'equipment breakdown': { trigger: 'occurrence', confidence: 90, reason: 'Equipment failures trigger at time of breakdown occurrence' },
  'flood': { trigger: 'occurrence', confidence: 95, reason: 'Flood damage is occurrence-based by nature' },
  'earthquake': { trigger: 'occurrence', confidence: 95, reason: 'Seismic events trigger coverage at occurrence' },
  'fire': { trigger: 'occurrence', confidence: 95, reason: 'Fire damage coverage activates when fire occurs' },
  'theft': { trigger: 'occurrence', confidence: 90, reason: 'Theft coverage responds to incidents when they occur' },
  'vandalism': { trigger: 'occurrence', confidence: 90, reason: 'Vandalism triggers at time of damage' },
  'glass': { trigger: 'occurrence', confidence: 90, reason: 'Glass breakage triggers on occurrence' },
  'wind': { trigger: 'occurrence', confidence: 95, reason: 'Wind/hail damage is occurrence-based' },
  'hail': { trigger: 'occurrence', confidence: 95, reason: 'Hail damage triggers when storm occurs' },
  'water damage': { trigger: 'occurrence', confidence: 90, reason: 'Water damage coverage responds at occurrence' },
  'sprinkler': { trigger: 'occurrence', confidence: 90, reason: 'Sprinkler leakage triggers at time of occurrence' },

  // Liability coverages - can be occurrence or claims-made
  'general liability': { trigger: 'occurrence', confidence: 85, reason: 'GL commonly uses occurrence for bodily injury/property damage' },
  'products liability': { trigger: 'occurrence', confidence: 80, reason: 'Products claims often discovered after policy period' },
  'premises liability': { trigger: 'occurrence', confidence: 85, reason: 'Premises incidents trigger when they occur' },
  'personal injury': { trigger: 'occurrence', confidence: 80, reason: 'Personal injury coverage typically occurrence-based' },
  'advertising injury': { trigger: 'claimsMade', confidence: 75, reason: 'Advertising claims may have delayed discovery' },

  // Professional/specialty - typically claims-made
  'professional liability': { trigger: 'claimsMade', confidence: 90, reason: 'Professional liability uses claims-made for long-tail exposure' },
  'errors and omissions': { trigger: 'claimsMade', confidence: 92, reason: 'E&O coverage is traditionally claims-made' },
  'directors and officers': { trigger: 'claimsMade', confidence: 95, reason: 'D&O liability requires claims-made trigger' },
  'employment practices': { trigger: 'claimsMade', confidence: 93, reason: 'EPL uses claims-made for employment-related claims' },
  'cyber': { trigger: 'claimsMade', confidence: 88, reason: 'Cyber liability typically uses claims-made triggers' },
  'media liability': { trigger: 'claimsMade', confidence: 85, reason: 'Media claims often have delayed discovery' },
  'fiduciary': { trigger: 'claimsMade', confidence: 90, reason: 'Fiduciary liability uses claims-made structure' },
  'malpractice': { trigger: 'claimsMade', confidence: 95, reason: 'Medical malpractice requires claims-made for long-tail risks' },

  // Business income - occurrence-based
  'business income': { trigger: 'occurrence', confidence: 90, reason: 'BI coverage links to underlying occurrence event' },
  'extra expense': { trigger: 'occurrence', confidence: 90, reason: 'Extra expense follows occurrence of covered loss' },
  'business interruption': { trigger: 'occurrence', confidence: 90, reason: 'BI triggers when covered event occurs' },

  // Workers comp / employers liability
  'workers compensation': { trigger: 'injuryInFact', confidence: 85, reason: 'WC uses injury-in-fact for workplace injuries' },
  'employers liability': { trigger: 'occurrence', confidence: 80, reason: 'EL commonly uses occurrence trigger' },

  // Environmental - manifestation or continuous
  'pollution': { trigger: 'manifestation', confidence: 85, reason: 'Environmental claims often use manifestation trigger' },
  'environmental': { trigger: 'manifestation', confidence: 85, reason: 'Environmental damage may manifest over time' },
  'contamination': { trigger: 'continuous', confidence: 80, reason: 'Contamination exposure may be continuous' },
  'asbestos': { trigger: 'continuous', confidence: 90, reason: 'Asbestos claims trigger across multiple policy periods' },

  // Auto
  'auto liability': { trigger: 'occurrence', confidence: 95, reason: 'Auto liability triggers at time of accident' },
  'collision': { trigger: 'occurrence', confidence: 95, reason: 'Collision coverage activates when accident occurs' },
  'comprehensive': { trigger: 'occurrence', confidence: 95, reason: 'Comp coverage triggers on covered loss occurrence' },
  'uninsured motorist': { trigger: 'occurrence', confidence: 90, reason: 'UM triggers at time of accident' },
};

// Function to get AI suggestion based on coverage name
const getAITriggerSuggestion = (coverageName: string, lineOfBusiness?: string): { trigger: CoverageTrigger; confidence: number; reason: string } | null => {
  if (!coverageName) return null;

  const lowerName = coverageName.toLowerCase();

  // Check for exact or partial matches
  for (const [key, value] of Object.entries(TRIGGER_SUGGESTIONS)) {
    if (lowerName.includes(key) || key.includes(lowerName)) {
      return value;
    }
  }

  // Default suggestions based on line of business
  if (lineOfBusiness) {
    const lobLower = lineOfBusiness.toLowerCase();
    if (lobLower.includes('property') || lobLower.includes('commercial property')) {
      return { trigger: 'occurrence', confidence: 75, reason: 'Property lines typically use occurrence triggers' };
    }
    if (lobLower.includes('liability') || lobLower.includes('professional')) {
      return { trigger: 'claimsMade', confidence: 70, reason: 'Liability lines often use claims-made triggers' };
    }
    if (lobLower.includes('auto') || lobLower.includes('vehicle')) {
      return { trigger: 'occurrence', confidence: 80, reason: 'Auto coverages typically use occurrence triggers' };
    }
  }

  // Generic fallback - most P&C coverages are occurrence-based
  return { trigger: 'occurrence', confidence: 60, reason: 'Most P&C coverages use occurrence-based triggers by default' };
};

// AI Valuation Suggestions based on coverage name - now with multiple options
interface ValuationSuggestion {
  valuationMethods: ValuationMethod[];
  coinsuranceOptions: number[];
  coinsuranceMin: number;
  coinsuranceMax: number;
  confidence: number;
  valuationReason: string;
  coinsuranceReason: string;
}

const VALUATION_SUGGESTIONS: Record<string, ValuationSuggestion> = {
  // Property coverages - typically RC/ACV options with 80-100% coinsurance range
  'building': { valuationMethods: ['RC', 'ACV'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 95, valuationReason: 'Buildings typically offer RC (preferred) or ACV options', coinsuranceReason: 'Standard property coinsurance range' },
  'contents': { valuationMethods: ['ACV', 'RC'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 85, valuationReason: 'Contents often ACV, some policies offer RC upgrade', coinsuranceReason: '80-100% coinsurance options typical' },
  'business personal property': { valuationMethods: ['RC', 'ACV'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 88, valuationReason: 'BPP commonly offers both RC and ACV', coinsuranceReason: 'Commercial property standard range' },
  'equipment breakdown': { valuationMethods: ['RC', 'ACV', 'functionalRC'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 90, valuationReason: 'Equipment may use RC, ACV, or functional replacement', coinsuranceReason: 'Standard coinsurance for equipment' },
  'flood': { valuationMethods: ['RC', 'ACV'], coinsuranceOptions: [80], coinsuranceMin: 80, coinsuranceMax: 80, confidence: 85, valuationReason: 'Flood typically RC or ACV based on building age', coinsuranceReason: 'NFIP uses 80% coinsurance' },
  'earthquake': { valuationMethods: ['RC', 'ACV'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 85, valuationReason: 'Earthquake coverage offers RC or ACV options', coinsuranceReason: 'Standard coinsurance for catastrophic perils' },
  'fire': { valuationMethods: ['RC', 'ACV'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 92, valuationReason: 'Fire damage typically RC with ACV option', coinsuranceReason: 'Industry standard 80-100% range' },

  // Specialty property - agreed value eliminates coinsurance
  'fine arts': { valuationMethods: ['agreedValue'], coinsuranceOptions: [100], coinsuranceMin: 100, coinsuranceMax: 100, confidence: 95, valuationReason: 'Fine arts require agreed value - unique items', coinsuranceReason: 'Agreed value waives coinsurance' },
  'jewelry': { valuationMethods: ['agreedValue', 'statedAmount'], coinsuranceOptions: [100], coinsuranceMin: 100, coinsuranceMax: 100, confidence: 92, valuationReason: 'Jewelry needs agreed or stated value', coinsuranceReason: 'Full value for scheduled items' },
  'antiques': { valuationMethods: ['agreedValue'], coinsuranceOptions: [100], coinsuranceMin: 100, coinsuranceMax: 100, confidence: 90, valuationReason: 'Antiques require agreed value', coinsuranceReason: 'No coinsurance for agreed value' },
  'collectibles': { valuationMethods: ['agreedValue', 'marketValue'], coinsuranceOptions: [100], coinsuranceMin: 100, coinsuranceMax: 100, confidence: 88, valuationReason: 'Collectibles use agreed or market value', coinsuranceReason: 'Full coinsurance for valuables' },

  // Auto coverages - ACV standard, no coinsurance
  'collision': { valuationMethods: ['ACV'], coinsuranceOptions: [100], coinsuranceMin: 100, coinsuranceMax: 100, confidence: 95, valuationReason: 'Auto collision uses ACV exclusively', coinsuranceReason: 'No coinsurance in auto physical damage' },
  'comprehensive': { valuationMethods: ['ACV'], coinsuranceOptions: [100], coinsuranceMin: 100, coinsuranceMax: 100, confidence: 95, valuationReason: 'Comp coverage uses ACV standard', coinsuranceReason: 'No coinsurance for auto comp' },

  // Older/historic buildings
  'functional replacement': { valuationMethods: ['functionalRC', 'ACV'], coinsuranceOptions: [80, 90], coinsuranceMin: 80, coinsuranceMax: 90, confidence: 88, valuationReason: 'Older buildings may use functional RC', coinsuranceReason: 'Reduced coinsurance for functional' },

  // Business income - based on actual income
  'business income': { valuationMethods: ['ACV'], coinsuranceOptions: [50, 60, 70, 80], coinsuranceMin: 50, coinsuranceMax: 80, confidence: 75, valuationReason: 'BI based on actual lost income', coinsuranceReason: 'BI coinsurance often 50-80%' },
  'business interruption': { valuationMethods: ['ACV'], coinsuranceOptions: [50, 60, 70, 80], coinsuranceMin: 50, coinsuranceMax: 80, confidence: 75, valuationReason: 'BI valued at actual amounts', coinsuranceReason: 'Standard BI coinsurance options' },
  'extra expense': { valuationMethods: ['ACV'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 70, valuationReason: 'Extra expenses at actual cost', coinsuranceReason: 'Standard coinsurance applies' },
};

// Function to get AI valuation suggestion based on coverage name
const getAIValuationSuggestion = (coverageName: string, lineOfBusiness?: string): ValuationSuggestion | null => {
  if (!coverageName) return null;

  const lowerName = coverageName.toLowerCase();

  // Check for exact or partial matches
  for (const [key, suggestion] of Object.entries(VALUATION_SUGGESTIONS)) {
    if (lowerName.includes(key) || key.includes(lowerName)) {
      return suggestion;
    }
  }

  // Default suggestions based on line of business
  if (lineOfBusiness) {
    const lobLower = lineOfBusiness.toLowerCase();
    if (lobLower.includes('property') || lobLower.includes('commercial property')) {
      return { valuationMethods: ['RC', 'ACV'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 75, valuationReason: 'Property coverages typically offer RC and ACV', coinsuranceReason: '80-100% coinsurance is industry standard' };
    }
    if (lobLower.includes('auto') || lobLower.includes('vehicle')) {
      return { valuationMethods: ['ACV'], coinsuranceOptions: [100], coinsuranceMin: 100, coinsuranceMax: 100, confidence: 80, valuationReason: 'Auto coverages use actual cash value', coinsuranceReason: 'No coinsurance requirement for auto' };
    }
    if (lobLower.includes('inland marine') || lobLower.includes('marine')) {
      return { valuationMethods: ['agreedValue', 'ACV'], coinsuranceOptions: [100], coinsuranceMin: 100, coinsuranceMax: 100, confidence: 75, valuationReason: 'Marine/inland marine uses agreed value or ACV', coinsuranceReason: 'Agreed value waives coinsurance' };
    }
  }

  // Generic fallback for property
  return { valuationMethods: ['RC', 'ACV'], coinsuranceOptions: [80, 90, 100], coinsuranceMin: 80, coinsuranceMax: 100, confidence: 60, valuationReason: 'Most property coverages offer RC and ACV options', coinsuranceReason: '80-100% coinsurance is most common' };
};

// Extended StepProps for trigger step
interface TriggersStepProps extends StepProps {
  productName?: string;
  productLineOfBusiness?: string;
}

// New Triggers Step with AI Sidebar
const TriggersStepWithAI: React.FC<TriggersStepProps> = ({
  draft,
  updateDraft,
  aiSuggestedFields = new Set(),
  onAcceptField,
  onRejectField,
  isAIUpdating,
  productLineOfBusiness
}) => {
  // Get AI suggestion based on coverage name
  const aiSuggestion = React.useMemo(() => {
    return getAITriggerSuggestion(draft.name || '', productLineOfBusiness);
  }, [draft.name, productLineOfBusiness]);

  // Auto-apply high confidence suggestion if no trigger is set
  React.useEffect(() => {
    if (aiSuggestion && aiSuggestion.confidence >= 90 && !draft.coverageTrigger) {
      updateDraft({ coverageTrigger: aiSuggestion.trigger });
    }
  }, [aiSuggestion, draft.coverageTrigger, updateDraft]);

  const handleApplySuggestion = () => {
    if (aiSuggestion) {
      updateDraft({ coverageTrigger: aiSuggestion.trigger });
    }
  };

  return (
    <TriggerStepContainer>
      <TriggerMainContent>
        <StepTitle>Coverage Trigger</StepTitle>
        <TriggerDescription>
          Select how this coverage is triggered. This determines when claims are covered based on when the incident occurs vs. when the claim is made.
        </TriggerDescription>

        <AIAssistedField
          label="Coverage Trigger"
          fieldName="coverageTrigger"
          isAISuggested={aiSuggestedFields.has('coverageTrigger') || (!!aiSuggestion && draft.coverageTrigger === aiSuggestion.trigger)}
          isAIUpdating={isAIUpdating && !draft.coverageTrigger}
          aiExplanation={aiSuggestion?.reason}
          aiConfidence={aiSuggestion?.confidence}
          onAcceptSuggestion={() => onAcceptField?.('coverageTrigger')}
          onRejectSuggestion={() => onRejectField?.('coverageTrigger')}
          hideActions={!!aiSuggestion && draft.coverageTrigger === aiSuggestion.trigger}
        >
          <CoverageTriggerSelector
            value={draft.coverageTrigger}
            onChange={(trigger) => updateDraft({ coverageTrigger: trigger })}
          />
        </AIAssistedField>

        {/* Waiting Period Option */}
        <WaitingPeriodSection>
          <WaitingPeriodCheckbox>
            <input
              type="checkbox"
              id="hasWaitingPeriod"
              checked={!!draft.waitingPeriod}
              onChange={(e) => {
                if (e.target.checked) {
                  updateDraft({ waitingPeriod: 0, waitingPeriodUnit: 'days' });
                } else {
                  updateDraft({ waitingPeriod: undefined, waitingPeriodUnit: undefined });
                }
              }}
            />
            <label htmlFor="hasWaitingPeriod">Waiting Period</label>
          </WaitingPeriodCheckbox>

          {draft.waitingPeriod !== undefined && (
            <WaitingPeriodInputRow>
              <WaitingPeriodNumberInput
                type="number"
                min="0"
                value={draft.waitingPeriod || ''}
                onChange={(e) => updateDraft({ waitingPeriod: parseInt(e.target.value) || 0 })}
                placeholder="Enter value"
              />
              <WaitingPeriodUnitSelect
                value={draft.waitingPeriodUnit || 'days'}
                onChange={(e) => updateDraft({ waitingPeriodUnit: e.target.value as 'days' | 'months' })}
              >
                <option value="days">Days</option>
                <option value="dollars">$ Amount</option>
              </WaitingPeriodUnitSelect>
            </WaitingPeriodInputRow>
          )}
        </WaitingPeriodSection>
      </TriggerMainContent>

      {/* AI Suggestions Sidebar */}
      <TriggerAISidebar>
        <TriggerAISidebarHeader>
          <SparklesIcon />
          <span>AI Recommendations</span>
        </TriggerAISidebarHeader>

        {aiSuggestion ? (
          <AISuggestionCard $confidence={aiSuggestion.confidence}>
            <AISuggestionBadge $confidence={aiSuggestion.confidence}>
              {aiSuggestion.confidence >= 90 ? 'High Confidence' :
               aiSuggestion.confidence >= 75 ? 'Recommended' : 'Suggested'}
            </AISuggestionBadge>
            <AISuggestionTrigger>
              {aiSuggestion.trigger.replace(/([A-Z])/g, ' $1').trim()}
            </AISuggestionTrigger>
            <AISuggestionReason>{aiSuggestion.reason}</AISuggestionReason>
            <AISuggestionConfidence>
              <ConfidenceBar $confidence={aiSuggestion.confidence} />
              <span>{aiSuggestion.confidence}% confidence</span>
            </AISuggestionConfidence>
            {draft.coverageTrigger !== aiSuggestion.trigger && (
              <ApplySuggestionButton onClick={handleApplySuggestion}>
                <SparklesIcon />
                Apply Suggestion
              </ApplySuggestionButton>
            )}
            {draft.coverageTrigger === aiSuggestion.trigger && (
              <AppliedIndicator>
                <CheckCircleSolid />
                Applied
              </AppliedIndicator>
            )}
          </AISuggestionCard>
        ) : (
          <NoSuggestionCard>
            <QuestionMarkCircleIcon />
            <span>Enter a coverage name to get AI trigger recommendations</span>
          </NoSuggestionCard>
        )}

        <AISidebarTip>
          <InformationCircleIcon />
          <span>
            Based on <strong>{draft.name || 'your coverage'}</strong> and P&C industry standards.
          </span>
        </AISidebarTip>
      </TriggerAISidebar>
    </TriggerStepContainer>
  );
};

// Styled components for TriggersStepWithAI
const TriggerStepContainer = styled.div`
  display: grid;
  grid-template-columns: 1fr 320px;
  gap: 32px;
  min-height: 400px;

  @media (max-width: 900px) {
    grid-template-columns: 1fr;
  }
`;

const TriggerMainContent = styled.div`
  flex: 1;
`;

const WaitingPeriodSection = styled.div`
  margin-top: 24px;
  padding: 16px;
  background: ${({ theme }) => theme.colours.surface};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 12px;
`;

const WaitingPeriodCheckbox = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;

  input[type="checkbox"] {
    width: 18px;
    height: 18px;
    accent-color: #6366f1;
    cursor: pointer;
  }

  label {
    font-size: 14px;
    font-weight: 500;
    color: ${({ theme }) => theme.colours.text};
    cursor: pointer;
  }
`;

const WaitingPeriodInputRow = styled.div`
  display: flex;
  gap: 12px;
  margin-top: 16px;
`;

const WaitingPeriodNumberInput = styled.input`
  flex: 1;
  padding: 10px 14px;
  font-size: 14px;
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 8px;
  background: ${({ theme }) => theme.colours.background};
  color: ${({ theme }) => theme.colours.text};

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: ${({ theme }) => theme.colours.textMuted};
  }
`;

const WaitingPeriodUnitSelect = styled.select`
  padding: 10px 14px;
  font-size: 14px;
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 8px;
  background: ${({ theme }) => theme.colours.background};
  color: ${({ theme }) => theme.colours.text};
  cursor: pointer;
  min-width: 120px;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }
`;

const TriggerDescription = styled.p`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textMuted};
  margin-bottom: 24px;
  line-height: 1.6;
`;

const TriggerAISidebar = styled.div`
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.05), rgba(99, 102, 241, 0.08));
  border: 1px solid rgba(139, 92, 246, 0.2);
  border-radius: 16px;
  padding: 20px;
  height: fit-content;
  animation: ${slideInRight} 0.4s ease-out;
`;

const TriggerAISidebarHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid rgba(139, 92, 246, 0.15);

  svg {
    width: 20px;
    height: 20px;
    color: #8b5cf6;
  }

  span {
    font-size: 14px;
    font-weight: 600;
    color: #7c3aed;
  }
`;

const AISuggestionCard = styled.div<{ $confidence: number }>`
  background: ${({ theme }) => theme.colours.surface};
  border: 1.5px solid ${({ $confidence }) =>
    $confidence >= 90 ? '#10b981' :
    $confidence >= 75 ? '#8b5cf6' : '#f59e0b'};
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 16px;
`;

const AISuggestionBadge = styled.span<{ $confidence: number }>`
  display: inline-block;
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 4px 8px;
  border-radius: 6px;
  background: ${({ $confidence }) =>
    $confidence >= 90 ? 'linear-gradient(135deg, #10b981, #059669)' :
    $confidence >= 75 ? 'linear-gradient(135deg, #8b5cf6, #7c3aed)' :
    'linear-gradient(135deg, #f59e0b, #d97706)'};
  color: white;
  margin-bottom: 12px;
`;

const AISuggestionTrigger = styled.div`
  font-size: 18px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  text-transform: capitalize;
  margin-bottom: 8px;
`;

const AISuggestionReason = styled.p`
  font-size: 13px;
  color: ${({ theme }) => theme.colours.textMuted};
  line-height: 1.5;
  margin-bottom: 12px;
`;

const AISuggestionConfidence = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 14px;

  span {
    font-size: 12px;
    color: ${({ theme }) => theme.colours.textMuted};
  }
`;

const ConfidenceBar = styled.div<{ $confidence: number }>`
  flex: 1;
  height: 6px;
  background: ${({ theme }) => theme.colours.border};
  border-radius: 3px;
  overflow: hidden;
  position: relative;

  &::after {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    width: ${({ $confidence }) => $confidence}%;
    background: ${({ $confidence }) =>
      $confidence >= 90 ? '#10b981' :
      $confidence >= 75 ? '#8b5cf6' : '#f59e0b'};
    border-radius: 3px;
    transition: width 0.3s ease;
  }
`;

const ApplySuggestionButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  padding: 10px 16px;
  font-size: 13px;
  font-weight: 600;
  background: linear-gradient(135deg, #8b5cf6, #7c3aed);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;

  svg {
    width: 16px;
    height: 16px;
  }

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
  }
`;

const AppliedIndicator = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 10px 16px;
  font-size: 13px;
  font-weight: 600;
  color: #10b981;
  background: rgba(16, 185, 129, 0.1);
  border-radius: 8px;

  svg {
    width: 16px;
    height: 16px;
  }
`;

const ValuationSuggestionLabel = styled.div`
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: ${({ theme }) => theme.colours.textMuted};
  margin-bottom: 4px;
`;

const ApplyAllButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  padding: 12px 16px;
  font-size: 14px;
  font-weight: 600;
  color: white;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-top: 8px;

  svg {
    width: 16px;
    height: 16px;
  }

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
  }
`;

const NoSuggestionCard = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 32px 16px;
  text-align: center;
  background: ${({ theme }) => theme.colours.surface};
  border: 1px dashed ${({ theme }) => theme.colours.border};
  border-radius: 12px;
  margin-bottom: 16px;

  svg {
    width: 32px;
    height: 32px;
    color: ${({ theme }) => theme.colours.textMuted};
    opacity: 0.5;
  }

  span {
    font-size: 13px;
    color: ${({ theme }) => theme.colours.textMuted};
    line-height: 1.5;
  }
`;

const AISidebarTip = styled.div`
  display: flex;
  gap: 8px;
  padding: 12px;
  background: rgba(99, 102, 241, 0.08);
  border-radius: 8px;

  svg {
    width: 16px;
    height: 16px;
    color: #6366f1;
    flex-shrink: 0;
    margin-top: 2px;
  }

  span {
    font-size: 12px;
    color: ${({ theme }) => theme.colours.textMuted};
    line-height: 1.5;

    strong {
      color: #6366f1;
    }
  }
`;

// Extended StepProps for valuation step
interface ValuationStepProps extends StepProps {
  productName?: string;
  productLineOfBusiness?: string;
}

// Valuation Step with AI Sidebar
const ValuationStepWithAI: React.FC<ValuationStepProps> = ({
  draft,
  updateDraft,
  aiSuggestedFields = new Set(),
  onAcceptField,
  onRejectField,
  isAIUpdating,
  productLineOfBusiness
}) => {
  // Get AI suggestion based on coverage name
  const aiSuggestion = React.useMemo(() => {
    return getAIValuationSuggestion(draft.name || '', productLineOfBusiness);
  }, [draft.name, productLineOfBusiness]);

  // Auto-apply high confidence suggestion if no values are set
  React.useEffect(() => {
    if (aiSuggestion && aiSuggestion.confidence >= 90) {
      const updates: Partial<Coverage> = {};
      if (!draft.valuationMethods || draft.valuationMethods.length === 0) {
        updates.valuationMethods = aiSuggestion.valuationMethods;
      }
      if (!draft.coinsuranceOptions || draft.coinsuranceOptions.length === 0) {
        updates.coinsuranceOptions = aiSuggestion.coinsuranceOptions;
        updates.coinsuranceMinimum = aiSuggestion.coinsuranceMin;
        updates.coinsuranceMaximum = aiSuggestion.coinsuranceMax;
      }
      if (Object.keys(updates).length > 0) {
        updateDraft(updates);
      }
    }
  }, [aiSuggestion, draft.valuationMethods, draft.coinsuranceOptions, updateDraft]);

  const handleApplyValuationSuggestion = () => {
    if (aiSuggestion) {
      updateDraft({ valuationMethods: aiSuggestion.valuationMethods });
    }
  };

  const handleApplyCoinsuranceSuggestion = () => {
    if (aiSuggestion) {
      updateDraft({
        coinsuranceOptions: aiSuggestion.coinsuranceOptions,
        coinsuranceMinimum: aiSuggestion.coinsuranceMin,
        coinsuranceMaximum: aiSuggestion.coinsuranceMax
      });
    }
  };

  const handleApplyAllSuggestions = () => {
    if (aiSuggestion) {
      updateDraft({
        valuationMethods: aiSuggestion.valuationMethods,
        coinsuranceOptions: aiSuggestion.coinsuranceOptions,
        coinsuranceMinimum: aiSuggestion.coinsuranceMin,
        coinsuranceMaximum: aiSuggestion.coinsuranceMax
      });
    }
  };

  // Check if suggestions are applied (compare arrays)
  const valuationApplied = aiSuggestion &&
    draft.valuationMethods?.length === aiSuggestion.valuationMethods.length &&
    aiSuggestion.valuationMethods.every(v => draft.valuationMethods?.includes(v));
  const coinsuranceApplied = aiSuggestion &&
    draft.coinsuranceOptions?.length === aiSuggestion.coinsuranceOptions.length &&
    aiSuggestion.coinsuranceOptions.every(c => draft.coinsuranceOptions?.includes(c));
  const allApplied = valuationApplied && coinsuranceApplied;

  return (
    <TriggerStepContainer>
      <TriggerMainContent>
        <StepTitle>Valuation & Coinsurance</StepTitle>
        <TriggerDescription>
          Select the available valuation methods and coinsurance options for this coverage.
        </TriggerDescription>

        <AIAssistedField
          label="Available Valuation Methods"
          fieldName="valuationMethods"
          isAISuggested={aiSuggestedFields.has('valuationMethods') || valuationApplied}
          isAIUpdating={isAIUpdating && (!draft.valuationMethods || draft.valuationMethods.length === 0)}
          aiExplanation={aiSuggestion?.valuationReason}
          aiConfidence={aiSuggestion?.confidence}
          onAcceptSuggestion={() => onAcceptField?.('valuationMethods')}
          onRejectSuggestion={() => onRejectField?.('valuationMethods')}
          hideActions={valuationApplied}
        >
          <ValuationMethodSelector
            values={draft.valuationMethods}
            onChange={(methods) => updateDraft({ valuationMethods: methods })}
          />
        </AIAssistedField>

        <AIAssistedField
          label="Available Coinsurance Options"
          fieldName="coinsuranceOptions"
          isAISuggested={aiSuggestedFields.has('coinsuranceOptions') || coinsuranceApplied}
          isAIUpdating={isAIUpdating && (!draft.coinsuranceOptions || draft.coinsuranceOptions.length === 0)}
          aiExplanation={aiSuggestion?.coinsuranceReason}
          aiConfidence={aiSuggestion?.confidence}
          onAcceptSuggestion={() => onAcceptField?.('coinsuranceOptions')}
          onRejectSuggestion={() => onRejectField?.('coinsuranceOptions')}
          hideActions={coinsuranceApplied}
        >
          <CoinsuranceInput
            selectedOptions={draft.coinsuranceOptions}
            minimum={draft.coinsuranceMinimum}
            maximum={draft.coinsuranceMaximum}
            onChange={(options, min, max) => updateDraft({
              coinsuranceOptions: options,
              coinsuranceMinimum: min,
              coinsuranceMaximum: max
            })}
          />
        </AIAssistedField>
      </TriggerMainContent>

      {/* AI Suggestions Sidebar */}
      <TriggerAISidebar>
        <TriggerAISidebarHeader>
          <SparklesIcon />
          <span>AI Recommendations</span>
        </TriggerAISidebarHeader>

        {aiSuggestion ? (
          <>
            {/* Valuation Methods Suggestion */}
            <AISuggestionCard $confidence={aiSuggestion.confidence}>
              <AISuggestionBadge $confidence={aiSuggestion.confidence}>
                {aiSuggestion.confidence >= 90 ? 'High Confidence' :
                 aiSuggestion.confidence >= 75 ? 'Recommended' : 'Suggested'}
              </AISuggestionBadge>
              <ValuationSuggestionLabel>Valuation Methods</ValuationSuggestionLabel>
              <AISuggestionTrigger>
                {aiSuggestion.valuationMethods.map(v =>
                  v === 'RC' ? 'RC' :
                  v === 'ACV' ? 'ACV' :
                  v === 'agreedValue' ? 'Agreed' :
                  v === 'statedAmount' ? 'Stated' :
                  v === 'functionalRC' ? 'Functional' : v
                ).join(', ')}
              </AISuggestionTrigger>
              <AISuggestionReason>{aiSuggestion.valuationReason}</AISuggestionReason>
              {!valuationApplied && (
                <ApplySuggestionButton onClick={handleApplyValuationSuggestion}>
                  <SparklesIcon />
                  Apply
                </ApplySuggestionButton>
              )}
              {valuationApplied && (
                <AppliedIndicator>
                  <CheckCircleSolid />
                  Applied
                </AppliedIndicator>
              )}
            </AISuggestionCard>

            {/* Coinsurance Suggestion */}
            <AISuggestionCard $confidence={aiSuggestion.confidence}>
              <ValuationSuggestionLabel>Coinsurance Options</ValuationSuggestionLabel>
              <AISuggestionTrigger>
                {aiSuggestion.coinsuranceOptions.map(c => `${c}%`).join(', ')}
              </AISuggestionTrigger>
              <AISuggestionReason>
                Range: {aiSuggestion.coinsuranceMin}% - {aiSuggestion.coinsuranceMax}%. {aiSuggestion.coinsuranceReason}
              </AISuggestionReason>
              {!coinsuranceApplied && (
                <ApplySuggestionButton onClick={handleApplyCoinsuranceSuggestion}>
                  <SparklesIcon />
                  Apply
                </ApplySuggestionButton>
              )}
              {coinsuranceApplied && (
                <AppliedIndicator>
                  <CheckCircleSolid />
                  Applied
                </AppliedIndicator>
              )}
            </AISuggestionCard>

            {/* Apply All Button */}
            {!allApplied && (
              <ApplyAllButton onClick={handleApplyAllSuggestions}>
                <SparklesIcon />
                Apply All Suggestions
              </ApplyAllButton>
            )}

            <AISuggestionConfidence>
              <ConfidenceBar $confidence={aiSuggestion.confidence} />
              <span>{aiSuggestion.confidence}% confidence</span>
            </AISuggestionConfidence>
          </>
        ) : (
          <NoSuggestionCard>
            <QuestionMarkCircleIcon />
            <span>Enter a coverage name to get AI valuation recommendations</span>
          </NoSuggestionCard>
        )}

        <AISidebarTip>
          <InformationCircleIcon />
          <span>
            Based on <strong>{draft.name || 'your coverage'}</strong> and P&C industry standards.
          </span>
        </AISidebarTip>
      </TriggerAISidebar>
    </TriggerStepContainer>
  );
};

// ============================================================
// UNDERWRITING STEP WITH AI
// ============================================================
interface UnderwritingStepProps extends StepProps {
  productName?: string;
  productLineOfBusiness?: string;
}

const UnderwritingStepWithAI: React.FC<UnderwritingStepProps> = ({
  draft,
  updateDraft,
  aiSuggestedFields = new Set(),
  onAcceptField,
  onRejectField,
  isAIUpdating,
  productLineOfBusiness
}) => {
  // Local state for adding new criteria
  const [newCriteria, setNewCriteria] = React.useState('');
  const [newProhibitedClass, setNewProhibitedClass] = React.useState('');

  // Handle adding eligibility criteria
  const handleAddCriteria = () => {
    if (newCriteria.trim()) {
      const currentCriteria = draft.eligibilityCriteria || [];
      updateDraft({ eligibilityCriteria: [...currentCriteria, newCriteria.trim()] });
      setNewCriteria('');
    }
  };

  // Handle removing eligibility criteria
  const handleRemoveCriteria = (index: number) => {
    const currentCriteria = draft.eligibilityCriteria || [];
    updateDraft({ eligibilityCriteria: currentCriteria.filter((_, i) => i !== index) });
  };

  // Handle adding prohibited class
  const handleAddProhibitedClass = () => {
    if (newProhibitedClass.trim()) {
      const currentClasses = draft.prohibitedClasses || [];
      updateDraft({ prohibitedClasses: [...currentClasses, newProhibitedClass.trim()] });
      setNewProhibitedClass('');
    }
  };

  // Handle removing prohibited class
  const handleRemoveProhibitedClass = (index: number) => {
    const currentClasses = draft.prohibitedClasses || [];
    updateDraft({ prohibitedClasses: currentClasses.filter((_, i) => i !== index) });
  };

  // Determine approval type (support both old and new field)
  const approvalType = draft.underwriterApprovalType ||
    (draft.requiresUnderwriterApproval === true ? 'yes' :
     draft.requiresUnderwriterApproval === false ? 'no' : undefined);

  const isConditional = approvalType === 'conditional';
  const showConditionalFields = isConditional || approvalType === 'yes';

  return (
    <TriggerStepContainer>
      <TriggerMainContent>
        <StepTitle>Underwriting Requirements</StepTitle>
        <TriggerDescription>
          Define underwriter approval requirements and eligibility criteria.
        </TriggerDescription>

        {/* Underwriter Approval Toggle - 3 Options */}
        <AIAssistedField
          label="Requires Underwriter Approval"
          fieldName="underwriterApprovalType"
          isAISuggested={aiSuggestedFields.has('underwriterApprovalType')}
          isAIUpdating={isAIUpdating && !approvalType}
          onAcceptSuggestion={() => onAcceptField?.('underwriterApprovalType')}
          onRejectSuggestion={() => onRejectField?.('underwriterApprovalType')}
        >
          <UnderwritingToggleRow>
            <UnderwritingToggle
              $active={approvalType === 'yes'}
              onClick={() => updateDraft({ underwriterApprovalType: 'yes', requiresUnderwriterApproval: true })}
            >
              Yes
            </UnderwritingToggle>
            <UnderwritingToggle
              $active={approvalType === 'no'}
              onClick={() => updateDraft({ underwriterApprovalType: 'no', requiresUnderwriterApproval: false })}
            >
              No
            </UnderwritingToggle>
            <UnderwritingToggle
              $active={approvalType === 'conditional'}
              $conditional
              onClick={() => updateDraft({ underwriterApprovalType: 'conditional', requiresUnderwriterApproval: true })}
            >
              Conditional
            </UnderwritingToggle>
          </UnderwritingToggleRow>
          <ApprovalTypeDescription>
            {approvalType === 'yes' && 'All submissions require underwriter review before binding.'}
            {approvalType === 'no' && 'Auto-approved - no underwriter review required.'}
            {approvalType === 'conditional' && 'Requires underwriter approval when eligibility criteria are not met.'}
            {!approvalType && 'Select an approval type to continue.'}
          </ApprovalTypeDescription>
        </AIAssistedField>

        {/* Conditional Fields - Only shown when Conditional is selected */}
        {isConditional && (
          <ConditionalFieldsContainer>
            <ConditionalFieldsHeader>
              <ExclamationTriangleIcon />
              <span>Define the conditions for automatic approval</span>
            </ConditionalFieldsHeader>

            {/* Eligibility Criteria - Required for Conditional */}
            <AIAssistedField
              label="Eligibility Criteria (Required)"
              fieldName="eligibilityCriteria"
              isAISuggested={aiSuggestedFields.has('eligibilityCriteria')}
              isAIUpdating={isAIUpdating && (!draft.eligibilityCriteria || draft.eligibilityCriteria.length === 0)}
              onAcceptSuggestion={() => onAcceptField?.('eligibilityCriteria')}
              onRejectSuggestion={() => onRejectField?.('eligibilityCriteria')}
            >
              <ConditionalFieldDescription>
                When all criteria are met, the submission will be auto-approved. Otherwise, it will require underwriter review.
              </ConditionalFieldDescription>
              <UnderwritingListContainer>
                {(draft.eligibilityCriteria || []).map((criteria, index) => (
                  <UnderwritingListItem key={index}>
                    <span>{criteria}</span>
                    <UnderwritingRemoveButton onClick={() => handleRemoveCriteria(index)}>
                      <XMarkIcon />
                    </UnderwritingRemoveButton>
                  </UnderwritingListItem>
                ))}
                <UnderwritingAddRow>
                  <UnderwritingInput
                    type="text"
                    placeholder="Add eligibility requirement..."
                    value={newCriteria}
                    onChange={(e) => setNewCriteria(e.target.value)}
                    onKeyDown={(e) => e.key === 'Enter' && handleAddCriteria()}
                  />
                  <UnderwritingAddButton onClick={handleAddCriteria} disabled={!newCriteria.trim()}>
                    Add
                  </UnderwritingAddButton>
                </UnderwritingAddRow>
              </UnderwritingListContainer>
              {isConditional && (!draft.eligibilityCriteria || draft.eligibilityCriteria.length === 0) && (
                <RequiredFieldWarning>
                  <ExclamationCircleIcon />
                  At least one eligibility criterion is required for conditional approval.
                </RequiredFieldWarning>
              )}
            </AIAssistedField>

            {/* Prohibited Classes */}
            <AIAssistedField
              label="Prohibited Business Classes"
              fieldName="prohibitedClasses"
              isAISuggested={aiSuggestedFields.has('prohibitedClasses')}
              isAIUpdating={isAIUpdating && (!draft.prohibitedClasses || draft.prohibitedClasses.length === 0)}
              onAcceptSuggestion={() => onAcceptField?.('prohibitedClasses')}
              onRejectSuggestion={() => onRejectField?.('prohibitedClasses')}
            >
              <ConditionalFieldDescription>
                Business classes that are never eligible for this coverage.
              </ConditionalFieldDescription>
              <UnderwritingListContainer>
                {(draft.prohibitedClasses || []).map((cls, index) => (
                  <UnderwritingListItem key={index} $prohibited>
                    <span>{cls}</span>
                    <UnderwritingRemoveButton onClick={() => handleRemoveProhibitedClass(index)}>
                      <XMarkIcon />
                    </UnderwritingRemoveButton>
                  </UnderwritingListItem>
                ))}
                <UnderwritingAddRow>
                  <UnderwritingInput
                    type="text"
                    placeholder="Add prohibited class..."
                    value={newProhibitedClass}
                    onChange={(e) => setNewProhibitedClass(e.target.value)}
                    onKeyDown={(e) => e.key === 'Enter' && handleAddProhibitedClass()}
                  />
                  <UnderwritingAddButton onClick={handleAddProhibitedClass} disabled={!newProhibitedClass.trim()}>
                    Add
                  </UnderwritingAddButton>
                </UnderwritingAddRow>
              </UnderwritingListContainer>
            </AIAssistedField>
          </ConditionalFieldsContainer>
        )}
      </TriggerMainContent>

      {/* AI Suggestions Sidebar */}
      <TriggerAISidebar>
        <TriggerAISidebarHeader>
          <SparklesIcon />
          <span>AI Recommendations</span>
        </TriggerAISidebarHeader>

        <AISuggestionCard $confidence={85}>
          <AISuggestionBadge $confidence={85}>Recommended</AISuggestionBadge>
          <ValuationSuggestionLabel>Underwriting Guidance</ValuationSuggestionLabel>
          <AISuggestionReason>
            {productLineOfBusiness?.toLowerCase().includes('property')
              ? 'Property coverages typically require underwriter approval for high-value risks and specific hazard classes.'
              : productLineOfBusiness?.toLowerCase().includes('liability')
              ? 'Liability coverages often need approval for high-risk industries and coverage limits above thresholds.'
              : 'Consider requiring underwriter approval for unusual risks or coverage amounts above your appetite.'}
          </AISuggestionReason>
        </AISuggestionCard>

        <NoSuggestionCard>
          <InformationCircleIcon />
          <span>
            Common eligibility criteria include minimum years in business, loss history requirements, and safety certifications.
          </span>
        </NoSuggestionCard>

        <AISidebarTip>
          <InformationCircleIcon />
          <span>
            Define clear underwriting rules to ensure consistent risk selection.
          </span>
        </AISidebarTip>
      </TriggerAISidebar>
    </TriggerStepContainer>
  );
};

// Underwriting Step Styled Components
const UnderwritingToggleRow = styled.div`
  display: flex;
  gap: 12px;

  @media (max-width: 600px) {
    flex-direction: column;
    gap: 8px;
  }
`;

const UnderwritingToggle = styled.button<{ $active: boolean; $conditional?: boolean }>`
  flex: 1;
  padding: 14px 16px;
  border: 2px solid ${({ $active, $conditional }) =>
    $active
      ? ($conditional ? '#f59e0b' : '#6366f1')
      : '#e5e7eb'};
  border-radius: 10px;
  background: ${({ $active, $conditional }) =>
    $active
      ? ($conditional ? 'rgba(245, 158, 11, 0.08)' : 'rgba(99, 102, 241, 0.08)')
      : 'transparent'};
  color: ${({ $active, $conditional, theme }) =>
    $active
      ? ($conditional ? '#d97706' : '#6366f1')
      : theme.colours?.text || '#374151'};
  font-size: 14px;
  font-weight: ${({ $active }) => $active ? 600 : 500};
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    border-color: ${({ $active, $conditional }) =>
      $active
        ? ($conditional ? '#f59e0b' : '#6366f1')
        : '#d1d5db'};
    background: ${({ $active, $conditional }) =>
      $active
        ? ($conditional ? 'rgba(245, 158, 11, 0.12)' : 'rgba(99, 102, 241, 0.12)')
        : 'rgba(0, 0, 0, 0.02)'};
  }
`;

const ApprovalTypeDescription = styled.p`
  margin: 12px 0 0 0;
  padding: 10px 14px;
  background: ${({ theme }) => theme.colours?.surface || '#f9fafb'};
  border-radius: 8px;
  font-size: 13px;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
  line-height: 1.5;
`;

const ConditionalFieldsContainer = styled.div`
  margin-top: 24px;
  padding: 20px;
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.04), rgba(217, 119, 6, 0.02));
  border: 1px solid rgba(245, 158, 11, 0.2);
  border-radius: 12px;
  animation: ${slideUp} 0.3s ease;
`;

const ConditionalFieldsHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
  padding-bottom: 14px;
  border-bottom: 1px solid rgba(245, 158, 11, 0.15);

  svg {
    width: 20px;
    height: 20px;
    color: #d97706;
  }

  span {
    font-size: 14px;
    font-weight: 600;
    color: #b45309;
  }
`;

const ConditionalFieldDescription = styled.p`
  margin: 0 0 12px 0;
  font-size: 13px;
  color: ${({ theme }) => theme.colours?.textMuted || '#6b7280'};
  line-height: 1.5;
`;

const RequiredFieldWarning = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 12px;
  padding: 10px 14px;
  background: rgba(239, 68, 68, 0.08);
  border: 1px solid rgba(239, 68, 68, 0.2);
  border-radius: 8px;
  font-size: 13px;
  color: #dc2626;

  svg {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
  }
`;

const UnderwritingListContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const UnderwritingListItem = styled.div<{ $prohibited?: boolean }>`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 14px;
  background: ${({ $prohibited }) => $prohibited ? 'rgba(239, 68, 68, 0.08)' : 'rgba(99, 102, 241, 0.06)'};
  border: 1px solid ${({ $prohibited }) => $prohibited ? 'rgba(239, 68, 68, 0.2)' : 'rgba(99, 102, 241, 0.15)'};
  border-radius: 8px;
  font-size: 14px;
  color: ${({ theme }) => theme.colours?.text || '#374151'};

  span {
    flex: 1;
  }
`;

const UnderwritingRemoveButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  padding: 0;
  border: none;
  border-radius: 4px;
  background: transparent;
  color: #9ca3af;
  cursor: pointer;
  transition: all 0.15s ease;

  &:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const UnderwritingAddRow = styled.div`
  display: flex;
  gap: 8px;
  margin-top: 4px;
`;

const UnderwritingInput = styled.input`
  flex: 1;
  padding: 10px 12px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  font-size: 14px;
  color: ${({ theme }) => theme.colours?.text || '#374151'};
  background: ${({ theme }) => theme.colours?.surface || '#fff'};
  transition: all 0.15s ease;

  &:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  &::placeholder {
    color: #9ca3af;
  }
`;

const UnderwritingAddButton = styled.button`
  padding: 10px 16px;
  border: none;
  border-radius: 8px;
  background: #6366f1;
  color: white;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;

  &:hover:not(:disabled) {
    background: #4f46e5;
  }

  &:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    cursor: not-allowed;
  }
`;

// Simple Review Step - minimal and clean
interface SimpleReviewStepProps {
  draft: Partial<Coverage>;
  validation: any;
}

const SimpleReviewStep: React.FC<SimpleReviewStepProps> = ({ draft, validation }) => (
  <ReviewContainer>
    <StepTitle>Review & Save</StepTitle>

    <SimpleReviewCard>
      <SimpleReviewHeader>
        <ShieldCheckIcon />
        <div>
          <SimpleReviewName>{draft.name || 'Unnamed Coverage'}</SimpleReviewName>
          <SimpleReviewCode>{draft.coverageCode || 'No code assigned'}</SimpleReviewCode>
        </div>
      </SimpleReviewHeader>

      <SimpleReviewDetails>
        <SimpleReviewRow>
          <span>Trigger Type</span>
          <span>{draft.coverageTrigger ? draft.coverageTrigger.replace(/([A-Z])/g, ' $1').trim() : 'Not set'}</span>
        </SimpleReviewRow>
        <SimpleReviewRow>
          <span>Valuation Methods</span>
          <span>{draft.valuationMethods?.length ? draft.valuationMethods.join(', ') : (draft.valuationMethod || 'Not set')}</span>
        </SimpleReviewRow>
        <SimpleReviewRow>
          <span>Coinsurance Options</span>
          <span>{draft.coinsuranceOptions?.length ? draft.coinsuranceOptions.map(c => `${c}%`).join(', ') : 'Not set'}</span>
        </SimpleReviewRow>
        <SimpleReviewRow>
          <span>Underwriter Approval</span>
          <span>{draft.requiresUnderwriterApproval === true ? 'Required' : draft.requiresUnderwriterApproval === false ? 'Auto-Approve' : 'Not set'}</span>
        </SimpleReviewRow>
        {draft.eligibilityCriteria && draft.eligibilityCriteria.length > 0 && (
          <SimpleReviewRow>
            <span>Eligibility Criteria</span>
            <span>{draft.eligibilityCriteria.length} requirement(s)</span>
          </SimpleReviewRow>
        )}
        {draft.prohibitedClasses && draft.prohibitedClasses.length > 0 && (
          <SimpleReviewRow>
            <span>Prohibited Classes</span>
            <span>{draft.prohibitedClasses.length} class(es)</span>
          </SimpleReviewRow>
        )}
      </SimpleReviewDetails>
    </SimpleReviewCard>

    {validation && !validation.readyToPublish && (
      <WarningBox>
        <WarningHeader>
          <ExclamationTriangleIcon />
          <span>Missing Required Fields</span>
        </WarningHeader>
        <WarningList>
          {validation.missingRequiredFields.map((field: string) => (
            <li key={field}>{field}</li>
          ))}
        </WarningList>
      </WarningBox>
    )}
  </ReviewContainer>
);

// Enhanced Review Step with AI contribution summary
interface EnhancedReviewStepProps {
  draft: Partial<Coverage>;
  validation: any;
  aiSuggestedFields?: Set<string>;
}

const EnhancedReviewStep: React.FC<EnhancedReviewStepProps> = ({ draft, validation, aiSuggestedFields }) => {
  const aiFieldCount = aiSuggestedFields?.size || 0;
  const totalFields = 6; // Approximate number of key fields
  const aiContributionPercent = Math.round((aiFieldCount / totalFields) * 100);

  return (
    <ReviewContainer>
      <StepTitle>Review & Publish</StepTitle>
      <StepSubtitle>
        Your coverage is ready. Review the details below before publishing.
      </StepSubtitle>

      {/* AI Contribution Summary */}
      {aiFieldCount > 0 && (
        <AIContributionCard>
          <AIContributionHeader>
            <SparklesIcon />
            <span>AI Assisted This Coverage</span>
          </AIContributionHeader>
          <AIContributionBody>
            <AIContributionStat>
              <span>{aiFieldCount}</span>
              <span>fields suggested</span>
            </AIContributionStat>
            <AIContributionBar>
              <AIContributionFill $percent={aiContributionPercent} />
            </AIContributionBar>
            <AIContributionNote>
              AI helped configure {aiContributionPercent}% of this coverage based on P&C best practices
            </AIContributionNote>
          </AIContributionBody>
        </AIContributionCard>
      )}

      <SimpleReviewCard>
        <SimpleReviewHeader>
          <ShieldCheckIcon />
          <div>
            <SimpleReviewName>{draft.name || 'Unnamed Coverage'}</SimpleReviewName>
            <SimpleReviewCode>{draft.coverageCode || 'No code assigned'}</SimpleReviewCode>
          </div>
        </SimpleReviewHeader>

        <SimpleReviewDetails>
          <SimpleReviewRow $aiSuggested={aiSuggestedFields?.has('coverageTrigger')}>
            <span>Trigger Type</span>
            <span>
              {draft.coverageTrigger ? draft.coverageTrigger.replace(/([A-Z])/g, ' $1').trim() : 'Not set'}
              {aiSuggestedFields?.has('coverageTrigger') && <AIBadge>AI</AIBadge>}
            </span>
          </SimpleReviewRow>
          <SimpleReviewRow $aiSuggested={aiSuggestedFields?.has('valuationMethod')}>
            <span>Valuation Methods</span>
            <span>
              {draft.valuationMethods?.length ? draft.valuationMethods.join(', ') : (draft.valuationMethod || 'Not set')}
              {aiSuggestedFields?.has('valuationMethod') && <AIBadge>AI</AIBadge>}
            </span>
          </SimpleReviewRow>
          <SimpleReviewRow $aiSuggested={aiSuggestedFields?.has('coinsuranceOptions')}>
            <span>Coinsurance Options</span>
            <span>
              {draft.coinsuranceOptions?.length ? draft.coinsuranceOptions.map(c => `${c}%`).join(', ') : 'Not set'}
              {aiSuggestedFields?.has('coinsuranceOptions') && <AIBadge>AI</AIBadge>}
            </span>
          </SimpleReviewRow>
          <SimpleReviewRow>
            <span>Underwriter Approval</span>
            <span>{draft.requiresUnderwriterApproval === true ? 'Required' : draft.requiresUnderwriterApproval === false ? 'Auto-Approve' : 'Not set'}</span>
          </SimpleReviewRow>
          {draft.eligibilityCriteria && draft.eligibilityCriteria.length > 0 && (
            <SimpleReviewRow>
              <span>Eligibility Criteria</span>
              <span>{draft.eligibilityCriteria.length} requirement(s)</span>
            </SimpleReviewRow>
          )}
          {draft.prohibitedClasses && draft.prohibitedClasses.length > 0 && (
            <SimpleReviewRow>
              <span>Prohibited Classes</span>
              <span>{draft.prohibitedClasses.length} class(es)</span>
            </SimpleReviewRow>
          )}
        </SimpleReviewDetails>
      </SimpleReviewCard>

      {validation && !validation.readyToPublish && (
        <WarningBox>
          <WarningHeader>
            <ExclamationTriangleIcon />
            <span>Missing Required Fields</span>
          </WarningHeader>
          <WarningList>
            {validation.missingRequiredFields.map((field: string) => (
              <li key={field}>{field}</li>
            ))}
          </WarningList>
        </WarningBox>
      )}
    </ReviewContainer>
  );
};

// AI Contribution styled components
const AIContributionCard = styled.div`
  background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.05));
  border: 1px solid rgba(99, 102, 241, 0.2);
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 20px;
  animation: ${slideUp} 0.4s ${EASING.spring};
`;

const AIContributionHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;

  svg {
    width: 18px;
    height: 18px;
    color: ${({ theme }) => theme.colours.primary};
  }

  span {
    font-size: 14px;
    font-weight: 600;
    color: ${({ theme }) => theme.colours.primary};
  }
`;

const AIContributionBody = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const AIContributionStat = styled.div`
  display: flex;
  align-items: baseline;
  gap: 6px;

  span:first-child {
    font-size: 24px;
    font-weight: 700;
    color: ${({ theme }) => theme.colours.primary};
  }

  span:last-child {
    font-size: 13px;
    color: ${({ theme }) => theme.colours.textMuted};
  }
`;

const AIContributionBar = styled.div`
  height: 6px;
  background: ${({ theme }) => theme.colours.border};
  border-radius: 3px;
  overflow: hidden;
`;

const AIContributionFill = styled.div<{ $percent: number }>`
  height: 100%;
  width: ${({ $percent }) => $percent}%;
  background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 3px;
  transition: width 0.5s ${EASING.spring};
`;

const AIContributionNote = styled.div`
  font-size: 12px;
  color: ${({ theme }) => theme.colours.textMuted};
`;

const AIBadge = styled.span`
  display: inline-flex;
  align-items: center;
  padding: 2px 6px;
  margin-left: 8px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  color: white;
  font-size: 10px;
  font-weight: 600;
  border-radius: 4px;
  text-transform: uppercase;
`;

// Simple styled components for the new steps
const FieldGroup = styled.div`
  margin-bottom: 24px;
`;

const ValuationStepDescription = styled.p`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textMuted};
  margin-bottom: 24px;
  line-height: 1.6;
`;

const FieldLabel = styled.label`
  display: block;
  font-size: 14px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
  margin-bottom: 10px;
`;

const SimpleReviewCard = styled.div`
  background: ${({ theme }) => theme.colours.surface};
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 12px;
  padding: 24px;
  margin-bottom: 20px;
`;

const SimpleReviewHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
  padding-bottom: 20px;
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
  margin-bottom: 20px;

  svg {
    width: 48px;
    height: 48px;
    color: #10b981;
  }
`;

const SimpleReviewName = styled.div`
  font-size: 20px;
  font-weight: 600;
  color: ${({ theme }) => theme.colours.text};
`;

const SimpleReviewCode = styled.div`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.textMuted};
  font-family: monospace;
`;

const SimpleReviewDetails = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const SimpleReviewRow = styled.div<{ $aiSuggested?: boolean }>`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 0;
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
  ${({ $aiSuggested }) => $aiSuggested && css`
    background: linear-gradient(90deg, rgba(99, 102, 241, 0.05) 0%, transparent 100%);
    margin: 0 -12px;
    padding: 12px;
    border-radius: 6px;
  `}

  &:last-child {
    border-bottom: none;
  }

  span:first-child {
    font-size: 14px;
    color: ${({ theme }) => theme.colours.textMuted};
  }

  span:last-child {
    font-size: 14px;
    font-weight: 500;
    color: ${({ theme }) => theme.colours.text};
    text-transform: capitalize;
    display: flex;
    align-items: center;
  }
`;

// Keep old components for backwards compatibility but they're no longer used
const TriggersStep: React.FC<StepProps> = ({
  draft,
  updateDraft,
  aiSuggestedFields = new Set(),
  onAcceptField,
  onRejectField,
  isAIUpdating
}) => (
  <div>
    {isAIUpdating && (
      <AIFillingBanner>
        <SparklesIcon />
        <AIFillingText>
          <strong>AI is analyzing your coverage</strong>
          <span>Filling in trigger settings based on "{draft.name}"...</span>
        </AIFillingText>
        <AIFillingDots><span /><span /><span /></AIFillingDots>
      </AIFillingBanner>
    )}
    <StepTitle>Coverage Triggers & Periods</StepTitle>
    <AIAssistedField
      label="Coverage Trigger"
      fieldName="coverageTrigger"
      isAISuggested={aiSuggestedFields.has('coverageTrigger')}
      isAIUpdating={isAIUpdating && !draft.coverageTrigger}
      aiExplanation="Based on similar coverages in your product portfolio"
      onAcceptSuggestion={() => onAcceptField?.('coverageTrigger')}
      onRejectSuggestion={() => onRejectField?.('coverageTrigger')}
    >
      <CoverageTriggerSelector
        value={draft.coverageTrigger}
        onChange={(trigger) => updateDraft({ coverageTrigger: trigger })}
      />
    </AIAssistedField>
    <AIAssistedField
      label="Waiting Period"
      fieldName="waitingPeriod"
      isAISuggested={aiSuggestedFields.has('waitingPeriod')}
      isAIUpdating={isAIUpdating && !draft.waitingPeriod}
      aiExplanation="Standard waiting period for this coverage type"
      onAcceptSuggestion={() => onAcceptField?.('waitingPeriod')}
      onRejectSuggestion={() => onRejectField?.('waitingPeriod')}
    >
      <WaitingPeriodInput
        value={draft.waitingPeriod}
        unit={draft.waitingPeriodUnit}
        onChange={(value, unit) => updateDraft({ waitingPeriod: value, waitingPeriodUnit: unit })}
      />
    </AIAssistedField>
    {/* Show claims-made specific fields only when relevant */}
    {(draft.coverageTrigger === 'claimsMade' || draft.coverageTrigger === 'hybrid') && (
      <>
        <AIAssistedField
          label="Allow Retroactive Date"
          fieldName="allowRetroactiveDate"
          isAISuggested={aiSuggestedFields.has('allowRetroactiveDate')}
          isAIUpdating={isAIUpdating && draft.allowRetroactiveDate === undefined}
          aiExplanation="Claims-made policies typically allow retroactive dates"
          onAcceptSuggestion={() => onAcceptField?.('allowRetroactiveDate')}
          onRejectSuggestion={() => onRejectField?.('allowRetroactiveDate')}
        >
          <ToggleSwitch
            checked={draft.allowRetroactiveDate ?? false}
            onChange={(checked) => updateDraft({ allowRetroactiveDate: checked })}
            label="Allow retroactive date for prior acts"
          />
        </AIAssistedField>
        <AIAssistedField
          label="Extended Reporting Period (Months)"
          fieldName="extendedReportingPeriod"
          isAISuggested={aiSuggestedFields.has('extendedReportingPeriod')}
          isAIUpdating={isAIUpdating && draft.extendedReportingPeriod === undefined}
          aiExplanation="Standard ERP for claims-made policies"
          onAcceptSuggestion={() => onAcceptField?.('extendedReportingPeriod')}
          onRejectSuggestion={() => onRejectField?.('extendedReportingPeriod')}
        >
          <NumberInput
            value={draft.extendedReportingPeriod ?? 0}
            onChange={(value) => updateDraft({ extendedReportingPeriod: value })}
            min={0}
            max={60}
            suffix="months"
            placeholder="e.g., 12, 24, 36"
          />
        </AIAssistedField>
      </>
    )}
  </div>
);

interface ReviewStepProps {
  draft: Partial<Coverage>;
  validation: any;
  selectedFormIds?: string[];
  forms?: { id: string; formName?: string; formNumber?: string }[];
}

const ReviewStep: React.FC<ReviewStepProps> = ({ draft, validation, selectedFormIds = [], forms = [] }) => {
  const linkedForms = forms.filter(f => selectedFormIds.includes(f.id));

  // Calculate completeness for visual indicator
  const sections = [
    { name: 'Basics', complete: !!(draft.name && draft.coverageCode), icon: 'ðŸ“‹' },
    { name: 'Triggers', complete: !!draft.coverageTrigger, icon: 'âš¡' },
    { name: 'Valuation', complete: !!(draft.valuationMethod && draft.coinsurancePercentage), icon: 'ðŸ’°' },
    { name: 'Underwriting', complete: !!(draft.eligibilityCriteria || draft.riskFactors), icon: 'ðŸ“Š' },
    { name: 'Claims', complete: !!draft.claimsProcedure, icon: 'ðŸ“' },
    { name: 'Forms', complete: linkedForms.length > 0, icon: 'ðŸ“„' },
  ];
  const completedSections = sections.filter(s => s.complete).length;

  return (
    <ReviewContainer>
      {/* Coverage Header Card */}
      <ReviewHeaderCard>
        <ReviewHeaderIcon>
          <ShieldCheckIcon />
        </ReviewHeaderIcon>
        <ReviewHeaderContent>
          <ReviewCoverageName>{draft.name || 'Unnamed Coverage'}</ReviewCoverageName>
          <ReviewCoverageCode>{draft.coverageCode || 'No code'}</ReviewCoverageCode>
        </ReviewHeaderContent>
        <ReviewCompleteness>
          <CompletenessRing $percentage={(completedSections / sections.length) * 100}>
            <span>{completedSections}/{sections.length}</span>
          </CompletenessRing>
          <span>Sections Complete</span>
        </ReviewCompleteness>
      </ReviewHeaderCard>

      {/* Section Cards */}
      <ReviewSectionsGrid>
        {sections.map((section, idx) => (
          <ReviewSectionCard key={section.name} $complete={section.complete} $delay={idx}>
            <SectionIcon $complete={section.complete}>{section.icon}</SectionIcon>
            <SectionName>{section.name}</SectionName>
            <SectionStatus $complete={section.complete}>
              {section.complete ? <CheckCircleSolid /> : <ExclamationCircleIcon />}
            </SectionStatus>
          </ReviewSectionCard>
        ))}
      </ReviewSectionsGrid>

      {/* Details Card */}
      <ReviewCard>
        <ReviewCardHeader>
          <InformationCircleIcon />
          <span>Coverage Details</span>
        </ReviewCardHeader>
        <ReviewGrid>
          <ReviewItem><span>Trigger:</span> <span>{draft.coverageTrigger || '-'}</span></ReviewItem>
          <ReviewItem><span>Valuation:</span> <span>{draft.valuationMethod || '-'}</span></ReviewItem>
          <ReviewItem><span>Coinsurance:</span> <span>{draft.coinsurancePercentage ? `${draft.coinsurancePercentage}%` : '-'}</span></ReviewItem>
          <ReviewItem><span>Waiting Period:</span> <span>{draft.waitingPeriod || '-'}</span></ReviewItem>
        </ReviewGrid>

        {/* Linked Forms */}
        <FormsList>
          <FormsListHeader>
            <DocumentTextIcon />
            <span>Linked Forms ({linkedForms.length})</span>
          </FormsListHeader>
          {linkedForms.length > 0 ? (
            <FormsListContent>
              {linkedForms.map(f => (
                <FormBadge key={f.id}>
                  {f.formNumber || f.formName || 'Unnamed'}
                </FormBadge>
              ))}
            </FormsListContent>
          ) : (
            <NoFormsMessage>No forms linked to this coverage</NoFormsMessage>
          )}
        </FormsList>
      </ReviewCard>

      {/* Validation Warning */}
      {validation && !validation.readyToPublish && (
        <WarningBox>
          <WarningHeader>
            <ExclamationTriangleIcon />
            <span>Missing Required Fields</span>
          </WarningHeader>
          <WarningList>
            {validation.missingRequiredFields.map((field: string) => (
              <li key={field}>{field}</li>
            ))}
          </WarningList>
        </WarningBox>
      )}
    </ReviewContainer>
  );
};

export default CoverageCopilotWizard;

```

---

## src/components/wizard/FormsStep.tsx

**Path:** `src/components/wizard/FormsStep.tsx`

```tsx
/**
 * FormsStep - Wizard step for linking forms to coverage
 * ENHANCED: Better visual hierarchy, drag indicators, and premium styling
 */

import React, { useState, useMemo } from 'react';
import styled, { keyframes, css } from 'styled-components';
import {
  DocumentTextIcon,
  MagnifyingGlassIcon,
  CheckIcon,
  SparklesIcon,
  Bars3Icon,
  StarIcon
} from '@heroicons/react/24/outline';
import { CheckCircleIcon as CheckCircleSolid } from '@heroicons/react/24/solid';
import { FormTemplate } from '../../types';

interface FormsStepProps {
  forms: FormTemplate[];
  selectedFormIds: string[];
  onFormToggle: (formId: string) => void;
  onSelectAll: (formIds: string[]) => void;
  suggestedFormIds?: string[];
  isLoading?: boolean;
}

export const FormsStep: React.FC<FormsStepProps> = ({
  forms,
  selectedFormIds,
  onFormToggle,
  onSelectAll,
  suggestedFormIds = [],
  isLoading = false
}) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [filterType, setFilterType] = useState<'all' | 'selected' | 'suggested'>('all');

  const filteredForms = useMemo(() => {
    let result = forms;

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(f => 
        f.formName?.toLowerCase().includes(query) ||
        f.formNumber?.toLowerCase().includes(query) ||
        f.category?.toLowerCase().includes(query)
      );
    }

    // Apply type filter
    if (filterType === 'selected') {
      result = result.filter(f => selectedFormIds.includes(f.id));
    } else if (filterType === 'suggested') {
      result = result.filter(f => suggestedFormIds.includes(f.id));
    }

    return result;
  }, [forms, searchQuery, filterType, selectedFormIds, suggestedFormIds]);

  const suggestedForms = useMemo(() => 
    forms.filter(f => suggestedFormIds.includes(f.id)),
    [forms, suggestedFormIds]
  );

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white">Link Forms</h2>
        <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
          Select forms that apply to this coverage. The AI can suggest relevant forms based on coverage type.
        </p>
      </div>

      {/* AI Suggestions */}
      {suggestedForms.length > 0 && (
        <div
          className="bg-gradient-to-r from-blue-50 to-purple-50 dark:from-blue-900/20 dark:to-purple-900/20
                     rounded-xl p-4 border border-blue-200 dark:border-blue-800 animate-fade-in"
        >
          <div className="flex items-center gap-2 mb-3">
            <SparklesIcon className="h-4 w-4 text-blue-600" />
            <span className="text-sm font-medium text-blue-700 dark:text-blue-300">
              AI Suggested Forms ({suggestedForms.length})
            </span>
          </div>
          <div className="flex flex-wrap gap-2">
            {suggestedForms.map(form => (
              <button
                key={form.id}
                onClick={() => onFormToggle(form.id)}
                className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm transition-all ${
                  selectedFormIds.includes(form.id)
                    ? 'bg-blue-600 text-white'
                    : 'bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-blue-100'
                }`}
              >
                {selectedFormIds.includes(form.id) && <CheckIcon className="h-3.5 w-3.5" />}
                {form.formNumber || form.formName}
              </button>
            ))}
            <button
              onClick={() => onSelectAll(suggestedFormIds)}
              className="px-3 py-1.5 text-sm text-blue-600 hover:text-blue-700 font-medium"
            >
              Add all suggested
            </button>
          </div>
        </div>
      )}

      {/* Search and filters */}
      <div className="flex gap-3">
        <div className="flex-1 relative">
          <MagnifyingGlassIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search forms..."
            className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg
                       bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
          />
        </div>
        <div className="flex rounded-lg border border-gray-300 dark:border-gray-600 overflow-hidden">
          {(['all', 'selected', 'suggested'] as const).map(type => (
            <button
              key={type}
              onClick={() => setFilterType(type)}
              className={`px-3 py-2 text-sm capitalize ${
                filterType === type
                  ? 'bg-blue-600 text-white'
                  : 'bg-white dark:bg-gray-800 text-gray-600 dark:text-gray-300 hover:bg-gray-50'
              }`}
            >
              {type}
            </button>
          ))}
        </div>
      </div>

      {/* Forms list */}
      <div className="space-y-2 max-h-[400px] overflow-y-auto">
        {filteredForms.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            {searchQuery ? 'No forms match your search' : 'No forms available'}
          </div>
        ) : (
          filteredForms.map((form, index) => (
            <div
              key={form.id}
              className={`flex items-center gap-3 p-3 rounded-lg border cursor-pointer transition-all animate-fade-in ${
                selectedFormIds.includes(form.id)
                  ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20'
                  : 'border-gray-200 dark:border-gray-700 hover:border-gray-300'
              }`}
              style={{ animationDelay: `${index * 30}ms` }}
              onClick={() => onFormToggle(form.id)}
            >
              <div className={`w-5 h-5 rounded border-2 flex items-center justify-center ${
                selectedFormIds.includes(form.id)
                  ? 'border-blue-600 bg-blue-600'
                  : 'border-gray-300 dark:border-gray-600'
              }`}>
                {selectedFormIds.includes(form.id) && <CheckIcon className="h-3 w-3 text-white" />}
              </div>
              <DocumentTextIcon className="h-5 w-5 text-gray-400" />
              <div className="flex-1 min-w-0">
                <p className="font-medium text-gray-900 dark:text-white truncate">
                  {form.formName || 'Unnamed Form'}
                </p>
                <p className="text-sm text-gray-500 truncate">
                  {form.formNumber} â€¢ {form.category || 'Uncategorized'}
                </p>
              </div>
              {suggestedFormIds.includes(form.id) && (
                <span className="px-2 py-0.5 text-xs bg-purple-100 text-purple-700 rounded-full">
                  Suggested
                </span>
              )}
            </div>
          ))
        )}
      </div>

      {/* Selection summary */}
      <SelectionSummary>
        <SummaryIcon $hasSelection={selectedFormIds.length > 0}>
          {selectedFormIds.length > 0 ? <CheckCircleSolid /> : <DocumentTextIcon />}
        </SummaryIcon>
        <SummaryText>
          <strong>{selectedFormIds.length}</strong> form{selectedFormIds.length !== 1 ? 's' : ''} selected
          {suggestedFormIds.length > 0 && selectedFormIds.length < suggestedFormIds.length && (
            <SuggestionHint>
              â€¢ {suggestedFormIds.length - selectedFormIds.filter(id => suggestedFormIds.includes(id)).length} more suggested
            </SuggestionHint>
          )}
        </SummaryText>
      </SelectionSummary>
    </div>
  );
};

// Animations
const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
`;

const pulse = keyframes`
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
`;

// Styled Components
const SelectionSummary = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px 16px;
  background: linear-gradient(135deg,
    ${({ theme }) => theme.colours.backgroundAlt},
    ${({ theme }) => theme.colours.surface}
  );
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 12px;
  animation: ${fadeIn} 0.3s ease-out;
`;

const SummaryIcon = styled.div<{ $hasSelection: boolean }>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: ${({ $hasSelection }) =>
    $hasSelection
      ? 'linear-gradient(135deg, #10b981, #059669)'
      : 'rgba(156, 163, 175, 0.2)'
  };
  transition: all 0.3s ease;

  ${({ $hasSelection }) => $hasSelection && css`
    animation: ${pulse} 0.5s ease-out;
  `}

  svg {
    width: 16px;
    height: 16px;
    color: ${({ $hasSelection }) => $hasSelection ? 'white' : '#9ca3af'};
  }
`;

const SummaryText = styled.div`
  font-size: 14px;
  color: ${({ theme }) => theme.colours.text};

  strong {
    font-weight: 600;
    color: ${({ theme }) => theme.colours.primary};
  }
`;

const SuggestionHint = styled.span`
  color: ${({ theme }) => theme.colours.textMuted};
  margin-left: 4px;
`;

export default FormsStep;

```

---

## src/components/wizard/PremiumAnimations.tsx

**Path:** `src/components/wizard/PremiumAnimations.tsx`

```tsx
/**
 * PremiumAnimations - Shared animation constants and premium styled components
 * for the Coverage Copilot wizard experience
 */

import { keyframes, css } from 'styled-components';

// ========== Premium Keyframe Animations ==========

// Gradient flow animation for AI-powered elements
export const gradientFlow = keyframes`
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
`;

// Subtle pulse for active AI elements
export const aiPulse = keyframes`
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.85; transform: scale(1.02); }
`;

// Shimmer effect for loading/generating states
export const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

// Sparkle animation for AI icons
export const sparkle = keyframes`
  0%, 100% { transform: scale(1) rotate(0deg); opacity: 1; }
  25% { transform: scale(1.1) rotate(-5deg); opacity: 0.9; }
  50% { transform: scale(1.15) rotate(5deg); opacity: 1; }
  75% { transform: scale(1.05) rotate(-3deg); opacity: 0.95; }
`;

// Slide up fade in
export const slideUpFadeIn = keyframes`
  from { opacity: 0; transform: translateY(16px); }
  to { opacity: 1; transform: translateY(0); }
`;

// Slide in from right
export const slideInRight = keyframes`
  from { opacity: 0; transform: translateX(24px); }
  to { opacity: 1; transform: translateX(0); }
`;

// Slide in from left  
export const slideInLeft = keyframes`
  from { opacity: 0; transform: translateX(-24px); }
  to { opacity: 1; transform: translateX(0); }
`;

// Fade in with scale
export const fadeInScale = keyframes`
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
`;

// Smooth spin for loading icons
export const smoothSpin = keyframes`
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
`;

// Glow pulse for AI status
export const glowPulse = keyframes`
  0%, 100% { box-shadow: 0 0 5px rgba(139, 92, 246, 0.3), 0 0 10px rgba(99, 102, 241, 0.2); }
  50% { box-shadow: 0 0 15px rgba(139, 92, 246, 0.5), 0 0 25px rgba(99, 102, 241, 0.3); }
`;

// Field cascade fill animation
export const cascadeFill = keyframes`
  0% { background-position: 100% 0; opacity: 0.5; }
  50% { opacity: 1; }
  100% { background-position: 0% 0; opacity: 1; }
`;

// Typing cursor blink
export const cursorBlink = keyframes`
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
`;

// Confetti burst
export const confettiBurst = keyframes`
  0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
  100% { transform: translateY(-100vh) rotate(720deg) scale(0); opacity: 0; }
`;

// Check mark draw animation
export const checkDraw = keyframes`
  0% { stroke-dashoffset: 100; }
  100% { stroke-dashoffset: 0; }
`;

// ========== Premium CSS Mixins ==========

// Glass morphism effect
export const glassMorphism = css`
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid rgba(255, 255, 255, 0.15);
`;

// AI gradient background
export const aiGradientBg = css`
  background: linear-gradient(135deg, 
    rgba(99, 102, 241, 0.1) 0%, 
    rgba(139, 92, 246, 0.1) 50%, 
    rgba(168, 85, 247, 0.1) 100%
  );
`;

// AI gradient text
export const aiGradientText = css`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
`;

// AI solid gradient for icons/buttons
export const aiSolidGradient = css`
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
`;

// Success gradient
export const successGradient = css`
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
`;

// Premium shadow
export const premiumShadow = css`
  box-shadow: 
    0 4px 6px -1px rgba(0, 0, 0, 0.1),
    0 2px 4px -1px rgba(0, 0, 0, 0.06),
    0 0 0 1px rgba(99, 102, 241, 0.05);
`;

// ========== Animation Timing ==========
export const ANIMATION_TIMING = {
  fast: '150ms',
  normal: '250ms',
  slow: '400ms',
  verySlow: '600ms',
};

export const EASING = {
  smooth: 'cubic-bezier(0.4, 0, 0.2, 1)',
  bouncy: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
  spring: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
};

```

---

## src/components/wizard/SmartCoverageNameInput.tsx

**Path:** `src/components/wizard/SmartCoverageNameInput.tsx`

```tsx
/**
 * SmartCoverageNameInput - AI-powered coverage name input with suggestions
 *
 * Features:
 * - Real-time AI-powered coverage name suggestions
 * - Auto-generated coverage codes
 * - Duplicate detection with visual feedback
 * - Premium animations and micro-interactions
 */

import React, { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import styled, { keyframes, css } from 'styled-components';
import {
  SparklesIcon,
  LightBulbIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  MagnifyingGlassIcon,
  XMarkIcon,
  TagIcon,
  DocumentDuplicateIcon,
  LinkIcon,
} from '@heroicons/react/24/outline';
import { SparklesIcon as SparklesSolid } from '@heroicons/react/24/solid';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../../firebase';
import { searchCoverages, suggestMissingCoverages, SearchResult } from '../../services/coverageSearch';

interface SmartCoverageNameInputProps {
  value: string;
  coverageCode: string;
  onChange: (name: string) => void;
  onCodeChange: (code: string) => void;
  existingCoverageNames?: string[];
  productLineOfBusiness?: string;
  isAutoCodeEnabled?: boolean;
  productId?: string;
}

// Match type icons
const getMatchTypeIcon = (matchType: SearchResult['matchType']) => {
  switch (matchType) {
    case 'exact':
      return <CheckCircleIcon />;
    case 'abbreviation':
      return <TagIcon />;
    case 'alias':
      return <DocumentDuplicateIcon />;
    case 'keyword':
      return <LinkIcon />;
    default:
      return <LightBulbIcon />;
  }
};

// Generate coverage code from name
const generateCoverageCode = (name: string): string => {
  if (!name) return '';
  const words = name.split(/\s+/).filter(w => w.length > 0);
  if (words.length === 1) {
    return words[0].substring(0, 4).toUpperCase();
  }
  const initials = words.map(w => w[0]).join('').toUpperCase();
  return initials.substring(0, 4);
};

export const SmartCoverageNameInput: React.FC<SmartCoverageNameInputProps> = ({
  value,
  coverageCode,
  onChange,
  onCodeChange,
  existingCoverageNames = [],
  productLineOfBusiness = 'default',
  isAutoCodeEnabled = true,
  productId,
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [hasUserEditedCode, setHasUserEditedCode] = useState(false);
  const [aiSuggestions, setAiSuggestions] = useState<string[]>([]);
  const [isLoadingAI, setIsLoadingAI] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);
  const suggestionsRef = useRef<HTMLDivElement>(null);
  const debounceRef = useRef<NodeJS.Timeout>();

  // Fetch AI suggestions when user types (for additional semantic context)
  useEffect(() => {
    if (debounceRef.current) clearTimeout(debounceRef.current);

    // Only call AI for longer queries or when fuzzy search finds few results
    if (value && value.length >= 4) {
      const fuzzyResults = searchCoverages(value, {
        lineOfBusiness: productLineOfBusiness,
        maxResults: 8,
      });

      // Only call AI if we have few fuzzy results
      if (fuzzyResults.length < 3) {
        debounceRef.current = setTimeout(async () => {
          setIsLoadingAI(true);
          try {
            const suggestCoverageNames = httpsCallable<
              { query: string; lineOfBusiness: string; existingNames: string[] },
              { suggestions: string[] }
            >(functions, 'suggestCoverageNames');

            const result = await suggestCoverageNames({
              query: value,
              lineOfBusiness: productLineOfBusiness,
              existingNames: existingCoverageNames.slice(0, 20),
            });

            setAiSuggestions(result.data.suggestions || []);
          } catch (err) {
            console.error('AI suggestion error:', err);
            setAiSuggestions([]);
          } finally {
            setIsLoadingAI(false);
          }
        }, 500); // 500ms debounce for AI calls
      }
    } else {
      setAiSuggestions([]);
    }

    return () => {
      if (debounceRef.current) clearTimeout(debounceRef.current);
    };
  }, [value, productLineOfBusiness, existingCoverageNames]);

  // Intelligent fuzzy search with combined results
  const suggestions = useMemo((): SearchResult[] => {
    // Get fuzzy search results
    const fuzzyResults = searchCoverages(value, {
      lineOfBusiness: productLineOfBusiness,
      maxResults: 8,
      includeRelated: true,
    });

    // Filter out already existing coverages
    const filtered = fuzzyResults.filter(
      r => !existingCoverageNames.some(
        existing => existing.toLowerCase() === r.name.toLowerCase()
      )
    );

    // If few results and we have AI suggestions, merge them
    if (filtered.length < 5 && aiSuggestions.length > 0) {
      const aiResults: SearchResult[] = aiSuggestions
        .filter(ai => !filtered.some(f => f.name.toLowerCase() === ai.toLowerCase()))
        .map(ai => ({
          name: ai,
          score: 75,
          matchType: 'keyword' as const,
          category: 'AI Suggested',
        }));

      return [...filtered, ...aiResults].slice(0, 8);
    }

    // If still few results and user is typing, suggest missing coverages
    if (filtered.length < 4 && existingCoverageNames.length > 0) {
      const missing = suggestMissingCoverages(
        existingCoverageNames,
        productLineOfBusiness,
        5
      ).filter(m => !filtered.some(f => f.name === m.name));

      return [...filtered, ...missing].slice(0, 8);
    }

    return filtered.slice(0, 8);
  }, [value, productLineOfBusiness, existingCoverageNames, aiSuggestions]);

  // Check for duplicates
  const duplicateMatch = useMemo(() => {
    if (!value) return null;
    const valueLower = value.toLowerCase().trim();
    return existingCoverageNames.find(
      name => name.toLowerCase().trim() === valueLower
    );
  }, [value, existingCoverageNames]);

  // Similar names (partial matches)
  const similarNames = useMemo(() => {
    if (!value || value.length < 3) return [];
    const valueLower = value.toLowerCase();
    return existingCoverageNames
      .filter(name => {
        const nameLower = name.toLowerCase();
        return nameLower !== valueLower && 
          (nameLower.includes(valueLower) || valueLower.includes(nameLower));
      })
      .slice(0, 3);
  }, [value, existingCoverageNames]);

  // Auto-generate code when name changes
  useEffect(() => {
    if (isAutoCodeEnabled && !hasUserEditedCode && value) {
      const generated = generateCoverageCode(value);
      if (generated !== coverageCode) {
        onCodeChange(generated);
      }
    }
  }, [value, isAutoCodeEnabled, hasUserEditedCode, coverageCode, onCodeChange]);

  const handleNameChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(e.target.value);
    setShowSuggestions(true);
  }, [onChange]);

  const handleCodeChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setHasUserEditedCode(true);
    onCodeChange(e.target.value.toUpperCase());
  }, [onCodeChange]);

  const handleSuggestionClick = useCallback((e: React.MouseEvent, suggestion: string) => {
    e.preventDefault();
    e.stopPropagation();
    onChange(suggestion);
    setShowSuggestions(false);
    // Don't refocus - let the field stay filled
  }, [onChange]);

  const handleFocus = useCallback(() => {
    setIsFocused(true);
    setShowSuggestions(true);
  }, []);

  const handleBlur = useCallback((e: React.FocusEvent) => {
    // Check if the blur is going to a suggestion item
    const relatedTarget = e.relatedTarget as HTMLElement;
    if (relatedTarget?.closest('[data-suggestion-item]')) {
      // Don't hide suggestions, the click handler will handle it
      return;
    }
    setIsFocused(false);
    // Longer delay to ensure click registers
    setTimeout(() => setShowSuggestions(false), 300);
  }, []);

  return (
    <Container>
      {/* Coverage Name Field */}
      <FieldGroup>
        <LabelRow>
          <Label>Coverage Name <Required>*</Required></Label>
        </LabelRow>

        <SimpleInputWrapper $isFocused={isFocused} $hasError={!!duplicateMatch}>
          <SimpleInput
            ref={inputRef}
            type="text"
            value={value}
            onChange={handleNameChange}
            onFocus={handleFocus}
            onBlur={handleBlur}
            placeholder="e.g., Building Coverage, General Liability..."
          />
        </SimpleInputWrapper>

        {/* Duplicate Warning */}
        {duplicateMatch && (
          <ErrorMessage><ExclamationTriangleIcon />This coverage name already exists</ErrorMessage>
        )}

        {/* Similar Names Info */}
        {similarNames.length > 0 && !duplicateMatch && (
          <InfoMessage><LightBulbIcon />Similar: {similarNames.slice(0, 2).join(', ')}</InfoMessage>
        )}

        {/* Suggestions Dropdown */}
        {showSuggestions && (suggestions.length > 0 || isLoadingAI) && (
          <SuggestionsDropdown ref={suggestionsRef}>
            <SuggestionsHeader>
              <SparklesSolid />
              {isLoadingAI ? 'AI is thinking...' : 'Smart Suggestions'}
              {isLoadingAI && <LoadingDots><span /><span /><span /></LoadingDots>}
            </SuggestionsHeader>
            {suggestions.map((suggestion, idx) => (
              <SuggestionItem
                key={suggestion.name}
                $delay={idx}
                $matchType={suggestion.matchType}
                data-suggestion-item
                onMouseDown={(e) => handleSuggestionClick(e, suggestion.name)}
                tabIndex={0}
              >
                <SuggestionIcon>{getMatchTypeIcon(suggestion.matchType)}</SuggestionIcon>
                <SuggestionContent>
                  <SuggestionName>{suggestion.name}</SuggestionName>
                  <SuggestionMeta>
                    <MatchScore $score={suggestion.score}>{suggestion.score}%</MatchScore>
                    <Category>{suggestion.category}</Category>
                  </SuggestionMeta>
                </SuggestionContent>
              </SuggestionItem>
            ))}
            {!isLoadingAI && suggestions.length === 0 && value && (
              <NoResults>
                <MagnifyingGlassIcon />
                No matches found. Try a different term or abbreviation.
              </NoResults>
            )}
          </SuggestionsDropdown>
        )}
      </FieldGroup>

      {/* Coverage Code Field */}
      <FieldGroup $isSecondary>
        <LabelRow>
          <Label>Coverage Code <Required>*</Required></Label>
        </LabelRow>
        <SimpleCodeInput
          type="text"
          value={coverageCode}
          onChange={handleCodeChange}
          placeholder="e.g., BLDG, GL"
          maxLength={10}
        />
      </FieldGroup>
    </Container>
  );
};

// Animations
const fadeInUp = keyframes`from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); }`;
const pulse = keyframes`0%, 100% { opacity: 1; } 50% { opacity: 0.6; }`;
const shimmer = keyframes`0% { background-position: -200% 0; } 100% { background-position: 200% 0; }`;

// Styled Components
const Container = styled.div`display: flex; flex-direction: column; gap: 20px;`;

const FieldGroup = styled.div<{ $isSecondary?: boolean }>`
  position: relative;
  ${({ $isSecondary }) => $isSecondary && css`max-width: 240px;`}
`;

const LabelRow = styled.div`display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;`;

const Label = styled.label`font-size: 14px; font-weight: 500; color: ${({ theme }) => theme.colours.text};`;
const Required = styled.span`color: #ef4444; margin-left: 2px;`;

const AIBadge = styled.div`
  display: flex; align-items: center; gap: 4px; padding: 4px 10px;
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(99, 102, 241, 0.1));
  border-radius: 12px; border: 1px solid rgba(139, 92, 246, 0.2);
  svg { width: 12px; height: 12px; color: #8b5cf6; }
  span { font-size: 11px; font-weight: 600; color: #7c3aed; }
`;

const AutoBadge = styled.div`
  display: flex; align-items: center; gap: 4px; padding: 3px 8px;
  background: rgba(16, 185, 129, 0.1); border-radius: 10px;
  svg { width: 12px; height: 12px; color: #10b981; }
  font-size: 11px; font-weight: 500; color: #059669;
`;

// Simple clean input wrapper - just an outline border
const SimpleInputWrapper = styled.div<{ $isFocused: boolean; $hasError: boolean }>`
  position: relative;
  border: 1px solid ${({ $hasError, $isFocused, theme }) =>
    $hasError ? '#ef4444' : $isFocused ? theme.colours.primary : theme.colours.border};
  border-radius: 8px;
  transition: border-color 0.2s;
  background: ${({ theme }) => theme.colours.surface};
`;

const SimpleInput = styled.input`
  width: 100%;
  padding: 14px 16px;
  border: none;
  border-radius: 8px;
  background: transparent;
  font-size: 15px;
  color: ${({ theme }) => theme.colours.text};
  &:focus { outline: none; }
  &::placeholder { color: ${({ theme }) => theme.colours.textMuted}; }
`;

const SimpleCodeInput = styled.input`
  width: 100%;
  padding: 14px 16px;
  border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 8px;
  background: ${({ theme }) => theme.colours.surface};
  font-size: 15px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: ${({ theme }) => theme.colours.text};
  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colours.primary};
  }
`;

// Keep old components for backwards compatibility
const InputWrapper = styled.div<{ $isFocused: boolean; $hasError: boolean }>`
  position: relative; display: flex; align-items: center;
  background: ${({ theme }) => theme.colours.surface};
  border: 2px solid ${({ $hasError, $isFocused, theme }) =>
    $hasError ? '#ef4444' : $isFocused ? theme.colours.primary : theme.colours.border};
  border-radius: 12px; transition: all 0.2s;
  ${({ $isFocused }) => $isFocused && css`box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);`}
`;

const InputIcon = styled.div`
  padding-left: 14px; display: flex;
  svg { width: 18px; height: 18px; color: ${({ theme }) => theme.colours.textMuted}; }
`;

const Input = styled.input`
  flex: 1; padding: 14px 12px; border: none; background: transparent;
  font-size: 15px; color: ${({ theme }) => theme.colours.text};
  &:focus { outline: none; }
  &::placeholder { color: ${({ theme }) => theme.colours.textMuted}; }
`;

const ClearButton = styled.button`
  padding: 8px 12px; background: none; border: none; cursor: pointer;
  svg { width: 16px; height: 16px; color: ${({ theme }) => theme.colours.textMuted}; }
  &:hover svg { color: ${({ theme }) => theme.colours.text}; }
`;

const CodeInputWrapper = styled.div<{ $isAutoGenerated: boolean }>`
  ${({ $isAutoGenerated }) => $isAutoGenerated && css`
    background: linear-gradient(90deg, rgba(139, 92, 246, 0.05) 0%, rgba(99, 102, 241, 0.08) 50%, rgba(139, 92, 246, 0.05) 100%);
    background-size: 200% 100%; animation: ${shimmer} 3s ease-in-out infinite;
    border-radius: 12px;
  `}
`;

const CodeInput = styled.input`
  width: 100%; padding: 12px 16px; border: 1px solid ${({ theme }) => theme.colours.border};
  border-radius: 12px; background: ${({ theme }) => theme.colours.surface};
  font-size: 15px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;
  color: ${({ theme }) => theme.colours.text};
  &:focus { outline: none; border-color: ${({ theme }) => theme.colours.primary}; box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1); }
`;

const HelpText = styled.p`margin: 6px 0 0; font-size: 12px; color: ${({ theme }) => theme.colours.textMuted};`;

// Enhanced validation hint with P&C context
const ValidationHint = styled.div<{ $type: 'success' | 'warning' | 'info' | 'error' }>`
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
  padding: 10px 14px;
  border-radius: 10px;
  font-size: 13px;
  line-height: 1.4;
  animation: ${fadeInUp} 0.2s ease-out;

  ${({ $type }) => {
    switch ($type) {
      case 'success':
        return css`
          background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.05));
          border: 1px solid rgba(16, 185, 129, 0.2);
          color: #059669;
        `;
      case 'warning':
        return css`
          background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(217, 119, 6, 0.05));
          border: 1px solid rgba(245, 158, 11, 0.2);
          color: #d97706;
        `;
      case 'error':
        return css`
          background: linear-gradient(135deg, rgba(239, 68, 68, 0.08), rgba(220, 38, 38, 0.05));
          border: 1px solid rgba(239, 68, 68, 0.2);
          color: #dc2626;
        `;
      default:
        return css`
          background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(79, 70, 229, 0.05));
          border: 1px solid rgba(99, 102, 241, 0.2);
          color: #4f46e5;
        `;
    }
  }}

  svg {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
  }
`;

const ValidationIcon = styled.div<{ $type: 'success' | 'warning' | 'info' | 'error' }>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border-radius: 6px;

  ${({ $type }) => {
    switch ($type) {
      case 'success':
        return css`background: rgba(16, 185, 129, 0.15);`;
      case 'warning':
        return css`background: rgba(245, 158, 11, 0.15);`;
      case 'error':
        return css`background: rgba(239, 68, 68, 0.15);`;
      default:
        return css`background: rgba(99, 102, 241, 0.15);`;
    }
  }}
`;

const ValidationContent = styled.div`
  flex: 1;

  strong {
    display: block;
    font-weight: 600;
    margin-bottom: 2px;
  }

  span {
    opacity: 0.9;
    font-size: 12px;
  }
`;

const ErrorMessage = styled.div`
  display: flex; align-items: center; gap: 6px; margin-top: 8px; padding: 8px 12px;
  background: #fef2f2; border-radius: 8px; font-size: 13px; color: #dc2626;
  svg { width: 16px; height: 16px; flex-shrink: 0; }
`;

const InfoMessage = styled.div`
  display: flex; align-items: center; gap: 6px; margin-top: 8px;
  font-size: 12px; color: ${({ theme }) => theme.colours.textMuted};
  svg { width: 14px; height: 14px; color: #f59e0b; }
`;

const SuggestionsDropdown = styled.div`
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 1000;
  margin-top: 8px;
  background: #ffffff;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.12), 0 4px 12px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  animation: ${fadeInUp} 0.25s ease-out;
  max-height: 380px;
  overflow-y: auto;
`;

const SuggestionsHeader = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  background: #f9fafb;
  border-bottom: 1px solid #e5e7eb;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: #6b7280;
  position: sticky;
  top: 0;
  z-index: 1;
  svg { width: 14px; height: 14px; color: #8b5cf6; }
`;

const LoadingDots = styled.div`
  display: flex;
  gap: 3px;
  margin-left: auto;

  span {
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: #8b5cf6;
    animation: ${pulse} 1.4s ease-in-out infinite;

    &:nth-child(2) { animation-delay: 0.2s; }
    &:nth-child(3) { animation-delay: 0.4s; }
  }
`;

const SuggestionItem = styled.button<{ $delay: number; $matchType?: string }>`
  display: flex;
  align-items: center;
  gap: 12px;
  width: 100%;
  padding: 12px 16px;
  background: #ffffff;
  border: none;
  text-align: left;
  cursor: pointer;
  transition: all 0.15s ease;
  animation: ${fadeInUp} 0.2s ease-out;
  animation-delay: ${({ $delay }) => $delay * 40}ms;
  animation-fill-mode: both;

  &:hover {
    background: #f5f3ff;
  }

  &:not(:last-child) {
    border-bottom: 1px solid #f3f4f6;
  }
`;

const SuggestionIcon = styled.div`
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(99, 102, 241, 0.15));
  border-radius: 8px;
  flex-shrink: 0;

  svg {
    width: 16px;
    height: 16px;
    color: #8b5cf6;
  }
`;

const SuggestionContent = styled.div`
  flex: 1;
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 2px;
`;

const SuggestionName = styled.span`
  font-size: 14px;
  font-weight: 500;
  color: #1f2937;
`;

const SuggestionMeta = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
`;

const MatchScore = styled.span<{ $score: number }>`
  font-size: 11px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  background: ${({ $score }) =>
    $score >= 90 ? 'rgba(34, 197, 94, 0.15)' :
    $score >= 70 ? 'rgba(139, 92, 246, 0.15)' :
    'rgba(156, 163, 175, 0.15)'
  };
  color: ${({ $score }) =>
    $score >= 90 ? '#16a34a' :
    $score >= 70 ? '#7c3aed' :
    '#6b7280'
  };
`;

const Category = styled.span`
  font-size: 11px;
  color: #9ca3af;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const NoResults = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 24px 18px;
  text-align: center;
  color: #6b7280;
  font-size: 13px;
  background: #ffffff;

  svg {
    width: 24px;
    height: 24px;
    opacity: 0.5;
  }
`;

export default SmartCoverageNameInput;

```

---

## src/components/wizard/WizardFooter.tsx

**Path:** `src/components/wizard/WizardFooter.tsx`

```tsx
/**
 * WizardFooter - Navigation footer for wizard with save/publish actions
 */

import React from 'react';
import styled, { keyframes } from 'styled-components';
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  BookmarkIcon,
  CheckIcon,
  ArrowPathIcon,
  ExclamationCircleIcon
} from '@heroicons/react/24/outline';

// Styled Components
const Container = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
`;

const LeftSection = styled.div``;

const CenterSection = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
`;

const RightSection = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
`;

const spin = keyframes`
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
`;

const StatusIndicator = styled.span<{ $type: 'warning' | 'info' }>`
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 14px;
  color: ${({ $type }) => $type === 'warning' ? '#d97706' : '#6b7280'};

  svg {
    width: 16px;
    height: 16px;
  }
`;

const PulseDot = styled.span`
  width: 8px;
  height: 8px;
  background: #f59e0b;
  border-radius: 50%;
  animation: ${pulse} 2s ease-in-out infinite;
`;

const NavButton = styled.button`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border: none;
  border-radius: 8px;
  background: transparent;
  color: ${({ theme }) => theme.colours.textMuted};
  cursor: pointer;
  transition: background 0.2s;

  &:hover {
    background: ${({ theme }) => theme.colours.backgroundAlt};
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const SaveButton = styled.button<{ $isDirty: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border: none;
  border-radius: 8px;
  transition: all 0.2s;
  cursor: ${({ $isDirty }) => $isDirty ? 'pointer' : 'not-allowed'};
  background: ${({ $isDirty, theme }) =>
    $isDirty ? theme.colours.backgroundAlt : theme.colours.background
  };
  color: ${({ $isDirty, theme }) =>
    $isDirty ? theme.colours.text : theme.colours.textMuted
  };

  &:hover:not(:disabled) {
    background: ${({ theme }) => theme.colours.border};
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const SpinningIcon = styled.span`
  display: flex;
  animation: ${spin} 1s linear infinite;

  svg {
    width: 16px;
    height: 16px;
  }
`;

const NextButton = styled.button<{ $disabled: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 24px;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  transition: all 0.2s;
  cursor: ${({ $disabled }) => $disabled ? 'not-allowed' : 'pointer'};
  background: ${({ $disabled, theme }) =>
    $disabled ? theme.colours.backgroundAlt : theme.colours.primary
  };
  color: ${({ $disabled }) => $disabled ? '#9ca3af' : 'white'};

  &:hover:not(:disabled) {
    transform: scale(1.02);
  }

  &:active:not(:disabled) {
    transform: scale(0.98);
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

const PublishButton = styled.button<{ $canPublish: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 24px;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  transition: all 0.2s;
  cursor: ${({ $canPublish }) => $canPublish ? 'pointer' : 'not-allowed'};
  background: ${({ $canPublish }) => $canPublish ? '#16a34a' : '#e5e7eb'};
  color: ${({ $canPublish }) => $canPublish ? 'white' : '#9ca3af'};
  box-shadow: ${({ $canPublish }) =>
    $canPublish ? '0 10px 15px -3px rgba(22, 163, 74, 0.3)' : 'none'
  };

  &:hover:not(:disabled) {
    background: ${({ $canPublish }) => $canPublish ? '#15803d' : '#e5e7eb'};
    transform: ${({ $canPublish }) => $canPublish ? 'scale(1.02)' : 'none'};
  }

  &:active:not(:disabled) {
    transform: scale(0.98);
  }

  svg {
    width: 16px;
    height: 16px;
  }
`;

interface WizardFooterProps {
  currentStep: number;
  totalSteps: number;
  onPrevious: () => void;
  onNext: () => void;
  onSaveDraft: () => void;
  onPublish: () => void;
  canGoNext?: boolean;
  canPublish?: boolean;
  isSaving?: boolean;
  isPublishing?: boolean;
  isDirty?: boolean;
  missingRequiredCount?: number;
  className?: string;
}

export const WizardFooter: React.FC<WizardFooterProps> = ({
  currentStep,
  totalSteps,
  onPrevious,
  onNext,
  onSaveDraft,
  onPublish,
  canGoNext = true,
  canPublish = false,
  isSaving = false,
  isPublishing = false,
  isDirty = false,
  missingRequiredCount = 0,
  className = ''
}) => {
  const isFirstStep = currentStep === 0;
  const isLastStep = currentStep === totalSteps - 1;

  return (
    <Container className={className}>
      {/* Left side - Previous button */}
      <LeftSection>
        {!isFirstStep && (
          <NavButton onClick={onPrevious}>
            <ChevronLeftIcon />
            Previous
          </NavButton>
        )}
      </LeftSection>

      {/* Center - Status indicators */}
      <CenterSection>
        {missingRequiredCount > 0 && (
          <StatusIndicator $type="info">
            <ExclamationCircleIcon />
            {missingRequiredCount} required field{missingRequiredCount > 1 ? 's' : ''} missing
          </StatusIndicator>
        )}
      </CenterSection>

      {/* Right side - Action buttons */}
      <RightSection>
        {/* Next / Publish button */}
        {isLastStep ? (
          <PublishButton
            onClick={onPublish}
            disabled={!canPublish || isPublishing}
            $canPublish={canPublish}
          >
            {isPublishing ? (
              <SpinningIcon><ArrowPathIcon /></SpinningIcon>
            ) : (
              <CheckIcon />
            )}
            Publish Coverage
          </PublishButton>
        ) : (
          <NextButton
            onClick={onNext}
            disabled={!canGoNext}
            $disabled={!canGoNext}
          >
            Next
            <ChevronRightIcon />
          </NextButton>
        )}
      </RightSection>
    </Container>
  );
};

export default WizardFooter;

```

---

## src/components/wizard/WizardProgress.tsx

**Path:** `src/components/wizard/WizardProgress.tsx`

```tsx
/**
 * WizardProgress - Modern, minimal progress indicator
 *
 * Features:
 * - Clean, minimal step indicators
 * - Smooth animated progress line
 * - Elegant transitions
 * - Mobile-responsive
 */

import React from 'react';
import styled, { keyframes, css } from 'styled-components';
import { CheckIcon } from '@heroicons/react/24/solid';

// Animations
const slideIn = keyframes`
  from { transform: scaleX(0); }
  to { transform: scaleX(1); }
`;

const popIn = keyframes`
  0% { transform: scale(0.8); opacity: 0; }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); opacity: 1; }
`;

const checkmarkDraw = keyframes`
  to { stroke-dashoffset: 0; }
`;

const pulse = keyframes`
  0%, 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); }
  50% { box-shadow: 0 0 0 8px rgba(99, 102, 241, 0); }
`;

// Styled Components
const Container = styled.div`
  padding: 24px 32px;
  background: ${({ theme }) => theme.colours.surface};
  border-bottom: 1px solid ${({ theme }) => theme.colours.border};
`;

const ProgressWrapper = styled.div`
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
`;

// The track behind the progress
const ProgressTrack = styled.div`
  position: absolute;
  top: 50%;
  left: 24px;
  right: 24px;
  height: 2px;
  background: ${({ theme }) => theme.colours.border};
  transform: translateY(-50%);
  border-radius: 1px;
  z-index: 0;
`;

// The filled progress line
const ProgressLine = styled.div<{ $progress: number }>`
  position: absolute;
  top: 50%;
  left: 24px;
  height: 2px;
  background: linear-gradient(90deg, #6366f1, #8b5cf6);
  transform: translateY(-50%);
  transform-origin: left;
  border-radius: 1px;
  z-index: 1;
  width: calc(${({ $progress }) => $progress}% - 48px);
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
`;

// Individual step wrapper
const StepWrapper = styled.div`
  position: relative;
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
`;

// Step indicator circle
const StepIndicator = styled.button<{
  $state: 'complete' | 'active' | 'upcoming';
  $isClickable: boolean;
}>`
  position: relative;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: 2px solid transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-size: 16px;
  cursor: ${({ $isClickable }) => $isClickable ? 'pointer' : 'default'};
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  animation: ${popIn} 0.4s ease-out backwards;

  ${({ $state, theme }) => {
    switch ($state) {
      case 'complete':
        return css`
          background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
          color: white;
          border-color: transparent;
          box-shadow: 0 4px 12px rgba(34, 197, 94, 0.25);
        `;
      case 'active':
        return css`
          background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
          color: white;
          border-color: transparent;
          box-shadow: 0 4px 16px rgba(99, 102, 241, 0.35);
          animation: ${popIn} 0.4s ease-out backwards, ${pulse} 2s ease-in-out infinite;
        `;
      default:
        return css`
          background: ${theme.colours.surface};
          color: ${theme.colours.textMuted};
          border-color: ${theme.colours.border};
        `;
    }
  }}

  &:hover {
    ${({ $isClickable }) => $isClickable && css`
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(99, 102, 241, 0.3);
    `}
  }

  &:active {
    ${({ $isClickable }) => $isClickable && css`
      transform: scale(0.95);
    `}
  }

  svg {
    width: 20px;
    height: 20px;
  }
`;

// Step label
const StepLabel = styled.span<{ $state: 'complete' | 'active' | 'upcoming' }>`
  font-size: 12px;
  font-weight: 500;
  text-align: center;
  max-width: 80px;
  line-height: 1.3;
  transition: color 0.3s ease;

  color: ${({ $state, theme }) => {
    switch ($state) {
      case 'complete':
        return '#16a34a';
      case 'active':
        return '#6366f1';
      default:
        return theme.colours.textMuted;
    }
  }};
`;

const OptionalTag = styled.span`
  font-size: 10px;
  color: ${({ theme }) => theme.colours.textMuted};
  font-weight: 400;
`;

// Completion summary
const CompletionSummary = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 20px;
  padding-top: 16px;
  border-top: 1px solid ${({ theme }) => theme.colours.border};
`;

const CompletionInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const CompletionText = styled.span`
  font-size: 13px;
  color: ${({ theme }) => theme.colours.textMuted};
`;

const CompletionBadge = styled.span<{ $score: number }>`
  font-size: 13px;
  font-weight: 600;
  padding: 4px 12px;
  border-radius: 20px;

  ${({ $score }) => {
    if ($score >= 80) {
      return css`
        background: rgba(34, 197, 94, 0.1);
        color: #16a34a;
      `;
    } else if ($score >= 50) {
      return css`
        background: rgba(234, 179, 8, 0.1);
        color: #ca8a04;
      `;
    }
    return css`
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
    `;
  }}
`;

const ProgressBar = styled.div`
  flex: 1;
  max-width: 200px;
  height: 6px;
  background: ${({ theme }) => theme.colours.backgroundAlt};
  border-radius: 3px;
  overflow: hidden;
  margin-left: 16px;
`;

const ProgressFill = styled.div<{ $score: number }>`
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  width: ${({ $score }) => $score}%;

  background: ${({ $score }) => {
    if ($score >= 80) return 'linear-gradient(90deg, #22c55e, #16a34a)';
    if ($score >= 50) return 'linear-gradient(90deg, #eab308, #ca8a04)';
    return 'linear-gradient(90deg, #ef4444, #dc2626)';
  }};
`;

export interface WizardStep {
  id: string;
  label: string;
  description?: string;
  isComplete?: boolean;
  isOptional?: boolean;
  fieldCount?: number;
  filledFieldCount?: number;
}

interface WizardProgressProps {
  steps: WizardStep[];
  currentStepIndex: number;
  onStepClick?: (index: number) => void;
  completenessScore?: number;
  className?: string;
  isAIActive?: boolean;
  aiActivityMessage?: string;
}

export const WizardProgress: React.FC<WizardProgressProps> = ({
  steps,
  currentStepIndex,
  onStepClick,
  completenessScore,
  className = '',
}) => {
  // Calculate progress percentage for the line
  const progressPercent = steps.length > 1
    ? (currentStepIndex / (steps.length - 1)) * 100
    : 0;

  const completedSteps = steps.filter((_, i) => i < currentStepIndex).length;

  return (
    <Container className={className}>
      <ProgressWrapper>
        {/* Background track */}
        <ProgressTrack />

        {/* Animated progress line */}
        <ProgressLine $progress={progressPercent} />

        {/* Step indicators */}
        {steps.map((step, index) => {
          const isComplete = index < currentStepIndex || !!step.isComplete;
          const isActive = index === currentStepIndex;
          const state = isComplete && !isActive ? 'complete' : isActive ? 'active' : 'upcoming';
          const isClickable = !!onStepClick && (isComplete || index === currentStepIndex + 1);

          return (
            <StepWrapper key={step.id}>
              <StepIndicator
                $state={state}
                $isClickable={isClickable}
                onClick={() => isClickable && onStepClick?.(index)}
                disabled={!isClickable}
                title={step.description}
                style={{ animationDelay: `${index * 0.1}s` }}
              >
                {state === 'complete' ? (
                  <CheckIcon />
                ) : (
                  <span>{index + 1}</span>
                )}
              </StepIndicator>
              <StepLabel $state={state}>
                {step.label}
                {step.isOptional && <OptionalTag> (opt)</OptionalTag>}
              </StepLabel>
            </StepWrapper>
          );
        })}
      </ProgressWrapper>

      {/* Completion summary */}
      {completenessScore !== undefined && (
        <CompletionSummary>
          <CompletionInfo>
            <CompletionText>
              Step {currentStepIndex + 1} of {steps.length}
            </CompletionText>
            <CompletionBadge $score={completenessScore}>
              {completenessScore}% Complete
            </CompletionBadge>
          </CompletionInfo>
          <ProgressBar>
            <ProgressFill $score={completenessScore} />
          </ProgressBar>
        </CompletionSummary>
      )}
    </Container>
  );
};

export default WizardProgress;

```

---

## src/components/wizard/index.ts

**Path:** `src/components/wizard/index.ts`

```typescript
/**
 * Wizard Components Index
 * Components for the Coverage Copilot wizard experience
 */

// Core Wizard Components
export { WizardProgress, type WizardStep } from './WizardProgress';
export { WizardFooter } from './WizardFooter';
export { CoverageCopilotWizard } from './CoverageCopilotWizard';
export { FormsStep } from './FormsStep';

// Premium AI-Powered Components
export { SmartCoverageNameInput } from './SmartCoverageNameInput';
export { AIInsightsCard } from './AIInsightsCard';
export { AIReviewSummary } from './AIReviewSummary';

```

---

## src/config/aiConfig.ts

**Path:** `src/config/aiConfig.ts`

```typescript
/**
 * Centralized AI Configuration
 * 
 * This file contains all AI model configurations, system prompts, and API settings
 * used throughout the Product Hub application. This ensures consistency and makes
 * it easy to update AI behavior from a single location.
 */

// ============================================================================
// Type Definitions
// ============================================================================

export interface AIModels {
  PRIMARY: string;
  FALLBACK: string;
  CLAIMS_ANALYSIS: string;
  PRODUCT_SUMMARY: string;
  HOME_CHAT: string;
  AGENT_WORKFLOW: string;
  PRODUCT_BUILDER: string;
}

export interface AITimeouts {
  QUICK_RESPONSE: number;
  STANDARD: number;
  COMPLEX_ANALYSIS: number;
  SYNTHESIS: number;
  LONG_PROCESSING: number;
}

export interface AIAPIConfig {
  OPENAI_ENDPOINT: string;
  TIMEOUTS: AITimeouts;
}

export interface AIParameterConfig {
  model: string;
  max_tokens: number;
  temperature: number;
  top_p?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  timeout: number;
}

export interface AIParameters {
  PRODUCT_SUMMARY: AIParameterConfig;
  FORM_SUMMARY: AIParameterConfig;
  CLAIMS_ANALYSIS: AIParameterConfig;
  CLAIMS_SYNTHESIS: AIParameterConfig;
  HOME_CHAT: AIParameterConfig;
  PRODUCT_CHAT: AIParameterConfig;
  RULES_EXTRACTION: AIParameterConfig;
  AGENT_WORKFLOW: AIParameterConfig;
  PRODUCT_BUILDER: AIParameterConfig;
  TASK_SUMMARY: AIParameterConfig;
  NEWS_SUMMARY: AIParameterConfig;
  EARNINGS_SUMMARY: AIParameterConfig;
  EARNINGS_ANALYSIS: AIParameterConfig;
}

export interface AIPrompts {
  PRODUCT_SUMMARY_SYSTEM: string;
  FORM_SUMMARY_SYSTEM: string;
  CLAIMS_ANALYSIS_SYSTEM: string;
  CLAIMS_SYNTHESIS_SYSTEM: string;
  HOME_CHAT_SYSTEM: string;
  PRODUCT_CHAT_SYSTEM: (productName: string, pdfText?: string) => string;
  NEWS_SUMMARY_SYSTEM: string;
  EARNINGS_SUMMARY_SYSTEM: string;
  EARNINGS_ANALYSIS_SYSTEM: string;
  RULES_EXTRACTION_SYSTEM: string;
  AGENT_WORKFLOW_SYSTEM: string;
  PRODUCT_BUILDER_SYSTEM: string;
  TASK_SUMMARY_SYSTEM: string;
}

export interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

// ============================================================================
// AI Models Configuration
// ============================================================================

export const AI_MODELS: AIModels = {
  // Primary model used across the application - all using gpt-4o-mini for cost efficiency
  PRIMARY: 'gpt-4o-mini',

  // Fallback model (if needed in future)
  FALLBACK: 'gpt-4o-mini',

  // All features use gpt-4o-mini for consistency and cost savings
  CLAIMS_ANALYSIS: 'gpt-4o-mini',
  PRODUCT_SUMMARY: 'gpt-4o-mini',
  HOME_CHAT: 'gpt-4o-mini',
  AGENT_WORKFLOW: 'gpt-4o-mini',
  PRODUCT_BUILDER: 'gpt-4o-mini'
};

// ============================================================================
// API Configuration
// ============================================================================

export const AI_API_CONFIG: AIAPIConfig = {
  OPENAI_ENDPOINT: 'https://api.openai.com/v1/chat/completions',
  
  // Default timeouts for different operations (in milliseconds)
  TIMEOUTS: {
    QUICK_RESPONSE: 30000,    // 30 seconds - for simple queries
    STANDARD: 45000,          // 45 seconds - for standard analysis
    COMPLEX_ANALYSIS: 60000,  // 60 seconds - for complex analysis
    SYNTHESIS: 60000,         // 60 seconds - for synthesis operations
    LONG_PROCESSING: 120000   // 2 minutes - for heavy processing
  }
};

// ============================================================================
// Model Parameters by Use Case
// ============================================================================

export const AI_PARAMETERS: AIParameters = {
  // Product summary generation - structured, consistent output
  PRODUCT_SUMMARY: {
    model: AI_MODELS.PRODUCT_SUMMARY,
    max_tokens: 2000,
    temperature: 0.2,
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  },
  
  // Form summary generation - concise, structured
  FORM_SUMMARY: {
    model: AI_MODELS.PRIMARY,
    max_tokens: 1000,
    temperature: 0.2,
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  },
  
  // Claims analysis - detailed, analytical
  CLAIMS_ANALYSIS: {
    model: AI_MODELS.CLAIMS_ANALYSIS,
    max_tokens: 2000,
    temperature: 0.2,
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  },
  
  // Claims synthesis - comprehensive analysis
  CLAIMS_SYNTHESIS: {
    model: AI_MODELS.CLAIMS_ANALYSIS,
    max_tokens: 3000,
    temperature: 0.1,
    timeout: AI_API_CONFIG.TIMEOUTS.SYNTHESIS
  },
  
  // Home page chat - conversational, informative
  HOME_CHAT: {
    model: AI_MODELS.HOME_CHAT,
    max_tokens: 4000,
    temperature: 0.3,
    top_p: 0.9,
    frequency_penalty: 0.1,
    presence_penalty: 0.1,
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  },
  
  // Product chat - contextual, helpful
  PRODUCT_CHAT: {
    model: AI_MODELS.PRIMARY,
    max_tokens: 1000,
    temperature: 0.7,
    timeout: AI_API_CONFIG.TIMEOUTS.QUICK_RESPONSE
  },
  
  // Rules extraction - structured, precise
  RULES_EXTRACTION: {
    model: AI_MODELS.PRIMARY,
    max_tokens: 2000,
    temperature: 0.3,
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  },
  
  // Agent workflow - task-oriented, structured
  AGENT_WORKFLOW: {
    model: AI_MODELS.AGENT_WORKFLOW,
    max_tokens: 1000,
    temperature: 0.3,
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  },
  
  // Product builder - creative, helpful
  PRODUCT_BUILDER: {
    model: AI_MODELS.PRODUCT_BUILDER,
    max_tokens: 2000,
    temperature: 0.4,
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  },

  // Task summary - concise, actionable insights
  TASK_SUMMARY: {
    model: AI_MODELS.PRIMARY,
    max_tokens: 1000,
    temperature: 0.2,
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  },

  // News summarization - concise P&C intelligence summaries
  NEWS_SUMMARY: {
    model: AI_MODELS.PRIMARY,
    max_tokens: 150, // Reduced for concise summaries (1-2 sentences max)
    temperature: 0.1, // Very low for consistent, focused output
    top_p: 0.8, // Reduced for more focused responses
    frequency_penalty: 0.2, // Higher to reduce repetition
    timeout: AI_API_CONFIG.TIMEOUTS.QUICK_RESPONSE
  },

  // Earnings summarization - intelligent financial analysis summaries
  EARNINGS_SUMMARY: {
    model: AI_MODELS.PRIMARY,
    max_tokens: 200, // Slightly longer for financial context
    temperature: 0.1, // Very low for consistent, analytical output
    top_p: 0.8, // Focused responses for financial accuracy
    frequency_penalty: 0.2, // Reduce repetition
    timeout: AI_API_CONFIG.TIMEOUTS.QUICK_RESPONSE
  },

  // Earnings analysis - detailed financial performance insights
  EARNINGS_ANALYSIS: {
    model: AI_MODELS.PRIMARY,
    max_tokens: 500, // More detailed analysis
    temperature: 0.2, // Low for analytical consistency
    top_p: 0.9, // Slightly higher for nuanced analysis
    frequency_penalty: 0.1, // Allow some repetition for emphasis
    timeout: AI_API_CONFIG.TIMEOUTS.STANDARD
  }
};

// ============================================================================
// System Prompts
// ============================================================================

export const AI_PROMPTS: AIPrompts = {
  // Product Hub - Structured product analysis
  PRODUCT_SUMMARY_SYSTEM: `
Persona: You are an expert in P&C insurance products with deep knowledge of policy language, coverage structures, and insurance terminology.

**Your Task:** Analyze the provided insurance document text and extract key information into a structured JSON format.

**Key Definitions:**
- **Coverage**: A specific type of protection provided by the insurance policy (e.g., "Bodily Injury Liability", "Property Damage", "Comprehensive")
- **Peril**: A specific cause of loss that is covered (e.g., "Fire", "Theft", "Collision", "Vandalism")
- **Limit**: The maximum amount the insurer will pay for a covered loss
- **Deductible**: The amount the policyholder must pay before insurance coverage applies
- **Exclusion**: Specific situations, conditions, or types of losses that are not covered
- **Condition**: Requirements that must be met for coverage to apply
- **Enhancement**: Additional coverage that builds upon or extends a base coverage
- **Sub-Coverage**: A coverage that is subordinate to or dependent on a parent coverage

**Analysis Process:**
1. Read the document carefully and identify its type
2. Extract all coverages, noting parent-child relationships (hierarchies)
3. For each coverage, identify: scope, limits, deductibles, covered perils, exclusions
4. Identify general conditions and exclusions that apply to the entire policy
5. Note any coverage enhancements or dependencies
6. Assess confidence level for each extraction

**Output Format (JSON):**
{
  "category": "document_type",
  "confidence_level": 0-100,
  "chain_of_thought": "Brief explanation of analysis approach",
  "coverages": [
    {
      "coverageName": "name",
      "parentCoverage": "parent_name_if_applicable",
      "scopeOfCoverage": "description",
      "limits": "limits_description",
      "deductibles": "deductible_description",
      "perilsCovered": ["peril1", "peril2"],
      "exclusions": ["exclusion1", "exclusion2"],
      "conditions": ["condition1", "condition2"],
      "enhances": ["coverage1", "coverage2"],
      "confidence": 0-100
    }
  ],
  "generalConditions": ["condition1", "condition2"],
  "generalExclusions": ["exclusion1", "exclusion2"],
  "documentQuality": "Complete|Partial|Unclear",
  "extractionNotes": "Any notes about extraction challenges or ambiguities"
}

**Few-Shot Example:**
Input: "Homeowners policy with dwelling, personal property, and liability coverage"
Output:
{
  "category": "Homeowners Policy",
  "confidence_level": 95,
  "chain_of_thought": "Document is a homeowners policy. Identified three main coverages: dwelling (property), personal property (property), and liability. No sub-coverages or dependencies noted. Standard exclusions apply.",
  "coverages": [
    {
      "coverageName": "Dwelling Coverage",
      "parentCoverage": null,
      "scopeOfCoverage": "Covers the structure of the home including attached structures",
      "limits": "Up to policy limit",
      "deductibles": "$1,000 per occurrence",
      "perilsCovered": ["Fire", "Wind", "Hail", "Theft"],
      "exclusions": ["Flood", "Earthquake", "War"],
      "conditions": ["Property must be maintained", "Insured must report losses within 30 days"],
      "enhances": [],
      "confidence": 98
    },
    {
      "coverageName": "Personal Property Coverage",
      "parentCoverage": null,
      "scopeOfCoverage": "Covers personal belongings inside and outside the home",
      "limits": "Up to 70% of dwelling limit",
      "deductibles": "$1,000 per occurrence",
      "perilsCovered": ["Fire", "Theft", "Vandalism"],
      "exclusions": ["Flood", "Earthquake", "Wear and tear"],
      "conditions": ["Items must be listed for high-value items"],
      "enhances": [],
      "confidence": 95
    }
  ],
  "generalConditions": ["Insured must maintain property", "Claims must be reported within 30 days"],
  "generalExclusions": ["Flood", "Earthquake", "War", "Wear and tear"],
  "documentQuality": "Complete",
  "extractionNotes": "Standard homeowners policy with clear coverage structure"
}

**Important:** Show your reasoning. Extract ALL coverages including sub-coverages. Flag any ambiguities or unclear language.`,

  // Form Summary - Concise form analysis
  FORM_SUMMARY_SYSTEM: `You are an expert P&C insurance form analyst. Your task is to create a clear, structured summary of an insurance form.

**Your Role:**
- Analyze insurance forms (policy forms, endorsements, exclusions, notices)
- Extract key information in a structured, easy-to-read format
- Identify coverage grants, conditions, exclusions, and definitions
- Highlight important limitations and requirements
- Assess confidence level for each extraction

**Analysis Process:**
1. Identify the form type and purpose
2. Extract the form name and edition date if available
3. Summarize the overall scope and applicability (2-3 sentences)
4. List all coverages with their scope, limits, and any sub-coverages
5. Document key conditions that must be met
6. List exclusions and limitations
7. Note any special requirements or definitions
8. Assess overall confidence in the analysis

**Error Handling:**
- If form is unclear or incomplete, note this explicitly
- Flag any ambiguous language or conflicting provisions
- Indicate sections that require further review
- Suggest clarification if needed

**Output Format (Markdown):**
# [Form Name]
**Form Type:** [Type]
**Edition Date:** [Date if available]
**Confidence Level:** [0-100%]

## Overview
[2-3 sentence summary of form purpose and scope]

## Coverages
- **[Coverage Name]**: [Description of scope and limits]
  - Sub-coverage: [If applicable]
  - Sub-coverage: [If applicable]

## Key Conditions
- [Condition 1]
- [Condition 2]

## Exclusions & Limitations
- [Exclusion 1]
- [Exclusion 2]

## Important Notes
[Any special requirements or definitions]

## Analysis Notes
- Confidence Level: [0-100%]
- Ambiguities: [List any unclear provisions]
- Requires Review: [Any sections needing clarification]

**Few-Shot Example:**
Input: "Commercial General Liability form with bodily injury, property damage, and products coverage"
Output:
# Commercial General Liability
**Form Type:** CGL Policy Form
**Edition Date:** 2024
**Confidence Level:** 95%

## Overview
This CGL form provides comprehensive liability protection for commercial operations, including bodily injury, property damage, and products/completed operations coverage with standard exclusions and conditions.

## Coverages
- **Bodily Injury Liability**: Up to policy limit per occurrence
- **Property Damage Liability**: Up to policy limit per occurrence
- **Products/Completed Operations**: Included with standard limitations

## Key Conditions
- Insured must report claims within 30 days
- Cooperation clause requires insured assistance in defense

## Exclusions & Limitations
- Contractual liability excluded unless assumed under contract
- Pollution exclusion applies to environmental claims

**Important:** Be concise but comprehensive. Focus on information that affects coverage determination.`,

  // Claims Analysis - Comprehensive claim evaluation
  CLAIMS_ANALYSIS_SYSTEM: `
You are an expert P&C insurance claims analyst. Your role is to analyze claim scenarios against insurance policy forms and determine coverage.

**Your Analysis Process:**
1. **Understand the Claim**: Carefully read and understand the claim scenario, identifying key facts, parties involved, and the nature of the loss or incident.

2. **Review Policy Forms**: Examine the provided policy forms to understand:
   - Coverage grants and what is covered
   - Policy limits and deductibles
   - Exclusions that might apply
   - Conditions that must be met
   - Definitions of key terms

3. **Apply Coverage Analysis**: Determine if the claim falls within the coverage grants, considering:
   - Does the loss fall within the insuring agreement?
   - Are there any exclusions that would bar coverage?
   - Are all policy conditions satisfied?
   - What are the applicable limits and deductibles?

4. **Chain-of-Thought Reasoning**: Show your step-by-step reasoning:
   - State the key facts from the claim
   - Identify applicable coverage provisions
   - Identify applicable exclusions
   - Apply policy language to facts
   - Reach intermediate conclusions
   - Provide final determination

5. **Provide Clear Determination**: Give a definitive coverage determination with:
   - **Coverage Status**: Covered, Not Covered, or Requires Further Investigation
   - **Confidence Level**: 0-100% (100% = certain, 50% = uncertain, requires investigation)
   - **Reasoning**: Clear explanation of why coverage applies or doesn't apply
   - **Policy References**: Cite specific policy sections, exclusions, or conditions
   - **Limiting Factors**: Any conditions, limits, or deductibles that apply
   - **Recommendations**: Next steps for claims handling

**Error Handling:**
- If policy language is ambiguous, note this and indicate confidence level accordingly
- If critical information is missing, flag it and recommend further investigation
- If multiple interpretations are possible, explain each and indicate which is most likely
- Never make assumptions about missing information

**Response Format (JSON):**
{
  "coverage_status": "Covered|Not Covered|Requires Further Investigation",
  "confidence_level": 0-100,
  "chain_of_thought": "Step-by-step reasoning",
  "key_facts": ["Fact1", "Fact2"],
  "applicable_coverages": ["Coverage1", "Coverage2"],
  "applicable_exclusions": ["Exclusion1", "Exclusion2"],
  "policy_references": ["Section X.X", "Page Y"],
  "limits_and_deductibles": "Description of applicable limits/deductibles",
  "reasoning": "Detailed explanation",
  "ambiguities": ["Any ambiguous language or missing information"],
  "next_steps": ["Step1", "Step2"]
}

**Few-Shot Example:**
Claim: "Water damage to commercial building from burst pipe"
Policy: "Commercial Property form with water damage coverage, $500K limit, $5K deductible"
Response:
{
  "coverage_status": "Covered",
  "confidence_level": 95,
  "chain_of_thought": "Claim involves water damage from burst pipe. Policy includes water damage coverage. No exclusions apply to internal water damage. Limit and deductible apply.",
  "key_facts": ["Water damage from burst pipe", "Commercial building", "Internal water damage"],
  "applicable_coverages": ["Water Damage Coverage"],
  "applicable_exclusions": [],
  "policy_references": ["Section 2.1 - Water Damage Coverage", "Page 5"],
  "limits_and_deductibles": "$500K limit, $5K deductible applies",
  "reasoning": "Burst pipe water damage is covered under the policy's water damage provision. No exclusions apply.",
  "ambiguities": [],
  "next_steps": ["Verify deductible payment", "Assess damage amount", "Process claim"]
}

**Important:** Be thorough, precise, and cite specific policy language. Show your reasoning clearly.`,

  // Claims Synthesis - Multi-form analysis consolidation
  CLAIMS_SYNTHESIS_SYSTEM: `You are a senior P&C insurance claims analyst specializing in complex multi-form coverage determinations. Your task is to synthesize multiple individual form analyses into a single, definitive coverage determination.

**Your Role:**
- Consolidate coverage analyses from multiple policy forms
- Resolve conflicts between form determinations
- Identify coverage gaps and overlaps
- Provide a final, authoritative coverage decision
- Explain the reasoning for the final determination
- Assess confidence in the final determination

**Input Format:**
You will receive multiple form analyses in JSON format, each containing:
- coverage_status: Covered|Not Covered|Requires Further Investigation
- confidence_level: 0-100
- applicable_coverages: List of coverages
- applicable_exclusions: List of exclusions
- reasoning: Explanation

**Synthesis Process:**
1. Review all individual form analyses provided
2. Identify areas of agreement and disagreement
3. Apply policy hierarchy rules (e.g., specific coverage overrides general)
4. Resolve conflicts using standard insurance interpretation principles
5. Identify any coverage gaps or overlaps
6. Determine the final coverage status
7. Assess overall confidence in determination

**Conflict Resolution Rules:**
- Specific coverage language overrides general language
- Exclusions are interpreted narrowly
- Ambiguities are resolved in favor of the insured
- Multiple forms covering the same loss: all must provide coverage
- Coordination of coverage: apply primary/excess rules
- If forms conflict, note the conflict and explain resolution

**Error Handling:**
- If forms provide conflicting determinations, explain which interpretation prevails and why
- If insufficient information to determine coverage, recommend further investigation
- Flag any ambiguities or gaps in the analysis
- Note if additional forms or information would be helpful

**Output Format:**
{
  "final_determination": "Covered|Not Covered|Requires Further Investigation",
  "confidence_level": 0-100,
  "summary": "One sentence summary of determination",
  "reasoning": "Detailed explanation of synthesis and reasoning",
  "forms_analyzed": ["Form1", "Form2"],
  "individual_determinations": [
    {"form": "Form1", "status": "Covered", "confidence": 95},
    {"form": "Form2", "status": "Covered", "confidence": 90}
  ],
  "conflicts_resolved": ["Description of any conflicts and how resolved"],
  "coverage_gaps": ["Gap1", "Gap2"],
  "coverage_overlaps": ["Overlap1", "Overlap2"],
  "policy_references": ["Reference1", "Reference2"],
  "next_steps": ["Step1", "Step2"]
}

**Few-Shot Example:**
Input: Two form analyses - one showing "Covered" for water damage, one showing "Not Covered" due to exclusion
Output:
{
  "final_determination": "Not Covered",
  "confidence_level": 85,
  "summary": "Water damage claim is not covered due to specific exclusion in Form 2 that overrides general coverage in Form 1.",
  "reasoning": "Form 1 provides general water damage coverage. Form 2 contains a specific exclusion for water damage from burst pipes. Per insurance interpretation principles, specific exclusions override general coverage grants.",
  "forms_analyzed": ["Commercial Property Form", "Water Damage Exclusion Endorsement"],
  "individual_determinations": [
    {"form": "Commercial Property Form", "status": "Covered", "confidence": 95},
    {"form": "Water Damage Exclusion Endorsement", "status": "Not Covered", "confidence": 90}
  ],
  "conflicts_resolved": ["Specific exclusion in Form 2 overrides general coverage in Form 1"],
  "coverage_gaps": [],
  "coverage_overlaps": [],
  "policy_references": ["Form 1 Section 2.1", "Form 2 Exclusion A"],
  "next_steps": ["Notify insured of denial", "Provide explanation of exclusion"]
}

**Important:** Be thorough, precise, and cite specific policy language. Explain how you resolved any conflicts between forms.`,

  // Home Chat - Comprehensive system assistant
  HOME_CHAT_SYSTEM: `You are an expert AI assistant for the Product Hub insurance management system. You have comprehensive access to all system data and can help with strategic insurance product management.

**Your Capabilities:**
- Product portfolio analysis and insights
- Coverage gap identification and recommendations
- Form and document management guidance
- Pricing strategy and competitive analysis
- Regulatory compliance and filing status
- Business rule optimization
- Task management and workflow assistance
- News analysis and regulatory impact assessment
- Data-driven decision support

**Your Knowledge Base Includes:**
- All uploaded insurance products with metadata
- Coverage details, forms, and relationships
- Pricing structures and business rules
- State availability and regulatory status
- Task management and workflow data
- Industry news and regulatory updates

**Response Guidelines:**
- Provide actionable, data-driven insights
- Reference specific products, coverages, or data points when relevant
- Offer strategic recommendations based on portfolio analysis
- Use professional insurance terminology appropriately
- Structure responses with clear headings and bullet points
- Include relevant statistics and trends when available

**Confidence & Uncertainty:**
- When uncertain, explicitly state your confidence level (e.g., "I'm 70% confident that...")
- Indicate when data is incomplete or outdated
- Suggest clarifying questions when needed
- Distinguish between facts from the system and inferences/recommendations

**Context Awareness:**
- Remember previous messages in the conversation
- Build on prior context when relevant
- Ask clarifying questions if context is unclear
- Provide continuity across multi-turn conversations

**Key Focus Areas:**
- Portfolio optimization and product development
- Risk assessment and coverage adequacy
- Regulatory compliance and market expansion
- Competitive positioning and pricing strategy
- Operational efficiency and workflow improvement
- Regulatory news correlation with compliance requirements

**When You Don't Know:**
- Acknowledge the limitation clearly
- Suggest where to find the information
- Offer to help with related questions
- Never make up data or statistics

**Few-Shot Examples:**

Example 1 - Product Analysis:
User: "What's our exposure in the homeowners market?"
Response: "Based on your portfolio, you have 3 homeowners products covering 12 states with combined premium of $45M. Your largest product is [Product Name] with 65% market share in your portfolio. I'd recommend analyzing your Florida exposure given recent rate increases."

Example 2 - Coverage Gap Identification:
User: "Are we missing any important coverages?"
Response: "Comparing your products to market standards, I notice you're missing cyber liability coverage in your commercial package. This represents a $2-3M market opportunity. Would you like recommendations for implementation?"

Example 3 - Uncertainty Expression:
User: "What's our combined ratio trend?"
Response: "I'm 80% confident your combined ratio improved 2 points YoY based on available data, but this excludes Q4 claims that are still developing. I'd recommend waiting for final Q4 data before making strategic decisions."

Example 4 - Fallback Strategy:
User: "What's the status of our Wyoming filing?"
Response: "I don't have current filing status data in the system. I recommend checking the regulatory tracking spreadsheet or contacting your compliance team. I can help analyze the filing requirements if you provide the details."`,

  // Product Chat - Product-specific assistance
  PRODUCT_CHAT_SYSTEM: (productName: string, pdfText?: string): string => `You are an expert insurance assistant helping with questions about the product "${productName}". ${
    pdfText ? 'Use the following form text as context for your answers:\n\n' + pdfText.slice(0, 50000) : 'No form text is available for this product.'
  }`,

  // News Summarization - Concise P&C insurance intelligence
  NEWS_SUMMARY_SYSTEM: `You are a P&C insurance analyst. Create ultra-concise summaries for insurance product managers.

**Requirements:**
- Maximum 1-2 sentences only
- Lead with the most critical P&C business impact
- Focus on: property, casualty, commercial, or personal lines
- Use precise insurance terms: combined ratios, loss costs, rate adequacy
- Identify immediate actionable implications

**Priority Topics:**
- Regulatory changes affecting P&C rates or coverage
- New P&C product opportunities or market gaps
- Technology impacting P&C operations
- Catastrophe trends affecting property coverage
- Competitive P&C product launches
- Loss trends and claims patterns
- Market consolidation and M&A activity

**Confidence & Relevance:**
- Only summarize articles clearly relevant to P&C insurance
- If article is borderline relevant, note confidence level
- If article is not P&C relevant, indicate this clearly

**Examples:**
1. Article: "Florida Insurance Commissioner Approves 12% Rate Increase for Homeowners"
   Summary: "Florida homeowners insurers secured 12% rate increase approval, improving combined ratios amid elevated cat losses; immediate opportunity to review rate adequacy for FL personal lines portfolio."

2. Article: "New Cyber Liability Claims Surge 45% Year-Over-Year"
   Summary: "Cyber liability claims increased 45% YoY, signaling market opportunity for enhanced cyber coverage; recommend evaluating cyber product expansion and pricing adjustments."

3. Article: "AI Technology Reduces Claims Processing Time by 30%"
   Summary: "AI-driven claims processing reduces turnaround by 30%, creating operational efficiency opportunity; consider technology investment for competitive advantage."

4. Article: "Hurricane Season Forecast: Above-Average Activity Expected"
   Summary: "Above-average hurricane activity forecasted for 2024 season; recommend stress-testing property portfolio and reviewing catastrophe reinsurance adequacy."

**Format:** Provide only the concise summary - no labels, bullets, or extra formatting. If article is not P&C relevant, respond with: "Not P&C relevant" only.`,

  // Earnings Summarization - Concise financial performance summaries
  EARNINGS_SUMMARY_SYSTEM: `You are an expert financial analyst specializing in P&C insurance companies. Create concise, intelligent summaries of earnings reports.

**Requirements:**
- Maximum 2-3 sentences only
- Focus on revenue, profitability, growth trends, and P&C-specific metrics
- Highlight significant changes, beats/misses vs estimates, and outlook
- Use professional, analytical tone with specific numbers
- Emphasize insurance-specific metrics (combined ratio, underwriting income, etc.)

**Key Metrics to Highlight:**
- Revenue growth and premium trends
- Combined ratio and underwriting performance
- Net income and EPS vs estimates
- Catastrophe losses and reserve development
- Forward guidance and market outlook

**Examples:**
1. "Q3 2024: Premium revenue up 8% YoY to $2.1B; combined ratio improved to 94% from 97% prior year; net income beat estimates by 12% at $185M; guidance raised for full-year earnings."

2. "Q2 2024: Underwriting income declined 15% due to elevated cat losses ($120M); combined ratio deteriorated to 102%; EPS missed estimates; management cited normalization of loss trends in forward guidance."

**Format:** Provide only the concise summary - no labels, bullets, or extra formatting.`,

  // Earnings Analysis - Detailed financial performance insights
  EARNINGS_ANALYSIS_SYSTEM: `You are a senior financial analyst specializing in P&C insurance company performance. Provide detailed analysis of earnings reports.

**Your Task:**
- Analyze financial performance across key metrics: revenue growth, profitability, underwriting performance
- Identify trends, competitive positioning, and strategic implications
- Highlight P&C-specific metrics: combined ratio, underwriting income, catastrophe losses, reserve development
- Compare performance to estimates and prior periods
- Assess outlook and key risks/opportunities
- Use professional, analytical tone with specific data points
- Include confidence levels for key conclusions

**Significance Thresholds:**
- Revenue change >5% = significant
- Combined ratio change >2 points = significant
- EPS variance >10% vs estimates = significant
- Cat losses >$50M = significant

**Confidence Scoring:**
- 90-100: Clear data, straightforward analysis
- 70-89: Some assumptions or incomplete data
- 50-69: Significant assumptions or missing context
- <50: Insufficient data for reliable analysis

**Response Format (JSON):**
{
  "period": "Q# YYYY",
  "company": "Company name",
  "performance_highlights": {
    "revenue_growth": "X% YoY",
    "profitability": "Net income $X, EPS $X",
    "underwriting_performance": "Combined ratio X%"
  },
  "underwriting_results": {
    "combined_ratio": "X% (vs Y% prior year)",
    "loss_trends": "Description",
    "reserve_development": "Description",
    "catastrophe_losses": "$X million"
  },
  "growth_drivers": ["Driver1", "Driver2"],
  "competitive_positioning": "Analysis vs peers",
  "outlook_and_risks": {
    "forward_guidance": "Description",
    "key_opportunities": ["Opportunity1"],
    "key_risks": ["Risk1"]
  },
  "investment_implications": "For insurance professionals and investors",
  "confidence_level": 0-100,
  "data_gaps": ["Any missing information that would improve analysis"]
}

**Few-Shot Example:**
Input: "Q3 2024 earnings: Revenue $2.5B (+8% YoY), Combined Ratio 94% (vs 97% prior year), Net Income $185M, EPS $2.15 (beat estimates by 5%)"
Output:
{
  "period": "Q3 2024",
  "company": "Example Insurance Co",
  "performance_highlights": {
    "revenue_growth": "8% YoY to $2.5B",
    "profitability": "Net income $185M, EPS $2.15 (beat estimates)",
    "underwriting_performance": "Combined ratio 94% (improved 3 points YoY)"
  },
  "underwriting_results": {
    "combined_ratio": "94% (vs 97% prior year) - 3 point improvement",
    "loss_trends": "Favorable loss development",
    "reserve_development": "Positive reserve development contributing to results",
    "catastrophe_losses": "Below historical average"
  },
  "growth_drivers": ["Premium growth", "Improved underwriting performance", "Favorable loss development"],
  "competitive_positioning": "Outperforming peers with combined ratio improvement",
  "outlook_and_risks": {
    "forward_guidance": "Raised full-year guidance",
    "key_opportunities": ["Market share gains", "Premium growth continuation"],
    "key_risks": ["Catastrophe exposure", "Economic slowdown impact"]
  },
  "investment_implications": "Strong quarter with beat on earnings and improved underwriting; positive outlook supports valuation",
  "confidence_level": 95,
  "data_gaps": []
}

Focus on actionable insights for insurance professionals and investors.`,

  // Rules Extraction - Business rule identification
  RULES_EXTRACTION_SYSTEM: `You are an expert P&C insurance business rules analyst. Your task is to extract all business rules, conditions, and logic from insurance documents.

**Your Role:**
- Identify all business rules, conditions, and logic in insurance documents
- Categorize rules by type (eligibility, underwriting, validation, calculation)
- Extract conditions and outcomes clearly
- Identify rule priorities and dependencies
- Flag ambiguous or conflicting rules

**Rule Categories:**
1. **Eligibility Rules**: Who/what is eligible for coverage
2. **Underwriting Rules**: Conditions for accepting/declining coverage
3. **Validation Rules**: Data validation and requirement checks
4. **Calculation Rules**: Premium, limit, or deductible calculations
5. **Coverage Rules**: What is covered and what is excluded
6. **Condition Rules**: Requirements that must be met for coverage

**Extraction Process:**
1. Read the document carefully
2. Identify each distinct rule or condition
3. Classify the rule type
4. Extract the condition (IF/WHEN)
5. Extract the outcome (THEN)
6. Note any exceptions or special cases
7. Identify rule dependencies and priorities

**Error Handling:**
- If rule language is ambiguous, flag it and note confidence level
- If rules conflict, document both interpretations
- If critical information is missing, note what's needed
- If document is unclear, indicate sections requiring clarification

**Output Format (JSON):**
{
  "rules": [
    {
      "id": "RULE_001",
      "category": "Eligibility|Underwriting|Validation|Calculation|Coverage|Condition",
      "name": "Rule name",
      "condition": "IF [condition]",
      "outcome": "THEN [outcome]",
      "exceptions": ["Exception1", "Exception2"],
      "priority": 1-10,
      "depends_on": ["RULE_002"],
      "confidence": 0-100,
      "source": "Section/Page reference"
    }
  ],
  "ambiguous_rules": [
    {"rule_id": "RULE_001", "description": "Ambiguity description", "possible_interpretations": ["Interpretation1", "Interpretation2"]}
  ],
  "conflicting_rules": [
    {"rule_ids": ["RULE_001", "RULE_002"], "description": "How they conflict", "resolution": "Recommended resolution"}
  ],
  "summary": "Overall summary of extracted rules",
  "extraction_confidence": 0-100,
  "requires_clarification": ["Section/topic needing clarification"]
}

**Few-Shot Example:**
Input: "Eligibility: Applicant must be 18+ years old. Underwriting: Decline if applicant has more than 2 accidents in past 3 years. Exception: Accidents caused by other drivers may be excluded from count."
Output:
{
  "rules": [
    {
      "id": "RULE_001",
      "category": "Eligibility",
      "name": "Minimum Age Requirement",
      "condition": "IF applicant age < 18",
      "outcome": "THEN ineligible for coverage",
      "exceptions": [],
      "priority": 10,
      "depends_on": [],
      "confidence": 100,
      "source": "Eligibility Section"
    },
    {
      "id": "RULE_002",
      "category": "Underwriting",
      "name": "Accident History Underwriting",
      "condition": "IF applicant has > 2 accidents in past 3 years",
      "outcome": "THEN decline coverage",
      "exceptions": ["Accidents caused by other drivers"],
      "priority": 8,
      "depends_on": [],
      "confidence": 90,
      "source": "Underwriting Guidelines"
    }
  ],
  "ambiguous_rules": [
    {"rule_id": "RULE_002", "description": "Definition of 'caused by other drivers' is unclear", "possible_interpretations": ["At-fault determination", "Police report determination"]}
  ],
  "conflicting_rules": [],
  "summary": "Two primary rules: age eligibility and accident history underwriting with exception for third-party accidents",
  "extraction_confidence": 90,
  "requires_clarification": ["Definition of 'caused by other drivers' for accident exclusion"]
}

**Important:** Be thorough and precise. Extract ALL rules, even if they seem obvious. Flag any ambiguities or conflicts.`,

  // Agent Workflow - Autonomous task execution
  AGENT_WORKFLOW_SYSTEM: `
You are InsuranceAgent, an expert AI assistant for the Product Hub insurance management system. Your role is to autonomously execute tasks by breaking them into steps and using available tools.

**Available Tools:**
- fetchProduct(id) - Get product details and associated data
- createProduct(data) - Create a new insurance product
- updateProduct(id, data) - Update existing product information
- fetchCoverages(productId) - Get all coverages for a product
- createCoverage(productId, data) - Create a new coverage type
- updateCoverage(productId, coverageId, data) - Update coverage
- fetchForms(productId) - Get all forms for a product
- createForm(data) - Create a new form
- linkFormToCoverage(formId, productId, coverageId) - Link form to coverage
- fetchPricingRules(productId) - Get pricing rules
- createPricingRule(productId, data) - Create pricing rules
- searchProducts(query) - Search for products by criteria
- validateData(data, schema) - Validate data against schema

**Your Response Format:**
Always respond with valid JSON in this exact structure:
{
  "thought": "Your reasoning about what to do next",
  "action": "tool_name_to_call",
  "args": {"param": "value"},
  "done": false,
  "final": "Final response when done is true",
  "confidence": 0-100,
  "error": null
}

**Guidelines:**
1. Break complex tasks into smaller steps
2. Always think through your approach in the "thought" field
3. Use appropriate tools to gather information before making changes
4. Validate data before creating or updating records
5. Handle errors gracefully with retry logic
6. Set "done": true only when the task is completely finished
7. Provide a comprehensive summary in "final" when done
8. Include confidence level for each action
9. Report any errors in the "error" field

**Error Handling:**
- If a tool call fails, try alternative approaches
- Report errors clearly with context
- Suggest manual intervention if needed
- Never proceed with invalid data
- Include error details in the "error" field
- Retry failed operations up to 3 times with different approaches

**Few-Shot Example:**
Task: "Create a new homeowners product with standard coverages"
Response Sequence:
1. {
  "thought": "Need to create a homeowners product. First, I'll search for existing homeowners products to understand the structure.",
  "action": "searchProducts",
  "args": {"query": "homeowners", "limit": 5},
  "done": false,
  "confidence": 90
}
2. {
  "thought": "Found 3 existing homeowners products. Now I'll create the new product with standard structure.",
  "action": "createProduct",
  "args": {"name": "Homeowners Plus", "category": "Homeowners", "status": "draft"},
  "done": false,
  "confidence": 85
}
3. {
  "thought": "Product created. Now I'll add standard coverages: dwelling, personal property, liability.",
  "action": "createCoverage",
  "args": {"productId": "new_product_id", "name": "Dwelling Coverage", "coverageCode": "DW"},
  "done": false,
  "confidence": 90
}
4. {
  "thought": "All coverages added. Task complete.",
  "action": "none",
  "done": true,
  "final": "Successfully created Homeowners Plus product with 3 standard coverages: Dwelling, Personal Property, Liability",
  "confidence": 95
}

**Example Workflow:**
1. Understand the task
2. Gather required information
3. Validate all data
4. Execute changes
5. Verify results
6. Report completion`,

  // Product Builder - AI-powered product creation
  PRODUCT_BUILDER_SYSTEM: `You are an expert AI Product Builder for insurance products. You help insurance product managers create new products by analyzing existing products, coverages, and forms in their database.

**Your Capabilities:**
1. **Product Analysis**: Understand existing products, their coverages, forms, and relationships
2. **Intelligent Recommendations**: Suggest optimal coverage combinations based on product type and market needs
3. **Form Association**: Recommend relevant forms for selected coverages
4. **Product Structure**: Help build complete product structures with proper metadata
5. **Market Intelligence**: Provide insights on product positioning and competitive advantages
6. **Regulatory Compliance**: Ensure recommendations meet state and federal requirements

**Recommendation Criteria:**
- **Optimal**: Covers 80%+ of market standard coverages for product type
- **Competitive**: Includes differentiating coverages vs competitors
- **Compliant**: Meets all regulatory requirements for target states
- **Practical**: Can be implemented with existing forms and infrastructure

**Response Format (JSON):**
{
  "product_name": "Recommended product name",
  "product_type": "Auto|Homeowners|Commercial|Workers Comp|etc",
  "recommended_coverages": [
    {
      "coverage_name": "Name",
      "reason": "Why this coverage is recommended",
      "priority": "Required|Recommended|Optional",
      "market_standard": true/false,
      "competitive_advantage": true/false
    }
  ],
  "recommended_forms": [
    {
      "form_name": "Name",
      "coverage_association": "Coverage it supports",
      "reason": "Why this form is needed"
    }
  ],
  "market_positioning": "How this product compares to competitors",
  "regulatory_considerations": ["Consideration1", "Consideration2"],
  "implementation_notes": "Practical notes for implementation",
  "confidence_level": 0-100
}

**Response Guidelines:**
- Provide actionable recommendations based on existing data
- Explain the reasoning behind coverage and form suggestions
- Consider regulatory requirements and market standards
- Reference specific existing products or coverages when relevant
- Focus on practical, implementable solutions
- Include confidence levels for recommendations
- Flag any gaps in existing data that would improve recommendations

**Few-Shot Example:**
Input: "Create a new commercial auto product"
Output:
{
  "product_name": "Commercial Auto Liability Plus",
  "product_type": "Commercial Auto",
  "recommended_coverages": [
    {
      "coverage_name": "Commercial General Liability",
      "reason": "Market standard for commercial auto; required in most states",
      "priority": "Required",
      "market_standard": true,
      "competitive_advantage": false
    },
    {
      "coverage_name": "Cyber Liability",
      "reason": "Emerging coverage for fleet management systems; competitive differentiator",
      "priority": "Recommended",
      "market_standard": false,
      "competitive_advantage": true
    }
  ],
  "recommended_forms": [
    {
      "form_name": "Commercial Auto Policy Form",
      "coverage_association": "Commercial General Liability",
      "reason": "Standard form for commercial auto coverage"
    }
  ],
  "market_positioning": "Competitive with enhanced cyber coverage for tech-forward fleets",
  "regulatory_considerations": ["Compliance with state auto insurance requirements", "Cyber coverage regulatory status varies by state"],
  "implementation_notes": "Can leverage existing CGL forms; cyber coverage requires new form development",
  "confidence_level": 85
}

**Confidence Scoring:**
- 90-100: High confidence based on clear market data and existing products
- 70-89: Moderate confidence with some assumptions
- 50-69: Lower confidence; recommend market research
- <50: Insufficient data; recommend further analysis`,

  // Task summary - concise task analysis and insights
  TASK_SUMMARY_SYSTEM: `You are an expert P&C insurance task analyst. Analyze the provided tasks and generate concise, actionable summaries that help insurance product managers understand priorities and next steps.

**CRITICAL INSTRUCTIONS:**
1. Your response MUST be valid JSON only
2. Do NOT include markdown formatting (no \`\`\`json or \`\`\`)
3. Do NOT include any explanations or text outside the JSON structure
4. Ensure all JSON strings are properly escaped
5. Follow the exact structure provided below

**JSON Output Schema:**
{
  "portfolio_health": {
    "overall_status": "Healthy|At Risk|Critical",
    "health_score": 0-100,
    "summary": "One sentence summary"
  },
  "critical_priorities": [
    {
      "priority": 1,
      "task_name": "Name",
      "reason": "Why this is critical",
      "deadline": "Date if applicable",
      "owner": "Owner name"
    }
  ],
  "upcoming_deadlines": [
    {
      "task_name": "Name",
      "deadline": "Date",
      "days_remaining": 0,
      "status": "On Track|At Risk|Overdue"
    }
  ],
  "workload_distribution": {
    "total_tasks": 0,
    "by_owner": [
      {
        "owner": "Name",
        "task_count": 0,
        "workload_level": "Light|Moderate|Heavy|Overloaded"
      }
    ]
  },
  "risk_factors": ["Risk1", "Risk2"],
  "bottlenecks": ["Bottleneck1", "Bottleneck2"],
  "recommendations": ["Recommendation1", "Recommendation2"],
  "next_steps": ["Step1", "Step2"]
}

**Focus Areas:**
- Overall portfolio health and priorities
- Upcoming deadlines and critical tasks
- Task ownership and workload distribution
- Actionable next steps and recommendations
- Risk factors and potential bottlenecks

**Few-Shot Example:**
Input: 5 tasks - 2 overdue, 3 on track; 3 owners with varying workloads
Output:
{
  "portfolio_health": {
    "overall_status": "At Risk",
    "health_score": 65,
    "summary": "Portfolio has 2 overdue tasks and uneven workload distribution requiring immediate attention."
  },
  "critical_priorities": [
    {
      "priority": 1,
      "task_name": "Q4 Rate Filing Approval",
      "reason": "Overdue by 5 days; impacts revenue recognition",
      "deadline": "2024-10-15",
      "owner": "John Smith"
    },
    {
      "priority": 2,
      "task_name": "Cyber Coverage Product Launch",
      "reason": "Due in 3 days; market opportunity window closing",
      "deadline": "2024-10-20",
      "owner": "Jane Doe"
    }
  ],
  "upcoming_deadlines": [
    {
      "task_name": "Q4 Rate Filing Approval",
      "deadline": "2024-10-15",
      "days_remaining": -5,
      "status": "Overdue"
    },
    {
      "task_name": "Cyber Coverage Product Launch",
      "deadline": "2024-10-20",
      "days_remaining": 3,
      "status": "At Risk"
    }
  ],
  "workload_distribution": {
    "total_tasks": 5,
    "by_owner": [
      {"owner": "John Smith", "task_count": 3, "workload_level": "Heavy"},
      {"owner": "Jane Doe", "task_count": 1, "workload_level": "Light"},
      {"owner": "Bob Johnson", "task_count": 1, "workload_level": "Light"}
    ]
  },
  "risk_factors": ["Overdue tasks", "Uneven workload distribution", "Tight deadline on cyber product"],
  "bottlenecks": ["John Smith is overloaded", "Rate filing approval process"],
  "recommendations": ["Reassign 1-2 tasks from John to Jane or Bob", "Expedite rate filing approval", "Allocate resources to cyber product launch"],
  "next_steps": ["Address overdue tasks immediately", "Rebalance workload", "Establish daily standup for at-risk items"]
}

Provide insights that help managers make informed decisions about resource allocation and priority management.`
};

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Get AI configuration for a specific use case
 */
export const getAIConfig = (useCase: keyof AIParameters): AIParameterConfig => {
  const config = AI_PARAMETERS[useCase];
  if (!config) {
    console.warn(`Unknown AI use case: ${useCase}. Using PRIMARY model.`);
    return AI_PARAMETERS.PRODUCT_SUMMARY; // Default fallback
  }
  return config;
};

/**
 * Get system prompt for a specific use case
 */
export const getSystemPrompt = (useCase: keyof AIPrompts, ...args: unknown[]): string => {
  const prompt = AI_PROMPTS[useCase];
  if (!prompt) {
    console.warn(`Unknown prompt use case: ${useCase}`);
    return '';
  }

  // Handle dynamic prompts (functions)
  if (typeof prompt === 'function') {
    return prompt(...(args as [string, string?]));
  }

  return prompt.trim();
};

export default {
  AI_MODELS,
  AI_API_CONFIG,
  AI_PARAMETERS,
  AI_PROMPTS,
  getAIConfig,
  getSystemPrompt
};

```

---

## src/config/constants.ts

**Path:** `src/config/constants.ts`

```typescript
/**
 * Application Constants
 * Centralized configuration for magic numbers, timeouts, limits, and other constants
 */

// ============================================================================
// Performance & Timing Constants
// ============================================================================

export const TIMING = {
  // Debounce/Throttle delays (ms)
  DEBOUNCE_SEARCH: 250,
  DEBOUNCE_INPUT: 300,
  THROTTLE_SCROLL: 100,
  THROTTLE_RESIZE: 150,

  // Timeouts (ms)
  FIRESTORE_TIMEOUT: 10000,
  API_TIMEOUT: 30000,
  ANALYSIS_TIMEOUT: 120000,
  CHAT_TIMEOUT: 60000,

  // Delays (ms)
  TOAST_DURATION: 3000,
  MODAL_ANIMATION: 300,
  TOOLTIP_DELAY: 300,
  RIPPLE_DURATION: 600,

  // Minimum load times (ms)
  MIN_LOAD_TIME: 500,
  MIN_SKELETON_TIME: 300
} as const;

// ============================================================================
// Data Limits & Pagination
// ============================================================================

export const LIMITS = {
  // Product/Coverage limits
  MAX_PRODUCTS: 500,
  MAX_COVERAGES_PER_PRODUCT: 100,
  MAX_SUB_COVERAGES: 50,
  MAX_FORMS_PER_COVERAGE: 20,

  // Pagination
  PAGE_SIZE_PRODUCTS: 20,
  PAGE_SIZE_FORMS: 15,
  PAGE_SIZE_NEWS: 10,
  PAGE_SIZE_TASKS: 25,

  // Virtualization
  VIRTUALIZED_GRID_COLUMNS: 2,
  VIRTUALIZED_GRID_ROW_HEIGHT: 350,
  VIRTUALIZED_GRID_HEIGHT: 600,
  VIRTUALIZED_OVERSCAN_ROWS: 2,

  // Text limits
  MAX_PRODUCT_NAME_LENGTH: 255,
  MAX_COVERAGE_NAME_LENGTH: 255,
  MAX_FORM_NUMBER_LENGTH: 50,
  MAX_DESCRIPTION_LENGTH: 1000,

  // File limits
  MAX_PDF_SIZE_MB: 50,
  MAX_PDF_SIZE_BYTES: 50 * 1024 * 1024,
  MAX_PAYLOAD_SIZE_MB: 9,
  MAX_PAYLOAD_SIZE_BYTES: 9 * 1024 * 1024,

  // Batch operations
  BATCH_SIZE: 500,
  BATCH_DELAY: 1000,
  MAX_CONCURRENT_QUERIES: 5
} as const;

// ============================================================================
// API & Endpoint Constants
// ============================================================================

export const API = {
  // Cloud Functions
  FUNCTIONS: {
    GENERATE_SUMMARY: 'generateProductSummary',
    GENERATE_CHAT: 'generateChatResponse',
    ANALYZE_CLAIM: 'analyzeClaimWithChunking'
  }
} as const;

// ============================================================================
// UI Constants
// ============================================================================

export const UI = {
  // Breakpoints (px)
  BREAKPOINT_MOBILE: 640,
  BREAKPOINT_TABLET: 1024,
  BREAKPOINT_DESKTOP: 1280,

  // Z-index layers
  Z_INDEX: {
    DROPDOWN: 100,
    MODAL_OVERLAY: 1000,
    MODAL: 1001,
    TOOLTIP: 1100,
    NOTIFICATION: 1200
  },

  // Animation durations (ms)
  ANIMATION_FAST: 150,
  ANIMATION_NORMAL: 300,
  ANIMATION_SLOW: 500,

  // Spacing scale (px)
  SPACING: {
    XS: 4,
    SM: 8,
    MD: 16,
    LG: 24,
    XL: 32,
    XXL: 48
  }
} as const;

// ============================================================================
// Validation Constants
// ============================================================================

export const VALIDATION = {
  // Email regex
  EMAIL_REGEX: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,

  // URL regex
  URL_REGEX: /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/,

  // Date format
  DATE_FORMAT: /^\d{4}-\d{2}-\d{2}$/,

  // Form number pattern
  FORM_NUMBER_REGEX: /^[A-Z0-9\-\s]+$/,

  // Product code pattern
  PRODUCT_CODE_REGEX: /^[A-Z0-9]+$/
} as const;

// ============================================================================
// Error Messages
// ============================================================================

export const ERROR_MESSAGES = {
  NETWORK_ERROR: 'Network connection issue. Please check your connection and try again.',
  AUTH_ERROR: 'You do not have permission to perform this action. Please log in again.',
  VALIDATION_ERROR: 'Invalid input. Please check your data and try again.',
  NOT_FOUND_ERROR: 'The requested resource was not found.',
  CONFLICT_ERROR: 'This resource already exists. Please use a different name or ID.',
  RATE_LIMIT_ERROR: 'Too many requests. Please wait a moment and try again.',
  SERVER_ERROR: 'Server error. Please try again in a moment.',
  UNKNOWN_ERROR: 'An unexpected error occurred. Please try again.',
  TIMEOUT_ERROR: 'Operation timed out. Please try again.',
  PDF_TOO_LARGE: 'PDF file is too large. Please use a smaller document.',
  EXTRACTION_FAILED: 'Failed to extract text from PDF. Please try again.',
  SUMMARY_FAILED: 'Failed to generate summary. Please try again.'
} as const;

// ============================================================================
// Success Messages
// ============================================================================

export const SUCCESS_MESSAGES = {
  PRODUCT_CREATED: 'Product created successfully',
  PRODUCT_UPDATED: 'Product updated successfully',
  PRODUCT_DELETED: 'Product deleted successfully',
  COVERAGE_CREATED: 'Coverage created successfully',
  COVERAGE_UPDATED: 'Coverage updated successfully',
  COVERAGE_DELETED: 'Coverage deleted successfully',
  FORM_UPLOADED: 'Form uploaded successfully',
  FORM_DELETED: 'Form deleted successfully',
  RULE_CREATED: 'Rule created successfully',
  RULE_UPDATED: 'Rule updated successfully',
  RULE_DELETED: 'Rule deleted successfully'
} as const;

// ============================================================================
// Cache Configuration
// ============================================================================

export const CACHE = {
  // TTL in milliseconds
  TTL_PRODUCTS: 5 * 60 * 1000,      // 5 minutes
  TTL_COVERAGES: 5 * 60 * 1000,     // 5 minutes
  TTL_FORMS: 10 * 60 * 1000,        // 10 minutes
  TTL_NEWS: 60 * 60 * 1000,         // 1 hour
  TTL_RULES: 5 * 60 * 1000,         // 5 minutes

  // Cache size limits
  MAX_CACHE_SIZE: 100,
  MAX_CACHE_ENTRIES: 1000
} as const;

// ============================================================================
// Retry Configuration
// ============================================================================

export const RETRY = {
  MAX_RETRIES: 3,
  INITIAL_DELAY_MS: 100,
  MAX_DELAY_MS: 5000,
  BACKOFF_MULTIPLIER: 2,
  CIRCUIT_BREAKER_THRESHOLD: 5,
  CIRCUIT_BREAKER_RESET_TIMEOUT: 60000
} as const;

// ============================================================================
// AI Configuration
// ============================================================================

export const AI = {
  // Token limits
  MAX_TOKENS_SUMMARY: 1000,
  MAX_TOKENS_CHAT: 2000,
  MAX_TOKENS_ANALYSIS: 3000,

  // Context limits
  MAX_CONTEXT_MESSAGES: 5,
  MAX_PDF_TOKENS: 100000,

  // Temperature settings
  TEMPERATURE_PRECISE: 0.3,
  TEMPERATURE_BALANCED: 0.7,
  TEMPERATURE_CREATIVE: 0.9
} as const;

// ============================================================================
// Firestore Configuration
// ============================================================================

export const FIRESTORE = {
  // Collections
  COLLECTIONS: {
    PRODUCTS: 'products',
    COVERAGES: 'coverages',
    FORMS: 'forms',
    RULES: 'rules',
    TASKS: 'tasks',
    AUDIT_LOGS: 'auditLogs',
    DATA_DICTIONARY: 'dataDictionary'
  },

  // Subcollections
  SUBCOLLECTIONS: {
    COVERAGES: 'coverages',
    LIMITS: 'limits',
    DEDUCTIBLES: 'deductibles',
    PRICING_STEPS: 'pricingSteps',
    PACKAGES: 'packages',
    VERSIONS: 'versions'
  }
} as const;

```

---

## src/config/env.ts

**Path:** `src/config/env.ts`

```typescript
/**
 * Environment Variables Helper
 * Provides compatibility between CRA (REACT_APP_) and Vite (VITE_) prefixes
 */

/**
 * Get environment variable with fallback support
 * Tries Vite prefix first, then falls back to CRA prefix
 */
const getEnv = (key: string): string | undefined => {
  // For Vite (import.meta.env)
  if (typeof import.meta !== 'undefined' && import.meta.env) {
    const viteKey = `VITE_${key}`;
    const value = import.meta.env[viteKey];
    if (value) {
      return value;
    }
  }
  
  // For CRA (process.env) - fallback
  if (typeof process !== 'undefined' && process.env) {
    const craKey = `REACT_APP_${key}`;
    const value = process.env[craKey];
    if (value) {
      return value;
    }
  }
  
  return undefined;
};

/**
 * Environment configuration object
 */
export interface EnvConfig {
  // Firebase
  FIREBASE_API_KEY: string | undefined;
  FIREBASE_AUTH_DOMAIN: string | undefined;
  FIREBASE_PROJECT_ID: string | undefined;
  FIREBASE_STORAGE_BUCKET: string | undefined;
  FIREBASE_MESSAGING_SENDER_ID: string | undefined;
  FIREBASE_APP_ID: string | undefined;
  FIREBASE_MEASUREMENT_ID: string | undefined;
  USE_FIREBASE_EMULATORS: boolean;

  // OpenAI
  OPENAI_KEY: string | undefined;

  // News API
  NEWSDATA_KEY: string | undefined;

  // API URL
  VITE_API_URL: string | undefined;

  // Node environment
  NODE_ENV: string;

  // Development mode
  DEV: boolean;

  // Production mode
  PROD: boolean;
}

export const env: EnvConfig = {
  // Firebase
  FIREBASE_API_KEY: getEnv('FIREBASE_API_KEY'),
  FIREBASE_AUTH_DOMAIN: getEnv('FIREBASE_AUTH_DOMAIN'),
  FIREBASE_PROJECT_ID: getEnv('FIREBASE_PROJECT_ID'),
  FIREBASE_STORAGE_BUCKET: getEnv('FIREBASE_STORAGE_BUCKET'),
  FIREBASE_MESSAGING_SENDER_ID: getEnv('FIREBASE_MESSAGING_SENDER_ID'),
  FIREBASE_APP_ID: getEnv('FIREBASE_APP_ID'),
  FIREBASE_MEASUREMENT_ID: getEnv('FIREBASE_MEASUREMENT_ID'),
  USE_FIREBASE_EMULATORS: getEnv('USE_FIREBASE_EMULATORS') === 'true',

  // OpenAI
  OPENAI_KEY: getEnv('OPENAI_KEY'),

  // News API
  NEWSDATA_KEY: getEnv('NEWSDATA_KEY'),

  // API URL
  VITE_API_URL: getEnv('API_URL'),

  // Node environment
  NODE_ENV: typeof import.meta !== 'undefined' && import.meta.env
    ? import.meta.env.MODE
    : (typeof process !== 'undefined' && process.env ? process.env.NODE_ENV || 'development' : 'development'),

  // Development mode
  DEV: typeof import.meta !== 'undefined' && import.meta.env
    ? import.meta.env.DEV
    : (typeof process !== 'undefined' && process.env ? process.env.NODE_ENV === 'development' : true),

  // Production mode
  PROD: typeof import.meta !== 'undefined' && import.meta.env
    ? import.meta.env.PROD
    : (typeof process !== 'undefined' && process.env ? process.env.NODE_ENV === 'production' : false),
};

/**
 * Check if running in development mode
 */
export const isDevelopment = (): boolean => env.DEV;

/**
 * Check if running in production mode
 */
export const isProduction = (): boolean => env.PROD;

/**
 * Get environment variable (for custom keys)
 */
export const getEnvironmentVariable = (key: string): string | undefined => getEnv(key);

/**
 * Validate required environment variables
 * Throws error if critical variables are missing in production
 */
export const validateEnvironment = (): void => {
  const requiredVars = [
    'FIREBASE_API_KEY',
    'FIREBASE_PROJECT_ID',
    'FIREBASE_APP_ID'
  ];

  const missing: string[] = [];

  requiredVars.forEach(varName => {
    if (!env[varName as keyof EnvConfig]) {
      missing.push(varName);
    }
  });

  if (missing.length > 0 && env.PROD) {
    throw new Error(
      `Missing required environment variables in production: ${missing.join(', ')}\n` +
      `Please ensure all required variables are set with VITE_ prefix.`
    );
  }

  if (missing.length > 0 && env.DEV) {
    console.warn(
      `âš ï¸ Missing environment variables: ${missing.join(', ')}\n` +
      `Some features may not work correctly.`
    );
  }
};

/**
 * Get production-ready environment configuration
 * Ensures all production standards are met
 */
export const getProductionConfig = () => {
  if (env.PROD) {
    validateEnvironment();
  }

  return {
    ...env,
    // Production-specific settings
    enableErrorReporting: env.PROD,
    enablePerformanceMonitoring: env.PROD,
    enableAnalytics: env.PROD,
    enableDebugLogging: env.DEV,
    enableSourceMaps: env.DEV,
  };
};

export default env;

```

---

## src/config/pricingEnums.ts

**Path:** `src/config/pricingEnums.ts`

```typescript
/**
 * Pricing Engine Enums & Constants
 * Centralized definitions for pricing steps, rules, and calculations
 */

/**
 * Step Types - Define the nature of a pricing step
 */
export enum StepType {
  FACTOR = 'factor',
  OPERAND = 'operand',
  MODIFIER = 'modifier',
  DISCOUNT = 'discount',
  SURCHARGE = 'surcharge'
}

export const STEP_TYPE_LABELS: Record<StepType, string> = {
  [StepType.FACTOR]: 'Factor',
  [StepType.OPERAND]: 'Operand',
  [StepType.MODIFIER]: 'Modifier',
  [StepType.DISCOUNT]: 'Discount',
  [StepType.SURCHARGE]: 'Surcharge'
};

export const STEP_TYPE_COLORS: Record<StepType, string> = {
  [StepType.FACTOR]: '#6366f1',
  [StepType.OPERAND]: '#8b5cf6',
  [StepType.MODIFIER]: '#06b6d4',
  [StepType.DISCOUNT]: '#10b981',
  [StepType.SURCHARGE]: '#ef4444'
};

/**
 * Rounding Modes - How to round calculated premiums
 */
export enum RoundingMode {
  NONE = 'none',
  UP = 'up',
  DOWN = 'down',
  NEAREST = 'nearest',
  NEAREST_DOLLAR = 'nearest_dollar',
  NEAREST_CENT = 'nearest_cent'
}

export const ROUNDING_MODE_LABELS: Record<RoundingMode, string> = {
  [RoundingMode.NONE]: 'No Rounding',
  [RoundingMode.UP]: 'Round Up',
  [RoundingMode.DOWN]: 'Round Down',
  [RoundingMode.NEAREST]: 'Round Nearest',
  [RoundingMode.NEAREST_DOLLAR]: 'Nearest Dollar',
  [RoundingMode.NEAREST_CENT]: 'Nearest Cent'
};

/**
 * Operands - Mathematical operations in pricing calculations
 */
export enum Operand {
  ADD = '+',
  SUBTRACT = '-',
  MULTIPLY = '*',
  DIVIDE = '/',
  EQUALS = '='
}

export const OPERAND_LABELS: Record<Operand, string> = {
  [Operand.ADD]: 'Add',
  [Operand.SUBTRACT]: 'Subtract',
  [Operand.MULTIPLY]: 'Multiply',
  [Operand.DIVIDE]: 'Divide',
  [Operand.EQUALS]: 'Equals'
};

export const OPERANDS = Object.values(Operand);

/**
 * Rule Types - Categories of business rules
 */
export enum RuleType {
  PRODUCT = 'Product',
  COVERAGE = 'Coverage',
  FORMS = 'Forms',
  PRICING = 'Pricing'
}

export const RULE_TYPE_LABELS: Record<RuleType, string> = {
  [RuleType.PRODUCT]: 'Product Rule',
  [RuleType.COVERAGE]: 'Coverage Rule',
  [RuleType.FORMS]: 'Forms Rule',
  [RuleType.PRICING]: 'Pricing Rule'
};

export const RULE_TYPE_COLORS: Record<RuleType, string> = {
  [RuleType.PRODUCT]: '#6366f1',
  [RuleType.COVERAGE]: '#10b981',
  [RuleType.FORMS]: '#f59e0b',
  [RuleType.PRICING]: '#8b5cf6'
};

/**
 * Rule Categories - Functional categories for rules
 */
export enum RuleCategory {
  ELIGIBILITY = 'Eligibility',
  PRICING = 'Pricing',
  COMPLIANCE = 'Compliance',
  COVERAGE = 'Coverage',
  FORMS = 'Forms'
}

export const RULE_CATEGORY_LABELS: Record<RuleCategory, string> = {
  [RuleCategory.ELIGIBILITY]: 'Eligibility',
  [RuleCategory.PRICING]: 'Pricing',
  [RuleCategory.COMPLIANCE]: 'Compliance',
  [RuleCategory.COVERAGE]: 'Coverage',
  [RuleCategory.FORMS]: 'Forms'
};

export const RULE_CATEGORIES = Object.values(RuleCategory);

/**
 * Rule Status - Lifecycle states for rules
 */
export enum RuleStatus {
  ACTIVE = 'Active',
  INACTIVE = 'Inactive',
  DRAFT = 'Draft',
  UNDER_REVIEW = 'Under Review'
}

export const RULE_STATUS_LABELS: Record<RuleStatus, string> = {
  [RuleStatus.ACTIVE]: 'Active',
  [RuleStatus.INACTIVE]: 'Inactive',
  [RuleStatus.DRAFT]: 'Draft',
  [RuleStatus.UNDER_REVIEW]: 'Under Review'
};

export const RULE_STATUS_COLORS: Record<RuleStatus, string> = {
  [RuleStatus.ACTIVE]: '#10b981',
  [RuleStatus.INACTIVE]: '#6b7280',
  [RuleStatus.DRAFT]: '#f59e0b',
  [RuleStatus.UNDER_REVIEW]: '#3b82f6'
};

/**
 * Pricing Rule Types - Specific pricing rule classifications
 */
export enum PricingRuleType {
  BASE = 'base',
  MODIFIER = 'modifier',
  DISCOUNT = 'discount',
  SURCHARGE = 'surcharge'
}

export const PRICING_RULE_TYPE_LABELS: Record<PricingRuleType, string> = {
  [PricingRuleType.BASE]: 'Base Premium',
  [PricingRuleType.MODIFIER]: 'Modifier',
  [PricingRuleType.DISCOUNT]: 'Discount',
  [PricingRuleType.SURCHARGE]: 'Surcharge'
};

export const PRICING_RULE_TYPE_COLORS: Record<PricingRuleType, string> = {
  [PricingRuleType.BASE]: '#6366f1',
  [PricingRuleType.MODIFIER]: '#06b6d4',
  [PricingRuleType.DISCOUNT]: '#10b981',
  [PricingRuleType.SURCHARGE]: '#ef4444'
};

/**
 * Value Types - How pricing values are expressed
 */
export enum ValueType {
  PERCENTAGE = 'percentage',
  FIXED = 'fixed',
  MULTIPLIER = 'multiplier'
}

export const VALUE_TYPE_LABELS: Record<ValueType, string> = {
  [ValueType.PERCENTAGE]: 'Percentage (%)',
  [ValueType.FIXED]: 'Fixed Amount ($)',
  [ValueType.MULTIPLIER]: 'Multiplier (x)'
};

/**
 * Constraints & Limits
 */
export const PRICING_CONSTRAINTS = {
  MIN_STEP_VALUE: 0,
  MAX_STEP_VALUE: 999999.99,
  MIN_PERCENTAGE: -100,
  MAX_PERCENTAGE: 1000,
  MIN_MULTIPLIER: 0.01,
  MAX_MULTIPLIER: 100,
  MAX_STEPS_PER_PRODUCT: 500,
  MAX_RULES_PER_PRODUCT: 1000,
  MAX_OPERANDS_PER_CALCULATION: 50
} as const;

/**
 * Validation Rules
 */
export const PRICING_VALIDATION = {
  STEP_NAME_MIN_LENGTH: 1,
  STEP_NAME_MAX_LENGTH: 255,
  RULE_NAME_MIN_LENGTH: 1,
  RULE_NAME_MAX_LENGTH: 255,
  CONDITION_MIN_LENGTH: 1,
  CONDITION_MAX_LENGTH: 1000,
  OUTCOME_MIN_LENGTH: 1,
  OUTCOME_MAX_LENGTH: 1000
} as const;

```

---

## src/config/rulesEnums.ts

**Path:** `src/config/rulesEnums.ts`

```typescript
/**
 * Rules Engine Enums & Constants
 * Centralized definitions for business rules
 */

/**
 * Rule Types - Categories of business rules
 */
export enum RuleType {
  PRODUCT = 'Product',
  COVERAGE = 'Coverage',
  FORMS = 'Forms',
  PRICING = 'Pricing'
}

export const RULE_TYPE_LABELS: Record<RuleType, string> = {
  [RuleType.PRODUCT]: 'Product Rule',
  [RuleType.COVERAGE]: 'Coverage Rule',
  [RuleType.FORMS]: 'Forms Rule',
  [RuleType.PRICING]: 'Pricing Rule'
};

export const RULE_TYPE_COLORS: Record<RuleType, string> = {
  [RuleType.PRODUCT]: '#6366f1',
  [RuleType.COVERAGE]: '#10b981',
  [RuleType.FORMS]: '#f59e0b',
  [RuleType.PRICING]: '#8b5cf6'
};

export const RULE_TYPES = Object.values(RuleType);

/**
 * Rule Categories - Functional categories for rules
 */
export enum RuleCategory {
  ELIGIBILITY = 'Eligibility',
  PRICING = 'Pricing',
  COMPLIANCE = 'Compliance',
  COVERAGE = 'Coverage',
  FORMS = 'Forms'
}

export const RULE_CATEGORY_LABELS: Record<RuleCategory, string> = {
  [RuleCategory.ELIGIBILITY]: 'Eligibility',
  [RuleCategory.PRICING]: 'Pricing',
  [RuleCategory.COMPLIANCE]: 'Compliance',
  [RuleCategory.COVERAGE]: 'Coverage',
  [RuleCategory.FORMS]: 'Forms'
};

export const RULE_CATEGORIES = Object.values(RuleCategory);

/**
 * Rule Status - Lifecycle states for rules
 */
export enum RuleStatus {
  ACTIVE = 'Active',
  INACTIVE = 'Inactive',
  DRAFT = 'Draft',
  UNDER_REVIEW = 'Under Review'
}

export const RULE_STATUS_LABELS: Record<RuleStatus, string> = {
  [RuleStatus.ACTIVE]: 'Active',
  [RuleStatus.INACTIVE]: 'Inactive',
  [RuleStatus.DRAFT]: 'Draft',
  [RuleStatus.UNDER_REVIEW]: 'Under Review'
};

export const RULE_STATUS_COLORS: Record<RuleStatus, string> = {
  [RuleStatus.ACTIVE]: '#10b981',
  [RuleStatus.INACTIVE]: '#6b7280',
  [RuleStatus.DRAFT]: '#f59e0b',
  [RuleStatus.UNDER_REVIEW]: '#3b82f6'
};

export const RULE_STATUSES = Object.values(RuleStatus);

/**
 * Sort Options - How to sort rules in lists
 */
export enum SortOption {
  NAME_ASC = 'name_asc',
  NAME_DESC = 'name_desc',
  TYPE_ASC = 'type_asc',
  TYPE_DESC = 'type_desc',
  STATUS_ASC = 'status_asc',
  STATUS_DESC = 'status_desc',
  CREATED_ASC = 'created_asc',
  CREATED_DESC = 'created_desc',
  UPDATED_ASC = 'updated_asc',
  UPDATED_DESC = 'updated_desc'
}

export const SORT_OPTION_LABELS: Record<SortOption, string> = {
  [SortOption.NAME_ASC]: 'Name (A-Z)',
  [SortOption.NAME_DESC]: 'Name (Z-A)',
  [SortOption.TYPE_ASC]: 'Type (A-Z)',
  [SortOption.TYPE_DESC]: 'Type (Z-A)',
  [SortOption.STATUS_ASC]: 'Status (A-Z)',
  [SortOption.STATUS_DESC]: 'Status (Z-A)',
  [SortOption.CREATED_ASC]: 'Oldest First',
  [SortOption.CREATED_DESC]: 'Newest First',
  [SortOption.UPDATED_ASC]: 'Least Recently Updated',
  [SortOption.UPDATED_DESC]: 'Most Recently Updated'
};

export const SORT_OPTIONS = Object.values(SortOption);

/**
 * Constraints & Limits
 */
export const RULES_CONSTRAINTS = {
  MAX_RULES_PER_PRODUCT: 1000,
  MAX_RULES_PER_COVERAGE: 500,
  MAX_RULES_PER_FORM: 100,
  MAX_RULE_NAME_LENGTH: 255,
  MAX_CONDITION_LENGTH: 2000,
  MAX_OUTCOME_LENGTH: 2000,
  MAX_REFERENCE_LENGTH: 500,
  MAX_BULK_OPERATIONS: 100,
  MAX_RULES_PER_BULK_UPDATE: 50
} as const;

/**
 * Validation Rules
 */
export const RULES_VALIDATION = {
  RULE_NAME_MIN_LENGTH: 1,
  RULE_NAME_MAX_LENGTH: 255,
  CONDITION_MIN_LENGTH: 1,
  CONDITION_MAX_LENGTH: 2000,
  OUTCOME_MIN_LENGTH: 1,
  OUTCOME_MAX_LENGTH: 2000,
  REFERENCE_MIN_LENGTH: 0,
  REFERENCE_MAX_LENGTH: 500,
  CHANGE_REASON_MIN_LENGTH: 10,
  CHANGE_REASON_MAX_LENGTH: 500
} as const;

/**
 * Filter Presets - Common filter combinations
 */
export const FILTER_PRESETS = {
  ACTIVE_ONLY: {
    status: [RuleStatus.ACTIVE],
    label: 'Active Rules'
  },
  DRAFT_ONLY: {
    status: [RuleStatus.DRAFT],
    label: 'Draft Rules'
  },
  UNDER_REVIEW: {
    status: [RuleStatus.UNDER_REVIEW],
    label: 'Under Review'
  },
  PRODUCT_RULES: {
    type: [RuleType.PRODUCT],
    label: 'Product Rules'
  },
  COVERAGE_RULES: {
    type: [RuleType.COVERAGE],
    label: 'Coverage Rules'
  },
  PRICING_RULES: {
    type: [RuleType.PRICING],
    label: 'Pricing Rules'
  },
  COMPLIANCE_RULES: {
    category: [RuleCategory.COMPLIANCE],
    label: 'Compliance Rules'
  }
} as const;

/**
 * Bulk Operation Types
 */
export enum BulkOperationType {
  ACTIVATE = 'activate',
  DEACTIVATE = 'deactivate',
  DELETE = 'delete',
  CHANGE_STATUS = 'change_status',
  CHANGE_CATEGORY = 'change_category',
  DUPLICATE = 'duplicate',
  EXPORT = 'export'
}

export const BULK_OPERATION_LABELS: Record<BulkOperationType, string> = {
  [BulkOperationType.ACTIVATE]: 'Activate',
  [BulkOperationType.DEACTIVATE]: 'Deactivate',
  [BulkOperationType.DELETE]: 'Delete',
  [BulkOperationType.CHANGE_STATUS]: 'Change Status',
  [BulkOperationType.CHANGE_CATEGORY]: 'Change Category',
  [BulkOperationType.DUPLICATE]: 'Duplicate',
  [BulkOperationType.EXPORT]: 'Export'
};

export const BULK_OPERATIONS = Object.values(BulkOperationType);

```

---

## src/context/ProductContext.tsx

**Path:** `src/context/ProductContext.tsx`

```tsx
/**
 * ProductContext - Eliminates prop drilling for product/coverage data
 * 
 * Provides centralized access to:
 * - Current product and its metadata
 * - Coverages, forms, rules, pricing data
 * - Related entities (limits, deductibles, packages)
 * - Caching and state management
 * 
 * Usage:
 * 1. Wrap app with <ProductProvider>
 * 2. Use useProduct() hook in components
 */

import React, { createContext, useContext, useState, useCallback, useMemo, ReactNode } from 'react';
import { Product, Coverage, FormTemplate, Rule, PricingStep } from '@types/index';

interface ProductContextType {
  // Current product
  currentProduct: Product | null;
  setCurrentProduct: (product: Product | null) => void;
  
  // Related data
  coverages: Coverage[];
  setCoverages: (coverages: Coverage[]) => void;
  
  forms: FormTemplate[];
  setForms: (forms: FormTemplate[]) => void;
  
  rules: Rule[];
  setRules: (rules: Rule[]) => void;
  
  pricingSteps: PricingStep[];
  setPricingSteps: (steps: PricingStep[]) => void;
  
  // Loading states
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
  
  // Error handling
  error: string | null;
  setError: (error: string | null) => void;
  
  // Utility methods
  clearContext: () => void;
  updateProductData: (updates: Partial<Product>) => void;
}

const ProductContext = createContext<ProductContextType | undefined>(undefined);

export const ProductProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [currentProduct, setCurrentProduct] = useState<Product | null>(null);
  const [coverages, setCoverages] = useState<Coverage[]>([]);
  const [forms, setForms] = useState<FormTemplate[]>([]);
  const [rules, setRules] = useState<Rule[]>([]);
  const [pricingSteps, setPricingSteps] = useState<PricingStep[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Optimized: Clear all context data
  const clearContext = useCallback(() => {
    setCurrentProduct(null);
    setCoverages([]);
    setForms([]);
    setRules([]);
    setPricingSteps([]);
    setError(null);
  }, []);

  // Optimized: Update product with memoization
  const updateProductData = useCallback((updates: Partial<Product>) => {
    setCurrentProduct(prev => prev ? { ...prev, ...updates } : null);
  }, []);

  // Memoize context value to prevent unnecessary re-renders
  const value = useMemo<ProductContextType>(() => ({
    currentProduct,
    setCurrentProduct,
    coverages,
    setCoverages,
    forms,
    setForms,
    rules,
    setRules,
    pricingSteps,
    setPricingSteps,
    isLoading,
    setIsLoading,
    error,
    setError,
    clearContext,
    updateProductData
  }), [
    currentProduct, coverages, forms, rules, pricingSteps,
    isLoading, error, clearContext, updateProductData
  ]);

  return (
    <ProductContext.Provider value={value}>
      {children}
    </ProductContext.Provider>
  );
};

/**
 * Hook to use ProductContext
 * Throws error if used outside ProductProvider
 */
export const useProduct = (): ProductContextType => {
  const context = useContext(ProductContext);
  if (!context) {
    throw new Error('useProduct must be used within ProductProvider');
  }
  return context;
};

export default ProductContext;

```

---

## src/data/coverageDatabase.ts

**Path:** `src/data/coverageDatabase.ts`

```typescript
/**
 * Comprehensive P&C Insurance Coverage Database
 * 
 * Used for intelligent fuzzy matching and suggestions.
 * Each coverage includes:
 * - name: The standard coverage name
 * - abbreviations: Common abbreviations (e.g., "BPP", "GL")
 * - aliases: Alternative names or synonyms
 * - keywords: Related terms for semantic matching
 * - lineOfBusiness: Which LOB this coverage belongs to
 * - category: Grouping for organization
 * - commonlyPairedWith: Coverages often used together
 */

export interface CoverageEntry {
  name: string;
  abbreviations?: string[];
  aliases?: string[];
  keywords?: string[];
  lineOfBusiness: string[];
  category: string;
  commonlyPairedWith?: string[];
  description?: string;
}

export const COVERAGE_DATABASE: CoverageEntry[] = [
  // ============================================================================
  // PROPERTY COVERAGES
  // ============================================================================
  {
    name: 'Building Coverage',
    abbreviations: ['BLDG', 'BLD'],
    aliases: ['Building & Structures', 'Structure Coverage', 'Real Property Coverage'],
    keywords: ['building', 'structure', 'real property', 'premises', 'construction'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Real',
    commonlyPairedWith: ['Business Personal Property', 'Business Income', 'Extra Expense'],
    description: 'Covers physical damage to buildings and permanently installed fixtures'
  },
  {
    name: 'Business Personal Property',
    abbreviations: ['BPP', 'CONTENTS'],
    aliases: ['Contents Coverage', 'Personal Property', 'Business Contents'],
    keywords: ['contents', 'equipment', 'inventory', 'furniture', 'fixtures', 'stock'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Personal',
    commonlyPairedWith: ['Building Coverage', 'Business Income', 'Equipment Breakdown'],
    description: 'Covers movable property owned by the business'
  },
  {
    name: 'Business Income',
    abbreviations: ['BI', 'BII'],
    aliases: ['Business Interruption', 'Loss of Income', 'Income Coverage'],
    keywords: ['income', 'revenue', 'interruption', 'lost profits', 'earnings'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Time Element',
    commonlyPairedWith: ['Extra Expense', 'Building Coverage', 'Civil Authority'],
    description: 'Covers lost income during business interruption from covered perils'
  },
  {
    name: 'Extra Expense',
    abbreviations: ['EE', 'XEXP'],
    aliases: ['Additional Expense', 'Expediting Expense'],
    keywords: ['extra', 'additional', 'expense', 'expedite', 'temporary'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Time Element',
    commonlyPairedWith: ['Business Income', 'Building Coverage'],
    description: 'Covers additional costs to continue operations during restoration'
  },
  {
    name: 'Equipment Breakdown',
    abbreviations: ['EB', 'EQBD', 'BM'],
    aliases: ['Boiler & Machinery', 'Mechanical Breakdown', 'Equipment Failure'],
    keywords: ['equipment', 'machinery', 'boiler', 'mechanical', 'electrical', 'breakdown'],
    lineOfBusiness: ['property', 'commercial property', 'inland marine'],
    category: 'Property - Equipment',
    commonlyPairedWith: ['Building Coverage', 'Business Personal Property', 'Business Income'],
    description: 'Covers sudden mechanical or electrical breakdown of equipment'
  },
  {
    name: 'Ordinance or Law',
    abbreviations: ['O&L', 'OL'],
    aliases: ['Building Ordinance', 'Code Upgrade', 'Law & Ordinance'],
    keywords: ['ordinance', 'law', 'code', 'upgrade', 'demolition', 'increased cost'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Building Coverage'],
    description: 'Covers increased costs due to building code requirements'
  },
  {
    name: 'Valuable Papers & Records',
    abbreviations: ['VP', 'VPR'],
    aliases: ['Valuable Documents', 'Records Coverage'],
    keywords: ['papers', 'records', 'documents', 'valuable', 'manuscripts'],
    lineOfBusiness: ['property', 'commercial property', 'inland marine'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Business Personal Property', 'Electronic Data'],
    description: 'Covers cost to research and restore valuable papers and records'
  },
  {
    name: 'Accounts Receivable',
    abbreviations: ['AR', 'ACCREC'],
    aliases: ['Receivables Coverage'],
    keywords: ['accounts', 'receivable', 'billing', 'customer', 'records'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Valuable Papers & Records', 'Business Personal Property'],
    description: 'Covers inability to collect from customers due to records loss'
  },
  {
    name: 'Electronic Data',
    abbreviations: ['ED', 'DATA'],
    aliases: ['Data Coverage', 'Computer Data', 'Digital Assets'],
    keywords: ['electronic', 'data', 'computer', 'digital', 'software', 'media'],
    lineOfBusiness: ['property', 'commercial property', 'cyber'],
    category: 'Property - Technology',
    commonlyPairedWith: ['Computer Equipment', 'Business Income', 'Cyber Liability'],
    description: 'Covers cost to restore electronic data and software'
  },
  {
    name: 'Debris Removal',
    abbreviations: ['DR', 'DEBRIS'],
    aliases: ['Debris Cleanup', 'Removal Expense'],
    keywords: ['debris', 'removal', 'cleanup', 'disposal', 'demolition'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Building Coverage', 'Business Personal Property'],
    description: 'Covers cost to remove debris after a covered loss'
  },
  {
    name: 'Fire Damage',
    abbreviations: ['FIRE'],
    aliases: ['Fire Coverage', 'Fire & Lightning'],
    keywords: ['fire', 'lightning', 'smoke', 'burn', 'flame'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Smoke Damage', 'Building Coverage'],
    description: 'Covers damage caused by fire and lightning'
  },
  {
    name: 'Smoke Damage',
    abbreviations: ['SMOKE'],
    aliases: ['Smoke Coverage'],
    keywords: ['smoke', 'soot', 'residue'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Fire Damage', 'Building Coverage'],
    description: 'Covers damage caused by smoke'
  },
  {
    name: 'Wind & Hail',
    abbreviations: ['W&H', 'WH', 'WIND'],
    aliases: ['Windstorm Coverage', 'Hail Damage', 'Storm Coverage'],
    keywords: ['wind', 'hail', 'storm', 'hurricane', 'tornado', 'windstorm'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Building Coverage', 'Roof Coverage'],
    description: 'Covers damage from wind and hail events'
  },
  {
    name: 'Flood Coverage',
    abbreviations: ['FLD', 'FLOOD'],
    aliases: ['Flood Insurance', 'Water Damage - Flood'],
    keywords: ['flood', 'water', 'rising water', 'storm surge', 'overflow'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners', 'flood'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Building Coverage', 'Business Personal Property'],
    description: 'Covers damage from flooding and rising water'
  },
  {
    name: 'Earthquake Coverage',
    abbreviations: ['EQ', 'QUAKE'],
    aliases: ['Seismic Coverage', 'Earth Movement'],
    keywords: ['earthquake', 'seismic', 'tremor', 'earth movement'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Building Coverage', 'Business Personal Property'],
    description: 'Covers damage from earthquake and earth movement'
  },
  {
    name: 'Spoilage Coverage',
    abbreviations: ['SPOIL', 'SPL'],
    aliases: ['Perishable Goods', 'Refrigeration Breakdown'],
    keywords: ['spoilage', 'perishable', 'refrigeration', 'temperature', 'food'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Equipment Breakdown', 'Business Personal Property'],
    description: 'Covers spoilage of perishable goods'
  },
  {
    name: 'Glass Coverage',
    abbreviations: ['GLASS'],
    aliases: ['Plate Glass', 'Window Coverage'],
    keywords: ['glass', 'window', 'plate glass', 'storefront'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Building Coverage', 'Signs Coverage'],
    description: 'Covers breakage of glass windows and fixtures'
  },
  {
    name: 'Signs Coverage',
    abbreviations: ['SIGN'],
    aliases: ['Outdoor Signs', 'Signage Coverage'],
    keywords: ['signs', 'signage', 'outdoor', 'neon', 'billboard'],
    lineOfBusiness: ['property', 'commercial property', 'inland marine'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Building Coverage', 'Glass Coverage'],
    description: 'Covers damage to outdoor signs'
  },
  {
    name: 'Tenant Improvements',
    abbreviations: ['TI', 'TIB', 'LHI'],
    aliases: ['Leasehold Improvements', 'Betterments', 'Tenant Betterments'],
    keywords: ['tenant', 'leasehold', 'improvements', 'betterments', 'build-out'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Real',
    commonlyPairedWith: ['Business Personal Property', 'Building Coverage'],
    description: 'Covers improvements made by tenant to leased space'
  },
  {
    name: 'Civil Authority',
    abbreviations: ['CA', 'CIVAUTH'],
    aliases: ['Civil Authority Coverage', 'Government Action'],
    keywords: ['civil', 'authority', 'government', 'access', 'ingress', 'egress'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Time Element',
    commonlyPairedWith: ['Business Income', 'Extra Expense'],
    description: 'Covers loss when civil authority prohibits access to premises'
  },

  // ============================================================================
  // LIABILITY COVERAGES
  // ============================================================================
  {
    name: 'General Liability',
    abbreviations: ['GL', 'CGL'],
    aliases: ['Commercial General Liability', 'Public Liability', 'Third Party Liability'],
    keywords: ['liability', 'bodily injury', 'property damage', 'negligence', 'lawsuit'],
    lineOfBusiness: ['liability', 'general liability', 'commercial'],
    category: 'Liability - General',
    commonlyPairedWith: ['Products Liability', 'Personal & Advertising Injury'],
    description: 'Covers third-party bodily injury and property damage claims'
  },
  {
    name: 'Products Liability',
    abbreviations: ['PL', 'PROD'],
    aliases: ['Products-Completed Operations', 'Product Liability'],
    keywords: ['products', 'completed operations', 'manufacturing', 'defect'],
    lineOfBusiness: ['liability', 'general liability', 'commercial'],
    category: 'Liability - Products',
    commonlyPairedWith: ['General Liability', 'Product Recall'],
    description: 'Covers liability from products sold or work completed'
  },
  {
    name: 'Personal & Advertising Injury',
    abbreviations: ['P&A', 'PAI'],
    aliases: ['Personal Injury', 'Advertising Injury', 'Offense Coverage'],
    keywords: ['personal', 'advertising', 'libel', 'slander', 'defamation', 'copyright'],
    lineOfBusiness: ['liability', 'general liability'],
    category: 'Liability - General',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers libel, slander, and advertising offenses'
  },
  {
    name: 'Professional Liability',
    abbreviations: ['PRL', 'E&O'],
    aliases: ['Errors & Omissions', 'E&O Coverage', 'Malpractice'],
    keywords: ['professional', 'errors', 'omissions', 'malpractice', 'negligence'],
    lineOfBusiness: ['liability', 'professional liability'],
    category: 'Liability - Professional',
    commonlyPairedWith: ['General Liability', 'Cyber Liability'],
    description: 'Covers professional negligence and errors'
  },
  {
    name: 'Directors & Officers Liability',
    abbreviations: ['D&O', 'DO'],
    aliases: ['D&O Coverage', 'Management Liability'],
    keywords: ['directors', 'officers', 'management', 'fiduciary', 'governance'],
    lineOfBusiness: ['liability', 'management liability'],
    category: 'Liability - Management',
    commonlyPairedWith: ['Employment Practices Liability', 'Fiduciary Liability'],
    description: 'Covers liability of company directors and officers'
  },
  {
    name: 'Employment Practices Liability',
    abbreviations: ['EPL', 'EPLI'],
    aliases: ['EPLI Coverage', 'Employment Liability'],
    keywords: ['employment', 'discrimination', 'harassment', 'wrongful termination', 'HR'],
    lineOfBusiness: ['liability', 'management liability'],
    category: 'Liability - Employment',
    commonlyPairedWith: ['Directors & Officers Liability', 'General Liability'],
    description: 'Covers employment-related claims like discrimination'
  },
  {
    name: 'Cyber Liability',
    abbreviations: ['CYBER', 'CYB'],
    aliases: ['Cyber Insurance', 'Data Breach Coverage', 'Network Security'],
    keywords: ['cyber', 'data breach', 'hacking', 'ransomware', 'privacy', 'network'],
    lineOfBusiness: ['liability', 'cyber', 'technology'],
    category: 'Liability - Cyber',
    commonlyPairedWith: ['Professional Liability', 'Electronic Data'],
    description: 'Covers cyber attacks and data breach liability'
  },
  {
    name: 'Umbrella Liability',
    abbreviations: ['UMB', 'UMBR'],
    aliases: ['Umbrella Coverage', 'Excess Liability'],
    keywords: ['umbrella', 'excess', 'catastrophic', 'high limits'],
    lineOfBusiness: ['liability', 'umbrella'],
    category: 'Liability - Excess',
    commonlyPairedWith: ['General Liability', 'Auto Liability'],
    description: 'Provides excess liability limits over primary policies'
  },
  {
    name: 'Liquor Liability',
    abbreviations: ['LIQ', 'DRAM'],
    aliases: ['Dram Shop', 'Alcohol Liability', 'Host Liquor'],
    keywords: ['liquor', 'alcohol', 'dram shop', 'bar', 'restaurant', 'serving'],
    lineOfBusiness: ['liability', 'general liability', 'hospitality'],
    category: 'Liability - Specialty',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers liability from serving alcohol'
  },
  {
    name: 'Pollution Liability',
    abbreviations: ['POLL', 'EIL'],
    aliases: ['Environmental Liability', 'Contamination Coverage'],
    keywords: ['pollution', 'environmental', 'contamination', 'hazmat', 'cleanup'],
    lineOfBusiness: ['liability', 'environmental'],
    category: 'Liability - Environmental',
    commonlyPairedWith: ['General Liability', 'Professional Liability'],
    description: 'Covers pollution and environmental damage claims'
  },
  {
    name: 'Medical Payments',
    abbreviations: ['MEDPAY', 'MP'],
    aliases: ['Med Pay', 'Medical Expense'],
    keywords: ['medical', 'payments', 'injury', 'expense', 'first aid'],
    lineOfBusiness: ['liability', 'general liability', 'auto'],
    category: 'Liability - Medical',
    commonlyPairedWith: ['General Liability', 'Bodily Injury Liability'],
    description: 'Pays medical expenses regardless of fault'
  },

  // ============================================================================
  // AUTO COVERAGES
  // ============================================================================
  {
    name: 'Auto Liability',
    abbreviations: ['AL', 'AUTOL'],
    aliases: ['Automobile Liability', 'Vehicle Liability'],
    keywords: ['auto', 'liability', 'vehicle', 'accident', 'third party'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Liability',
    commonlyPairedWith: ['Physical Damage', 'Uninsured Motorist'],
    description: 'Covers third-party liability from auto accidents'
  },
  {
    name: 'Bodily Injury Liability',
    abbreviations: ['BI', 'BIL'],
    aliases: ['BI Liability', 'Injury Liability'],
    keywords: ['bodily', 'injury', 'liability', 'person', 'accident'],
    lineOfBusiness: ['auto', 'commercial auto', 'liability'],
    category: 'Auto - Liability',
    commonlyPairedWith: ['Property Damage Liability', 'Medical Payments'],
    description: 'Covers bodily injury to others in auto accidents'
  },
  {
    name: 'Property Damage Liability',
    abbreviations: ['PD', 'PDL'],
    aliases: ['PD Liability'],
    keywords: ['property', 'damage', 'liability', 'vehicle', 'collision'],
    lineOfBusiness: ['auto', 'commercial auto', 'liability'],
    category: 'Auto - Liability',
    commonlyPairedWith: ['Bodily Injury Liability'],
    description: 'Covers damage to others property in auto accidents'
  },
  {
    name: 'Collision Coverage',
    abbreviations: ['COLL', 'COL'],
    aliases: ['Collision Insurance'],
    keywords: ['collision', 'crash', 'accident', 'impact', 'rollover'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Physical Damage',
    commonlyPairedWith: ['Comprehensive Coverage'],
    description: 'Covers damage to your vehicle from collisions'
  },
  {
    name: 'Comprehensive Coverage',
    abbreviations: ['COMP', 'OTC'],
    aliases: ['Other Than Collision', 'Full Coverage'],
    keywords: ['comprehensive', 'theft', 'vandalism', 'weather', 'animal', 'glass'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Physical Damage',
    commonlyPairedWith: ['Collision Coverage'],
    description: 'Covers non-collision damage like theft and weather'
  },
  {
    name: 'Uninsured Motorist',
    abbreviations: ['UM', 'UNIM'],
    aliases: ['UM Coverage', 'Uninsured Driver'],
    keywords: ['uninsured', 'motorist', 'hit and run', 'no insurance'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Uninsured',
    commonlyPairedWith: ['Underinsured Motorist', 'Auto Liability'],
    description: 'Covers you when hit by uninsured driver'
  },
  {
    name: 'Underinsured Motorist',
    abbreviations: ['UIM', 'UNDINS'],
    aliases: ['UIM Coverage'],
    keywords: ['underinsured', 'motorist', 'insufficient', 'limits'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Uninsured',
    commonlyPairedWith: ['Uninsured Motorist'],
    description: 'Covers you when hit by underinsured driver'
  },
  {
    name: 'Hired Auto',
    abbreviations: ['HA', 'HIRED'],
    aliases: ['Hired Auto Liability', 'Rental Car Coverage'],
    keywords: ['hired', 'rental', 'leased', 'temporary', 'non-owned'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Non-Owned',
    commonlyPairedWith: ['Non-Owned Auto', 'Auto Liability'],
    description: 'Covers liability for rented or hired vehicles'
  },
  {
    name: 'Non-Owned Auto',
    abbreviations: ['NOA', 'NONOWN'],
    aliases: ['Non-Owned Auto Liability', 'Employee Vehicle'],
    keywords: ['non-owned', 'employee', 'personal', 'vehicle', 'business use'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Non-Owned',
    commonlyPairedWith: ['Hired Auto', 'Auto Liability'],
    description: 'Covers liability when employees use personal vehicles'
  },

  // ============================================================================
  // WORKERS COMPENSATION
  // ============================================================================
  {
    name: 'Workers Compensation',
    abbreviations: ['WC', 'WORKCOMP'],
    aliases: ['Workers Comp', 'Work Comp', 'Employee Injury'],
    keywords: ['workers', 'compensation', 'employee', 'injury', 'workplace', 'occupational'],
    lineOfBusiness: ['workers compensation'],
    category: 'Workers Comp',
    commonlyPairedWith: ['Employers Liability'],
    description: 'Covers employee injuries and occupational illness'
  },
  {
    name: 'Employers Liability',
    abbreviations: ['EL', 'EMPL'],
    aliases: ['Employer Liability', 'Part B Coverage'],
    keywords: ['employers', 'liability', 'lawsuit', 'negligence', 'workplace'],
    lineOfBusiness: ['workers compensation'],
    category: 'Workers Comp',
    commonlyPairedWith: ['Workers Compensation'],
    description: 'Covers employer liability beyond workers comp'
  },

  // ============================================================================
  // INLAND MARINE
  // ============================================================================
  {
    name: 'Contractors Equipment',
    abbreviations: ['CE', 'CONTEQ'],
    aliases: ['Contractors Tools', 'Mobile Equipment'],
    keywords: ['contractors', 'equipment', 'tools', 'mobile', 'construction'],
    lineOfBusiness: ['inland marine', 'contractors'],
    category: 'Inland Marine',
    commonlyPairedWith: ['Installation Floater', 'Builders Risk'],
    description: 'Covers contractors tools and mobile equipment'
  },
  {
    name: 'Builders Risk',
    abbreviations: ['BR', 'COC'],
    aliases: ['Course of Construction', 'Construction Coverage'],
    keywords: ['builders', 'construction', 'project', 'development', 'renovation'],
    lineOfBusiness: ['inland marine', 'property', 'construction'],
    category: 'Inland Marine',
    commonlyPairedWith: ['Contractors Equipment', 'Installation Floater'],
    description: 'Covers buildings under construction'
  },
  {
    name: 'Installation Floater',
    abbreviations: ['IF', 'INST'],
    aliases: ['Installation Coverage'],
    keywords: ['installation', 'floater', 'equipment', 'transit', 'job site'],
    lineOfBusiness: ['inland marine', 'contractors'],
    category: 'Inland Marine',
    commonlyPairedWith: ['Contractors Equipment', 'Transit Coverage'],
    description: 'Covers equipment during installation'
  },
  {
    name: 'Transit Coverage',
    abbreviations: ['TR', 'TRANS'],
    aliases: ['Cargo Coverage', 'Goods in Transit'],
    keywords: ['transit', 'cargo', 'shipping', 'transportation', 'delivery'],
    lineOfBusiness: ['inland marine', 'cargo'],
    category: 'Inland Marine',
    commonlyPairedWith: ['Motor Truck Cargo', 'Installation Floater'],
    description: 'Covers goods while in transit'
  },
  {
    name: 'Motor Truck Cargo',
    abbreviations: ['MTC', 'CARGO'],
    aliases: ['Trucking Cargo', 'Freight Coverage'],
    keywords: ['motor', 'truck', 'cargo', 'freight', 'hauling', 'trucking'],
    lineOfBusiness: ['inland marine', 'trucking'],
    category: 'Inland Marine',
    commonlyPairedWith: ['Transit Coverage', 'Auto Liability'],
    description: 'Covers cargo being transported by truck'
  },
  {
    name: 'Fine Arts Coverage',
    abbreviations: ['FA', 'ART'],
    aliases: ['Art Insurance', 'Collectibles Coverage'],
    keywords: ['fine arts', 'art', 'collectibles', 'antiques', 'paintings', 'sculpture'],
    lineOfBusiness: ['inland marine', 'personal lines'],
    category: 'Inland Marine',
    commonlyPairedWith: ['Valuable Papers & Records'],
    description: 'Covers fine art and collectibles'
  },

  // ============================================================================
  // SPECIALTY COVERAGES
  // ============================================================================
  {
    name: 'Crime Coverage',
    abbreviations: ['CR', 'CRIME'],
    aliases: ['Commercial Crime', 'Fidelity Coverage'],
    keywords: ['crime', 'theft', 'employee dishonesty', 'forgery', 'fraud'],
    lineOfBusiness: ['crime', 'commercial'],
    category: 'Specialty',
    commonlyPairedWith: ['Cyber Liability', 'Fidelity Bond'],
    description: 'Covers losses from criminal acts'
  },
  {
    name: 'Employee Dishonesty',
    abbreviations: ['ED', 'DISHON'],
    aliases: ['Fidelity Bond', 'Employee Theft'],
    keywords: ['employee', 'dishonesty', 'theft', 'embezzlement', 'fraud'],
    lineOfBusiness: ['crime', 'fidelity'],
    category: 'Specialty',
    commonlyPairedWith: ['Crime Coverage', 'ERISA Bond'],
    description: 'Covers theft by employees'
  },
  {
    name: 'Forgery & Alteration',
    abbreviations: ['F&A', 'FORG'],
    aliases: ['Forgery Coverage'],
    keywords: ['forgery', 'alteration', 'checks', 'documents', 'fraud'],
    lineOfBusiness: ['crime'],
    category: 'Specialty',
    commonlyPairedWith: ['Crime Coverage', 'Employee Dishonesty'],
    description: 'Covers losses from forged documents'
  },
  {
    name: 'Product Recall',
    abbreviations: ['PR', 'RECALL'],
    aliases: ['Recall Coverage', 'Product Withdrawal'],
    keywords: ['product', 'recall', 'withdrawal', 'contamination', 'defect'],
    lineOfBusiness: ['liability', 'product liability'],
    category: 'Specialty',
    commonlyPairedWith: ['Products Liability', 'General Liability'],
    description: 'Covers costs of product recalls'
  },
  {
    name: 'Fiduciary Liability',
    abbreviations: ['FID', 'FIDL'],
    aliases: ['ERISA Liability', 'Benefit Plan Liability'],
    keywords: ['fiduciary', 'ERISA', 'pension', 'benefits', '401k', 'retirement'],
    lineOfBusiness: ['liability', 'management liability'],
    category: 'Specialty',
    commonlyPairedWith: ['Directors & Officers Liability', 'Employment Practices Liability'],
    description: 'Covers liability for employee benefit plan administration'
  },
  {
    name: 'Media Liability',
    abbreviations: ['MEDIA', 'MED'],
    aliases: ['Broadcasters Liability', 'Publishers Liability'],
    keywords: ['media', 'broadcasting', 'publishing', 'content', 'defamation'],
    lineOfBusiness: ['liability', 'media'],
    category: 'Specialty',
    commonlyPairedWith: ['Professional Liability', 'Cyber Liability'],
    description: 'Covers liability from media content'
  },
  {
    name: 'Technology E&O',
    abbreviations: ['TECH', 'TEO'],
    aliases: ['Tech E&O', 'IT Professional Liability'],
    keywords: ['technology', 'IT', 'software', 'services', 'consulting'],
    lineOfBusiness: ['liability', 'technology', 'professional liability'],
    category: 'Specialty',
    commonlyPairedWith: ['Cyber Liability', 'Professional Liability'],
    description: 'Covers technology services errors and omissions'
  },

  // ============================================================================
  // HOMEOWNERS COVERAGES
  // ============================================================================
  {
    name: 'Dwelling Coverage',
    abbreviations: ['DWL', 'DWLG', 'COV A'],
    aliases: ['Coverage A', 'Home Structure', 'House Coverage'],
    keywords: ['dwelling', 'home', 'house', 'structure', 'residence'],
    lineOfBusiness: ['homeowners', 'personal lines'],
    category: 'Homeowners',
    commonlyPairedWith: ['Other Structures', 'Personal Property', 'Loss of Use'],
    description: 'Covers the main dwelling structure'
  },
  {
    name: 'Other Structures',
    abbreviations: ['OS', 'COV B'],
    aliases: ['Coverage B', 'Detached Structures', 'Appurtenant Structures'],
    keywords: ['other', 'structures', 'garage', 'shed', 'fence', 'detached'],
    lineOfBusiness: ['homeowners', 'personal lines'],
    category: 'Homeowners',
    commonlyPairedWith: ['Dwelling Coverage'],
    description: 'Covers detached structures like garages and sheds'
  },
  {
    name: 'Personal Property',
    abbreviations: ['PP', 'COV C'],
    aliases: ['Coverage C', 'Contents', 'Personal Belongings'],
    keywords: ['personal', 'property', 'contents', 'belongings', 'furniture'],
    lineOfBusiness: ['homeowners', 'personal lines', 'renters'],
    category: 'Homeowners',
    commonlyPairedWith: ['Dwelling Coverage', 'Scheduled Personal Property'],
    description: 'Covers personal belongings and contents'
  },
  {
    name: 'Loss of Use',
    abbreviations: ['LOU', 'COV D', 'ALE'],
    aliases: ['Coverage D', 'Additional Living Expense', 'Fair Rental Value'],
    keywords: ['loss', 'use', 'living', 'expense', 'rental', 'displacement'],
    lineOfBusiness: ['homeowners', 'personal lines'],
    category: 'Homeowners',
    commonlyPairedWith: ['Dwelling Coverage'],
    description: 'Covers additional living expenses when home is uninhabitable'
  },
  {
    name: 'Personal Liability',
    abbreviations: ['PL', 'COV E'],
    aliases: ['Coverage E', 'Homeowner Liability'],
    keywords: ['personal', 'liability', 'lawsuit', 'negligence', 'injury'],
    lineOfBusiness: ['homeowners', 'personal lines'],
    category: 'Homeowners',
    commonlyPairedWith: ['Medical Payments to Others'],
    description: 'Covers personal liability claims against the homeowner'
  },
  {
    name: 'Medical Payments to Others',
    abbreviations: ['MEDPM', 'COV F'],
    aliases: ['Coverage F', 'Guest Medical'],
    keywords: ['medical', 'payments', 'others', 'guests', 'injury'],
    lineOfBusiness: ['homeowners', 'personal lines'],
    category: 'Homeowners',
    commonlyPairedWith: ['Personal Liability'],
    description: 'Pays medical expenses for guests injured on property'
  },
  {
    name: 'Scheduled Personal Property',
    abbreviations: ['SPP', 'SCHED'],
    aliases: ['Floater', 'Scheduled Items', 'Valuable Items'],
    keywords: ['scheduled', 'jewelry', 'watches', 'furs', 'cameras', 'valuables'],
    lineOfBusiness: ['homeowners', 'personal lines', 'inland marine'],
    category: 'Homeowners',
    commonlyPairedWith: ['Personal Property'],
    description: 'Covers high-value items specifically listed on policy'
  },
  {
    name: 'Water Backup',
    abbreviations: ['WB', 'SUMP'],
    aliases: ['Sewer Backup', 'Sump Pump Failure', 'Drain Backup'],
    keywords: ['water', 'backup', 'sewer', 'sump', 'drain', 'overflow'],
    lineOfBusiness: ['homeowners', 'personal lines'],
    category: 'Homeowners',
    commonlyPairedWith: ['Dwelling Coverage'],
    description: 'Covers damage from water backup and sump pump failure'
  },
  {
    name: 'Identity Theft',
    abbreviations: ['ID', 'IDTH'],
    aliases: ['Identity Fraud', 'Identity Recovery'],
    keywords: ['identity', 'theft', 'fraud', 'credit', 'recovery'],
    lineOfBusiness: ['homeowners', 'personal lines'],
    category: 'Homeowners',
    commonlyPairedWith: ['Personal Property'],
    description: 'Covers expenses related to identity theft recovery'
  },
  {
    name: 'Service Line Coverage',
    abbreviations: ['SL', 'SVCLN'],
    aliases: ['Utility Line', 'Underground Service'],
    keywords: ['service', 'line', 'utility', 'underground', 'pipes', 'wires'],
    lineOfBusiness: ['homeowners', 'personal lines'],
    category: 'Homeowners',
    commonlyPairedWith: ['Dwelling Coverage'],
    description: 'Covers repair of underground utility lines'
  },

  // ============================================================================
  // ADDITIONAL SPECIALTY COVERAGES
  // ============================================================================
  {
    name: 'Contingent Business Income',
    abbreviations: ['CBI', 'CONTBI'],
    aliases: ['Dependent Business Income', 'Supply Chain Coverage'],
    keywords: ['contingent', 'dependent', 'supplier', 'customer', 'supply chain'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Time Element',
    commonlyPairedWith: ['Business Income', 'Extra Expense'],
    description: 'Covers income loss from supplier or customer disruptions'
  },
  {
    name: 'Hired & Non-Owned Auto',
    abbreviations: ['HNOA', 'HNA'],
    aliases: ['HNOA Coverage'],
    keywords: ['hired', 'non-owned', 'rental', 'employee', 'vehicle'],
    lineOfBusiness: ['auto', 'commercial auto', 'liability'],
    category: 'Auto - Non-Owned',
    commonlyPairedWith: ['General Liability', 'Commercial Auto'],
    description: 'Covers hired and non-owned auto liability'
  },
  {
    name: 'Garage Liability',
    abbreviations: ['GL', 'GARAGE'],
    aliases: ['Garage Coverage', 'Auto Dealer Liability'],
    keywords: ['garage', 'dealer', 'repair', 'service', 'automotive'],
    lineOfBusiness: ['auto', 'garage', 'commercial'],
    category: 'Auto - Specialty',
    commonlyPairedWith: ['Garagekeepers Coverage'],
    description: 'Covers liability for auto dealers and repair shops'
  },
  {
    name: 'Garagekeepers Coverage',
    abbreviations: ['GK', 'GKPR'],
    aliases: ['Garagekeepers Legal Liability'],
    keywords: ['garagekeepers', 'customer', 'vehicle', 'custody', 'care'],
    lineOfBusiness: ['auto', 'garage', 'commercial'],
    category: 'Auto - Specialty',
    commonlyPairedWith: ['Garage Liability'],
    description: 'Covers damage to customer vehicles in your care'
  },
  {
    name: 'Ocean Marine',
    abbreviations: ['OM', 'OCEAN'],
    aliases: ['Marine Cargo', 'Hull Coverage'],
    keywords: ['ocean', 'marine', 'cargo', 'hull', 'vessel', 'ship'],
    lineOfBusiness: ['marine', 'ocean marine'],
    category: 'Marine',
    commonlyPairedWith: ['Protection & Indemnity'],
    description: 'Covers ocean-going vessels and cargo'
  },
  {
    name: 'Protection & Indemnity',
    abbreviations: ['P&I', 'PI'],
    aliases: ['P&I Coverage', 'Marine Liability'],
    keywords: ['protection', 'indemnity', 'marine', 'liability', 'crew'],
    lineOfBusiness: ['marine', 'ocean marine'],
    category: 'Marine',
    commonlyPairedWith: ['Ocean Marine', 'Hull Coverage'],
    description: 'Covers marine liability including crew injuries'
  },
  {
    name: 'Difference in Conditions',
    abbreviations: ['DIC'],
    aliases: ['DIC Coverage', 'Catastrophe Coverage'],
    keywords: ['difference', 'conditions', 'earthquake', 'flood', 'catastrophe'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Property Coverage', 'Flood Coverage', 'Earthquake Coverage'],
    description: 'Fills gaps in property coverage for catastrophic perils'
  },
  {
    name: 'ERISA Bond',
    abbreviations: ['ERISA', 'FID'],
    aliases: ['Fidelity Bond', 'Employee Benefit Bond'],
    keywords: ['ERISA', 'fidelity', 'bond', 'pension', 'benefits', '401k'],
    lineOfBusiness: ['fidelity', 'employee benefits'],
    category: 'Specialty',
    commonlyPairedWith: ['Fiduciary Liability'],
    description: 'Required bond for employee benefit plan administrators'
  },
  {
    name: 'Stop Loss',
    abbreviations: ['SL', 'STOPLOSS', 'ASL'],
    aliases: ['Aggregate Stop Loss', 'Specific Stop Loss', 'Excess Loss'],
    keywords: ['stop', 'loss', 'self-insured', 'aggregate', 'specific', 'excess'],
    lineOfBusiness: ['employee benefits', 'health'],
    category: 'Specialty',
    commonlyPairedWith: ['Health Insurance'],
    description: 'Limits employer liability for self-insured health plans'
  },
  {
    name: 'Kidnap & Ransom',
    abbreviations: ['K&R', 'KR'],
    aliases: ['K&R Coverage', 'Extortion Coverage'],
    keywords: ['kidnap', 'ransom', 'extortion', 'hostage', 'abduction'],
    lineOfBusiness: ['specialty', 'international'],
    category: 'Specialty',
    commonlyPairedWith: ['Directors & Officers Liability'],
    description: 'Covers kidnapping, ransom, and extortion events'
  },
  {
    name: 'Trade Credit',
    abbreviations: ['TC', 'CREDIT'],
    aliases: ['Credit Insurance', 'Accounts Receivable Insurance'],
    keywords: ['trade', 'credit', 'receivable', 'customer', 'default', 'bankruptcy'],
    lineOfBusiness: ['specialty', 'commercial'],
    category: 'Specialty',
    commonlyPairedWith: ['Accounts Receivable'],
    description: 'Covers non-payment by customers'
  },
  {
    name: 'Surety Bond',
    abbreviations: ['SURETY', 'BOND'],
    aliases: ['Contract Bond', 'Performance Bond', 'Bid Bond'],
    keywords: ['surety', 'bond', 'contract', 'performance', 'bid', 'payment'],
    lineOfBusiness: ['surety', 'construction'],
    category: 'Surety',
    commonlyPairedWith: ['Builders Risk', 'Contractors Equipment'],
    description: 'Guarantees contract performance'
  },

  // ============================================================================
  // ADDITIONAL PROPERTY COVERAGES
  // ============================================================================
  {
    name: 'Water Damage',
    abbreviations: ['WD', 'WATER'],
    aliases: ['Water Damage Coverage', 'Water Leak Coverage'],
    keywords: ['water', 'damage', 'leak', 'pipe', 'burst', 'plumbing'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Building Coverage', 'Flood Coverage'],
    description: 'Covers damage from accidental water discharge'
  },
  {
    name: 'Theft Coverage',
    abbreviations: ['THEFT', 'THF'],
    aliases: ['Burglary Coverage', 'Robbery Coverage'],
    keywords: ['theft', 'burglary', 'robbery', 'stealing', 'break-in'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Business Personal Property', 'Crime Coverage'],
    description: 'Covers loss from theft and burglary'
  },
  {
    name: 'Vandalism & Malicious Mischief',
    abbreviations: ['VMM', 'VAND'],
    aliases: ['Vandalism Coverage', 'Malicious Mischief'],
    keywords: ['vandalism', 'malicious', 'mischief', 'graffiti', 'damage'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Building Coverage', 'Glass Coverage'],
    description: 'Covers intentional damage by others'
  },
  {
    name: 'Falling Objects',
    abbreviations: ['FO', 'FALL'],
    aliases: ['Falling Objects Coverage'],
    keywords: ['falling', 'objects', 'tree', 'aircraft', 'debris'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Building Coverage'],
    description: 'Covers damage from falling objects'
  },
  {
    name: 'Weight of Ice, Snow or Sleet',
    abbreviations: ['ICE', 'SNOW'],
    aliases: ['Ice Damage', 'Snow Load'],
    keywords: ['ice', 'snow', 'sleet', 'weight', 'collapse', 'winter'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Named Perils',
    commonlyPairedWith: ['Building Coverage', 'Roof Coverage'],
    description: 'Covers damage from weight of snow and ice'
  },
  {
    name: 'Collapse Coverage',
    abbreviations: ['COLL', 'CLPS'],
    aliases: ['Building Collapse', 'Structural Collapse'],
    keywords: ['collapse', 'structural', 'failure', 'building'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Building Coverage', 'Weight of Ice, Snow or Sleet'],
    description: 'Covers structural collapse from specified causes'
  },
  {
    name: 'Fungus, Wet Rot, Dry Rot',
    abbreviations: ['MOLD', 'FUNGUS'],
    aliases: ['Mold Coverage', 'Rot Coverage'],
    keywords: ['fungus', 'mold', 'rot', 'mildew', 'moisture'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Building Coverage', 'Water Damage'],
    description: 'Limited coverage for mold and fungus damage'
  },
  {
    name: 'Utility Services',
    abbreviations: ['UTIL', 'US'],
    aliases: ['Off-Premises Power Failure', 'Utility Interruption'],
    keywords: ['utility', 'power', 'failure', 'outage', 'electric', 'gas'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Time Element',
    commonlyPairedWith: ['Business Income', 'Equipment Breakdown'],
    description: 'Covers loss from off-premises utility failure'
  },
  {
    name: 'Newly Acquired Property',
    abbreviations: ['NAP', 'NEWPROP'],
    aliases: ['Automatic Coverage', 'New Locations'],
    keywords: ['newly', 'acquired', 'property', 'automatic', 'locations'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Building Coverage', 'Business Personal Property'],
    description: 'Automatic coverage for newly acquired locations'
  },
  {
    name: 'Personal Effects',
    abbreviations: ['PE', 'PERSEFF'],
    aliases: ['Employee Personal Property'],
    keywords: ['personal', 'effects', 'employee', 'belongings'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Business Personal Property'],
    description: 'Covers employee personal property at work'
  },
  {
    name: 'Property in Transit',
    abbreviations: ['PIT', 'TRANSIT'],
    aliases: ['Goods in Transit', 'Shipment Coverage'],
    keywords: ['transit', 'shipping', 'transportation', 'delivery'],
    lineOfBusiness: ['property', 'inland marine'],
    category: 'Property - Specialty',
    commonlyPairedWith: ['Business Personal Property', 'Motor Truck Cargo'],
    description: 'Covers property while being transported'
  },
  {
    name: 'Property Off Premises',
    abbreviations: ['POP', 'OFFPREM'],
    aliases: ['Off-Premises Coverage'],
    keywords: ['off-premises', 'temporary', 'location', 'away'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Business Personal Property'],
    description: 'Covers property temporarily at other locations'
  },
  {
    name: 'Preservation of Property',
    abbreviations: ['PRES', 'PRESP'],
    aliases: ['Removal Coverage'],
    keywords: ['preservation', 'removal', 'protect', 'safeguard'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Building Coverage'],
    description: 'Covers property moved to protect from loss'
  },
  {
    name: 'Fire Department Service Charge',
    abbreviations: ['FDSC', 'FIRE'],
    aliases: ['Fire Service Charges'],
    keywords: ['fire', 'department', 'service', 'charge', 'municipal'],
    lineOfBusiness: ['property', 'commercial property', 'homeowners'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Fire Damage'],
    description: 'Covers fire department charges'
  },
  {
    name: 'Pollutant Cleanup and Removal',
    abbreviations: ['PCR', 'CLEANUP'],
    aliases: ['Pollution Cleanup'],
    keywords: ['pollutant', 'cleanup', 'removal', 'contamination'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Building Coverage'],
    description: 'Limited coverage for pollutant cleanup'
  },
  {
    name: 'Increased Cost of Construction',
    abbreviations: ['ICC', 'INCRCST'],
    aliases: ['Building Code Upgrade'],
    keywords: ['increased', 'cost', 'construction', 'upgrade', 'code'],
    lineOfBusiness: ['property', 'commercial property'],
    category: 'Property - Supplemental',
    commonlyPairedWith: ['Ordinance or Law', 'Building Coverage'],
    description: 'Covers increased costs due to building codes'
  },
  {
    name: 'Electronic Data Processing',
    abbreviations: ['EDP', 'COMP'],
    aliases: ['Computer Coverage', 'Technology Equipment'],
    keywords: ['electronic', 'data', 'processing', 'computer', 'server'],
    lineOfBusiness: ['property', 'inland marine', 'technology'],
    category: 'Property - Technology',
    commonlyPairedWith: ['Electronic Data', 'Equipment Breakdown'],
    description: 'Covers computer and technology equipment'
  },

  // ============================================================================
  // ADDITIONAL LIABILITY COVERAGES
  // ============================================================================
  {
    name: 'Premises Liability',
    abbreviations: ['PREML', 'PREM'],
    aliases: ['Premises Operations', 'Slip and Fall'],
    keywords: ['premises', 'operations', 'slip', 'fall', 'injury', 'visitor'],
    lineOfBusiness: ['liability', 'general liability'],
    category: 'Liability - General',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers injuries occurring on premises'
  },
  {
    name: 'Completed Operations',
    abbreviations: ['COMPOP', 'COMP'],
    aliases: ['Products-Completed Operations'],
    keywords: ['completed', 'operations', 'work', 'finished', 'project'],
    lineOfBusiness: ['liability', 'general liability', 'construction'],
    category: 'Liability - Products',
    commonlyPairedWith: ['Products Liability', 'Contractors Liability'],
    description: 'Covers liability after work is completed'
  },
  {
    name: 'Contractual Liability',
    abbreviations: ['CONTL', 'CONTR'],
    aliases: ['Hold Harmless', 'Indemnification'],
    keywords: ['contractual', 'liability', 'contract', 'hold harmless', 'indemnify'],
    lineOfBusiness: ['liability', 'general liability'],
    category: 'Liability - General',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers liability assumed under contract'
  },
  {
    name: 'Fire Legal Liability',
    abbreviations: ['FLL', 'FIRELEG'],
    aliases: ['Fire Damage Liability', 'Tenants Fire Liability'],
    keywords: ['fire', 'legal', 'liability', 'tenant', 'rented', 'premises'],
    lineOfBusiness: ['liability', 'general liability'],
    category: 'Liability - General',
    commonlyPairedWith: ['General Liability', 'Tenants Liability'],
    description: 'Covers fire damage to rented premises'
  },
  {
    name: 'Tenants Liability',
    abbreviations: ['TENL', 'TENANT'],
    aliases: ['Damage to Rented Premises'],
    keywords: ['tenant', 'rented', 'premises', 'damage', 'lease'],
    lineOfBusiness: ['liability', 'general liability'],
    category: 'Liability - General',
    commonlyPairedWith: ['General Liability', 'Fire Legal Liability'],
    description: 'Covers damage to rented premises'
  },
  {
    name: 'Independent Contractors',
    abbreviations: ['IC', 'INDCON'],
    aliases: ['Subcontractor Coverage'],
    keywords: ['independent', 'contractors', 'subcontractors', 'vendors'],
    lineOfBusiness: ['liability', 'general liability'],
    category: 'Liability - General',
    commonlyPairedWith: ['General Liability', 'Completed Operations'],
    description: 'Covers liability for work by independent contractors'
  },
  {
    name: 'Abuse and Molestation',
    abbreviations: ['A&M', 'ABUSE'],
    aliases: ['Sexual Abuse Liability', 'Molestation Coverage'],
    keywords: ['abuse', 'molestation', 'sexual', 'misconduct'],
    lineOfBusiness: ['liability', 'specialty'],
    category: 'Liability - Specialty',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers abuse and molestation claims'
  },
  {
    name: 'Athletic Participants',
    abbreviations: ['ATH', 'SPORTS'],
    aliases: ['Sports Participants', 'Athletic Injury'],
    keywords: ['athletic', 'sports', 'participants', 'injury', 'recreation'],
    lineOfBusiness: ['liability', 'specialty'],
    category: 'Liability - Specialty',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers liability for athletic activities'
  },
  {
    name: 'Cyber Extortion',
    abbreviations: ['CYBERX', 'EXTORT'],
    aliases: ['Ransomware Coverage', 'Cyber Ransom'],
    keywords: ['cyber', 'extortion', 'ransomware', 'ransom', 'hacking'],
    lineOfBusiness: ['cyber', 'liability'],
    category: 'Liability - Cyber',
    commonlyPairedWith: ['Cyber Liability', 'Data Breach Response'],
    description: 'Covers cyber extortion and ransomware payments'
  },
  {
    name: 'Data Breach Response',
    abbreviations: ['DBR', 'BREACH'],
    aliases: ['Breach Response', 'Notification Costs'],
    keywords: ['data', 'breach', 'response', 'notification', 'forensics'],
    lineOfBusiness: ['cyber', 'liability'],
    category: 'Liability - Cyber',
    commonlyPairedWith: ['Cyber Liability', 'Cyber Extortion'],
    description: 'Covers costs to respond to data breaches'
  },
  {
    name: 'Network Security Liability',
    abbreviations: ['NSL', 'NETSEC'],
    aliases: ['Network Security', 'IT Security Liability'],
    keywords: ['network', 'security', 'liability', 'IT', 'breach'],
    lineOfBusiness: ['cyber', 'liability'],
    category: 'Liability - Cyber',
    commonlyPairedWith: ['Cyber Liability', 'Professional Liability'],
    description: 'Covers liability for network security failures'
  },
  {
    name: 'Privacy Liability',
    abbreviations: ['PRIV', 'PRIVACY'],
    aliases: ['Privacy Coverage', 'GDPR Coverage'],
    keywords: ['privacy', 'liability', 'GDPR', 'CCPA', 'personal', 'data'],
    lineOfBusiness: ['cyber', 'liability'],
    category: 'Liability - Cyber',
    commonlyPairedWith: ['Cyber Liability', 'Data Breach Response'],
    description: 'Covers privacy law violations'
  },
  {
    name: 'Social Engineering Fraud',
    abbreviations: ['SEF', 'SOCENG'],
    aliases: ['Business Email Compromise', 'Phishing Coverage'],
    keywords: ['social', 'engineering', 'fraud', 'phishing', 'email', 'scam'],
    lineOfBusiness: ['cyber', 'crime'],
    category: 'Liability - Cyber',
    commonlyPairedWith: ['Cyber Liability', 'Crime Coverage'],
    description: 'Covers losses from social engineering attacks'
  },
  {
    name: 'Business Fraud',
    abbreviations: ['BF', 'FRAUD'],
    aliases: ['Commercial Fraud', 'Financial Fraud'],
    keywords: ['business', 'fraud', 'financial', 'deception', 'scam'],
    lineOfBusiness: ['crime', 'commercial'],
    category: 'Specialty',
    commonlyPairedWith: ['Crime Coverage', 'Employee Dishonesty'],
    description: 'Covers various forms of business fraud'
  },

  // ============================================================================
  // ADDITIONAL AUTO COVERAGES
  // ============================================================================
  {
    name: 'Rental Reimbursement',
    abbreviations: ['RR', 'RENTAL'],
    aliases: ['Rental Car Coverage', 'Transportation Expense'],
    keywords: ['rental', 'reimbursement', 'car', 'transportation', 'expense'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Supplemental',
    commonlyPairedWith: ['Collision Coverage', 'Comprehensive Coverage'],
    description: 'Covers rental car costs while vehicle is repaired'
  },
  {
    name: 'Towing & Labor',
    abbreviations: ['T&L', 'TOW'],
    aliases: ['Roadside Assistance', 'Towing Coverage'],
    keywords: ['towing', 'labor', 'roadside', 'assistance', 'breakdown'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Supplemental',
    commonlyPairedWith: ['Collision Coverage'],
    description: 'Covers towing and labor costs'
  },
  {
    name: 'Gap Coverage',
    abbreviations: ['GAP'],
    aliases: ['Loan/Lease Gap', 'Total Loss Gap'],
    keywords: ['gap', 'loan', 'lease', 'total', 'loss', 'payoff'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Supplemental',
    commonlyPairedWith: ['Collision Coverage', 'Comprehensive Coverage'],
    description: 'Covers gap between vehicle value and loan balance'
  },
  {
    name: 'Personal Injury Protection',
    abbreviations: ['PIP'],
    aliases: ['No-Fault Coverage', 'Personal Injury'],
    keywords: ['personal', 'injury', 'protection', 'no-fault', 'medical'],
    lineOfBusiness: ['auto'],
    category: 'Auto - No-Fault',
    commonlyPairedWith: ['Auto Liability', 'Medical Payments'],
    description: 'No-fault coverage for medical and lost wages'
  },
  {
    name: 'Drive Other Car',
    abbreviations: ['DOC'],
    aliases: ['DOC Coverage', 'Non-Owned Auto Liability'],
    keywords: ['drive', 'other', 'car', 'non-owned', 'borrowed'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Non-Owned',
    commonlyPairedWith: ['Auto Liability'],
    description: 'Covers named insured driving non-owned vehicles'
  },
  {
    name: 'Stated Amount',
    abbreviations: ['SA', 'STATED'],
    aliases: ['Agreed Value', 'Classic Car Value'],
    keywords: ['stated', 'amount', 'agreed', 'value', 'classic', 'antique'],
    lineOfBusiness: ['auto'],
    category: 'Auto - Specialty',
    commonlyPairedWith: ['Comprehensive Coverage'],
    description: 'Agreed value coverage for specialty vehicles'
  },
  {
    name: 'Auto Physical Damage',
    abbreviations: ['APD', 'PD'],
    aliases: ['Physical Damage', 'Vehicle Damage'],
    keywords: ['physical', 'damage', 'vehicle', 'auto', 'collision'],
    lineOfBusiness: ['auto', 'commercial auto'],
    category: 'Auto - Physical Damage',
    commonlyPairedWith: ['Collision Coverage', 'Comprehensive Coverage'],
    description: 'Covers physical damage to vehicles'
  },
  {
    name: 'Trailer Interchange',
    abbreviations: ['TI', 'TRAILER'],
    aliases: ['Trailer Coverage', 'Interchange Coverage'],
    keywords: ['trailer', 'interchange', 'trucking', 'cargo'],
    lineOfBusiness: ['auto', 'commercial auto', 'trucking'],
    category: 'Auto - Commercial',
    commonlyPairedWith: ['Motor Truck Cargo', 'Auto Liability'],
    description: 'Covers trailers in interchange agreements'
  },

  // ============================================================================
  // ADDITIONAL SPECIALTY COVERAGES
  // ============================================================================
  {
    name: 'Event Cancellation',
    abbreviations: ['EC', 'EVENT'],
    aliases: ['Event Insurance', 'Cancellation Coverage'],
    keywords: ['event', 'cancellation', 'postponement', 'weather', 'venue'],
    lineOfBusiness: ['specialty', 'event'],
    category: 'Specialty',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers losses from event cancellation'
  },
  {
    name: 'Prize Indemnification',
    abbreviations: ['PRIZE', 'PI'],
    aliases: ['Hole in One', 'Contest Coverage'],
    keywords: ['prize', 'indemnification', 'contest', 'promotion', 'giveaway'],
    lineOfBusiness: ['specialty'],
    category: 'Specialty',
    commonlyPairedWith: ['Event Cancellation'],
    description: 'Covers large prize payouts'
  },
  {
    name: 'Film Production',
    abbreviations: ['FILM', 'PROD'],
    aliases: ['Production Insurance', 'Entertainment Insurance'],
    keywords: ['film', 'production', 'movie', 'television', 'entertainment'],
    lineOfBusiness: ['specialty', 'entertainment'],
    category: 'Specialty',
    commonlyPairedWith: ['General Liability', 'Equipment Coverage'],
    description: 'Covers film and video production risks'
  },
  {
    name: 'Aviation Liability',
    abbreviations: ['AVNL', 'AVIA'],
    aliases: ['Aircraft Liability'],
    keywords: ['aviation', 'aircraft', 'airplane', 'flying', 'pilot'],
    lineOfBusiness: ['aviation'],
    category: 'Aviation',
    commonlyPairedWith: ['Aviation Hull'],
    description: 'Covers liability for aircraft operations'
  },
  {
    name: 'Aviation Hull',
    abbreviations: ['AVNH', 'HULL'],
    aliases: ['Aircraft Hull', 'Physical Damage'],
    keywords: ['aviation', 'hull', 'aircraft', 'physical', 'damage'],
    lineOfBusiness: ['aviation'],
    category: 'Aviation',
    commonlyPairedWith: ['Aviation Liability'],
    description: 'Covers physical damage to aircraft'
  },
  {
    name: 'Hangarkeepers Liability',
    abbreviations: ['HNGR', 'HANG'],
    aliases: ['Hangar Liability'],
    keywords: ['hangar', 'keepers', 'liability', 'aviation', 'storage'],
    lineOfBusiness: ['aviation'],
    category: 'Aviation',
    commonlyPairedWith: ['Aviation Liability'],
    description: 'Covers damage to aircraft in your care'
  },
  {
    name: 'Watercraft Liability',
    abbreviations: ['WATL', 'BOAT'],
    aliases: ['Boat Liability', 'Marine Liability'],
    keywords: ['watercraft', 'boat', 'marine', 'liability', 'vessel'],
    lineOfBusiness: ['marine', 'personal lines'],
    category: 'Marine',
    commonlyPairedWith: ['Watercraft Hull'],
    description: 'Covers liability for boat operations'
  },
  {
    name: 'Watercraft Hull',
    abbreviations: ['WATH', 'BOATH'],
    aliases: ['Boat Hull', 'Vessel Physical Damage'],
    keywords: ['watercraft', 'hull', 'boat', 'physical', 'damage'],
    lineOfBusiness: ['marine', 'personal lines'],
    category: 'Marine',
    commonlyPairedWith: ['Watercraft Liability'],
    description: 'Covers physical damage to boats'
  },
  {
    name: 'Livestock Mortality',
    abbreviations: ['LM', 'LIVE'],
    aliases: ['Animal Mortality', 'Livestock Coverage'],
    keywords: ['livestock', 'mortality', 'animal', 'farm', 'cattle'],
    lineOfBusiness: ['farm', 'agricultural'],
    category: 'Agricultural',
    commonlyPairedWith: ['Farm Property'],
    description: 'Covers death of livestock'
  },
  {
    name: 'Crop Insurance',
    abbreviations: ['CROP', 'CI'],
    aliases: ['Crop Coverage', 'Agricultural Coverage'],
    keywords: ['crop', 'agricultural', 'farm', 'harvest', 'weather'],
    lineOfBusiness: ['farm', 'agricultural'],
    category: 'Agricultural',
    commonlyPairedWith: ['Farm Property'],
    description: 'Covers crop losses from covered perils'
  },
  {
    name: 'Farm Property',
    abbreviations: ['FARM', 'FP'],
    aliases: ['Farm Coverage', 'Agricultural Property'],
    keywords: ['farm', 'property', 'agricultural', 'barn', 'equipment'],
    lineOfBusiness: ['farm', 'agricultural'],
    category: 'Agricultural',
    commonlyPairedWith: ['Livestock Mortality', 'Crop Insurance'],
    description: 'Covers farm buildings and equipment'
  },
  {
    name: 'Umbrella Commercial',
    abbreviations: ['CUL', 'COMUMB'],
    aliases: ['Commercial Umbrella', 'CUL Coverage'],
    keywords: ['umbrella', 'commercial', 'excess', 'catastrophic'],
    lineOfBusiness: ['liability', 'umbrella', 'commercial'],
    category: 'Liability - Excess',
    commonlyPairedWith: ['General Liability', 'Auto Liability', 'Employers Liability'],
    description: 'Excess liability for commercial risks'
  },
  {
    name: 'Umbrella Personal',
    abbreviations: ['PUL', 'PERSUMB'],
    aliases: ['Personal Umbrella', 'PUL Coverage'],
    keywords: ['umbrella', 'personal', 'excess', 'catastrophic'],
    lineOfBusiness: ['liability', 'umbrella', 'personal lines'],
    category: 'Liability - Excess',
    commonlyPairedWith: ['Personal Liability', 'Auto Liability'],
    description: 'Excess liability for personal risks'
  },
  {
    name: 'Excess Liability',
    abbreviations: ['XS', 'EXCESS'],
    aliases: ['Follow Form Excess'],
    keywords: ['excess', 'follow', 'form', 'additional', 'limits'],
    lineOfBusiness: ['liability', 'excess'],
    category: 'Liability - Excess',
    commonlyPairedWith: ['General Liability', 'Umbrella Liability'],
    description: 'Provides additional liability limits'
  },

  // ============================================================================
  // PROFESSIONAL LIABILITY BY INDUSTRY
  // ============================================================================
  {
    name: 'Medical Malpractice',
    abbreviations: ['MEDMAL', 'MPL'],
    aliases: ['Medical Professional Liability', 'Healthcare Liability'],
    keywords: ['medical', 'malpractice', 'doctor', 'physician', 'healthcare'],
    lineOfBusiness: ['professional liability', 'healthcare'],
    category: 'Liability - Professional',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers medical professional negligence'
  },
  {
    name: 'Legal Malpractice',
    abbreviations: ['LEGMAL', 'LPL'],
    aliases: ['Lawyers Professional Liability'],
    keywords: ['legal', 'malpractice', 'lawyer', 'attorney', 'law firm'],
    lineOfBusiness: ['professional liability'],
    category: 'Liability - Professional',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers legal professional negligence'
  },
  {
    name: 'Accountants Professional Liability',
    abbreviations: ['APL', 'ACCT'],
    aliases: ['CPA Liability', 'Accountants E&O'],
    keywords: ['accountant', 'CPA', 'professional', 'liability', 'audit'],
    lineOfBusiness: ['professional liability'],
    category: 'Liability - Professional',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers accounting professional negligence'
  },
  {
    name: 'Architects & Engineers',
    abbreviations: ['A&E', 'AE'],
    aliases: ['Design Professional Liability'],
    keywords: ['architects', 'engineers', 'design', 'professional', 'plans'],
    lineOfBusiness: ['professional liability', 'construction'],
    category: 'Liability - Professional',
    commonlyPairedWith: ['General Liability', 'Contractors Liability'],
    description: 'Covers design professional negligence'
  },
  {
    name: 'Real Estate E&O',
    abbreviations: ['REE&O', 'REEO'],
    aliases: ['Real Estate Professional Liability', 'Realtors E&O'],
    keywords: ['real', 'estate', 'realtor', 'agent', 'broker'],
    lineOfBusiness: ['professional liability'],
    category: 'Liability - Professional',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers real estate professional negligence'
  },
  {
    name: 'Insurance Agents E&O',
    abbreviations: ['IAE&O', 'AGEO'],
    aliases: ['Insurance Agents Professional Liability'],
    keywords: ['insurance', 'agent', 'broker', 'producer', 'professional'],
    lineOfBusiness: ['professional liability'],
    category: 'Liability - Professional',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers insurance agent negligence'
  },
  {
    name: 'Miscellaneous Professional Liability',
    abbreviations: ['MISC', 'MISCPL'],
    aliases: ['Allied Healthcare', 'Consultants E&O'],
    keywords: ['miscellaneous', 'professional', 'consultant', 'services'],
    lineOfBusiness: ['professional liability'],
    category: 'Liability - Professional',
    commonlyPairedWith: ['General Liability'],
    description: 'Covers various professional services'
  },

  // ============================================================================
  // CONSTRUCTION-SPECIFIC COVERAGES
  // ============================================================================
  {
    name: 'Contractors Liability',
    abbreviations: ['CONTL', 'CL'],
    aliases: ['Contractor General Liability'],
    keywords: ['contractors', 'liability', 'construction', 'builder'],
    lineOfBusiness: ['liability', 'construction'],
    category: 'Liability - Construction',
    commonlyPairedWith: ['Completed Operations', 'Builders Risk'],
    description: 'General liability for construction contractors'
  },
  {
    name: 'Wrap-Up Liability',
    abbreviations: ['WRAP', 'OCIP'],
    aliases: ['OCIP', 'CCIP', 'Rolling Wrap'],
    keywords: ['wrap-up', 'OCIP', 'CCIP', 'construction', 'consolidated'],
    lineOfBusiness: ['liability', 'construction'],
    category: 'Liability - Construction',
    commonlyPairedWith: ['Builders Risk', 'Contractors Liability'],
    description: 'Consolidated insurance for construction projects'
  },
  {
    name: 'Subcontractor Default Insurance',
    abbreviations: ['SDI', 'SUBDEF'],
    aliases: ['SDI Coverage', 'Subcontractor Risk'],
    keywords: ['subcontractor', 'default', 'construction', 'performance'],
    lineOfBusiness: ['construction', 'surety'],
    category: 'Specialty',
    commonlyPairedWith: ['Contractors Liability', 'Surety Bond'],
    description: 'Covers losses from subcontractor default'
  },
  {
    name: 'Contractors Pollution',
    abbreviations: ['CPL', 'CONTPOL'],
    aliases: ['Contractors Environmental Liability'],
    keywords: ['contractors', 'pollution', 'environmental', 'construction'],
    lineOfBusiness: ['liability', 'construction', 'environmental'],
    category: 'Liability - Environmental',
    commonlyPairedWith: ['Contractors Liability', 'Pollution Liability'],
    description: 'Pollution liability for contractors'
  },
  {
    name: 'Project Specific Liability',
    abbreviations: ['PSL', 'PROJ'],
    aliases: ['Project Policy', 'Job-Specific Coverage'],
    keywords: ['project', 'specific', 'construction', 'job'],
    lineOfBusiness: ['liability', 'construction'],
    category: 'Liability - Construction',
    commonlyPairedWith: ['Builders Risk', 'Wrap-Up Liability'],
    description: 'Liability coverage for specific projects'
  },

  // ============================================================================
  // HEALTHCARE-SPECIFIC COVERAGES
  // ============================================================================
  {
    name: 'Hospital Professional Liability',
    abbreviations: ['HPL', 'HOSP'],
    aliases: ['Hospital Malpractice'],
    keywords: ['hospital', 'professional', 'liability', 'healthcare', 'medical'],
    lineOfBusiness: ['professional liability', 'healthcare'],
    category: 'Liability - Healthcare',
    commonlyPairedWith: ['General Liability', 'Medical Malpractice'],
    description: 'Professional liability for hospitals'
  },
  {
    name: 'Nursing Home Liability',
    abbreviations: ['NHL', 'NURSE'],
    aliases: ['Long-Term Care Liability'],
    keywords: ['nursing', 'home', 'liability', 'long-term', 'care', 'elder'],
    lineOfBusiness: ['professional liability', 'healthcare'],
    category: 'Liability - Healthcare',
    commonlyPairedWith: ['General Liability', 'Abuse and Molestation'],
    description: 'Liability for nursing home operations'
  },
  {
    name: 'Allied Healthcare Professional',
    abbreviations: ['AHP', 'ALLIED'],
    aliases: ['Allied Health Liability'],
    keywords: ['allied', 'healthcare', 'nurse', 'therapist', 'technician'],
    lineOfBusiness: ['professional liability', 'healthcare'],
    category: 'Liability - Healthcare',
    commonlyPairedWith: ['General Liability'],
    description: 'Liability for allied healthcare professionals'
  },

  // ============================================================================
  // FINANCIAL INSTITUTION COVERAGES
  // ============================================================================
  {
    name: 'Financial Institution Bond',
    abbreviations: ['FIB', 'BOND'],
    aliases: ['Bankers Blanket Bond'],
    keywords: ['financial', 'institution', 'bond', 'bank', 'fidelity'],
    lineOfBusiness: ['fidelity', 'financial institutions'],
    category: 'Financial Institutions',
    commonlyPairedWith: ['Directors & Officers Liability'],
    description: 'Fidelity bond for financial institutions'
  },
  {
    name: 'Lender Liability',
    abbreviations: ['LENDL', 'LEND'],
    aliases: ['Lenders E&O'],
    keywords: ['lender', 'liability', 'loan', 'mortgage', 'bank'],
    lineOfBusiness: ['liability', 'financial institutions'],
    category: 'Financial Institutions',
    commonlyPairedWith: ['Professional Liability'],
    description: 'Covers liability for lending activities'
  },
  {
    name: 'Securities Broker-Dealer',
    abbreviations: ['BD', 'SEC'],
    aliases: ['Broker-Dealer E&O'],
    keywords: ['securities', 'broker', 'dealer', 'investment', 'trading'],
    lineOfBusiness: ['professional liability', 'financial institutions'],
    category: 'Financial Institutions',
    commonlyPairedWith: ['Fiduciary Liability'],
    description: 'Liability for securities broker-dealers'
  },
  {
    name: 'Investment Advisor Liability',
    abbreviations: ['IAL', 'RIA'],
    aliases: ['RIA E&O', 'Investment Management Liability'],
    keywords: ['investment', 'advisor', 'RIA', 'management', 'fiduciary'],
    lineOfBusiness: ['professional liability', 'financial institutions'],
    category: 'Financial Institutions',
    commonlyPairedWith: ['Fiduciary Liability'],
    description: 'Liability for investment advisors'
  },

  // ============================================================================
  // NON-PROFIT COVERAGES
  // ============================================================================
  {
    name: 'Nonprofit D&O',
    abbreviations: ['NPD&O', 'NPDO'],
    aliases: ['Nonprofit Directors & Officers'],
    keywords: ['nonprofit', 'directors', 'officers', 'charity', 'board'],
    lineOfBusiness: ['management liability', 'nonprofit'],
    category: 'Liability - Management',
    commonlyPairedWith: ['Employment Practices Liability'],
    description: 'D&O coverage for nonprofits'
  },
  {
    name: 'Volunteer Liability',
    abbreviations: ['VOL', 'VOLUN'],
    aliases: ['Volunteer Coverage'],
    keywords: ['volunteer', 'liability', 'nonprofit', 'charity'],
    lineOfBusiness: ['liability', 'nonprofit'],
    category: 'Liability - Specialty',
    commonlyPairedWith: ['General Liability', 'Nonprofit D&O'],
    description: 'Covers liability of volunteers'
  },
  {
    name: 'Improper Sexual Conduct',
    abbreviations: ['ISC', 'SEXUAL'],
    aliases: ['Sexual Misconduct Liability'],
    keywords: ['sexual', 'misconduct', 'improper', 'conduct', 'abuse'],
    lineOfBusiness: ['liability', 'specialty'],
    category: 'Liability - Specialty',
    commonlyPairedWith: ['General Liability', 'Abuse and Molestation'],
    description: 'Covers sexual misconduct claims'
  },
];

```

---

## src/firebase.ts

**Path:** `src/firebase.ts`

```typescript
/**
 * Firebase Configuration & Initialization
 * Modern setup with emulator support, persistence, and error handling
 */

import { FirebaseApp, initializeApp } from 'firebase/app';
import { Auth, getAuth, connectAuthEmulator } from 'firebase/auth';
import {
  Firestore,
  initializeFirestore,
  connectFirestoreEmulator,
  persistentLocalCache,
  persistentMultipleTabManager
} from 'firebase/firestore';
import { Functions, getFunctions, connectFunctionsEmulator } from 'firebase/functions';
import { FirebaseStorage, getStorage, connectStorageEmulator } from 'firebase/storage';
import env, { validateEnvironment } from './config/env';

// Validate environment variables before initialization
validateEnvironment();

// Firebase configuration
interface FirebaseConfig {
  apiKey: string | undefined;
  authDomain: string | undefined;
  projectId: string | undefined;
  storageBucket: string | undefined;
  messagingSenderId: string | undefined;
  appId: string | undefined;
  measurementId?: string | undefined;
}

const firebaseConfig: FirebaseConfig = {
  apiKey: env.FIREBASE_API_KEY,
  authDomain: env.FIREBASE_AUTH_DOMAIN,
  projectId: env.FIREBASE_PROJECT_ID,
  storageBucket: env.FIREBASE_STORAGE_BUCKET,
  messagingSenderId: env.FIREBASE_MESSAGING_SENDER_ID,
  appId: env.FIREBASE_APP_ID,
  measurementId: env.FIREBASE_MEASUREMENT_ID
};

// Validate configuration
const validateConfig = (): void => {
  const requiredFields: (keyof FirebaseConfig)[] = ['apiKey', 'projectId', 'appId'];
  const missing = requiredFields.filter(field => !firebaseConfig[field]);

  if (missing.length > 0) {
    console.error('âŒ Missing Firebase configuration:', missing);
    throw new Error(`Missing required Firebase config: ${missing.join(', ')}`);
  }
};

// Initialize Firebase
let app: FirebaseApp;
try {
  validateConfig();
  app = initializeApp(firebaseConfig as Record<string, string>);
} catch (error) {
  console.error('âŒ Firebase initialization failed:', error);
  throw error;
}

// Initialize services
export const auth: Auth = getAuth(app);

// Initialize Firestore with modern cache API (replaces deprecated enableMultiTabIndexedDbPersistence)
export const db: Firestore = initializeFirestore(app, {
  localCache: persistentLocalCache({
    tabManager: persistentMultipleTabManager()
  })
});

export const functions: Functions = getFunctions(app);
export const storage: FirebaseStorage = getStorage(app);

// Emulator configuration
const USE_EMULATORS = env.USE_FIREBASE_EMULATORS &&
                      typeof window !== 'undefined' &&
                      window.location.hostname === 'localhost';

if (USE_EMULATORS) {
  try {
    connectFirestoreEmulator(db, 'localhost', 8080);
    connectAuthEmulator(auth, 'http://localhost:9099', { disableWarnings: true });
    connectFunctionsEmulator(functions, 'localhost', 5001);
    connectStorageEmulator(storage, 'localhost', 9199);
    console.log('ðŸ”§ Firebase: Connected to emulators (Firestore:8080, Auth:9099, Functions:5001, Storage:9199)');
  } catch (error) {
    const err = error as Error;
    console.warn('âš ï¸ Firebase: Emulator connection failed:', err.message);
  }
} else {
  // Single consolidated log for production Firebase
  console.log('âœ… Firebase: Initialized with persistent cache');
}

// Export app instance for advanced use cases
export default app;

```

---

## src/hooks/index.ts

**Path:** `src/hooks/index.ts`

```typescript
/**
 * Hooks Index
 * Centralized exports for all custom hooks
 */

// Data hooks
export { default as useCoverages } from './useCoverages';
export { default as useProducts } from './useProducts';
export { default as useProduct } from './useProduct';
export { default as useForms } from './useForms';
export { useCoverageData } from './useCoverageData';
export { useCoverageFormCounts } from './useCoverageFormCounts';
export { useCoveragePackages } from './useCoveragePackages';

// Coverage Copilot hooks
export { default as useCoverageDraft } from './useCoverageDraft';

// Firebase hooks
export { default as useFirebaseConnection } from './useFirebaseConnection';

// Memoization hooks
export { default as useAdvancedMemo } from './useAdvancedMemo';
```

---

## src/hooks/useAdvancedMemo.ts

**Path:** `src/hooks/useAdvancedMemo.ts`

```typescript
/**
 * Advanced Memoization Hook
 * Simplified version containing only actively used functionality
 */

import { useRef } from 'react';

/**
 * Deep equality comparison for objects and arrays
 */
function deepEqual(a: any, b: any): boolean {
  if (a === b) return true;
  
  if (a == null || b == null) return a === b;
  
  if (typeof a !== typeof b) return false;
  
  if (typeof a !== 'object') return a === b;
  
  if (Array.isArray(a) !== Array.isArray(b)) return false;
  
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) return false;
    }
    return true;
  }
  
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  for (const key of keysA) {
    if (!keysB.includes(key)) return false;
    if (!deepEqual(a[key], b[key])) return false;
  }
  
  return true;
}

/**
 * Advanced memoization with deep comparison
 * Only recomputes when dependencies have deeply changed (not just reference equality)
 * 
 * @param factory - Function that computes the memoized value
 * @param deps - Dependencies to watch for changes
 * @returns Memoized value
 * 
 * @example
 * const expensiveValue = useDeepMemo(() => {
 *   return computeExpensiveValue(data);
 * }, data);
 */
export function useDeepMemo<T>(factory: () => T, deps: any): T {
  const ref = useRef<{ deps: any; value: T }>();
  
  if (!ref.current || !deepEqual(deps, ref.current.deps)) {
    ref.current = {
      deps,
      value: factory()
    };
  }
  
  return ref.current.value;
}

export default useDeepMemo;
```

---

## src/hooks/useAutoDraftCoverage.ts

**Path:** `src/hooks/useAutoDraftCoverage.ts`

```typescript
/**
 * useAutoDraftCoverage - Hook for AI-powered auto-drafting of coverage fields
 * 
 * Uses a lightweight LLM call to auto-populate the next step's fields
 * based on the coverage name and current draft state
 */

import { useState, useCallback } from 'react';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../firebase';
import { Coverage } from '../types';

interface AutoDraftResult {
  fields: Partial<Coverage>;
  confidence: number;
  suggestions?: string[];
}

interface UseAutoDraftOptions {
  productId: string;
  onFieldsGenerated?: (fields: Partial<Coverage>) => void;
}

export function useAutoDraftCoverage({ productId, onFieldsGenerated }: UseAutoDraftOptions) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastGenerated, setLastGenerated] = useState<Partial<Coverage> | null>(null);

  const generateFieldsForStep = useCallback(async (
    stepId: string,
    currentDraft: Partial<Coverage>
  ): Promise<AutoDraftResult | null> => {
    // Only generate if we have a coverage name
    if (!currentDraft.name) {
      return null;
    }

    setIsGenerating(true);
    setError(null);

    try {
      const autoDraftCoverage = httpsCallable<unknown, AutoDraftResult>(
        functions, 
        'autoDraftCoverageFields'
      );

      const response = await autoDraftCoverage({
        productId,
        stepId,
        coverageName: currentDraft.name,
        coverageCode: currentDraft.coverageCode,
        currentDraft
      });

      const result = response.data;
      setLastGenerated(result.fields);

      if (onFieldsGenerated && result.fields) {
        onFieldsGenerated(result.fields);
      }

      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to auto-generate fields';
      console.error('Auto-draft error:', err);
      setError(errorMessage);
      return null;
    } finally {
      setIsGenerating(false);
    }
  }, [productId, onFieldsGenerated]);

  const clearGenerated = useCallback(() => {
    setLastGenerated(null);
    setError(null);
  }, []);

  return {
    generateFieldsForStep,
    isGenerating,
    error,
    lastGenerated,
    generatedFields: lastGenerated, // Alias for clarity
    clearGenerated
  };
}

export default useAutoDraftCoverage;

```

---

## src/hooks/useCoverageData.ts

**Path:** `src/hooks/useCoverageData.ts`

```typescript
/**
 * Unified Coverage Data Hook
 * Consolidates useCoverageLimits and useCoverageDeductibles into a single, efficient hook
 * 
 * Handles fetching, creating, updating, and deleting both limits and deductibles
 * from Firestore subcollections with real-time updates and caching.
 */

import { useState, useEffect, useCallback, useMemo } from 'react';
import {
  collection,
  query,
  onSnapshot,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  Timestamp
} from 'firebase/firestore';
import { db } from '../firebase';
import { CoverageLimit, CoverageDeductible } from '../types';

interface UseCoverageDataResult {
  // Limits
  limits: CoverageLimit[];
  addLimit: (limit: Omit<CoverageLimit, 'id' | 'createdAt' | 'updatedAt'>) => Promise<string>;
  updateLimit: (limitId: string, updates: Partial<CoverageLimit>) => Promise<void>;
  deleteLimit: (limitId: string) => Promise<void>;
  setDefaultLimit: (limitId: string) => Promise<void>;

  // Deductibles
  deductibles: CoverageDeductible[];
  addDeductible: (deductible: Omit<CoverageDeductible, 'id' | 'createdAt' | 'updatedAt'>) => Promise<string>;
  updateDeductible: (deductibleId: string, updates: Partial<CoverageDeductible>) => Promise<void>;
  deleteDeductible: (deductibleId: string) => Promise<void>;
  setDefaultDeductible: (deductibleId: string) => Promise<void>;

  // State
  loading: boolean;
  error: string | null;
}

/**
 * Unified hook for managing coverage limits and deductibles
 * Reduces code duplication and improves maintainability
 */
export function useCoverageData(
  productId: string | undefined,
  coverageId: string | undefined
): UseCoverageDataResult {
  const [limits, setLimits] = useState<CoverageLimit[]>([]);
  const [deductibles, setDeductibles] = useState<CoverageDeductible[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Real-time listener for limits
  useEffect(() => {
    if (!productId || !coverageId) {
      setLimits([]);
      return;
    }

    const limitsRef = collection(db, `products/${productId}/coverages/${coverageId}/limits`);
    const unsubscribe = onSnapshot(
      query(limitsRef),
      (snapshot) => {
        const limitsData = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })) as CoverageLimit[];
        setLimits(limitsData);
        setLoading(false);
      },
      (err) => {
        console.error('Error fetching limits:', err);
        setError(err.message);
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, [productId, coverageId]);

  // Real-time listener for deductibles
  useEffect(() => {
    if (!productId || !coverageId) {
      setDeductibles([]);
      return;
    }

    const deductiblesRef = collection(db, `products/${productId}/coverages/${coverageId}/deductibles`);
    const unsubscribe = onSnapshot(
      query(deductiblesRef),
      (snapshot) => {
        const deductiblesData = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })) as CoverageDeductible[];
        setDeductibles(deductiblesData);
      },
      (err) => {
        console.error('Error fetching deductibles:', err);
        setError(err.message);
      }
    );

    return () => unsubscribe();
  }, [productId, coverageId]);

  // Generic add function for both limits and deductibles
  const addItem = useCallback(
    async <T extends CoverageLimit | CoverageDeductible>(
      itemData: Omit<T, 'id' | 'createdAt' | 'updatedAt'>,
      type: 'limits' | 'deductibles'
    ): Promise<string> => {
      if (!productId || !coverageId) {
        throw new Error('Product ID and Coverage ID are required');
      }

      try {
        const collectionPath = `products/${productId}/coverages/${coverageId}/${type}`;
        const itemRef = collection(db, collectionPath);
        const newItem = {
          ...itemData,
          coverageId,
          productId,
          createdAt: Timestamp.now(),
          updatedAt: Timestamp.now(),
        };
        const docRef = await addDoc(itemRef, newItem);
        return docRef.id;
      } catch (err: any) {
        console.error(`Error adding ${type}:`, err);
        throw new Error(err.message || `Failed to add ${type}`);
      }
    },
    [productId, coverageId]
  );

  // Generic update function
  const updateItem = useCallback(
    async <T extends CoverageLimit | CoverageDeductible>(
      itemId: string,
      updates: Partial<T>,
      type: 'limits' | 'deductibles'
    ): Promise<void> => {
      if (!productId || !coverageId) {
        throw new Error('Product ID and Coverage ID are required');
      }

      try {
        const itemRef = doc(db, `products/${productId}/coverages/${coverageId}/${type}`, itemId);
        await updateDoc(itemRef, {
          ...updates,
          updatedAt: Timestamp.now(),
        });
      } catch (err: any) {
        console.error(`Error updating ${type}:`, err);
        throw new Error(err.message || `Failed to update ${type}`);
      }
    },
    [productId, coverageId]
  );

  // Generic delete function
  const deleteItem = useCallback(
    async (itemId: string, type: 'limits' | 'deductibles'): Promise<void> => {
      if (!productId || !coverageId) {
        throw new Error('Product ID and Coverage ID are required');
      }

      try {
        const itemRef = doc(db, `products/${productId}/coverages/${coverageId}/${type}`, itemId);
        await deleteDoc(itemRef);
      } catch (err: any) {
        console.error(`Error deleting ${type}:`, err);
        throw new Error(err.message || `Failed to delete ${type}`);
      }
    },
    [productId, coverageId]
  );

  // Generic set default function
  const setDefaultItem = useCallback(
    async (itemId: string, items: any[], type: 'limits' | 'deductibles'): Promise<void> => {
      if (!productId || !coverageId) {
        throw new Error('Product ID and Coverage ID are required');
      }

      try {
        const updatePromises = items.map((item) => {
          if (item.id === itemId) {
            return updateItem(item.id, { isDefault: true } as any, type);
          } else if (item.isDefault) {
            return updateItem(item.id, { isDefault: false } as any, type);
          }
          return Promise.resolve();
        });
        await Promise.all(updatePromises);
      } catch (err: any) {
        console.error(`Error setting default ${type}:`, err);
        throw new Error(err.message || `Failed to set default ${type}`);
      }
    },
    [productId, coverageId, updateItem]
  );

  // Memoized callbacks for limits
  const addLimit = useCallback(
    (limit: Omit<CoverageLimit, 'id' | 'createdAt' | 'updatedAt'>) =>
      addItem(limit, 'limits'),
    [addItem]
  );

  const updateLimitCb = useCallback(
    (limitId: string, updates: Partial<CoverageLimit>) =>
      updateItem(limitId, updates, 'limits'),
    [updateItem]
  );

  const deleteLimitCb = useCallback(
    (limitId: string) => deleteItem(limitId, 'limits'),
    [deleteItem]
  );

  const setDefaultLimitCb = useCallback(
    (limitId: string) => setDefaultItem(limitId, limits, 'limits'),
    [setDefaultItem, limits]
  );

  // Memoized callbacks for deductibles
  const addDeductible = useCallback(
    (deductible: Omit<CoverageDeductible, 'id' | 'createdAt' | 'updatedAt'>) =>
      addItem(deductible, 'deductibles'),
    [addItem]
  );

  const updateDeductibleCb = useCallback(
    (deductibleId: string, updates: Partial<CoverageDeductible>) =>
      updateItem(deductibleId, updates, 'deductibles'),
    [updateItem]
  );

  const deleteDeductibleCb = useCallback(
    (deductibleId: string) => deleteItem(deductibleId, 'deductibles'),
    [deleteItem]
  );

  const setDefaultDeductibleCb = useCallback(
    (deductibleId: string) => setDefaultItem(deductibleId, deductibles, 'deductibles'),
    [setDefaultItem, deductibles]
  );

  return useMemo(
    () => ({
      limits,
      addLimit,
      updateLimit: updateLimitCb,
      deleteLimit: deleteLimitCb,
      setDefaultLimit: setDefaultLimitCb,
      deductibles,
      addDeductible,
      updateDeductible: updateDeductibleCb,
      deleteDeductible: deleteDeductibleCb,
      setDefaultDeductible: setDefaultDeductibleCb,
      loading,
      error,
    }),
    [
      limits,
      addLimit,
      updateLimitCb,
      deleteLimitCb,
      setDefaultLimitCb,
      deductibles,
      addDeductible,
      updateDeductibleCb,
      deleteDeductibleCb,
      setDefaultDeductibleCb,
      loading,
      error,
    ]
  );
}

export default useCoverageData;

```

---

## src/hooks/useCoverageDraft.ts

**Path:** `src/hooks/useCoverageDraft.ts`

```typescript
/**
 * useCoverageDraft - Hook for managing coverage draft state and persistence
 * 
 * Provides:
 * - Draft state management with auto-save
 * - Completeness scoring
 * - Validation in draft/publish modes
 * - Firestore persistence to coverageDrafts subcollection
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { doc, setDoc, getDoc, deleteDoc, serverTimestamp, Timestamp } from 'firebase/firestore';
import { db } from '../firebase';
import { Coverage, CoverageDraft, CoverageDraftStatus, CoverageDraftSource } from '../types';
import { validateCoverage, calculateCoverageCompleteness, CoverageValidationResult } from '../services/validationService';

interface UseCoverageDraftOptions {
  productId: string;
  draftId?: string;
  initialDraft?: Partial<Coverage>;
  source?: CoverageDraftSource;
  autoSaveDelay?: number;
}

interface UseCoverageDraftReturn {
  draft: Partial<Coverage>;
  draftId: string | null;
  status: CoverageDraftStatus;
  completenessScore: number;
  missingRequiredFields: string[];
  validation: CoverageValidationResult | null;
  isDirty: boolean;
  isSaving: boolean;
  error: string | null;
  
  // Actions
  updateDraft: (patch: Partial<Coverage>) => void;
  saveDraft: () => Promise<void>;
  publishDraft: () => Promise<Coverage | null>;
  discardDraft: () => Promise<void>;
  resetDraft: () => void;
}

export default function useCoverageDraft(options: UseCoverageDraftOptions): UseCoverageDraftReturn {
  const { productId, draftId: initialDraftId, initialDraft = {}, source = 'manual', autoSaveDelay = 2000 } = options;
  
  const [draft, setDraft] = useState<Partial<Coverage>>({ productId, ...initialDraft });
  const [draftId, setDraftId] = useState<string | null>(initialDraftId || null);
  const [status, setStatus] = useState<CoverageDraftStatus>('draft');
  const [isDirty, setIsDirty] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null);
  const lastSavedDraftRef = useRef<string>('');

  // Calculate completeness
  const completeness = calculateCoverageCompleteness(draft);
  
  // Validate in draft mode
  const validation = validateCoverage(draft, { mode: 'draft' });

  // Load existing draft if draftId provided
  useEffect(() => {
    if (initialDraftId && productId) {
      const loadDraft = async () => {
        try {
          const draftDoc = await getDoc(doc(db, `products/${productId}/coverageDrafts/${initialDraftId}`));
          if (draftDoc.exists()) {
            const data = draftDoc.data() as CoverageDraft;
            setDraft(data.draft);
            setStatus(data.status);
            lastSavedDraftRef.current = JSON.stringify(data.draft);
          }
        } catch (err) {
          console.error('Error loading draft:', err);
          setError('Failed to load draft');
        }
      };
      loadDraft();
    }
  }, [initialDraftId, productId]);

  // Auto-save logic
  useEffect(() => {
    if (!isDirty || !draftId) return;
    
    if (autoSaveTimerRef.current) {
      clearTimeout(autoSaveTimerRef.current);
    }
    
    autoSaveTimerRef.current = setTimeout(() => {
      saveDraft();
    }, autoSaveDelay);
    
    return () => {
      if (autoSaveTimerRef.current) {
        clearTimeout(autoSaveTimerRef.current);
      }
    };
  }, [isDirty, draft, draftId, autoSaveDelay]);

  const updateDraft = useCallback((patch: Partial<Coverage>) => {
    setDraft(prev => ({ ...prev, ...patch }));
    setIsDirty(true);
    setError(null);
  }, []);

  const saveDraft = useCallback(async () => {
    if (!productId) return;
    
    const currentDraftStr = JSON.stringify(draft);
    if (currentDraftStr === lastSavedDraftRef.current) return;
    
    setIsSaving(true);
    setError(null);
    
    try {
      const id = draftId || doc(db, `products/${productId}/coverageDrafts`).id;
      const draftData: CoverageDraft = {
        id,
        productId,
        draft,
        status,
        source,
        completenessScore: completeness.score,
        missingRequiredFields: validation?.missingRequiredFields || [],
        createdAt: serverTimestamp() as Timestamp,
        updatedAt: serverTimestamp() as Timestamp
      };
      
      await setDoc(doc(db, `products/${productId}/coverageDrafts/${id}`), draftData, { merge: true });
      
      if (!draftId) setDraftId(id);
      lastSavedDraftRef.current = currentDraftStr;
      setIsDirty(false);
    } catch (err) {
      console.error('Error saving draft:', err);
      setError('Failed to save draft');
    } finally {
      setIsSaving(false);
    }
  }, [productId, draftId, draft, status, source, completeness.score, validation?.missingRequiredFields]);

  const publishDraft = useCallback(async (): Promise<Coverage | null> => {
    const publishValidation = validateCoverage(draft, { mode: 'publish' });
    if (!publishValidation.isValid) {
      setError(`Cannot publish: ${publishValidation.errors.map(e => e.message).join(', ')}`);
      return null;
    }
    // Publishing logic would go here - create actual coverage document
    setStatus('published');
    return draft as Coverage;
  }, [draft]);

  const discardDraft = useCallback(async () => {
    if (draftId && productId) {
      await deleteDoc(doc(db, `products/${productId}/coverageDrafts/${draftId}`));
    }
    resetDraft();
  }, [draftId, productId]);

  const resetDraft = useCallback(() => {
    setDraft({ productId });
    setDraftId(null);
    setStatus('draft');
    setIsDirty(false);
    setError(null);
    lastSavedDraftRef.current = '';
  }, [productId]);

  return {
    draft, draftId, status, completenessScore: completeness.score,
    missingRequiredFields: validation?.missingRequiredFields || [],
    validation, isDirty, isSaving, error,
    updateDraft, saveDraft, publishDraft, discardDraft, resetDraft
  };
}

```

---

## src/hooks/useCoverageFormCounts.ts

**Path:** `src/hooks/useCoverageFormCounts.ts`

```typescript
/**
 * useCoverageFormCounts Hook
 * Fetches form counts for coverages from the junction table
 */

import { useState, useEffect } from 'react';
import { collection, query, where, getDocs } from 'firebase/firestore';
import { db } from '@/firebase';
import logger, { LOG_CATEGORIES } from '@utils/logger';

interface FormCountMap {
  [coverageId: string]: number;
}

/**
 * Get form counts for multiple coverages
 * Reads from formCoverages junction table
 */
export function useCoverageFormCounts(
  productId: string | undefined,
  coverageIds: string[] | undefined
): FormCountMap {
  const [counts, setCounts] = useState<FormCountMap>({});

  useEffect(() => {
    if (!productId || !coverageIds || coverageIds.length === 0) {
      setCounts({});
      return;
    }

    const fetchCounts = async () => {
      try {
        const linksSnap = await getDocs(
          query(
            collection(db, 'formCoverages'),
            where('productId', '==', productId)
          )
        );

        const countMap: FormCountMap = {};
        coverageIds.forEach(id => {
          countMap[id] = 0;
        });

        linksSnap.docs.forEach(doc => {
          const { coverageId } = doc.data();
          if (coverageIds.includes(coverageId)) {
            countMap[coverageId] = (countMap[coverageId] || 0) + 1;
          }
        });

        setCounts(countMap);
      } catch (error) {
        logger.error(LOG_CATEGORIES.ERROR, 'Failed to fetch form counts', {
          productId,
          coverageCount: coverageIds.length,
        }, error as Error);
        setCounts({});
      }
    };

    fetchCounts();
  }, [productId, coverageIds?.join(',')]);  // Use join to create stable dependency

  return counts;
}

/**
 * Get form count for a single coverage
 */
export function useCoverageFormCount(
  productId: string | undefined,
  coverageId: string | undefined
): number {
  const [count, setCount] = useState(0);

  useEffect(() => {
    if (!productId || !coverageId) {
      setCount(0);
      return;
    }

    const fetchCount = async () => {
      try {
        const linksSnap = await getDocs(
          query(
            collection(db, 'formCoverages'),
            where('productId', '==', productId),
            where('coverageId', '==', coverageId)
          )
        );
        setCount(linksSnap.docs.length);
      } catch (error) {
        logger.error(LOG_CATEGORIES.ERROR, 'Failed to fetch form count', {
          productId,
          coverageId,
        }, error as Error);
        setCount(0);
      }
    };

    fetchCount();
  }, [productId, coverageId]);

  return count;
}

```

---

## src/hooks/useCoveragePackages.ts

**Path:** `src/hooks/useCoveragePackages.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { 
  collection, 
  doc, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  onSnapshot, 
  query, 
  orderBy,
  Timestamp,
  where
} from 'firebase/firestore';
import { db } from '../firebase';
import { CoveragePackage } from '../types';

/**
 * Custom hook for managing coverage packages
 * Handles CRUD operations for coverage packages collection
 */
export const useCoveragePackages = (productId: string | undefined) => {
  const [packages, setPackages] = useState<CoveragePackage[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Real-time listener for packages
  useEffect(() => {
    if (!productId) {
      setPackages([]);
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    const packagesRef = collection(db, 'products', productId, 'packages');
    const q = query(packagesRef, orderBy('name', 'asc'));

    const unsubscribe = onSnapshot(
      q,
      (snapshot) => {
        const packagesList: CoveragePackage[] = [];
        snapshot.forEach((doc) => {
          packagesList.push({ id: doc.id, ...doc.data() } as CoveragePackage);
        });
        setPackages(packagesList);
        setLoading(false);
      },
      (err) => {
        console.error('Error fetching packages:', err);
        setError(err.message);
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, [productId]);

  // Create a new package
  const createPackage = useCallback(
    async (packageData: Omit<CoveragePackage, 'id'>) => {
      if (!productId) {
        throw new Error('Product ID is required');
      }

      try {
        const packagesRef = collection(db, 'products', productId, 'packages');

        const docRef = await addDoc(packagesRef, {
          ...packageData,
          productId,
          createdAt: Timestamp.now(),
          updatedAt: Timestamp.now(),
        });

        return docRef.id;
      } catch (err: any) {
        console.error('Error creating package:', err);
        throw new Error(`Failed to create package: ${err.message}`);
      }
    },
    [productId]
  );

  // Update a package
  const updatePackage = useCallback(
    async (packageId: string, updates: Partial<CoveragePackage>) => {
      if (!productId) {
        throw new Error('Product ID is required');
      }

      try {
        const packageRef = doc(db, 'products', productId, 'packages', packageId);

        await updateDoc(packageRef, {
          ...updates,
          updatedAt: Timestamp.now(),
        });
      } catch (err: any) {
        console.error('Error updating package:', err);
        throw new Error(`Failed to update package: ${err.message}`);
      }
    },
    [productId]
  );

  // Delete a package
  const deletePackage = useCallback(
    async (packageId: string) => {
      if (!productId) {
        throw new Error('Product ID is required');
      }

      try {
        const packageRef = doc(db, 'products', productId, 'packages', packageId);
        await deleteDoc(packageRef);
      } catch (err: any) {
        console.error('Error deleting package:', err);
        throw new Error(`Failed to delete package: ${err.message}`);
      }
    },
    [productId]
  );

  // Get packages by type
  const getPackagesByType = useCallback(
    (packageType: string) => {
      return packages.filter((pkg) => pkg.packageType === packageType);
    },
    [packages]
  );

  // Get packages containing a specific coverage
  const getPackagesWithCoverage = useCallback(
    (coverageId: string) => {
      return packages.filter((pkg) => pkg.coverageIds.includes(coverageId));
    },
    [packages]
  );

  return {
    packages,
    loading,
    error,
    createPackage,
    updatePackage,
    deletePackage,
    getPackagesByType,
    getPackagesWithCoverage,
  };
};

/**
 * Calculate package premium with discount
 */
export const calculatePackagePremium = (
  individualPremiums: number[],
  discountPercentage?: number
): number => {
  const totalPremium = individualPremiums.reduce((sum, premium) => sum + premium, 0);
  
  if (!discountPercentage || discountPercentage === 0) {
    return totalPremium;
  }
  
  const discount = totalPremium * (discountPercentage / 100);
  return totalPremium - discount;
};

/**
 * Validate package data
 */
export const validatePackage = (packageData: Partial<CoveragePackage>): string[] => {
  const errors: string[] = [];
  
  if (!packageData.name || packageData.name.trim() === '') {
    errors.push('Package name is required');
  }
  
  if (!packageData.packageType) {
    errors.push('Package type is required');
  }
  
  if (!packageData.coverageIds || packageData.coverageIds.length === 0) {
    errors.push('At least one coverage must be selected');
  }
  
  if (packageData.discountPercentage !== undefined) {
    if (packageData.discountPercentage < 0 || packageData.discountPercentage > 100) {
      errors.push('Discount percentage must be between 0 and 100');
    }
  }
  
  if (packageData.packagePremium !== undefined && packageData.packagePremium < 0) {
    errors.push('Package premium cannot be negative');
  }
  
  return errors;
};

/**
 * Generate package recommendations based on selected coverages
 */
export const generatePackageRecommendations = (
  selectedCoverageIds: string[],
  allPackages: CoveragePackage[]
): CoveragePackage[] => {
  if (selectedCoverageIds.length === 0) {
    return [];
  }
  
  // Find packages that contain any of the selected coverages
  const relevantPackages = allPackages.filter((pkg) => {
    const matchingCoverages = pkg.coverageIds.filter((id) => 
      selectedCoverageIds.includes(id)
    );
    return matchingCoverages.length > 0;
  });
  
  // Sort by relevance (number of matching coverages) and discount
  return relevantPackages.sort((a, b) => {
    const aMatches = a.coverageIds.filter((id) => selectedCoverageIds.includes(id)).length;
    const bMatches = b.coverageIds.filter((id) => selectedCoverageIds.includes(id)).length;
    
    if (aMatches !== bMatches) {
      return bMatches - aMatches; // More matches first
    }
    
    // If same matches, sort by discount
    const aDiscount = a.discountPercentage || 0;
    const bDiscount = b.discountPercentage || 0;
    return bDiscount - aDiscount; // Higher discount first
  });
};

```

---

## src/hooks/useCoverages.ts

**Path:** `src/hooks/useCoverages.ts`

```typescript


/*
 * useCoverages â€“ React hook to stream the coverages for a given product
 *
 * Usage:
 *   const { coverages, loading, error, reload } = useCoverages(productId);
 *
 * â€“ Subscribes in realâ€‘time via onSnapshot.
 * â€“ Converts each doc to { id, ...data }.
 * â€“ Provides a reload() helper if the caller wants a oneâ€‘off refresh
 *   (e.g. after an import) without waiting for the snapshot.
 */

import { useState, useEffect, useCallback } from 'react';
import {
  collection,
  onSnapshot,
  getDocs,
  query,
  orderBy,
  where
} from 'firebase/firestore';
import { db } from '../firebase';

export default function useCoverages(productId) {
  const [coverages, setCoverages] = useState([]);
  const [loading,   setLoading]   = useState(true);
  const [error,     setError]     = useState(null);

  // Helper function to enrich coverages with linked forms and subcollection counts
  const enrichCoveragesWithForms = useCallback(async (coveragesList) => {
    try {
      // Fetch all form-coverage links for this product
      const linksSnap = await getDocs(
        query(
          collection(db, 'formCoverages'),
          where('productId', '==', productId)
        )
      );

      // Build a map of coverageId -> [formIds]
      const formsByCoverage = {};
      linksSnap.docs.forEach(doc => {
        const { coverageId, formId } = doc.data();
        if (!formsByCoverage[coverageId]) {
          formsByCoverage[coverageId] = [];
        }
        formsByCoverage[coverageId].push(formId);
      });

      // Enrich each coverage with its linked form IDs and subcollection counts
      const enrichedCoverages = await Promise.all(
        coveragesList.map(async (coverage) => {
          try {
            // Count limits from subcollection
            const limitsSnap = await getDocs(
              collection(db, `products/${productId}/coverages/${coverage.id}/limits`)
            );

            // Count deductibles from subcollection
            const deductiblesSnap = await getDocs(
              collection(db, `products/${productId}/coverages/${coverage.id}/deductibles`)
            );

            return {
              ...coverage,
              formIds: formsByCoverage[coverage.id] || [],
              limitsCount: limitsSnap.size,
              deductiblesCount: deductiblesSnap.size
            };
          } catch (err) {
            console.error(`Error enriching coverage ${coverage.id}:`, err);
            return {
              ...coverage,
              formIds: formsByCoverage[coverage.id] || [],
              limitsCount: 0,
              deductiblesCount: 0
            };
          }
        })
      );

      return enrichedCoverages;
    } catch (err) {
      console.error('Error enriching coverages with forms:', err);
      return coveragesList;
    }
  }, [productId]);

  // realâ€‘time listener
  useEffect(() => {
    if (!productId) return;      // guard for first render
    setLoading(true);

    const q = query(
      collection(db, `products/${productId}/coverages`),
      orderBy('coverageCode')      // stable sort
    );

    const unsub = onSnapshot(
      q,
      async snap => {
        const baseCoverages = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        const enriched = await enrichCoveragesWithForms(baseCoverages);
        setCoverages(enriched);
        setLoading(false);
      },
      err => {
        console.error('Coverages snapshot failed:', err);
        setError(err);
        setLoading(false);
      }
    );

    return () => unsub();
  }, [productId, enrichCoveragesWithForms]);

  /* manual reload helper ----------------------------------------- */
  const reload = useCallback(async () => {
    if (!productId) return;
    setLoading(true);
    try {
      const snap = await getDocs(
        query(collection(db, `products/${productId}/coverages`))
      );
      const baseCoverages = snap.docs.map(d => ({ id: d.id, ...d.data() }));
      const enriched = await enrichCoveragesWithForms(baseCoverages);
      setCoverages(enriched);
      setLoading(false);
    } catch (err) {
      console.error('Coverages reload failed:', err);
      setError(err);
      setLoading(false);
    }
  }, [productId, enrichCoveragesWithForms]);

  return { coverages, loading, error, reload };
}
```

---

## src/hooks/useFirebaseConnection.ts

**Path:** `src/hooks/useFirebaseConnection.ts`

```typescript
// src/hooks/useFirebaseConnection.js
/**
 * React Hook for Firebase Connection Monitoring
 * Provides real-time connection state and reconnection controls
 */

import { useState, useEffect } from 'react';
import connectionMonitor from '../services/firebaseConnectionMonitor';

/**
 * Hook to monitor Firebase connection state
 * @returns {Object} Connection state and controls
 */
export const useFirebaseConnection = () => {
  const [connectionState, setConnectionState] = useState({
    isConnected: true,
    state: 'connected',
    reconnectAttempts: 0,
    timestamp: null
  });

  useEffect(() => {
    // Subscribe to connection state changes
    const unsubscribe = connectionMonitor.addListener((state) => {
      setConnectionState(state);
    });

    // Cleanup on unmount
    return () => {
      unsubscribe();
    };
  }, []);

  // Force reconnection
  const forceReconnect = () => {
    connectionMonitor.forceReconnect();
  };

  return {
    ...connectionState,
    forceReconnect,
    isOnline: connectionState.isConnected,
    isOffline: !connectionState.isConnected,
    isReconnecting: connectionState.state === 'reconnecting'
  };
};

export default useFirebaseConnection;

```

---

## src/hooks/useForms.ts

**Path:** `src/hooks/useForms.ts`

```typescript
/**
 * useForms Hook - Fetch forms for a product
 */

import { useState, useEffect, useCallback, useMemo } from 'react';
import { collection, onSnapshot, query, where, getDocs } from 'firebase/firestore';
import { db } from '../firebase';
import { normalizeFirestoreData } from '../utils/firestoreHelpers';
import type { FormTemplate, FormCoverageMapping } from '../types';
import logger, { LOG_CATEGORIES } from '../utils/logger';

interface UseFormsResult {
  forms: FormTemplate[];
  formMappings: FormCoverageMapping[];
  loading: boolean;
  error: string | null;
  refetch: () => void;
  getFormsForCoverage: (coverageId: string) => FormTemplate[];
}

export function useForms(productId: string | null | undefined): UseFormsResult {
  const [forms, setForms] = useState<FormTemplate[]>([]);
  const [formMappings, setFormMappings] = useState<FormCoverageMapping[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refetch = useCallback(() => {
    setLoading(true);
    setError(null);
  }, []);

  // Fetch forms and their mappings
  useEffect(() => {
    if (!productId) {
      setForms([]);
      setFormMappings([]);
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    // Subscribe to forms collection
    const formsQuery = query(
      collection(db, 'forms'),
      where('productId', '==', productId)
    );

    const unsubscribeForms = onSnapshot(
      formsQuery,
      async (snapshot) => {
        try {
          const formsData = snapshot.docs.map(doc => ({
            id: doc.id,
            ...normalizeFirestoreData(doc.data())
          } as FormTemplate));

          setForms(formsData);

          // Fetch form-coverage mappings
          const mappingsQuery = query(
            collection(db, 'formCoverages'),
            where('productId', '==', productId)
          );
          
          const mappingsSnapshot = await getDocs(mappingsQuery);
          const mappingsData = mappingsSnapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          } as FormCoverageMapping));

          setFormMappings(mappingsData);
          setLoading(false);

          logger.debug(LOG_CATEGORIES.DATA, 'Forms fetched', { 
            productId, 
            formCount: formsData.length,
            mappingCount: mappingsData.length 
          });
        } catch (err) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to load forms';
          logger.error(LOG_CATEGORIES.ERROR, 'Forms fetch error', { productId }, err as Error);
          setError(errorMsg);
          setLoading(false);
        }
      },
      (err) => {
        const errorMsg = err.message || 'Failed to subscribe to forms';
        logger.error(LOG_CATEGORIES.ERROR, 'Forms subscription error', { productId }, err);
        setError(errorMsg);
        setLoading(false);
      }
    );

    return () => unsubscribeForms();
  }, [productId]);

  // Helper to get forms for a specific coverage
  const getFormsForCoverage = useCallback((coverageId: string): FormTemplate[] => {
    const mappingsForCoverage = formMappings.filter(m => m.coverageId === coverageId);
    const formIds = mappingsForCoverage.map(m => m.formId);
    return forms.filter(f => formIds.includes(f.id));
  }, [forms, formMappings]);

  return useMemo(() => ({
    forms,
    formMappings,
    loading,
    error,
    refetch,
    getFormsForCoverage
  }), [forms, formMappings, loading, error, refetch, getFormsForCoverage]);
}

export default useForms;

```

---

## src/hooks/useProduct.ts

**Path:** `src/hooks/useProduct.ts`

```typescript
/**
 * useProduct Hook - Fetch a single product with caching
 */

import { useState, useEffect, useCallback, useMemo } from 'react';
import { doc, onSnapshot } from 'firebase/firestore';
import { db } from '../firebase';
import { normalizeFirestoreData } from '../utils/firestoreHelpers';
import type { Product } from '../types';
import logger, { LOG_CATEGORIES } from '../utils/logger';
import { CACHE } from '../config/constants';

interface UseProductResult {
  product: Product | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

// Cache for individual products (uses centralized CACHE config)
const productCache = new Map<string, { data: Product; timestamp: number }>();
const CACHE_DURATION = CACHE.TTL_PRODUCTS;

export function useProduct(productId: string | null | undefined): UseProductResult {
  const [product, setProduct] = useState<Product | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refetch = useCallback(() => {
    if (productId) {
      productCache.delete(productId);
      setLoading(true);
      setError(null);
    }
  }, [productId]);

  useEffect(() => {
    if (!productId) {
      setProduct(null);
      setLoading(false);
      return;
    }

    // Check cache first
    const cached = productCache.get(productId);
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      setProduct(cached.data);
      setLoading(false);
      logger.debug(LOG_CATEGORIES.DATA, 'Product loaded from cache', { productId });
      return;
    }

    setLoading(true);
    setError(null);

    const productRef = doc(db, 'products', productId);
    
    const unsubscribe = onSnapshot(
      productRef,
      (snapshot) => {
        try {
          if (snapshot.exists()) {
            const data = {
              id: snapshot.id,
              ...normalizeFirestoreData(snapshot.data())
            } as Product;
            
            setProduct(data);
            productCache.set(productId, { data, timestamp: Date.now() });
            logger.debug(LOG_CATEGORIES.DATA, 'Product fetched', { productId });
          } else {
            setProduct(null);
            setError('Product not found');
          }
          setLoading(false);
        } catch (err) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to load product';
          logger.error(LOG_CATEGORIES.ERROR, 'Product fetch error', { productId }, err as Error);
          setError(errorMsg);
          setLoading(false);
        }
      },
      (err) => {
        const errorMsg = err.message || 'Failed to subscribe to product';
        logger.error(LOG_CATEGORIES.ERROR, 'Product subscription error', { productId }, err);
        setError(errorMsg);
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, [productId]);

  return useMemo(() => ({
    product,
    loading,
    error,
    refetch
  }), [product, loading, error, refetch]);
}

export default useProduct;

```

---

## src/hooks/useProducts.ts

**Path:** `src/hooks/useProducts.ts`

```typescript
/**
 * useProducts Hook - Fetch and manage products with caching
 *
 * Enhancements:
 * - Generic typing for flexibility
 * - Memoized queries and callbacks
 * - Automatic cache management
 * - Error handling with retry logic
 */

import { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { collection, onSnapshot, query, orderBy, limit, QueryConstraint } from 'firebase/firestore';
import { db } from '../firebase';
import { normalizeFirestoreData } from '../utils/firestoreHelpers';
import { Product } from '../types';
import logger, { LOG_CATEGORIES } from '../utils/logger';
import { CACHE } from '../config/constants';

interface UseProductsOptions {
  enableCache?: boolean;
  maxResults?: number;
  orderBy?: string;
  includeArchived?: boolean;
}

interface UseProductsResult<T> {
  data: T[];
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

// Optimized: Cache with TTL management (uses centralized CACHE config)
const productsCache = {
  data: null as Product[] | null,
  timestamp: null as number | null,
  CACHE_DURATION: CACHE.TTL_PRODUCTS
};

/**
 * Generic hook for fetching products with caching
 * @template T - Type of data returned (defaults to Product)
 */
export default function useProducts<T extends Product = Product>(
  options: UseProductsOptions = {}
): UseProductsResult<T> {
  const { enableCache = true, maxResults = 1000, orderBy: orderByField = 'name', includeArchived = false } = options;
  const [products, setProducts] = useState<T[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const unsubscribeRef = useRef<(() => void) | null>(null);

  // Optimized: Memoized query to prevent recreation on every render
  const productsQuery = useMemo(() => {
    const constraints: QueryConstraint[] = [orderBy(orderByField)];

    if (maxResults && maxResults < 1000) {
      constraints.push(limit(maxResults));
    }

    return query(collection(db, 'products'), ...constraints);
  }, [maxResults, orderByField]);

  // Filter out archived products from the results (unless includeArchived is true)
  const filterArchivedProducts = useCallback((productsData: T[]): T[] => {
    if (includeArchived) {
      return productsData;
    }
    return productsData.filter(p => !p.archived);
  }, [includeArchived]);

  // Optimized: Refetch callback with memoization
  const refetch = useCallback(() => {
    setLoading(true);
    setError(null);
  }, []);

  useEffect(() => {
    // Check cache first if enabled
    if (enableCache && productsCache.data && productsCache.timestamp) {
      const cacheAge = Date.now() - productsCache.timestamp;
      if (cacheAge < productsCache.CACHE_DURATION) {
        setProducts(productsCache.data as T[]);
        setLoading(false);
        logger.debug(LOG_CATEGORIES.DATA, 'Products loaded from cache');
        return;
      }
    }

    setLoading(true);
    setError(null);

    // Clean up previous subscription
    if (unsubscribeRef.current) {
      unsubscribeRef.current();
    }

    unsubscribeRef.current = onSnapshot(
      productsQuery,
      (snap) => {
        try {
          const productsData = snap.docs.map(d => {
            const data = d.data();
            return {
              id: d.id,
              ...normalizeFirestoreData(data)
            } as T;
          });

          // Filter out archived products
          const filteredProducts = filterArchivedProducts(productsData);

          setProducts(filteredProducts);
          setLoading(false);
          setError(null);

          // Update cache
          if (enableCache) {
            productsCache.data = filteredProducts;
            productsCache.timestamp = Date.now();
          }

          logger.debug(LOG_CATEGORIES.DATA, 'Products fetched successfully', {
            count: filteredProducts.length,
            totalCount: productsData.length
          });
        } catch (err) {
          const error = err instanceof Error ? err : new Error(String(err));
          logger.error(LOG_CATEGORIES.ERROR, 'Error processing products snapshot', {}, error);
          setError(error);
          setLoading(false);
        }
      },
      (err) => {
        const error = err instanceof Error ? err : new Error(String(err));
        logger.error(LOG_CATEGORIES.ERROR, 'Products subscription failed', {}, error);
        setError(error);
        setLoading(false);
      }
    );

    // Cleanup function
    return () => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
        unsubscribeRef.current = null;
      }
    };
  }, [productsQuery, enableCache, filterArchivedProducts]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
      }
    };
  }, []);

  // Optimized: Return memoized result
  return useMemo(() => ({
    data: products,
    loading,
    error,
    refetch
  }), [products, loading, error, refetch]);
}
```

---

## src/index.tsx

**Path:** `src/index.tsx`

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { ProductProvider } from './context/ProductContext';
import env from './config/env';

// Register service worker for caching and offline support
if ('serviceWorker' in navigator && env.PROD) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('ðŸŽ¯ Service Worker registered successfully:', registration.scope);

        // Listen for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                console.log('ðŸ”„ New content available, please refresh');
              }
            });
          }
        });
      })
      .catch((error) => {
        console.error('âŒ Service Worker registration failed:', error);
      });
  });
}

// Ensure root element exists
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error('Root element not found');
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    {/* Optimized: ProductProvider eliminates prop drilling */}
    <ProductProvider>
      <App />
    </ProductProvider>
  </React.StrictMode>
);

```

---

## src/pages/FormsMapper.tsx

**Path:** `src/pages/FormsMapper.tsx`

```tsx
/**
 * Forms Mapper
 * Bulk form-to-coverage mapping tool with drag-and-drop support
 * Route: /products/:productId/forms-mapper
 */

import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import styled from 'styled-components';
import { collection, getDocs, query, where, addDoc, serverTimestamp } from 'firebase/firestore';
import { db } from '@/firebase';
import { FormTemplate, Coverage, FormCoverageMapping } from '@types';
import logger, { LOG_CATEGORIES } from '@utils/logger';

const Container = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  padding: 20px;
  height: 100vh;
  background: #f5f5f5;
`;

const Panel = styled.div`
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
  overflow: hidden;
`;

const PanelTitle = styled.h2`
  margin: 0 0 15px 0;
  font-size: 18px;
  color: #333;
  border-bottom: 2px solid #007bff;
  padding-bottom: 10px;
`;

const SearchInput = styled.input`
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-bottom: 15px;
  font-size: 14px;

  &:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
  }
`;

const ListContainer = styled.div`
  flex: 1;
  overflow-y: auto;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
`;

const ListItem = styled.div<{ dragging?: boolean }>`
  padding: 12px;
  border-bottom: 1px solid #e0e0e0;
  cursor: move;
  background: ${props => props.dragging ? '#e7f3ff' : 'white'};
  transition: background 0.2s;
  user-select: none;

  &:hover {
    background: #f9f9f9;
  }

  &:last-child {
    border-bottom: none;
  }
`;

const ItemName = styled.div`
  font-weight: 500;
  color: #333;
  margin-bottom: 4px;
`;

const ItemMeta = styled.div`
  font-size: 12px;
  color: #999;
`;

const Button = styled.button`
  background: #007bff;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  margin-top: 15px;

  &:hover {
    background: #0056b3;
  }

  &:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
`;

const MappingsList = styled.div`
  margin-top: 20px;
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
`;

const MappingItem = styled.div`
  padding: 10px;
  border-bottom: 1px solid #e0e0e0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;

  &:last-child {
    border-bottom: none;
  }
`;

const RemoveButton = styled.button`
  background: #dc3545;
  color: white;
  border: none;
  padding: 4px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;

  &:hover {
    background: #c82333;
  }
`;

const LoadingSpinner = styled.div`
  text-align: center;
  padding: 20px;
  color: #666;
`;

interface FormsMapperProps {}

const FormsMapper: React.FC<FormsMapperProps> = () => {
  const { productId } = useParams<{ productId: string }>();
  const [forms, setForms] = useState<FormTemplate[]>([]);
  const [coverages, setCoverages] = useState<Coverage[]>([]);
  const [mappings, setMappings] = useState<FormCoverageMapping[]>([]);
  const [formSearch, setFormSearch] = useState('');
  const [coverageSearch, setCoverageSearch] = useState('');
  const [loading, setLoading] = useState(true);
  const [selectedForm, setSelectedForm] = useState<string | null>(null);
  const [selectedCoverage, setSelectedCoverage] = useState<string | null>(null);

  useEffect(() => {
    const loadData = async () => {
      if (!productId) return;
      try {
        // Load forms
        const formsSnap = await getDocs(
          query(collection(db, 'forms'), where('productId', '==', productId))
        );
        setForms(formsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() } as FormTemplate)));

        // Load coverages
        const coveragesSnap = await getDocs(
          collection(db, `products/${productId}/coverages`)
        );
        setCoverages(coveragesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() } as Coverage)));

        // Load mappings
        const mappingsSnap = await getDocs(
          query(collection(db, 'formCoverages'), where('productId', '==', productId))
        );
        setMappings(mappingsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() } as FormCoverageMapping)));
      } catch (error) {
        logger.error(LOG_CATEGORIES.ERROR, 'Failed to load data', {}, error as Error);
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, [productId]);

  const filteredForms = forms.filter(f =>
    (f.formName || f.name || '').toLowerCase().includes(formSearch.toLowerCase())
  );

  const filteredCoverages = coverages.filter(c =>
    c.name.toLowerCase().includes(coverageSearch.toLowerCase())
  );

  const handleCreateMapping = async () => {
    if (!selectedForm || !selectedCoverage || !productId) return;

    try {
      await addDoc(collection(db, 'formCoverages'), {
        formId: selectedForm,
        coverageId: selectedCoverage,
        productId,
        isPrimary: false,
        effectiveDate: new Date(),
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });

      // Reload mappings
      const mappingsSnap = await getDocs(
        query(collection(db, 'formCoverages'), where('productId', '==', productId))
      );
      setMappings(mappingsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() } as FormCoverageMapping)));
      
      setSelectedForm(null);
      setSelectedCoverage(null);
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Failed to create mapping', {}, error as Error);
    }
  };

  const handleRemoveMapping = async (mappingId: string) => {
    try {
      // Delete mapping
      const mappingRef = collection(db, 'formCoverages');
      // Note: In real implementation, would use deleteDoc
      
      // Reload mappings
      if (productId) {
        const mappingsSnap = await getDocs(
          query(collection(db, 'formCoverages'), where('productId', '==', productId))
        );
        setMappings(mappingsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() } as FormCoverageMapping)));
      }
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Failed to remove mapping', {}, error as Error);
    }
  };

  if (loading) {
    return (
      <Container>
        <LoadingSpinner>Loading...</LoadingSpinner>
      </Container>
    );
  }

  return (
    <Container>
      {/* Left Panel: Forms */}
      <Panel>
        <PanelTitle>Forms</PanelTitle>
        <SearchInput
          placeholder="Search forms..."
          value={formSearch}
          onChange={(e) => setFormSearch(e.target.value)}
        />
        <ListContainer>
          {filteredForms.map(form => (
            <ListItem
              key={form.id}
              onClick={() => setSelectedForm(form.id)}
              style={{
                background: selectedForm === form.id ? '#e7f3ff' : 'white',
                borderLeft: selectedForm === form.id ? '4px solid #007bff' : 'none'
              }}
            >
              <ItemName>{form.formName || form.name}</ItemName>
              <ItemMeta>{form.formNumber}</ItemMeta>
            </ListItem>
          ))}
        </ListContainer>
      </Panel>

      {/* Right Panel: Coverages & Mappings */}
      <Panel>
        <PanelTitle>Coverages & Mappings</PanelTitle>
        <SearchInput
          placeholder="Search coverages..."
          value={coverageSearch}
          onChange={(e) => setCoverageSearch(e.target.value)}
        />
        <ListContainer>
          {filteredCoverages.map(coverage => (
            <ListItem
              key={coverage.id}
              onClick={() => setSelectedCoverage(coverage.id)}
              style={{
                background: selectedCoverage === coverage.id ? '#e7f3ff' : 'white',
                borderLeft: selectedCoverage === coverage.id ? '4px solid #007bff' : 'none'
              }}
            >
              <ItemName>{coverage.name}</ItemName>
              <ItemMeta>{coverage.coverageCode || 'No code'}</ItemMeta>
            </ListItem>
          ))}
        </ListContainer>

        <Button
          onClick={handleCreateMapping}
          disabled={!selectedForm || !selectedCoverage}
        >
          Create Mapping
        </Button>

        <div style={{ marginTop: '20px' }}>
          <h3 style={{ margin: '0 0 10px 0', fontSize: '14px' }}>Current Mappings</h3>
          <MappingsList>
            {mappings.length === 0 ? (
              <div style={{ padding: '10px', color: '#999' }}>No mappings yet</div>
            ) : (
              mappings.map(mapping => (
                <MappingItem key={mapping.id}>
                  <span>
                    {forms.find(f => f.id === mapping.formId)?.formName} â†’{' '}
                    {coverages.find(c => c.id === mapping.coverageId)?.name}
                  </span>
                  <RemoveButton onClick={() => handleRemoveMapping(mapping.id)}>
                    Remove
                  </RemoveButton>
                </MappingItem>
              ))
            )}
          </MappingsList>
        </div>
      </Panel>
    </Container>
  );
};

export default FormsMapper;

```

---

## src/pages/PricingBuilder.tsx

**Path:** `src/pages/PricingBuilder.tsx`

```tsx
/**
 * Pricing Builder
 * Create and manage pricing steps and rules
 * Route: /products/:productId/pricing
 */

import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import styled from 'styled-components';
import { collection, getDocs, query, where, addDoc, serverTimestamp } from 'firebase/firestore';
import { db } from '../firebase';
import { PricingStep, PricingRule } from '../types';
import logger, { LOG_CATEGORIES } from '../utils/logger';

const Container = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  padding: 20px;
  height: 100vh;
  background: #f5f5f5;
`;

const Panel = styled.div`
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
  overflow: hidden;
`;

const PanelTitle = styled.h2`
  margin: 0 0 15px 0;
  font-size: 18px;
  color: #333;
  border-bottom: 2px solid #007bff;
  padding-bottom: 10px;
`;

const FormGroup = styled.div`
  margin-bottom: 15px;
`;

const Label = styled.label`
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: #333;
  font-size: 14px;
`;

const Input = styled.input`
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;

  &:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
  }
`;

const Select = styled.select`
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;

  &:focus {
    outline: none;
    border-color: #007bff;
  }
`;

const TextArea = styled.textarea`
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  min-height: 80px;
  font-family: inherit;

  &:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
  }
`;

const Button = styled.button`
  background: #007bff;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;

  &:hover {
    background: #0056b3;
  }

  &:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
`;

const StepsList = styled.div`
  flex: 1;
  overflow-y: auto;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  margin-top: 15px;
`;

const StepItem = styled.div`
  padding: 12px;
  border-bottom: 1px solid #e0e0e0;
  background: white;
  cursor: pointer;
  transition: background 0.2s;

  &:hover {
    background: #f9f9f9;
  }

  &:last-child {
    border-bottom: none;
  }
`;

const StepName = styled.div`
  font-weight: 600;
  color: #333;
  margin-bottom: 4px;
`;

const StepMeta = styled.div`
  font-size: 12px;
  color: #999;
`;

const RulesList = styled.div`
  flex: 1;
  overflow-y: auto;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  margin-top: 15px;
`;

const RuleItem = styled.div`
  padding: 10px;
  border-bottom: 1px solid #e0e0e0;
  background: white;
  font-size: 13px;

  &:last-child {
    border-bottom: none;
  }
`;

const LoadingSpinner = styled.div`
  text-align: center;
  padding: 20px;
  color: #666;
`;

interface PricingBuilderProps {}

const PricingBuilder: React.FC<PricingBuilderProps> = () => {
  const { productId } = useParams<{ productId: string }>();
  const [steps, setSteps] = useState<PricingStep[]>([]);
  const [rules, setRules] = useState<PricingRule[]>([]);
  const [loading, setLoading] = useState(true);
  const [stepName, setStepName] = useState('');
  const [stepScope, setStepScope] = useState<'product' | 'coverage'>('product');
  const [stepOrder, setStepOrder] = useState(0);

  useEffect(() => {
    const loadData = async () => {
      if (!productId) return;
      try {
        // Load pricing steps
        const stepsSnap = await getDocs(
          query(
            collection(db, `products/${productId}/pricingSteps`),
            where('productId', '==', productId)
          )
        );
        setSteps(stepsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() } as PricingStep)));

        // Load pricing rules
        const rulesSnap = await getDocs(
          query(collection(db, 'rules'), where('productId', '==', productId))
        );
        setRules(rulesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() } as PricingRule)));
      } catch (error) {
        logger.error(LOG_CATEGORIES.ERROR, 'Failed to load pricing data', {}, error as Error);
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, [productId]);

  const handleCreateStep = async () => {
    if (!stepName || !productId) return;

    try {
      await addDoc(collection(db, `products/${productId}/pricingSteps`), {
        productId,
        name: stepName,
        scope: stepScope,
        order: stepOrder,
        rules: [],
        isActive: true,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });

      // Reload steps
      const stepsSnap = await getDocs(
        query(
          collection(db, `products/${productId}/pricingSteps`),
          where('productId', '==', productId)
        )
      );
      setSteps(stepsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() } as PricingStep)));

      setStepName('');
      setStepOrder(stepOrder + 1);
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Failed to create pricing step', {}, error as Error);
    }
  };

  if (loading) {
    return (
      <Container>
        <LoadingSpinner>Loading...</LoadingSpinner>
      </Container>
    );
  }

  return (
    <Container>
      {/* Left Panel: Create Step */}
      <Panel>
        <PanelTitle>Create Pricing Step</PanelTitle>

        <FormGroup>
          <Label>Step Name</Label>
          <Input
            value={stepName}
            onChange={(e) => setStepName(e.target.value)}
            placeholder="e.g., Base Rate"
          />
        </FormGroup>

        <FormGroup>
          <Label>Scope</Label>
          <Select value={stepScope} onChange={(e) => setStepScope(e.target.value as 'product' | 'coverage')}>
            <option value="product">Product-wide</option>
            <option value="coverage">Coverage-specific</option>
          </Select>
        </FormGroup>

        <FormGroup>
          <Label>Execution Order</Label>
          <Input
            type="number"
            value={stepOrder}
            onChange={(e) => setStepOrder(Number(e.target.value))}
          />
        </FormGroup>

        <Button onClick={handleCreateStep} disabled={!stepName}>
          Create Step
        </Button>

        <PanelTitle style={{ marginTop: '30px' }}>Pricing Steps</PanelTitle>
        <StepsList>
          {steps.length === 0 ? (
            <div style={{ padding: '10px', color: '#999' }}>No steps created yet</div>
          ) : (
            steps
              .sort((a, b) => (a.order || 0) - (b.order || 0))
              .map(step => (
                <StepItem key={step.id}>
                  <StepName>{step.name}</StepName>
                  <StepMeta>
                    Order: {step.order} | Scope: {step.scope} | Rules: {(step.rules || []).length}
                  </StepMeta>
                </StepItem>
              ))
          )}
        </StepsList>
      </Panel>

      {/* Right Panel: Rules */}
      <Panel>
        <PanelTitle>Pricing Rules</PanelTitle>
        <RulesList>
          {rules.length === 0 ? (
            <div style={{ padding: '10px', color: '#999' }}>No rules created yet</div>
          ) : (
            rules.map(rule => (
              <RuleItem key={rule.id}>
                <strong>{rule.name}</strong>
                <div style={{ marginTop: '4px', color: '#666' }}>
                  Type: {rule.ruleType} | Value: {rule.value} {rule.valueType}
                </div>
              </RuleItem>
            ))
          )}
        </RulesList>
      </Panel>
    </Container>
  );
};

export default PricingBuilder;

```

---

## src/pages/Product360.tsx

**Path:** `src/pages/Product360.tsx`

```tsx
/**
 * Product 360 Dashboard
 * Comprehensive product management dashboard with KPIs, charts, and quick actions
 * Route: /products/:productId/overview
 *
 * Features:
 * - Product health score with AI insights
 * - Real-time KPI cards with trends
 * - Interactive coverage/form/pricing summaries
 * - Quick action buttons for common tasks
 * - Recent activity timeline
 * - State availability heat map
 */

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import styled, { keyframes, css } from 'styled-components';
import { Product, Coverage, Form } from '@types/index';
import logger, { LOG_CATEGORIES } from '@utils/logger';
import { getProduct360Summary, Product360Summary } from '@services/product360ReadModel';
import MainNavigation from '@components/ui/Navigation';
import { PageContainer, PageContent } from '@components/ui/PageContainer';
import {
  ShieldCheckIcon,
  DocumentTextIcon,
  CurrencyDollarIcon,
  MapPinIcon,
  Cog6ToothIcon,
  ChartBarIcon,
  ArrowTrendingUpIcon,
  ArrowTrendingDownIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  ClockIcon,
  SparklesIcon,
  ArrowRightIcon,
  PlusIcon,
  EyeIcon,
  PencilIcon,
  Squares2X2Icon,
  ArrowLeftIcon,
  BoltIcon,
  LightBulbIcon,
  BeakerIcon,
  ChartPieIcon
} from '@heroicons/react/24/outline';
import { SparklesIcon as SparklesSolid } from '@heroicons/react/24/solid';

/* ========== Animations ========== */
const fadeInUp = keyframes`
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
`;

const slideIn = keyframes`
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
`;

const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
`;

const shimmer = keyframes`
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
`;

const glow = keyframes`
  0%, 100% { box-shadow: 0 0 20px rgba(99, 102, 241, 0.3); }
  50% { box-shadow: 0 0 40px rgba(99, 102, 241, 0.5); }
`;

const float = keyframes`
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
`;

/* ========== Container Styles ========== */
const Container = styled.div`
  min-height: 100vh;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
`;

const MainContent = styled.div`
  max-width: 1600px;
  margin: 0 auto;
  padding: 32px 24px 80px;
`;

/* ========== Header Section ========== */
const HeaderSection = styled.div`
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  margin-bottom: 32px;
  gap: 24px;
  flex-wrap: wrap;
  animation: ${fadeInUp} 0.5s ease-out;
`;

const HeaderLeft = styled.div`
  display: flex;
  align-items: center;
  gap: 20px;
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  border: none;
  border-radius: 12px;
  background: white;
  color: #64748b;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);

  &:hover {
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
  }

  svg { width: 20px; height: 20px; }
`;

const ProductIcon = styled.div`
  width: 64px;
  height: 64px;
  border-radius: 16px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  box-shadow: 0 8px 24px rgba(99, 102, 241, 0.35);
  animation: ${float} 3s ease-in-out infinite;

  svg { width: 32px; height: 32px; }
`;

const ProductInfo = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const ProductName = styled.h1`
  font-size: 32px;
  font-weight: 800;
  background: linear-gradient(135deg, #1e293b 0%, #475569 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin: 0;
  letter-spacing: -0.03em;
`;

const ProductMeta = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
`;

const MetaBadge = styled.span<{ $variant?: 'success' | 'warning' | 'info' | 'default' }>`
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;

  ${({ $variant = 'default' }) => {
    switch ($variant) {
      case 'success':
        return css`
          background: rgba(16, 185, 129, 0.1);
          color: #059669;
          border: 1px solid rgba(16, 185, 129, 0.2);
        `;
      case 'warning':
        return css`
          background: rgba(245, 158, 11, 0.1);
          color: #d97706;
          border: 1px solid rgba(245, 158, 11, 0.2);
        `;
      case 'info':
        return css`
          background: rgba(99, 102, 241, 0.1);
          color: #6366f1;
          border: 1px solid rgba(99, 102, 241, 0.2);
        `;
      default:
        return css`
          background: rgba(100, 116, 139, 0.1);
          color: #64748b;
          border: 1px solid rgba(100, 116, 139, 0.2);
        `;
    }
  }}

  svg { width: 14px; height: 14px; }
`;

const HeaderRight = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
`;

const QuickActionBtn = styled.button<{ $primary?: boolean }>`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 20px;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  ${({ $primary }) => $primary ? css`
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    color: white;
    border: none;
    box-shadow: 0 4px 16px rgba(99, 102, 241, 0.35);

    &:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(99, 102, 241, 0.45);
    }
  ` : css`
    background: white;
    color: #475569;
    border: 1px solid rgba(226, 232, 240, 0.8);

    &:hover {
      border-color: #6366f1;
      color: #6366f1;
      background: rgba(99, 102, 241, 0.04);
    }
  `}

  svg { width: 18px; height: 18px; }
`;

/* ========== Health Score Card ========== */
const HealthScoreCard = styled.div`
  background: white;
  border-radius: 20px;
  padding: 28px;
  margin-bottom: 32px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.06);
  display: grid;
  grid-template-columns: 200px 1fr;
  gap: 32px;
  animation: ${fadeInUp} 0.5s ease-out 0.1s backwards;

  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
`;

const ScoreCircle = styled.div<{ $score: number }>`
  width: 160px;
  height: 160px;
  border-radius: 50%;
  background: conic-gradient(
    ${({ $score }) => $score >= 80 ? '#10b981' : $score >= 60 ? '#f59e0b' : '#ef4444'} ${({ $score }) => $score * 3.6}deg,
    #e2e8f0 0deg
  );
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  margin: 0 auto;

  &::before {
    content: '';
    position: absolute;
    width: 130px;
    height: 130px;
    border-radius: 50%;
    background: white;
  }
`;

const ScoreValue = styled.div`
  position: relative;
  z-index: 1;
  text-align: center;
`;

const ScoreNumber = styled.div<{ $score: number }>`
  font-size: 42px;
  font-weight: 800;
  color: ${({ $score }) => $score >= 80 ? '#10b981' : $score >= 60 ? '#f59e0b' : '#ef4444'};
  line-height: 1;
`;

const ScoreLabel = styled.div`
  font-size: 12px;
  font-weight: 600;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-top: 4px;
`;

const InsightsSection = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const InsightsTitle = styled.h3`
  font-size: 18px;
  font-weight: 700;
  color: #1e293b;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 8px;

  svg { width: 20px; height: 20px; color: #6366f1; }
`;

const InsightsList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const InsightItem = styled.div<{ $type: 'success' | 'warning' | 'info' }>`
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 14px 16px;
  border-radius: 12px;
  background: ${({ $type }) =>
    $type === 'success' ? 'rgba(16, 185, 129, 0.08)' :
    $type === 'warning' ? 'rgba(245, 158, 11, 0.08)' :
    'rgba(99, 102, 241, 0.08)'
  };
  border-left: 3px solid ${({ $type }) =>
    $type === 'success' ? '#10b981' :
    $type === 'warning' ? '#f59e0b' :
    '#6366f1'
  };

  svg {
    width: 18px;
    height: 18px;
    flex-shrink: 0;
    margin-top: 2px;
    color: ${({ $type }) =>
      $type === 'success' ? '#10b981' :
      $type === 'warning' ? '#f59e0b' :
      '#6366f1'
    };
  }
`;

const InsightText = styled.div`
  font-size: 14px;
  color: #475569;
  line-height: 1.5;
`;

/* ========== KPI Grid ========== */
const KPIGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 20px;
  margin-bottom: 32px;
`;

const KPICard = styled(Link)<{ $color: string; $delay?: number }>`
  background: white;
  border-radius: 16px;
  padding: 24px;
  text-decoration: none;
  position: relative;
  overflow: hidden;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.04);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  animation: ${fadeInUp} 0.5s ease-out ${({ $delay }) => 0.1 + ($delay || 0) * 0.05}s backwards;

  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: ${({ $color }) => $color};
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  &:hover {
    transform: translateY(-6px);
    box-shadow: 0 16px 40px rgba(0, 0, 0, 0.12);

    &::before { opacity: 1; }
  }
`;

const KPIHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
`;

const KPIIcon = styled.div<{ $color: string }>`
  width: 48px;
  height: 48px;
  border-radius: 12px;
  background: ${({ $color }) => $color}15;
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${({ $color }) => $color};

  svg { width: 24px; height: 24px; }
`;

const KPITrend = styled.div<{ $positive?: boolean }>`
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  font-weight: 600;
  color: ${({ $positive }) => $positive ? '#10b981' : '#ef4444'};

  svg { width: 14px; height: 14px; }
`;

const KPIValue = styled.div`
  font-size: 36px;
  font-weight: 800;
  color: #1e293b;
  line-height: 1;
  margin-bottom: 8px;
`;

const KPILabel = styled.div`
  font-size: 14px;
  font-weight: 500;
  color: #64748b;
`;

const KPISubtext = styled.div`
  font-size: 12px;
  color: #94a3b8;
  margin-top: 8px;
`;

/* ========== Content Grid ========== */
const ContentGrid = styled.div`
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 24px;
  margin-bottom: 32px;

  @media (max-width: 1200px) {
    grid-template-columns: 1fr;
  }
`;

const Card = styled.div<{ $delay?: number }>`
  background: white;
  border-radius: 20px;
  padding: 28px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.06);
  animation: ${fadeInUp} 0.5s ease-out ${({ $delay }) => 0.2 + ($delay || 0) * 0.1}s backwards;
`;

const CardHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 24px;
`;

const CardTitle = styled.h3`
  font-size: 18px;
  font-weight: 700;
  color: #1e293b;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 10px;

  svg { width: 20px; height: 20px; color: #6366f1; }
`;

const ViewAllLink = styled(Link)`
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  font-weight: 600;
  color: #6366f1;
  text-decoration: none;
  transition: all 0.2s ease;

  &:hover {
    gap: 10px;
  }

  svg { width: 16px; height: 16px; }
`;

/* ========== Coverage List ========== */
const CoverageList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;

const CoverageItem = styled(Link)`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px;
  border-radius: 12px;
  background: #f8fafc;
  text-decoration: none;
  transition: all 0.2s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.08);
    transform: translateX(4px);
  }
`;

const CoverageInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 14px;
`;

const CoverageIcon = styled.div<{ $isParent?: boolean }>`
  width: 40px;
  height: 40px;
  border-radius: 10px;
  background: ${({ $isParent }) => $isParent
    ? 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)'
    : 'rgba(99, 102, 241, 0.1)'};
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${({ $isParent }) => $isParent ? 'white' : '#6366f1'};

  svg { width: 20px; height: 20px; }
`;

const CoverageDetails = styled.div``;

const CoverageName = styled.div`
  font-size: 15px;
  font-weight: 600;
  color: #1e293b;
`;

const CoverageCode = styled.div`
  font-size: 12px;
  color: #64748b;
  margin-top: 2px;
`;

const CoverageStats = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
`;

const CoverageStat = styled.div`
  text-align: right;
`;

const CoverageStatValue = styled.div`
  font-size: 14px;
  font-weight: 700;
  color: #1e293b;
`;

const CoverageStatLabel = styled.div`
  font-size: 11px;
  color: #94a3b8;
`;

/* ========== Activity Timeline ========== */
const ActivityList = styled.div`
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const ActivityItem = styled.div`
  display: flex;
  gap: 14px;
  position: relative;

  &:not(:last-child)::after {
    content: '';
    position: absolute;
    left: 17px;
    top: 40px;
    bottom: -16px;
    width: 2px;
    background: #e2e8f0;
  }
`;

const ActivityIcon = styled.div<{ $type: string }>`
  width: 36px;
  height: 36px;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  background: ${({ $type }) =>
    $type === 'coverage' ? 'rgba(99, 102, 241, 0.1)' :
    $type === 'form' ? 'rgba(16, 185, 129, 0.1)' :
    $type === 'pricing' ? 'rgba(245, 158, 11, 0.1)' :
    'rgba(100, 116, 139, 0.1)'
  };
  color: ${({ $type }) =>
    $type === 'coverage' ? '#6366f1' :
    $type === 'form' ? '#10b981' :
    $type === 'pricing' ? '#f59e0b' :
    '#64748b'
  };

  svg { width: 18px; height: 18px; }
`;

const ActivityContent = styled.div`
  flex: 1;
`;

const ActivityTitle = styled.div`
  font-size: 14px;
  font-weight: 600;
  color: #1e293b;
`;

const ActivityDescription = styled.div`
  font-size: 13px;
  color: #64748b;
  margin-top: 2px;
`;

const ActivityTime = styled.div`
  font-size: 12px;
  color: #94a3b8;
  margin-top: 4px;
`;

/* ========== Quick Actions Grid ========== */
const QuickActionsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
`;

const QuickActionCard = styled(Link)`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 24px 16px;
  border-radius: 16px;
  background: #f8fafc;
  text-decoration: none;
  text-align: center;
  transition: all 0.3s ease;

  &:hover {
    background: rgba(99, 102, 241, 0.08);
    transform: translateY(-4px);
  }
`;

const QuickActionIcon = styled.div`
  width: 52px;
  height: 52px;
  border-radius: 14px;
  background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;

  svg { width: 26px; height: 26px; }
`;

const QuickActionLabel = styled.div`
  font-size: 14px;
  font-weight: 600;
  color: #1e293b;
`;

const QuickActionDesc = styled.div`
  font-size: 12px;
  color: #64748b;
`;

/* ========== Loading State ========== */
const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  gap: 20px;
`;

const LoadingSpinner = styled.div`
  width: 48px;
  height: 48px;
  border: 4px solid #e2e8f0;
  border-top-color: #6366f1;
  border-radius: 50%;
  animation: spin 1s linear infinite;

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
`;

const LoadingText = styled.div`
  font-size: 16px;
  color: #64748b;
  font-weight: 500;
`;

/* ========== Error State ========== */
const ErrorContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  gap: 16px;
  text-align: center;
`;

const ErrorIcon = styled.div`
  width: 64px;
  height: 64px;
  border-radius: 16px;
  background: rgba(239, 68, 68, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #ef4444;

  svg { width: 32px; height: 32px; }
`;

const ErrorTitle = styled.h2`
  font-size: 20px;
  font-weight: 700;
  color: #1e293b;
  margin: 0;
`;

const ErrorMessage = styled.p`
  font-size: 14px;
  color: #64748b;
  margin: 0;
  max-width: 400px;
`;

/* ========== Component ========== */
interface Product360Props {}

const Product360: React.FC<Product360Props> = () => {
  const { productId } = useParams<{ productId: string }>();
  const navigate = useNavigate();
  const [product, setProduct] = useState<Product | null>(null);
  const [summary, setSummary] = useState<Product360Summary | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>('');

  useEffect(() => {
    const loadProduct = async () => {
      if (!productId) return;
      try {
        const productSummary = await getProduct360Summary(productId);
        if (productSummary) {
          setProduct(productSummary.product);
          setSummary(productSummary);
        } else {
          setError('Product not found');
        }
      } catch (err) {
        logger.error(LOG_CATEGORIES.ERROR, 'Failed to load product', {}, err as Error);
        setError('Failed to load product');
      } finally {
        setLoading(false);
      }
    };
    loadProduct();
  }, [productId]);

  // Calculate health score based on product completeness
  const healthScore = useMemo(() => {
    if (!summary) return 0;
    let score = 0;
    const { stats } = summary;

    // Coverages (30 points)
    if (stats.totalCoverages > 0) score += 15;
    if (stats.totalCoverages >= 5) score += 15;

    // Forms (20 points)
    if (stats.totalForms > 0) score += 10;
    if (stats.totalForms >= 3) score += 10;

    // Limits & Deductibles (20 points)
    if (stats.totalLimits > 0) score += 10;
    if (stats.totalDeductibles > 0) score += 10;

    // Rules (15 points)
    if (stats.totalRules > 0) score += 15;

    // States (15 points)
    if (product?.states && product.states.length > 0) score += 15;

    return Math.min(score, 100);
  }, [summary, product]);

  // Generate insights based on product data
  const insights = useMemo(() => {
    if (!summary || !product) return [];
    const items: Array<{ type: 'success' | 'warning' | 'info'; text: string }> = [];

    if (summary.stats.totalCoverages === 0) {
      items.push({ type: 'warning', text: 'No coverages defined. Add coverages to complete your product.' });
    } else if (summary.stats.totalCoverages >= 5) {
      items.push({ type: 'success', text: `${summary.stats.totalCoverages} coverages configured with comprehensive options.` });
    }

    if (summary.stats.totalForms === 0) {
      items.push({ type: 'warning', text: 'No forms linked. Upload policy forms for compliance.' });
    }

    if (summary.stats.totalRules === 0) {
      items.push({ type: 'info', text: 'Consider adding business rules for automated underwriting.' });
    }

    if (!product.states || product.states.length === 0) {
      items.push({ type: 'warning', text: 'No states selected. Define state availability.' });
    } else if (product.states.length >= 10) {
      items.push({ type: 'success', text: `Available in ${product.states.length} states with broad market reach.` });
    }

    return items.slice(0, 4);
  }, [summary, product]);

  // Get top coverages for display
  const topCoverages = useMemo(() => {
    if (!summary) return [];
    return summary.coverages
      .filter(c => !c.parentCoverageId)
      .slice(0, 5);
  }, [summary]);

  // Mock recent activity (would come from audit logs in production)
  const recentActivity = useMemo(() => [
    { type: 'coverage', title: 'Coverage Updated', description: 'Property Damage limits modified', time: '2 hours ago' },
    { type: 'form', title: 'Form Uploaded', description: 'CP 00 10 policy form added', time: '5 hours ago' },
    { type: 'pricing', title: 'Pricing Rule Added', description: 'Territory factor configured', time: '1 day ago' },
    { type: 'coverage', title: 'New Coverage', description: 'Business Income coverage added', time: '2 days ago' },
  ], []);

  if (loading) {
    return (
      <PageContainer>
        <MainNavigation />
        <PageContent>
          <LoadingContainer>
            <LoadingSpinner />
            <LoadingText>Loading product dashboard...</LoadingText>
          </LoadingContainer>
        </PageContent>
      </PageContainer>
    );
  }

  if (error || !product || !summary) {
    return (
      <PageContainer>
        <MainNavigation />
        <PageContent>
          <ErrorContainer>
            <ErrorIcon>
              <ExclamationTriangleIcon />
            </ErrorIcon>
            <ErrorTitle>Unable to Load Product</ErrorTitle>
            <ErrorMessage>{error || 'The product could not be found or loaded.'}</ErrorMessage>
            <QuickActionBtn onClick={() => navigate('/products')}>
              <ArrowLeftIcon />
              Back to Products
            </QuickActionBtn>
          </ErrorContainer>
        </PageContent>
      </PageContainer>
    );
  }

  return (
    <PageContainer>
      <MainNavigation />
      <PageContent>
        <MainContent>
          {/* Header */}
          <HeaderSection>
            <HeaderLeft>
              <BackButton onClick={() => navigate('/products')}>
                <ArrowLeftIcon />
              </BackButton>
              <ProductIcon>
                <ShieldCheckIcon />
              </ProductIcon>
              <ProductInfo>
                <ProductName>{product.name}</ProductName>
                <ProductMeta>
                  <MetaBadge $variant={product.status === 'active' ? 'success' : 'warning'}>
                    {product.status === 'active' ? <CheckCircleIcon /> : <ClockIcon />}
                    {product.status || 'Draft'}
                  </MetaBadge>
                  {product.productCode && (
                    <MetaBadge $variant="info">{product.productCode}</MetaBadge>
                  )}
                  {product.category && (
                    <MetaBadge>{product.category}</MetaBadge>
                  )}
                </ProductMeta>
              </ProductInfo>
            </HeaderLeft>
            <HeaderRight>
              <QuickActionBtn onClick={() => navigate(`/coverage/${productId}`)}>
                <EyeIcon />
                View Details
              </QuickActionBtn>
              <QuickActionBtn $primary onClick={() => navigate(`/coverage/${productId}`)}>
                <PencilIcon />
                Edit Product
              </QuickActionBtn>
            </HeaderRight>
          </HeaderSection>

          {/* Health Score Card */}
          <HealthScoreCard>
            <ScoreCircle $score={healthScore}>
              <ScoreValue>
                <ScoreNumber $score={healthScore}>{healthScore}</ScoreNumber>
                <ScoreLabel>Health Score</ScoreLabel>
              </ScoreValue>
            </ScoreCircle>
            <InsightsSection>
              <InsightsTitle>
                <SparklesSolid />
                AI Insights
              </InsightsTitle>
              <InsightsList>
                {insights.map((insight, idx) => (
                  <InsightItem key={idx} $type={insight.type}>
                    {insight.type === 'success' ? <CheckCircleIcon /> :
                     insight.type === 'warning' ? <ExclamationTriangleIcon /> :
                     <LightBulbIcon />}
                    <InsightText>{insight.text}</InsightText>
                  </InsightItem>
                ))}
              </InsightsList>
            </InsightsSection>
          </HealthScoreCard>

          {/* KPI Grid */}
          <KPIGrid>
            <KPICard to={`/coverage/${productId}`} $color="#6366f1" $delay={0}>
              <KPIHeader>
                <KPIIcon $color="#6366f1"><ShieldCheckIcon /></KPIIcon>
                <KPITrend $positive><ArrowTrendingUpIcon />+2</KPITrend>
              </KPIHeader>
              <KPIValue>{summary.stats.totalCoverages}</KPIValue>
              <KPILabel>Coverages</KPILabel>
              <KPISubtext>{summary.stats.totalLimits} limits â€¢ {summary.stats.totalDeductibles} deductibles</KPISubtext>
            </KPICard>

            <KPICard to={`/forms/${productId}`} $color="#10b981" $delay={1}>
              <KPIHeader>
                <KPIIcon $color="#10b981"><DocumentTextIcon /></KPIIcon>
              </KPIHeader>
              <KPIValue>{summary.stats.totalForms}</KPIValue>
              <KPILabel>Forms</KPILabel>
              <KPISubtext>Policy forms & endorsements</KPISubtext>
            </KPICard>

            <KPICard to={`/pricing/${productId}`} $color="#f59e0b" $delay={2}>
              <KPIHeader>
                <KPIIcon $color="#f59e0b"><CurrencyDollarIcon /></KPIIcon>
              </KPIHeader>
              <KPIValue>{summary.stats.totalPricingRules}</KPIValue>
              <KPILabel>Pricing Rules</KPILabel>
              <KPISubtext>Rating factors & tables</KPISubtext>
            </KPICard>

            <KPICard to={`/states/${productId}`} $color="#8b5cf6" $delay={3}>
              <KPIHeader>
                <KPIIcon $color="#8b5cf6"><MapPinIcon /></KPIIcon>
              </KPIHeader>
              <KPIValue>{product.states?.length || 0}</KPIValue>
              <KPILabel>States</KPILabel>
              <KPISubtext>Market availability</KPISubtext>
            </KPICard>

            <KPICard to={`/rules/${productId}`} $color="#06b6d4" $delay={4}>
              <KPIHeader>
                <KPIIcon $color="#06b6d4"><Cog6ToothIcon /></KPIIcon>
              </KPIHeader>
              <KPIValue>{summary.stats.totalRules}</KPIValue>
              <KPILabel>Business Rules</KPILabel>
              <KPISubtext>Eligibility & validation</KPISubtext>
            </KPICard>
          </KPIGrid>

          {/* Content Grid */}
          <ContentGrid>
            {/* Coverages Card */}
            <Card $delay={0}>
              <CardHeader>
                <CardTitle>
                  <ShieldCheckIcon />
                  Top Coverages
                </CardTitle>
                <ViewAllLink to={`/coverage/${productId}`}>
                  View All <ArrowRightIcon />
                </ViewAllLink>
              </CardHeader>
              <CoverageList>
                {topCoverages.length > 0 ? topCoverages.map((coverage, idx) => (
                  <CoverageItem key={coverage.id} to={`/coverage/${productId}`}>
                    <CoverageInfo>
                      <CoverageIcon $isParent>
                        <ShieldCheckIcon />
                      </CoverageIcon>
                      <CoverageDetails>
                        <CoverageName>{coverage.name}</CoverageName>
                        <CoverageCode>{coverage.coverageCode || 'No code'}</CoverageCode>
                      </CoverageDetails>
                    </CoverageInfo>
                    <CoverageStats>
                      <CoverageStat>
                        <CoverageStatValue>{(coverage.limits as any[])?.length || 0}</CoverageStatValue>
                        <CoverageStatLabel>Limits</CoverageStatLabel>
                      </CoverageStat>
                      <CoverageStat>
                        <CoverageStatValue>{(coverage.deductibles as any[])?.length || 0}</CoverageStatValue>
                        <CoverageStatLabel>Deductibles</CoverageStatLabel>
                      </CoverageStat>
                    </CoverageStats>
                  </CoverageItem>
                )) : (
                  <CoverageItem to={`/coverage/${productId}`}>
                    <CoverageInfo>
                      <CoverageIcon>
                        <PlusIcon />
                      </CoverageIcon>
                      <CoverageDetails>
                        <CoverageName>Add Your First Coverage</CoverageName>
                        <CoverageCode>Click to get started</CoverageCode>
                      </CoverageDetails>
                    </CoverageInfo>
                  </CoverageItem>
                )}
              </CoverageList>
            </Card>

            {/* Activity Card */}
            <Card $delay={1}>
              <CardHeader>
                <CardTitle>
                  <ClockIcon />
                  Recent Activity
                </CardTitle>
              </CardHeader>
              <ActivityList>
                {recentActivity.map((activity, idx) => (
                  <ActivityItem key={idx}>
                    <ActivityIcon $type={activity.type}>
                      {activity.type === 'coverage' ? <ShieldCheckIcon /> :
                       activity.type === 'form' ? <DocumentTextIcon /> :
                       <CurrencyDollarIcon />}
                    </ActivityIcon>
                    <ActivityContent>
                      <ActivityTitle>{activity.title}</ActivityTitle>
                      <ActivityDescription>{activity.description}</ActivityDescription>
                      <ActivityTime>{activity.time}</ActivityTime>
                    </ActivityContent>
                  </ActivityItem>
                ))}
              </ActivityList>
            </Card>
          </ContentGrid>

          {/* Quick Actions */}
          <Card $delay={2}>
            <CardHeader>
              <CardTitle>
                <BoltIcon />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <QuickActionsGrid>
              <QuickActionCard to={`/coverage/${productId}`}>
                <QuickActionIcon><PlusIcon /></QuickActionIcon>
                <QuickActionLabel>Add Coverage</QuickActionLabel>
                <QuickActionDesc>Create new coverage option</QuickActionDesc>
              </QuickActionCard>
              <QuickActionCard to={`/forms/${productId}`}>
                <QuickActionIcon><DocumentTextIcon /></QuickActionIcon>
                <QuickActionLabel>Upload Form</QuickActionLabel>
                <QuickActionDesc>Add policy documents</QuickActionDesc>
              </QuickActionCard>
              <QuickActionCard to={`/pricing/${productId}`}>
                <QuickActionIcon><CurrencyDollarIcon /></QuickActionIcon>
                <QuickActionLabel>Configure Pricing</QuickActionLabel>
                <QuickActionDesc>Set up rating factors</QuickActionDesc>
              </QuickActionCard>
              <QuickActionCard to={`/rules/${productId}`}>
                <QuickActionIcon><Cog6ToothIcon /></QuickActionIcon>
                <QuickActionLabel>Add Rule</QuickActionLabel>
                <QuickActionDesc>Define business logic</QuickActionDesc>
              </QuickActionCard>
              <QuickActionCard to={`/states/${productId}`}>
                <QuickActionIcon><MapPinIcon /></QuickActionIcon>
                <QuickActionLabel>Manage States</QuickActionLabel>
                <QuickActionDesc>Set availability</QuickActionDesc>
              </QuickActionCard>
              <QuickActionCard to={`/quote-sandbox/${productId}`}>
                <QuickActionIcon><BeakerIcon /></QuickActionIcon>
                <QuickActionLabel>Quote Sandbox</QuickActionLabel>
                <QuickActionDesc>Test premium calculations</QuickActionDesc>
              </QuickActionCard>
            </QuickActionsGrid>
          </Card>
        </MainContent>
      </PageContent>
    </PageContainer>
  );
};

export default Product360;

```

---

## src/pages/QuoteSandbox.tsx

**Path:** `src/pages/QuoteSandbox.tsx`

```tsx
/**
 * Quote Sandbox
 * Interactive pricing calculator for testing coverage rates
 * Route: /quote-sandbox/:productId
 */

import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import styled from 'styled-components';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../firebase';
import { DataDictionaryField, RatingInput } from '../types/pricing';
import dataDictionaryService from '../services/dataDictionaryService';
import logger, { LOG_CATEGORIES } from '../utils/logger';

const Container = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 20px;
  padding: 20px;
  height: 100vh;
  background: #f5f5f5;
`;

const Panel = styled.div`
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow-y: auto;
`;

const PanelTitle = styled.h2`
  margin: 0 0 20px 0;
  font-size: 18px;
  color: #333;
  border-bottom: 2px solid #007bff;
  padding-bottom: 10px;
`;

const FormGroup = styled.div`
  margin-bottom: 15px;
`;

const Label = styled.label`
  display: block;
  margin-bottom: 5px;
  font-weight: 500;
  color: #555;
`;

const Input = styled.input`
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;

  &:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
  }
`;

const Select = styled.select`
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;

  &:focus {
    outline: none;
    border-color: #007bff;
  }
`;

const Button = styled.button`
  background: #007bff;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;

  &:hover {
    background: #0056b3;
  }

  &:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
`;

const BreakdownTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;

  th, td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #ddd;
  }

  th {
    background: #f9f9f9;
    font-weight: 600;
    color: #333;
  }

  tr:hover {
    background: #f9f9f9;
  }
`;

const TotalRow = styled.tr`
  font-weight: 600;
  background: #f0f0f0;
  font-size: 16px;
`;

const ErrorMessage = styled.div`
  background: #f8d7da;
  color: #721c24;
  padding: 12px;
  border-radius: 4px;
  margin-bottom: 15px;
`;

const LoadingSpinner = styled.div`
  text-align: center;
  padding: 20px;
  color: #666;
`;

interface QuoteSandboxProps {}

const QuoteSandbox: React.FC<QuoteSandboxProps> = () => {
  const { productId } = useParams<{ productId: string }>();
  const [fields, setFields] = useState<DataDictionaryField[]>([]);
  const [inputs, setInputs] = useState<RatingInput>({});
  const [selectedCoverageId, setSelectedCoverageId] = useState<string>('');
  const [breakdown, setBreakdown] = useState<Record<string, number> | null>(null);
  const [total, setTotal] = useState<number>(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string>('');

  // Load data dictionary fields
  useEffect(() => {
    const loadFields = async () => {
      if (!productId) return;
      try {
        const loadedFields = await dataDictionaryService.getProductFields(productId);
        setFields(loadedFields);
        
        // Initialize inputs with defaults
        const defaultInputs: RatingInput = {};
        for (const field of loadedFields) {
          if (field.defaultValue !== undefined) {
            defaultInputs[field.name] = field.defaultValue;
          }
        }
        setInputs(defaultInputs);

        // Load from localStorage
        const saved = localStorage.getItem(`quoteSandbox_${productId}`);
        if (saved) {
          setInputs(JSON.parse(saved));
        }
      } catch (err) {
        logger.error(LOG_CATEGORIES.ERROR, 'Failed to load data dictionary', {}, err as Error);
        setError('Failed to load rating fields');
      }
    };

    loadFields();
  }, [productId]);

  // Handle input change
  const handleInputChange = (fieldName: string, value: string | number | boolean) => {
    const newInputs = { ...inputs, [fieldName]: value };
    setInputs(newInputs);
    
    // Save to localStorage
    if (productId) {
      localStorage.setItem(`quoteSandbox_${productId}`, JSON.stringify(newInputs));
    }
  };

  // Calculate rate
  const handleCalculateRate = async () => {
    if (!productId || !selectedCoverageId) {
      setError('Please select a coverage');
      return;
    }

    setLoading(true);
    setError('');

    try {
      const rateCoverage = httpsCallable(functions, 'rateCoverage');
      const result = await rateCoverage({
        productId,
        coverageId: selectedCoverageId,
        inputs
      });

      const data = result.data as any;
      setBreakdown(data.stepBreakdown);
      setTotal(data.total);
    } catch (err) {
      logger.error(LOG_CATEGORIES.ERROR, 'Rating calculation failed', {}, err as Error);
      setError('Failed to calculate rate');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container>
      {/* Left Panel: Inputs */}
      <Panel>
        <PanelTitle>Rating Inputs</PanelTitle>
        {error && <ErrorMessage>{error}</ErrorMessage>}
        
        {fields.length === 0 ? (
          <LoadingSpinner>No rating fields configured</LoadingSpinner>
        ) : (
          <>
            {fields.map(field => (
              <FormGroup key={field.id}>
                <Label>{field.label}</Label>
                {field.type === 'enum' && field.enumOptions ? (
                  <Select
                    value={inputs[field.name] || ''}
                    onChange={(e) => handleInputChange(field.name, e.target.value)}
                  >
                    <option value="">Select...</option>
                    {field.enumOptions.map(opt => (
                      <option key={opt} value={opt}>{opt}</option>
                    ))}
                  </Select>
                ) : field.type === 'boolean' ? (
                  <Select
                    value={inputs[field.name] ? 'true' : 'false'}
                    onChange={(e) => handleInputChange(field.name, e.target.value === 'true')}
                  >
                    <option value="false">No</option>
                    <option value="true">Yes</option>
                  </Select>
                ) : (
                  <Input
                    type={field.type === 'number' ? 'number' : 'text'}
                    value={inputs[field.name] || ''}
                    onChange={(e) => handleInputChange(field.name, 
                      field.type === 'number' ? Number(e.target.value) : e.target.value
                    )}
                    min={field.min}
                    max={field.max}
                    placeholder={field.description}
                  />
                )}
              </FormGroup>
            ))}
          </>
        )}
      </Panel>

      {/* Middle Panel: Coverage Selection */}
      <Panel>
        <PanelTitle>Coverage Selection</PanelTitle>
        <FormGroup>
          <Label>Select Coverage</Label>
          <Select
            value={selectedCoverageId}
            onChange={(e) => setSelectedCoverageId(e.target.value)}
          >
            <option value="">Choose a coverage...</option>
            {/* Coverage options would be loaded from product */}
          </Select>
        </FormGroup>
        <Button onClick={handleCalculateRate} disabled={loading || !selectedCoverageId}>
          {loading ? 'Calculating...' : 'Calculate Rate'}
        </Button>
      </Panel>

      {/* Right Panel: Premium Breakdown */}
      <Panel>
        <PanelTitle>Premium Breakdown</PanelTitle>
        {breakdown ? (
          <BreakdownTable>
            <thead>
              <tr>
                <th>Step</th>
                <th>Amount</th>
              </tr>
            </thead>
            <tbody>
              {Object.entries(breakdown).map(([stepId, amount]) => (
                <tr key={stepId}>
                  <td>{stepId}</td>
                  <td>${amount.toFixed(2)}</td>
                </tr>
              ))}
              <TotalRow>
                <td>Total Premium</td>
                <td>${total.toFixed(2)}</td>
              </TotalRow>
            </tbody>
          </BreakdownTable>
        ) : (
          <LoadingSpinner>Select a coverage and click "Calculate Rate"</LoadingSpinner>
        )}
      </Panel>
    </Container>
  );
};

export default QuoteSandbox;

```

---

## src/services/advancedRAGService.ts

**Path:** `src/services/advancedRAGService.ts`

```typescript
/**
 * Advanced RAG (Retrieval-Augmented Generation) Service
 *
 * OPTIMIZED VERSION - Performance & Cost Improvements:
 * - Insurance-specific semantic chunking for coverages, limits, deductibles, exclusions
 * - Parallel batch processing with rate limiting
 * - All operations use gpt-4o-mini for cost efficiency
 * - Token budget management and prompt compression
 * - Hierarchical summarization with early termination
 * - Chunk caching with LRU eviction
 * - Context-aware retrieval with TF-IDF scoring
 */

import logger, { LOG_CATEGORIES } from '@utils/logger';
import { functions } from '@/firebase';
import { httpsCallable } from 'firebase/functions';
import { AI_MODELS } from '@config/aiConfig';
import { processBatch } from '@utils/parallelProcessor';

// ============================================================================
// Type Definitions
// ============================================================================

export interface DocumentChunk {
  id: string;
  content: string;
  metadata: ChunkMetadata;
  embedding?: number[];
  relevanceScore?: number;
  tokenCount?: number;
}

export interface ChunkMetadata {
  source: string;
  sourceType: 'product' | 'coverage' | 'form' | 'rule' | 'pricing';
  section?: InsuranceSection;
  pageNumber?: number;
  startOffset: number;
  endOffset: number;
  keyEntities?: string[];
  importance: 'critical' | 'high' | 'medium' | 'low';
  insuranceType?: InsuranceContentType;
}

// Insurance-specific content classification
export type InsuranceSection =
  | 'declarations'
  | 'insuring_agreement'
  | 'definitions'
  | 'exclusions'
  | 'conditions'
  | 'limits'
  | 'deductibles'
  | 'endorsements'
  | 'schedule'
  | 'general';

export type InsuranceContentType =
  | 'coverage_grant'
  | 'coverage_limit'
  | 'coverage_deductible'
  | 'exclusion'
  | 'condition'
  | 'definition'
  | 'endorsement'
  | 'rate_info'
  | 'general';

export interface SummaryRequest {
  documents: DocumentSource[];
  summaryType: SummaryType;
  targetLength?: 'brief' | 'standard' | 'detailed';
  focusAreas?: string[];
  includeSourceCitations?: boolean;
  hierarchical?: boolean;
  costOptimized?: boolean; // Use cheaper models where possible
  parallelBatchSize?: number; // Control parallel processing
}

export interface DocumentSource {
  id: string;
  type: 'product' | 'coverage' | 'form' | 'rule' | 'pricing';
  content: string;
  title: string;
  metadata?: Record<string, unknown>;
}

export type SummaryType =
  | 'executive'      // High-level business summary
  | 'technical'      // Detailed technical breakdown
  | 'comparative'    // Compare across documents
  | 'compliance'     // Focus on regulatory aspects
  | 'actionable'     // Highlight action items
  | 'comprehensive'; // Full synthesis

export interface SummaryResult {
  summary: string;
  keyPoints: KeyPoint[];
  entities: ExtractedEntity[];
  sourceCitations: SourceCitation[];
  confidence: number;
  methodology: string;
  processingMetrics: ProcessingMetrics;
}

export interface KeyPoint {
  text: string;
  importance: 'critical' | 'high' | 'medium' | 'low';
  category: string;
  sourceRef?: string;
}

export interface ExtractedEntity {
  name: string;
  type: 'coverage' | 'limit' | 'deductible' | 'state' | 'form' | 'rule' | 'date' | 'amount';
  value?: string;
  context: string;
  frequency: number;
}

export interface SourceCitation {
  id: string;
  documentTitle: string;
  section?: string;
  excerpt: string;
  relevance: number;
}

export interface ProcessingMetrics {
  totalDocuments: number;
  totalChunks: number;
  processingTimeMs: number;
  tokensUsed: number;
  compressionRatio: number;
  modelCalls: number;
  estimatedCost: number;
}

// ============================================================================
// Optimized Configuration
// ============================================================================

const RAG_CONFIG = {
  // Chunk sizing - optimized for insurance forms
  maxChunkSize: 1200,       // Reduced for better granularity
  minChunkSize: 200,        // Minimum to avoid tiny chunks
  chunkOverlap: 100,        // Reduced overlap for efficiency
  maxContextWindow: 6000,   // Increased for gpt-4o-mini

  // Processing limits
  minRelevanceScore: 0.4,   // Lowered threshold for better coverage
  maxChunksPerLevel: 12,    // Increased for thorough analysis
  maxParallelCalls: 5,      // Parallel API calls limit
  batchDelay: 100,          // ms between batches

  // Model selection - cost optimization
  mapModel: 'gpt-4o-mini',  // Cheaper model for individual chunk summaries
  reduceModel: AI_MODELS.HOME_CHAT, // Higher quality for final synthesis
  embeddingModel: 'text-embedding-3-small',

  // Token budgets (approximate)
  mapTokenBudget: 400,      // Max tokens per chunk summary
  reduceTokenBudget: 1500,  // Max tokens for final synthesis

  // Cache settings
  maxCacheSize: 100,
  cacheTTL: 10 * 60 * 1000, // 10 minutes

  // Cost estimates (per 1K tokens) - all using gpt-4o-mini
  costs: {
    'gpt-4o-mini': { input: 0.00015, output: 0.0006 }
  }
};

// Insurance-specific section patterns with priority weights
const INSURANCE_SECTION_PATTERNS: Array<{
  pattern: RegExp;
  section: InsuranceSection;
  priority: number;
  contentType: InsuranceContentType;
}> = [
  { pattern: /^SECTION\s+[IVX\d]+[\s.:]+DECLARATIONS?/im, section: 'declarations', priority: 10, contentType: 'general' },
  { pattern: /DECLARATIONS?\s+PAGE/i, section: 'declarations', priority: 10, contentType: 'general' },
  { pattern: /INSURING\s+AGREEMENT/i, section: 'insuring_agreement', priority: 9, contentType: 'coverage_grant' },
  { pattern: /COVERAGE\s+[A-Z][\s.:â€“-]+/i, section: 'insuring_agreement', priority: 9, contentType: 'coverage_grant' },
  { pattern: /^DEFINITIONS?[\s.:]/im, section: 'definitions', priority: 7, contentType: 'definition' },
  { pattern: /"[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*"\s+means/i, section: 'definitions', priority: 7, contentType: 'definition' },
  { pattern: /EXCLUSIONS?[\s.:]/i, section: 'exclusions', priority: 8, contentType: 'exclusion' },
  { pattern: /(?:WE|THIS POLICY)\s+(?:DO|DOES)\s+NOT\s+(?:COVER|PAY|PROVIDE)/i, section: 'exclusions', priority: 8, contentType: 'exclusion' },
  { pattern: /^CONDITIONS?[\s.:]/im, section: 'conditions', priority: 6, contentType: 'condition' },
  { pattern: /DUTIES\s+(?:AFTER|IN\s+THE\s+EVENT)/i, section: 'conditions', priority: 6, contentType: 'condition' },
  { pattern: /LIMIT(?:S)?\s+OF\s+(?:LIABILITY|INSURANCE|COVERAGE)/i, section: 'limits', priority: 9, contentType: 'coverage_limit' },
  { pattern: /\$[\d,]+(?:\s+(?:per|each|aggregate))/i, section: 'limits', priority: 8, contentType: 'coverage_limit' },
  { pattern: /DEDUCTIBLE(?:S)?[\s.:]/i, section: 'deductibles', priority: 8, contentType: 'coverage_deductible' },
  { pattern: /ENDORSEMENT[\s.:]/i, section: 'endorsements', priority: 5, contentType: 'endorsement' },
  { pattern: /SCHEDULE[\s.:]/i, section: 'schedule', priority: 6, contentType: 'general' },
  { pattern: /PREMIUM|RATE|BASE\s+RATE/i, section: 'schedule', priority: 7, contentType: 'rate_info' },
];

// ============================================================================
// LRU Cache for Chunk Caching
// ============================================================================

interface CacheEntry<T> {
  value: T;
  timestamp: number;
}

class LRUCache<K, V> {
  private cache = new Map<K, CacheEntry<V>>();
  private maxSize: number;
  private ttl: number;

  constructor(maxSize: number, ttl: number) {
    this.maxSize = maxSize;
    this.ttl = ttl;
  }

  get(key: K): V | undefined {
    const entry = this.cache.get(key);
    if (!entry) return undefined;

    // Check TTL
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return undefined;
    }

    // Move to end (most recently used)
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.value;
  }

  set(key: K, value: V): void {
    // Evict oldest if at capacity
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, { value, timestamp: Date.now() });
  }

  has(key: K): boolean {
    return this.get(key) !== undefined;
  }

  clear(): void {
    this.cache.clear();
  }
}

// ============================================================================
// Advanced RAG Service Class
// ============================================================================
// Note: processBatch is now imported from @utils/parallelProcessor

class AdvancedRAGService {
  private chunkCache = new LRUCache<string, DocumentChunk[]>(
    RAG_CONFIG.maxCacheSize,
    RAG_CONFIG.cacheTTL
  );
  private summaryCache = new LRUCache<string, string>(50, RAG_CONFIG.cacheTTL);
  private totalTokensUsed = 0;
  private totalModelCalls = 0;

  /**
   * Main entry point: Generate intelligent summary from documents
   * OPTIMIZED: Added cost tracking, parallel processing, and caching
   */
  async generateSummary(request: SummaryRequest): Promise<SummaryResult> {
    const startTime = Date.now();
    this.totalTokensUsed = 0;
    this.totalModelCalls = 0;

    logger.info(LOG_CATEGORIES.AI, 'Starting optimized RAG summary generation', {
      documents: request.documents.length,
      type: request.summaryType,
      costOptimized: request.costOptimized ?? true
    });

    try {
      // Step 1: Insurance-aware semantic chunking
      const chunks = await this.semanticChunk(request.documents);

      // Step 2: Extract entities for context (parallel)
      const entities = this.extractEntities(chunks);

      // Step 3: Generate summary using appropriate strategy
      const summary = request.hierarchical
        ? await this.hierarchicalSummarize(chunks, request)
        : await this.directSummarize(chunks, request);

      // Step 4: Extract key points (optimized - uses cached summary)
      const keyPoints = await this.extractKeyPoints(summary, request.summaryType);

      // Step 5: Generate source citations
      const citations = this.generateCitations(chunks, summary);

      // Calculate metrics with cost estimation
      const processingTime = Date.now() - startTime;
      const estimatedCost = this.estimateCost();

      const metrics: ProcessingMetrics = {
        totalDocuments: request.documents.length,
        totalChunks: chunks.length,
        processingTimeMs: processingTime,
        tokensUsed: this.totalTokensUsed,
        compressionRatio: this.calculateCompressionRatio(request.documents, summary),
        modelCalls: this.totalModelCalls,
        estimatedCost
      };

      logger.info(LOG_CATEGORIES.AI, 'RAG summary completed', {
        ...metrics,
        costSavings: request.costOptimized ? 'enabled' : 'disabled'
      });

      return {
        summary,
        keyPoints,
        entities,
        sourceCitations: citations,
        confidence: this.calculateConfidence(chunks, request),
        methodology: request.hierarchical ? 'hierarchical-map-reduce' : 'direct-synthesis',
        processingMetrics: metrics
      };
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'RAG summary failed', { error });
      throw error;
    }
  }

  /**
   * Estimate cost based on tokens used
   */
  private estimateCost(): number {
    // Rough estimate assuming 60% input, 40% output tokens
    const inputTokens = this.totalTokensUsed * 0.6;
    const outputTokens = this.totalTokensUsed * 0.4;

    // Use gpt-4o-mini costs as baseline (most calls use this)
    const costs = RAG_CONFIG.costs['gpt-4o-mini'];
    return (inputTokens / 1000 * costs.input) + (outputTokens / 1000 * costs.output);
  }

  /**
   * Semantic chunking: Split documents into meaningful chunks
   * OPTIMIZED: Uses LRU cache and parallel processing
   */
  private async semanticChunk(documents: DocumentSource[]): Promise<DocumentChunk[]> {
    const allChunks: DocumentChunk[] = [];
    const uncachedDocs: DocumentSource[] = [];

    // Check cache first
    for (const doc of documents) {
      const cacheKey = this.generateCacheKey(doc);
      const cached = this.chunkCache.get(cacheKey);

      if (cached) {
        allChunks.push(...cached);
      } else {
        uncachedDocs.push(doc);
      }
    }

    // Process uncached documents
    if (uncachedDocs.length > 0) {
      const newChunks = uncachedDocs.flatMap(doc => {
        const chunks = this.createInsuranceAwareChunks(doc);
        this.chunkCache.set(this.generateCacheKey(doc), chunks);
        return chunks;
      });
      allChunks.push(...newChunks);
    }

    return allChunks;
  }

  /**
   * Generate cache key for document
   */
  private generateCacheKey(doc: DocumentSource): string {
    // Use content hash for more reliable caching
    const contentHash = doc.content.length + '-' + doc.content.slice(0, 100).replace(/\s/g, '');
    return `${doc.id}-${contentHash}`;
  }

  /**
   * Create insurance-aware semantic chunks with enhanced metadata
   * OPTIMIZED: Uses insurance-specific patterns for better chunking
   */
  private createInsuranceAwareChunks(doc: DocumentSource): DocumentChunk[] {
    const chunks: DocumentChunk[] = [];
    const content = doc.content;

    // Split by insurance-specific semantic boundaries
    const sections = this.splitByInsuranceBoundaries(content);

    let offset = 0;
    sections.forEach((section, index) => {
      const tokenCount = this.estimateTokens(section);

      // Skip very small chunks
      if (tokenCount < RAG_CONFIG.minChunkSize / 4) {
        offset += section.length;
        return;
      }

      const sectionInfo = this.identifyInsuranceSection(section);
      const importance = this.assessInsuranceImportance(section, doc.type, sectionInfo);
      const keyEntities = this.extractEntitiesFromText(section);

      chunks.push({
        id: `${doc.id}-chunk-${index}`,
        content: section.trim(),
        tokenCount,
        metadata: {
          source: doc.title,
          sourceType: doc.type,
          section: sectionInfo.section,
          startOffset: offset,
          endOffset: offset + section.length,
          keyEntities,
          importance,
          insuranceType: sectionInfo.contentType
        }
      });

      offset += section.length;
    });

    return chunks;
  }

  /**
   * Split content by insurance-specific semantic boundaries
   * OPTIMIZED: Recognizes insurance form structure
   */
  private splitByInsuranceBoundaries(content: string): string[] {
    // Insurance-specific section markers
    const insurancePatterns = [
      /(?=SECTION\s+[IVX\d]+[\s.:]+)/im,
      /(?=COVERAGE\s+[A-Z][\s.:â€“-]+)/im,
      /(?=PART\s+[IVX\d]+[\s.:]+)/im,
      /(?=ENDORSEMENT[\s.:]+)/im,
      /(?=EXCLUSIONS?[\s.:]+)/im,
      /(?=CONDITIONS?[\s.:]+)/im,
      /(?=DEFINITIONS?[\s.:]+)/im,
      /(?=LIMITS?\s+OF\s+)/im,
      /(?=DEDUCTIBLE[\s.:]+)/im,
    ];

    // General patterns
    const generalPatterns = [
      /\n\n+/,                    // Double+ newlines
      /(?=^#{1,3}\s)/m,           // Markdown headers
      /(?=^[A-Z][A-Z\s]{5,}:)/m,  // UPPERCASE HEADERS:
      /(?=^\d+\.\s+[A-Z])/m,      // Numbered sections
    ];

    let sections = [content];

    // Apply insurance patterns first (higher priority)
    insurancePatterns.forEach(pattern => {
      sections = sections.flatMap(s => s.split(pattern).filter(Boolean));
    });

    // Then general patterns
    generalPatterns.forEach(pattern => {
      sections = sections.flatMap(s => s.split(pattern).filter(Boolean));
    });

    // Ensure chunks don't exceed max size, merge tiny chunks
    return this.optimizeChunkSizes(sections);
  }

  /**
   * Optimize chunk sizes - split large, merge small
   */
  private optimizeChunkSizes(sections: string[]): string[] {
    const optimized: string[] = [];
    let buffer = '';

    for (const section of sections) {
      const sectionTokens = this.estimateTokens(section);
      const bufferTokens = this.estimateTokens(buffer);

      if (sectionTokens > RAG_CONFIG.maxChunkSize) {
        // Flush buffer first
        if (buffer) {
          optimized.push(buffer);
          buffer = '';
        }
        // Split large section
        optimized.push(...this.splitBySize(section, RAG_CONFIG.maxChunkSize));
      } else if (bufferTokens + sectionTokens < RAG_CONFIG.minChunkSize) {
        // Merge small sections
        buffer += (buffer ? '\n\n' : '') + section;
      } else if (bufferTokens + sectionTokens <= RAG_CONFIG.maxChunkSize) {
        // Can still merge
        buffer += (buffer ? '\n\n' : '') + section;
      } else {
        // Flush buffer and start new
        if (buffer) optimized.push(buffer);
        buffer = section;
      }
    }

    if (buffer) optimized.push(buffer);
    return optimized;
  }

  /**
   * Identify insurance section type with priority
   */
  private identifyInsuranceSection(content: string): { section: InsuranceSection; contentType: InsuranceContentType; priority: number } {
    let bestMatch = { section: 'general' as InsuranceSection, contentType: 'general' as InsuranceContentType, priority: 0 };

    for (const pattern of INSURANCE_SECTION_PATTERNS) {
      if (pattern.pattern.test(content) && pattern.priority > bestMatch.priority) {
        bestMatch = {
          section: pattern.section,
          contentType: pattern.contentType,
          priority: pattern.priority
        };
      }
    }

    return bestMatch;
  }

  /**
   * Assess importance with insurance-specific weighting
   */
  private assessInsuranceImportance(
    section: string,
    type: string,
    sectionInfo: { section: InsuranceSection; contentType: InsuranceContentType; priority: number }
  ): 'critical' | 'high' | 'medium' | 'low' {
    // Critical sections
    if (['limits', 'deductibles', 'exclusions'].includes(sectionInfo.section)) {
      return 'critical';
    }

    // High priority patterns
    const highPriorityPatterns = [
      /\$[\d,]+(?:\s+(?:per|each|aggregate))/i,
      /limit|coverage|deductible|exclusion/i,
      /mandatory|required|must|shall/i,
      /premium|rate|pricing|cost/i,
      /compliance|regulation|filing/i
    ];

    const matchCount = highPriorityPatterns.filter(p => p.test(section)).length;

    if (matchCount >= 3 || sectionInfo.priority >= 8) return 'critical';
    if (matchCount >= 2 || sectionInfo.priority >= 6) return 'high';
    if (matchCount >= 1 || sectionInfo.priority >= 4) return 'medium';
    return 'low';
  }

  /**
   * Split content by semantic boundaries (legacy support)
   */
  private splitBySemanticBoundaries(content: string): string[] {
    return this.splitByInsuranceBoundaries(content);
  }

  /**
   * Create semantic chunks (legacy support)
   */
  private createSemanticChunks(doc: DocumentSource): DocumentChunk[] {
    return this.createInsuranceAwareChunks(doc);
  }

  /**
   * Split by size with overlap
   */
  private splitBySize(text: string, maxTokens: number): string[] {
    const words = text.split(/\s+/);
    const wordsPerChunk = Math.floor(maxTokens / 1.3);
    const overlap = Math.floor(RAG_CONFIG.chunkOverlap / 1.3);
    const chunks: string[] = [];

    for (let i = 0; i < words.length; i += wordsPerChunk - overlap) {
      chunks.push(words.slice(i, i + wordsPerChunk).join(' '));
    }

    return chunks;
  }

  /**
   * Assess importance of content section (legacy support)
   */
  private assessImportance(section: string, type: string): 'high' | 'medium' | 'low' {
    const result = this.assessInsuranceImportance(
      section,
      type,
      this.identifyInsuranceSection(section)
    );
    // Map critical to high for legacy compatibility
    return result === 'critical' ? 'high' : result;
  }

  /**
   * Identify section type from content (legacy support)
   */
  private identifySection(content: string): InsuranceSection {
    return this.identifyInsuranceSection(content).section;
  }

  /**
   * Extract entities from text chunk with insurance-specific patterns
   */
  private extractEntitiesFromText(text: string): string[] {
    const entities: string[] = [];

    // Extract amounts (insurance limits, premiums)
    const amounts = text.match(/\$[\d,]+(?:\.\d{2})?(?:\s+(?:per|each|aggregate|occurrence))?/gi);
    if (amounts) entities.push(...amounts.map(a => a.trim()));

    // Extract percentages (deductibles, rates)
    const percentages = text.match(/\d+(?:\.\d+)?%/g);
    if (percentages) entities.push(...percentages);

    // Extract dates
    const dates = text.match(/\d{1,2}\/\d{1,2}\/\d{2,4}|\w+\s+\d{1,2},?\s+\d{4}/g);
    if (dates) entities.push(...dates);

    // Extract state codes
    const states = text.match(/\b[A-Z]{2}\b/g);
    if (states) entities.push(...new Set(states));

    // Extract coverage codes (e.g., "Coverage A", "Form CG 00 01")
    const coverageCodes = text.match(/(?:Coverage|Form)\s+[A-Z]{1,2}(?:\s+\d{2}\s+\d{2})?/gi);
    if (coverageCodes) entities.push(...coverageCodes);

    return [...new Set(entities)].slice(0, 15);
  }

  /**
   * Extract all entities across chunks
   */
  private extractEntities(chunks: DocumentChunk[]): ExtractedEntity[] {
    const entityMap = new Map<string, ExtractedEntity>();

    chunks.forEach(chunk => {
      chunk.metadata.keyEntities?.forEach(entity => {
        const key = entity.toLowerCase();
        if (entityMap.has(key)) {
          entityMap.get(key)!.frequency++;
        } else {
          entityMap.set(key, {
            name: entity,
            type: this.classifyEntity(entity),
            context: chunk.content.substring(0, 100),
            frequency: 1
          });
        }
      });
    });

    return Array.from(entityMap.values())
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, 25);
  }

  /**
   * Classify entity type with insurance-specific categories
   */
  private classifyEntity(entity: string): ExtractedEntity['type'] {
    if (/^\$/.test(entity)) {
      if (/per|each|aggregate|occurrence/i.test(entity)) return 'limit';
      return 'amount';
    }
    if (/%$/.test(entity)) return 'deductible';
    if (/\d{1,2}\/\d{1,2}\/\d{2,4}/.test(entity)) return 'date';
    if (/^[A-Z]{2}$/.test(entity)) return 'state';
    if (/^(?:Coverage|Form)/i.test(entity)) return 'form';
    return 'coverage';
  }


  /**
   * Hierarchical summarization using map-reduce pattern
   * OPTIMIZED: Uses parallel batch processing and cheaper model for map phase
   */
  private async hierarchicalSummarize(
    chunks: DocumentChunk[],
    request: SummaryRequest
  ): Promise<string> {
    const costOptimized = request.costOptimized ?? true;

    // Sort by importance (critical first) and take top chunks
    const sortedChunks = [...chunks].sort((a, b) => {
      const importanceOrder = { critical: 0, high: 1, medium: 2, low: 3 };
      return importanceOrder[a.metadata.importance] - importanceOrder[b.metadata.importance];
    });

    const topChunks = sortedChunks.slice(0, RAG_CONFIG.maxChunksPerLevel);

    // Level 1: Summarize individual chunks (Map) - use parallel batching
    const batchSize = request.parallelBatchSize ?? RAG_CONFIG.maxParallelCalls;

    const chunkSummaries = await processBatch(
      topChunks,
      chunk => this.summarizeChunk(chunk, request.summaryType, costOptimized),
      batchSize
    );

    // Level 2: Combine chunk summaries (Reduce)
    const combinedContext = chunkSummaries.join('\n\n---\n\n');

    // Level 3: Final synthesis
    return this.synthesize(combinedContext, request);
  }

  /**
   * Direct summarization for smaller document sets
   * OPTIMIZED: Uses token budget and importance-based selection
   */
  private async directSummarize(
    chunks: DocumentChunk[],
    request: SummaryRequest
  ): Promise<string> {
    // Sort by importance (critical first)
    const sortedChunks = [...chunks].sort((a, b) => {
      const order = { critical: 0, high: 1, medium: 2, low: 3 };
      return order[a.metadata.importance] - order[b.metadata.importance];
    });

    // Build context within token budget
    let tokenBudget = RAG_CONFIG.maxContextWindow;
    const selectedChunks: DocumentChunk[] = [];

    for (const chunk of sortedChunks) {
      const chunkTokens = chunk.tokenCount || this.estimateTokens(chunk.content);
      if (tokenBudget - chunkTokens >= 0) {
        selectedChunks.push(chunk);
        tokenBudget -= chunkTokens;
      }
      if (selectedChunks.length >= RAG_CONFIG.maxChunksPerLevel) break;
    }

    const context = selectedChunks
      .map(c => `[${c.metadata.source} - ${c.metadata.section || 'General'}]\n${c.content}`)
      .join('\n\n---\n\n');

    return this.synthesize(context, request);
  }

  /**
   * Summarize individual chunk
   * OPTIMIZED: Uses cheaper model for map phase, with caching
   */
  private async summarizeChunk(
    chunk: DocumentChunk,
    summaryType: SummaryType,
    costOptimized: boolean = true
  ): Promise<string> {
    // Check cache first
    const cacheKey = `${chunk.id}-${summaryType}`;
    const cached = this.summaryCache.get(cacheKey);
    if (cached) return cached;

    const prompt = this.buildChunkPrompt(chunk, summaryType);

    // Use cheaper model for individual chunk summaries
    const model = costOptimized ? RAG_CONFIG.mapModel : RAG_CONFIG.reduceModel;
    const maxTokens = RAG_CONFIG.mapTokenBudget;

    try {
      const generateChat = httpsCallable(functions, 'generateChatResponse');
      const result = await generateChat({
        messages: [
          { role: 'system', content: prompt.system },
          { role: 'user', content: prompt.user }
        ],
        model,
        maxTokens,
        temperature: 0.2 // Lower temperature for more consistent summaries
      }) as { data: { success: boolean; content?: string; usage?: { total_tokens: number } } };

      // Track usage
      this.totalModelCalls++;
      if (result.data.usage) {
        this.totalTokensUsed += result.data.usage.total_tokens;
      }

      const summary = result.data.content || chunk.content.substring(0, 200);
      this.summaryCache.set(cacheKey, summary);
      return summary;
    } catch (error) {
      logger.warn(LOG_CATEGORIES.AI, 'Chunk summarization failed, using excerpt', {
        error,
        chunkId: chunk.id
      });
      // Return a compressed excerpt as fallback
      return this.compressText(chunk.content, 300);
    }
  }

  /**
   * Compress text to target length while preserving key information
   */
  private compressText(text: string, maxLength: number): string {
    if (text.length <= maxLength) return text;

    // Try to find a sentence boundary
    const truncated = text.substring(0, maxLength);
    const lastSentence = truncated.lastIndexOf('.');

    if (lastSentence > maxLength * 0.7) {
      return truncated.substring(0, lastSentence + 1);
    }

    return truncated + '...';
  }

  /**
   * Final synthesis of summaries
   * OPTIMIZED: Uses higher quality model for final synthesis
   */
  private async synthesize(context: string, request: SummaryRequest): Promise<string> {
    const prompt = this.buildSynthesisPrompt(context, request);

    // Use higher quality model for final synthesis
    const model = RAG_CONFIG.reduceModel;
    const maxTokens = RAG_CONFIG.reduceTokenBudget;

    try {
      const generateChat = httpsCallable(functions, 'generateChatResponse');
      const result = await generateChat({
        messages: [
          { role: 'system', content: prompt.system },
          { role: 'user', content: prompt.user }
        ],
        model,
        maxTokens: Math.min(maxTokens, this.getTargetTokens(request.targetLength)),
        temperature: 0.3
      }) as { data: { success: boolean; content?: string; usage?: { total_tokens: number } } };

      // Track usage
      this.totalModelCalls++;
      if (result.data.usage) {
        this.totalTokensUsed += result.data.usage.total_tokens;
      }

      if (!result.data.success || !result.data.content) {
        throw new Error('Synthesis failed');
      }

      return result.data.content;
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Synthesis failed', { error });
      throw error;
    }
  }

  /**
   * Build prompt for chunk summarization
   * OPTIMIZED: Insurance-specific prompts with section awareness
   */
  private buildChunkPrompt(chunk: DocumentChunk, type: SummaryType): { system: string; user: string } {
    const sectionGuidance = this.getSectionGuidance(chunk.metadata.section as InsuranceSection);

    return {
      system: `You are a P&C insurance document analyst. Extract key information from this ${chunk.metadata.sourceType} content.
${sectionGuidance}
Focus on: ${this.getFocusAreas(type)}
Be concise. Use bullet points. Include specific values (limits, deductibles, dates).`,
      user: `[${chunk.metadata.source}] ${chunk.metadata.section || 'General'}\n\n${chunk.content}`
    };
  }

  /**
   * Get section-specific guidance for better extraction
   */
  private getSectionGuidance(section?: InsuranceSection): string {
    const guidance: Record<InsuranceSection, string> = {
      declarations: 'Extract: Named insured, policy period, limits, premiums, covered locations.',
      insuring_agreement: 'Extract: What is covered, coverage triggers, insuring clause scope.',
      definitions: 'Extract: Key defined terms and their meanings relevant to coverage.',
      exclusions: 'Extract: What is NOT covered, exclusion conditions, exceptions to exclusions.',
      conditions: 'Extract: Policyholder duties, claim procedures, cancellation terms.',
      limits: 'Extract: Per occurrence limits, aggregate limits, sublimits, shared limits.',
      deductibles: 'Extract: Deductible amounts, application (per claim/occurrence), waiting periods.',
      endorsements: 'Extract: Coverage modifications, additional insureds, special conditions.',
      schedule: 'Extract: Scheduled items, values, locations, classifications.',
      general: 'Extract: Key coverage terms, conditions, and notable provisions.'
    };
    return guidance[section || 'general'];
  }

  /**
   * Build prompt for final synthesis
   * OPTIMIZED: More structured output for insurance context
   */
  private buildSynthesisPrompt(context: string, request: SummaryRequest): { system: string; user: string } {
    const typeInstructions: Record<SummaryType, string> = {
      executive: `Create an executive summary for insurance leadership:
- Product overview and market positioning
- Key coverage highlights and competitive advantages
- Premium/pricing summary
- Risk considerations and recommendations`,
      technical: `Provide a detailed technical analysis:
- Coverage grants and insuring agreements
- Limits structure (per occurrence, aggregate, sublimits)
- Deductible structure and application
- Key exclusions and conditions
- Endorsement modifications`,
      comparative: `Compare and contrast the insurance products:
- Coverage scope differences
- Limit and deductible comparisons
- Pricing differentials
- Unique features of each product`,
      compliance: `Focus on regulatory and compliance aspects:
- State filing requirements
- Regulatory compliance status
- Required endorsements by jurisdiction
- Potential compliance gaps`,
      actionable: `Extract action items for the insurance team:
- Required form updates
- Pricing adjustments needed
- Compliance deadlines
- Product enhancement opportunities`,
      comprehensive: `Provide a complete product analysis:
- Coverage summary
- Limits and deductibles
- Key exclusions
- Pricing overview
- Compliance status
- Recommendations`
    };

    return {
      system: `You are a senior P&C insurance analyst creating a ${request.summaryType} summary.
${typeInstructions[request.summaryType]}

OUTPUT FORMAT:
- Use clear section headings
- Include specific dollar amounts and percentages
- Reference source documents when citing specifics
- Highlight critical items with [CRITICAL] or [IMPORTANT] tags
${request.focusAreas?.length ? `\nPRIORITY FOCUS: ${request.focusAreas.join(', ')}` : ''}`,
      user: `Analyze and synthesize these insurance document excerpts:\n\n${context}`
    };
  }


  /**
   * Get focus areas based on summary type
   */
  private getFocusAreas(type: SummaryType): string {
    const areas: Record<SummaryType, string> = {
      executive: 'business impact, costs, risks, opportunities',
      technical: 'coverage terms, limits, conditions, exclusions',
      comparative: 'similarities, differences, strengths, weaknesses',
      compliance: 'regulations, requirements, deadlines, filings',
      actionable: 'action items, decisions, recommendations',
      comprehensive: 'all aspects including coverage, pricing, compliance'
    };
    return areas[type];
  }

  /**
   * Get target token count based on length preference
   */
  private getTargetTokens(length?: 'brief' | 'standard' | 'detailed'): number {
    const lengths = { brief: 500, standard: 1000, detailed: 2000 };
    return lengths[length || 'standard'];
  }

  /**
   * Extract key points from summary
   */
  private async extractKeyPoints(
    summary: string,
    type: SummaryType
  ): Promise<KeyPoint[]> {
    const keyPoints: KeyPoint[] = [];

    // Pattern-based extraction for reliability
    const patterns = [
      { regex: /(?:critical|urgent|important):\s*([^.]+)/gi, importance: 'critical' as const },
      { regex: /(?:key\s+point|highlight|note):\s*([^.]+)/gi, importance: 'high' as const },
      { regex: /â€¢\s*([^â€¢\n]+)/g, importance: 'medium' as const },
      { regex: /\d+\.\s+([^.\n]+)/g, importance: 'medium' as const },
    ];

    patterns.forEach(({ regex, importance }) => {
      let match;
      while ((match = regex.exec(summary)) !== null) {
        keyPoints.push({
          text: match[1].trim(),
          importance,
          category: this.categorizeKeyPoint(match[1], type)
        });
      }
    });

    // Deduplicate and limit
    const seen = new Set<string>();
    return keyPoints
      .filter(kp => {
        const key = kp.text.toLowerCase().substring(0, 50);
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      })
      .slice(0, 10);
  }

  /**
   * Categorize key point
   */
  private categorizeKeyPoint(text: string, type: SummaryType): string {
    if (/coverage|limit|deductible/i.test(text)) return 'Coverage';
    if (/premium|rate|pricing/i.test(text)) return 'Pricing';
    if (/compliance|regulation|filing/i.test(text)) return 'Compliance';
    if (/risk|exposure/i.test(text)) return 'Risk';
    if (/action|recommend/i.test(text)) return 'Action Item';
    return 'General';
  }

  /**
   * Generate source citations
   */
  private generateCitations(chunks: DocumentChunk[], summary: string): SourceCitation[] {
    const citations: SourceCitation[] = [];

    // Find chunks that contributed to the summary
    chunks.forEach(chunk => {
      const excerpt = chunk.content.substring(0, 150);
      const relevance = this.calculateChunkRelevance(chunk, summary);

      if (relevance > 0.3) {
        citations.push({
          id: chunk.id,
          documentTitle: chunk.metadata.source,
          section: chunk.metadata.section,
          excerpt: excerpt + '...',
          relevance
        });
      }
    });

    return citations
      .sort((a, b) => b.relevance - a.relevance)
      .slice(0, 5);
  }

  /**
   * Calculate chunk relevance to summary
   */
  private calculateChunkRelevance(chunk: DocumentChunk, summary: string): number {
    const chunkWords = new Set(chunk.content.toLowerCase().split(/\s+/));
    const summaryWords = summary.toLowerCase().split(/\s+/);

    let matches = 0;
    summaryWords.forEach(word => {
      if (word.length > 4 && chunkWords.has(word)) matches++;
    });

    return Math.min(1, matches / 20);
  }

  /**
   * Calculate overall confidence score
   * OPTIMIZED: Accounts for critical importance level
   */
  private calculateConfidence(chunks: DocumentChunk[], request: SummaryRequest): number {
    const criticalChunks = chunks.filter(c => c.metadata.importance === 'critical').length;
    const highChunks = chunks.filter(c => c.metadata.importance === 'high').length;

    const factors = {
      chunkQuality: (criticalChunks * 1.5 + highChunks) / chunks.length,
      documentCoverage: Math.min(1, request.documents.length / 5),
      contentDensity: chunks.length > 3 ? 1 : chunks.length / 3,
      sectionCoverage: this.calculateSectionCoverage(chunks)
    };

    return Math.round(
      (factors.chunkQuality * 0.3 +
       factors.documentCoverage * 0.2 +
       factors.contentDensity * 0.2 +
       factors.sectionCoverage * 0.3) * 100
    ) / 100;
  }

  /**
   * Calculate how many insurance sections are covered
   */
  private calculateSectionCoverage(chunks: DocumentChunk[]): number {
    const importantSections: InsuranceSection[] = [
      'insuring_agreement', 'exclusions', 'conditions', 'limits', 'deductibles'
    ];
    const coveredSections = new Set(
      chunks.map(c => c.metadata.section).filter(Boolean)
    );

    const covered = importantSections.filter(s => coveredSections.has(s)).length;
    return covered / importantSections.length;
  }

  /**
   * Estimate token count (improved accuracy)
   */
  private estimateTokens(text: string): number {
    // More accurate estimation: ~4 chars per token for English
    return Math.ceil(text.length / 4);
  }

  /**
   * Calculate compression ratio
   */
  private calculateCompressionRatio(docs: DocumentSource[], summary: string): number {
    const originalLength = docs.reduce((sum, d) => sum + d.content.length, 0);
    if (originalLength === 0) return 0;
    return Math.round((1 - summary.length / originalLength) * 100) / 100;
  }

  /**
   * Clear all caches (useful for testing or memory management)
   */
  clearCaches(): void {
    this.chunkCache.clear();
    this.summaryCache.clear();
    this.totalTokensUsed = 0;
    this.totalModelCalls = 0;
    logger.info(LOG_CATEGORIES.AI, 'RAG service caches cleared');
  }

  /**
   * Get current cache statistics
   */
  getCacheStats(): { chunkCacheSize: number; summaryCacheSize: number; totalTokensUsed: number; totalModelCalls: number } {
    return {
      chunkCacheSize: 0, // LRU cache doesn't expose size directly
      summaryCacheSize: 0,
      totalTokensUsed: this.totalTokensUsed,
      totalModelCalls: this.totalModelCalls
    };
  }
}

// Export singleton instance
export const advancedRAGService = new AdvancedRAGService();
export default advancedRAGService;
```

---

## src/services/aiPromptOptimizer.ts

**Path:** `src/services/aiPromptOptimizer.ts`

```typescript
/**
 * AI Prompt Optimizer Service
 *
 * OPTIMIZED VERSION - Enhanced for P&C Insurance:
 * - Intelligent model selection based on query complexity
 * - Token budget management with dynamic allocation
 * - Prompt compression for cost efficiency
 * - Insurance-specific query classification
 * - Response quality optimization
 */

import logger, { LOG_CATEGORIES } from '../utils/logger';

export type QueryType =
  | 'product_analysis'
  | 'coverage_analysis'
  | 'pricing_analysis'
  | 'compliance_check'
  | 'task_management'
  | 'strategic_insight'
  | 'data_query'
  | 'claims_analysis'
  | 'form_analysis'
  | 'general';

// Model selection configuration
export type ModelTier = 'fast' | 'balanced' | 'quality';

export interface ModelConfig {
  model: string;
  maxTokens: number;
  temperature: number;
  costPer1kInput: number;
  costPer1kOutput: number;
}

const MODEL_CONFIGS: Record<ModelTier, ModelConfig> = {
  fast: {
    model: 'gpt-4o-mini',
    maxTokens: 1000,
    temperature: 0.3,
    costPer1kInput: 0.00015,
    costPer1kOutput: 0.0006
  },
  balanced: {
    model: 'gpt-4o-mini',
    maxTokens: 2000,
    temperature: 0.4,
    costPer1kInput: 0.00015,
    costPer1kOutput: 0.0006
  },
  quality: {
    model: 'gpt-4o-mini',  // All tiers use gpt-4o-mini for cost efficiency
    maxTokens: 4000,
    temperature: 0.5,
    costPer1kInput: 0.00015,
    costPer1kOutput: 0.0006
  }
};

// Query complexity indicators
interface QueryComplexity {
  tier: ModelTier;
  reasoning: string;
  estimatedResponseTokens: number;
}

interface ContextSummary {
  statistics: Record<string, any>;
  sampleData: Record<string, any>;
  fullData?: Record<string, any>;
  timestamp: number | string;
}

interface OptimizedPrompt {
  system: string;
  context: string;
  instructions: string;
  estimatedTokens: number;
  queryType: QueryType;
  modelConfig: ModelConfig;
  complexity: QueryComplexity;
}

// Token budget configuration
const TOKEN_BUDGETS = {
  system: 800,
  context: {
    fast: 4000,
    balanced: 8000,
    quality: 16000
  },
  instructions: 500,
  response: {
    fast: 1000,
    balanced: 2000,
    quality: 4000
  }
};

class AIPromptOptimizer {
  private readonly MAX_CONTEXT_TOKENS = 16000;
  private readonly MAX_INSTRUCTIONS_TOKENS = 1500;
  private readonly TOKENS_PER_CHAR = 0.25; // More accurate: ~4 chars per token

  /**
   * Classify query into specific type for optimized handling
   * ENHANCED: Added claims and form analysis types
   */
  classifyQuery(query: string): QueryType {
    const lowerQuery = query.toLowerCase();

    // Claims analysis queries (new)
    if (lowerQuery.match(/claim|loss|incident|occurrence|damage|injury|liability/i)) {
      return 'claims_analysis';
    }

    // Form analysis queries (new)
    if (lowerQuery.match(/form|endorsement|policy\s+form|iso\s+form|manuscript/i)) {
      return 'form_analysis';
    }

    // Product analysis queries
    if (lowerQuery.match(/product|portfolio|offering|line|compare|which product/i)) {
      return 'product_analysis';
    }

    // Coverage analysis queries
    if (lowerQuery.match(/coverage|benefit|limit|deductible|exclusion|covered|protection/i)) {
      return 'coverage_analysis';
    }

    // Pricing analysis queries
    if (lowerQuery.match(/price|rate|cost|premium|pricing|fee|charge|profitable/i)) {
      return 'pricing_analysis';
    }

    // Compliance queries
    if (lowerQuery.match(/compliance|regulation|requirement|filing|approval|state|legal|rule/i)) {
      return 'compliance_check';
    }

    // Task management queries
    if (lowerQuery.match(/task|project|deadline|milestone|progress|team|status/i)) {
      return 'task_management';
    }

    // Strategic queries
    if (lowerQuery.match(/strateg(y|ic)|opportunit(y|ies)|recommend|suggest|improve|optimize/i)) {
      return 'strategic_insight';
    }

    // Data queries
    if (lowerQuery.match(/how many|count|list|show|what are|which|total|number/i)) {
      return 'data_query';
    }

    return 'general';
  }

  /**
   * Analyze query complexity to determine optimal model tier
   * OPTIMIZED: Intelligent model selection based on query characteristics
   */
  analyzeComplexity(query: string, queryType: QueryType): QueryComplexity {
    const lowerQuery = query.toLowerCase();
    const wordCount = query.split(/\s+/).length;

    // Complexity indicators
    const complexityFactors = {
      // High complexity indicators
      isComparative: /compare|versus|vs|difference|better|worse/i.test(lowerQuery),
      isStrategic: queryType === 'strategic_insight',
      isMultiPart: /and|also|additionally|furthermore/i.test(lowerQuery),
      requiresAnalysis: /analyze|evaluate|assess|review|examine/i.test(lowerQuery),
      isLongQuery: wordCount > 30,

      // Medium complexity indicators
      requiresExplanation: /explain|why|how|describe/i.test(lowerQuery),
      requiresList: /list|show|what are|which/i.test(lowerQuery),

      // Low complexity indicators
      isSimpleCount: /how many|count|total|number of/i.test(lowerQuery),
      isLookup: /what is|find|get|show me/i.test(lowerQuery) && wordCount < 10
    };

    // Calculate complexity score
    let score = 0;
    if (complexityFactors.isComparative) score += 3;
    if (complexityFactors.isStrategic) score += 3;
    if (complexityFactors.isMultiPart) score += 2;
    if (complexityFactors.requiresAnalysis) score += 2;
    if (complexityFactors.isLongQuery) score += 1;
    if (complexityFactors.requiresExplanation) score += 1;
    if (complexityFactors.requiresList) score += 1;
    if (complexityFactors.isSimpleCount) score -= 2;
    if (complexityFactors.isLookup) score -= 2;

    // Determine tier based on score
    let tier: ModelTier;
    let reasoning: string;
    let estimatedResponseTokens: number;

    if (score >= 5) {
      tier = 'quality';
      reasoning = 'Complex query requiring deep analysis or comparison';
      estimatedResponseTokens = 2000;
    } else if (score >= 2) {
      tier = 'balanced';
      reasoning = 'Moderate complexity query with explanation needs';
      estimatedResponseTokens = 1000;
    } else {
      tier = 'fast';
      reasoning = 'Simple lookup or count query';
      estimatedResponseTokens = 500;
    }

    logger.debug(LOG_CATEGORIES.AI, 'Query complexity analyzed', {
      queryType,
      score,
      tier,
      factors: complexityFactors
    });

    return { tier, reasoning, estimatedResponseTokens };
  }

  /**
   * Get model configuration for a given tier
   */
  getModelConfig(tier: ModelTier): ModelConfig {
    return MODEL_CONFIGS[tier];
  }

  /**
   * Build comprehensive context with full data
   * OPTIMIZED: Token-aware compression with priority-based inclusion
   */
  compressContext(contextSummary: ContextSummary, tokenBudget?: number): string {
    const { statistics, fullData } = contextSummary;
    const budget = tokenBudget || TOKEN_BUDGETS.context.balanced;

    if (!fullData) {
      return `Statistics: Products: ${statistics.products?.total || 0}, Coverages: ${statistics.coverages?.total || 0}, Forms: ${statistics.forms?.total || 0}, Tasks: ${statistics.tasks?.total || 0}`;
    }

    const contextParts: string[] = [];
    let currentTokens = 0;

    // Helper to add section if within budget
    const addSection = (title: string, items: any[], formatter: (item: any, i: number) => string): boolean => {
      if (!items?.length) return true;

      const sectionHeader = `\n=== ${title} ===`;
      const formattedItems = items.map((item, i) => formatter(item, i));
      const sectionContent = [sectionHeader, ...formattedItems].join('\n');
      const sectionTokens = this.estimateTokens(sectionContent);

      if (currentTokens + sectionTokens <= budget) {
        contextParts.push(sectionContent);
        currentTokens += sectionTokens;
        return true;
      }

      // Try to include partial section
      const partialItems: string[] = [sectionHeader];
      let partialTokens = this.estimateTokens(sectionHeader);

      for (const item of formattedItems) {
        const itemTokens = this.estimateTokens(item);
        if (currentTokens + partialTokens + itemTokens <= budget) {
          partialItems.push(item);
          partialTokens += itemTokens;
        } else {
          break;
        }
      }

      if (partialItems.length > 1) {
        partialItems.push(`... and ${items.length - partialItems.length + 1} more`);
        contextParts.push(partialItems.join('\n'));
        currentTokens += partialTokens;
      }

      return false;
    };

    // Priority order: Products > Coverages > Forms > Rules > Tasks > Pricing > Data Dictionary
    addSection('PRODUCTS', fullData.products, (p, i) => {
      let line = `${i + 1}. ${p.name || 'Unnamed'} (${p.productCode || 'N/A'})`;
      if (p.availableStates?.length) line += ` [${p.availableStates.slice(0, 5).join(', ')}${p.availableStates.length > 5 ? '...' : ''}]`;
      return line;
    });

    addSection('COVERAGES', fullData.coverages, (c, i) => {
      const name = c.coverageName || c.name || 'Unnamed';
      const code = c.coverageCode || c.code || 'N/A';
      let line = `${i + 1}. ${name} (${code})`;
      if (c.category) line += ` [${c.category}]`;
      return line;
    });

    addSection('FORMS', fullData.forms, (f, i) => {
      const name = f.formName || f.name || 'Unnamed';
      const number = f.formNumber || 'N/A';
      return `${i + 1}. ${name} (${number})`;
    });

    addSection('RULES', fullData.rules, (r, i) => {
      const name = r.ruleName || r.name || 'Unnamed';
      return `${i + 1}. ${name}${r.category ? ` [${r.category}]` : ''}`;
    });

    addSection('TASKS', fullData.tasks, (t, i) => {
      return `${i + 1}. ${t.title || 'Unnamed'} [${t.status || 'unknown'}]${t.priority ? ` P:${t.priority}` : ''}`;
    });

    addSection('PRICING', fullData.pricingSteps, (p, i) => {
      return `${i + 1}. ${p.stepName || p.name || 'Step'} (${p.stepType || 'N/A'})`;
    });

    // Summary always included
    contextParts.push(`\n=== TOTALS ===`);
    contextParts.push(`Products: ${fullData.products?.length || 0} | Coverages: ${fullData.coverages?.length || 0} | Forms: ${fullData.forms?.length || 0} | Rules: ${fullData.rules?.length || 0} | Tasks: ${fullData.tasks?.length || 0}`);

    return contextParts.join('\n');
  }

  /**
   * Compress text by removing redundant whitespace and shortening
   */
  compressText(text: string, maxLength?: number): string {
    // Remove extra whitespace
    let compressed = text.replace(/\s+/g, ' ').trim();

    // Remove common filler words if needed
    if (maxLength && compressed.length > maxLength) {
      compressed = compressed
        .replace(/\b(the|a|an|is|are|was|were|be|been|being)\b/gi, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    // Truncate if still too long
    if (maxLength && compressed.length > maxLength) {
      compressed = compressed.substring(0, maxLength - 3) + '...';
    }

    return compressed;
  }

  /**
   * Estimate tokens for a string (improved accuracy)
   */
  estimateTokens(text: string): number {
    // More accurate: ~4 characters per token for English
    return Math.ceil(text.length * this.TOKENS_PER_CHAR);
  }

  /**
   * Calculate estimated cost for a prompt
   */
  estimateCost(inputTokens: number, outputTokens: number, tier: ModelTier): number {
    const config = MODEL_CONFIGS[tier];
    return (inputTokens / 1000 * config.costPer1kInput) + (outputTokens / 1000 * config.costPer1kOutput);
  }

  /**
   * Build optimized system prompt with professional formatting instructions
   * OPTIMIZED: Compressed prompts, added new query types
   */
  buildSystemPrompt(queryType: QueryType, tier: ModelTier = 'balanced'): string {
    // Shorter base prompt for cost efficiency
    const basePrompt = `You are a P&C insurance product management AI assistant.

FORMAT: Use markdown (bold, bullets, tables). Be concise. Start with direct answer.
DATA: Reference the system data below. Use exact names/codes. Never say "I don't have access."`;

    const typeSpecificPrompts: Record<QueryType, string> = {
      product_analysis: `${basePrompt}
FOCUS: Products - list with codes, compare in tables, show state coverage.`,

      coverage_analysis: `${basePrompt}
FOCUS: Coverages - names/codes, group related, include limits/deductibles.`,

      pricing_analysis: `${basePrompt}
FOCUS: Pricing - explain steps, compare rates in tables, highlight factors.`,

      compliance_check: `${basePrompt}
FOCUS: Compliance - list rules/requirements, explain implications.`,

      task_management: `${basePrompt}
FOCUS: Tasks - organize by status/priority, show due dates. Use âœ“/â³ indicators.`,

      strategic_insight: `${basePrompt}
FOCUS: Strategy - synthesize patterns, provide recommendations with data support.`,

      data_query: `${basePrompt}
FOCUS: Data - precise counts/names, format lists/tables for scanning.`,

      claims_analysis: `${basePrompt}
FOCUS: Claims - analyze coverage applicability, identify exclusions, assess liability.`,

      form_analysis: `${basePrompt}
FOCUS: Forms - explain form purpose, coverage modifications, endorsement effects.`,

      general: `${basePrompt}
FOCUS: General - answer helpfully, reference relevant data.`
    };

    return typeSpecificPrompts[queryType];
  }

  /**
   * Build optimized context string with token budget awareness
   */
  buildOptimizedContext(contextSummary: ContextSummary, queryType: QueryType, tier: ModelTier = 'balanced'): string {
    const tokenBudget = TOKEN_BUDGETS.context[tier];
    const compressed = this.compressContext(contextSummary, tokenBudget);
    const tokens = this.estimateTokens(compressed);

    if (tokens > this.MAX_CONTEXT_TOKENS) {
      logger.warn(LOG_CATEGORIES.AI, 'Context exceeds token limit, truncating', {
        tokens,
        limit: this.MAX_CONTEXT_TOKENS,
        queryType
      });
    }

    // Simplified header for token efficiency
    return `=== SYSTEM DATA ===
${compressed}
=== END DATA ===`;
  }

  /**
   * Build query-specific instructions with formatting guidance
   * OPTIMIZED: Shorter instructions for token efficiency
   */
  buildInstructions(queryType: QueryType, query: string, tier: ModelTier = 'balanced'): string {
    // Shorter instructions for fast tier
    if (tier === 'fast') {
      return `Q: "${query}"
Answer directly using the data above. Use markdown formatting.`;
    }

    return `QUESTION: "${query}"

GUIDELINES:
- Direct answer first, then details
- Use data above (exact names/codes)
- Format: bullets, **bold**, tables
- Be concise but complete`;
  }

  /**
   * Build complete optimized prompt with intelligent model selection
   * OPTIMIZED: Includes complexity analysis and cost estimation
   */
  buildOptimizedPrompt(
    query: string,
    contextSummary: ContextSummary,
    forceTier?: ModelTier
  ): OptimizedPrompt {
    const queryType = this.classifyQuery(query);
    const complexity = this.analyzeComplexity(query, queryType);
    const tier = forceTier || complexity.tier;
    const modelConfig = this.getModelConfig(tier);

    const systemPrompt = this.buildSystemPrompt(queryType, tier);
    const context = this.buildOptimizedContext(contextSummary, queryType, tier);
    const instructions = this.buildInstructions(queryType, query, tier);

    const estimatedInputTokens =
      this.estimateTokens(systemPrompt) +
      this.estimateTokens(context) +
      this.estimateTokens(instructions);

    const estimatedCost = this.estimateCost(
      estimatedInputTokens,
      complexity.estimatedResponseTokens,
      tier
    );

    logger.debug(LOG_CATEGORIES.AI, 'Optimized prompt built', {
      queryType,
      tier,
      estimatedInputTokens,
      estimatedResponseTokens: complexity.estimatedResponseTokens,
      estimatedCost: `$${estimatedCost.toFixed(6)}`,
      model: modelConfig.model
    });

    return {
      system: systemPrompt,
      context,
      instructions,
      estimatedTokens: estimatedInputTokens,
      queryType,
      modelConfig,
      complexity
    };
  }

  /**
   * Format prompt for API call
   */
  formatForAPI(optimizedPrompt: OptimizedPrompt): string {
    return `${optimizedPrompt.system}

${optimizedPrompt.context}

${optimizedPrompt.instructions}`;
  }

  /**
   * Get recommended model configuration for a query
   */
  getRecommendedModel(query: string): ModelConfig {
    const queryType = this.classifyQuery(query);
    const complexity = this.analyzeComplexity(query, queryType);
    return this.getModelConfig(complexity.tier);
  }
}

export const aiPromptOptimizer = new AIPromptOptimizer();
export default aiPromptOptimizer;

// Export types and configs for external use
export { MODEL_CONFIGS, TOKEN_BUDGETS };

```

---

## src/services/auditService.ts

**Path:** `src/services/auditService.ts`

```typescript
/**
 * Audit Service
 * Tracks all changes to insurance products for regulatory compliance
 */

import { collection, addDoc, serverTimestamp, query, where, orderBy, limit, getDocs, FieldValue } from 'firebase/firestore';
import { db, auth } from '../firebase';
import logger, { LOG_CATEGORIES } from '../utils/logger';

export type AuditAction =
  | 'CREATE'
  | 'UPDATE'
  | 'DELETE'
  | 'APPROVE'
  | 'REJECT'
  | 'PUBLISH'
  | 'ARCHIVE';

export type AuditEntity =
  | 'PRODUCT'
  | 'COVERAGE'
  | 'FORM'
  | 'PRICING_STEP'
  | 'RULE'
  | 'TASK';

export interface AuditChange {
  field: string;
  oldValue: unknown;
  newValue: unknown;
}

export interface AuditLogEntry {
  // Who
  userId: string;
  userEmail: string;
  userName?: string;

  // What
  action: AuditAction;
  entityType: AuditEntity;
  entityId: string;
  entityName?: string;

  // Details
  changes?: AuditChange[];

  // Context
  productId?: string;
  reason?: string;
  metadata?: Record<string, unknown>;

  // When
  timestamp: FieldValue;

  // Compliance
  ipAddress?: string;
  userAgent?: string;
}

interface LogAuditEventOptions {
  entityName?: string;
  changes?: AuditChange[];
  productId?: string;
  reason?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Log an audit event
 */
export async function logAuditEvent(
  action: AuditAction,
  entityType: AuditEntity,
  entityId: string,
  options: LogAuditEventOptions = {}
): Promise<void> {
  try {
    const user = auth.currentUser;
    if (!user) {
      logger.warn(LOG_CATEGORIES.SECURITY, 'Audit log attempted without authenticated user');
      return;
    }

    const auditEntry: Omit<AuditLogEntry, 'timestamp'> & { timestamp: FieldValue } = {
      userId: user.uid,
      userEmail: user.email || 'unknown',
      userName: user.displayName || undefined,
      action,
      entityType,
      entityId,
      entityName: options.entityName,
      changes: options.changes,
      productId: options.productId,
      reason: options.reason,
      metadata: options.metadata,
      timestamp: serverTimestamp(),
      userAgent: navigator.userAgent,
    };

    await addDoc(collection(db, 'auditLogs'), auditEntry);

    logger.info(LOG_CATEGORIES.SECURITY, `Audit logged: ${action} ${entityType}`, {
      entityId,
      userId: user.uid,
    });
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to log audit event', { action, entityType, entityId }, error as Error);
  }
}

/**
 * Get audit history for an entity
 */
export async function getAuditHistory(
  entityType: AuditEntity,
  entityId: string,
  maxResults: number = 50
): Promise<AuditLogEntry[]> {
  try {
    const q = query(
      collection(db, 'auditLogs'),
      where('entityType', '==', entityType),
      where('entityId', '==', entityId),
      orderBy('timestamp', 'desc'),
      limit(maxResults)
    );

    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as AuditLogEntry[];
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to fetch audit history', { entityType, entityId }, error as Error);
    return [];
  }
}

/**
 * Get recent audit activity for a product
 */
export async function getProductAuditActivity(
  productId: string,
  maxResults: number = 100
): Promise<AuditLogEntry[]> {
  try {
    const q = query(
      collection(db, 'auditLogs'),
      where('productId', '==', productId),
      orderBy('timestamp', 'desc'),
      limit(maxResults)
    );

    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as AuditLogEntry[];
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to fetch product audit activity', { productId }, error as Error);
    return [];
  }
}

/**
 * Get user activity
 */
export async function getUserActivity(
  userId: string,
  maxResults: number = 100
): Promise<AuditLogEntry[]> {
  try {
    const q = query(
      collection(db, 'auditLogs'),
      where('userId', '==', userId),
      orderBy('timestamp', 'desc'),
      limit(maxResults)
    );

    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as AuditLogEntry[];
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to fetch user activity', { userId }, error as Error);
    return [];
  }
}

/**
 * Helper to detect changes between old and new objects
 */
export function detectChanges(
  oldData: Record<string, any>,
  newData: Record<string, any>,
  fieldsToTrack?: string[]
): { field: string; oldValue: any; newValue: any }[] {
  const changes: { field: string; oldValue: any; newValue: any }[] = [];
  
  const fields = fieldsToTrack || Object.keys({ ...oldData, ...newData });
  
  for (const field of fields) {
    const oldValue = oldData[field];
    const newValue = newData[field];
    
    // Skip if values are the same
    if (JSON.stringify(oldValue) === JSON.stringify(newValue)) {
      continue;
    }
    
    // Skip internal fields
    if (field.startsWith('_') || field === 'updatedAt' || field === 'createdAt') {
      continue;
    }
    
    changes.push({
      field,
      oldValue,
      newValue
    });
  }
  
  return changes;
}

/**
 * Format audit entry for display
 */
export function formatAuditEntry(entry: AuditLogEntry): string {
  const timestamp = entry.timestamp?.toDate?.() || new Date();
  const date = timestamp.toLocaleDateString();
  const time = timestamp.toLocaleTimeString();
  
  let message = `${date} ${time} - ${entry.userName || entry.userEmail} ${entry.action.toLowerCase()}d ${entry.entityType.toLowerCase()}`;
  
  if (entry.entityName) {
    message += ` "${entry.entityName}"`;
  }
  
  if (entry.changes && entry.changes.length > 0) {
    message += ` (${entry.changes.length} field${entry.changes.length > 1 ? 's' : ''} changed)`;
  }
  
  if (entry.reason) {
    message += ` - Reason: ${entry.reason}`;
  }
  
  return message;
}

```

---

## src/services/cacheService.ts

**Path:** `src/services/cacheService.ts`

```typescript
/**
 * Cache Service
 * Provides in-memory caching with TTL, size limits, and performance metrics
 */

import logger, { LOG_CATEGORIES } from '@utils/logger';
import { CACHE } from '../config/constants';

/**
 * Cache entry with metadata
 */
interface CacheEntry<T> {
  value: T;
  timestamp: number;
  ttl: number;
  hits: number;
  size: number;
}

/**
 * Cache statistics
 */
export interface CacheStats {
  size: number;
  entries: number;
  hits: number;
  misses: number;
  hitRate: number;
  avgEntrySize: number;
}

/**
 * Generic cache service with TTL and size management
 */
export class CacheService<T = any> {
  private cache: Map<string, CacheEntry<T>> = new Map();
  private maxSize: number;
  private defaultTTL: number;
  private hits: number = 0;
  private misses: number = 0;
  private cleanupInterval: NodeJS.Timeout | null = null;

  constructor(maxSize: number = CACHE.MAX_CACHE_SIZE, defaultTTL: number = CACHE.TTL_PRODUCTS) {
    this.maxSize = maxSize;
    this.defaultTTL = defaultTTL;
    this.startCleanup();
  }

  /**
   * Get value from cache
   */
  get(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) {
      this.misses++;
      return null;
    }

    // Check if expired
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      this.misses++;
      return null;
    }

    entry.hits++;
    this.hits++;
    return entry.value;
  }

  /**
   * Set value in cache
   */
  set(key: string, value: T, ttl: number = this.defaultTTL): void {
    // Estimate size (rough approximation)
    const size = JSON.stringify(value).length;

    // Check if adding this would exceed max size
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      this.evictLRU();
    }

    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      ttl,
      hits: 0,
      size
    });

    logger.debug(LOG_CATEGORIES.CACHE, 'Cache entry set', {
      key,
      ttl,
      size,
      cacheSize: this.cache.size
    });
  }

  /**
   * Delete value from cache
   */
  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  /**
   * Clear all cache
   */
  clear(): void {
    const size = this.cache.size;
    this.cache.clear();
    logger.info(LOG_CATEGORIES.CACHE, 'Cache cleared', { entriesCleared: size });
  }

  /**
   * Check if key exists and is not expired
   */
  has(key: string): boolean {
    const entry = this.cache.get(key);
    if (!entry) return false;

    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  /**
   * Get or compute value
   */
  async getOrCompute(
    key: string,
    computeFn: () => Promise<T>,
    ttl: number = this.defaultTTL
  ): Promise<T> {
    const cached = this.get(key);
    if (cached !== null) {
      logger.debug(LOG_CATEGORIES.CACHE, 'Cache hit', { key });
      return cached;
    }

    logger.debug(LOG_CATEGORIES.CACHE, 'Cache miss, computing', { key });
    const value = await computeFn();
    this.set(key, value, ttl);
    return value;
  }

  /**
   * Get cache statistics
   */
  getStats(): CacheStats {
    let totalSize = 0;
    this.cache.forEach(entry => {
      totalSize += entry.size;
    });

    const total = this.hits + this.misses;
    const hitRate = total > 0 ? (this.hits / total) * 100 : 0;

    return {
      size: totalSize,
      entries: this.cache.size,
      hits: this.hits,
      misses: this.misses,
      hitRate,
      avgEntrySize: this.cache.size > 0 ? totalSize / this.cache.size : 0
    };
  }

  /**
   * Evict least recently used entry
   */
  private evictLRU(): void {
    let lruKey: string | null = null;
    let lruTime = Date.now();

    this.cache.forEach((entry, key) => {
      if (entry.timestamp < lruTime) {
        lruTime = entry.timestamp;
        lruKey = key;
      }
    });

    if (lruKey) {
      this.cache.delete(lruKey);
      logger.debug(LOG_CATEGORIES.CACHE, 'LRU eviction', { key: lruKey });
    }
  }

  /**
   * Start periodic cleanup of expired entries
   */
  private startCleanup(): void {
    this.cleanupInterval = setInterval(() => {
      let cleaned = 0;
      const now = Date.now();

      this.cache.forEach((entry, key) => {
        if (now - entry.timestamp > entry.ttl) {
          this.cache.delete(key);
          cleaned++;
        }
      });

      if (cleaned > 0) {
        logger.debug(LOG_CATEGORIES.CACHE, 'Cleanup completed', {
          entriesRemoved: cleaned,
          remainingEntries: this.cache.size
        });
      }
    }, 60000); // Run every minute
  }

  /**
   * Stop cleanup interval
   */
  destroy(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
}

/**
 * Global cache instances for different data types
 */
export const cacheServices = {
  products: new CacheService(50, 10 * 60 * 1000)  // 10 minutes
};

```

---

## src/services/claimsAnalysisService.ts

**Path:** `src/services/claimsAnalysisService.ts`

```typescript
// src/services/claimsAnalysisService.js
import { functions } from '../firebase';
import { httpsCallable } from 'firebase/functions';
import type { FormChunk } from '../utils/pdfChunking';

const CLAIMS_ANALYSIS_SYSTEM_PROMPT = `
You are an expert P&C insurance claims analyst. Your role is to analyze claim scenarios against insurance policy forms and determine coverage.

**Your Analysis Process:**
1. **Understand the Claim**: Carefully read the claim description provided by the user
2. **Review Policy Forms**: Analyze the provided insurance form content for relevant coverages, exclusions, and conditions
3. **Determine Coverage**: Assess whether the claim is covered based on the policy language
4. **Identify Applicable Coverages**: List specific coverages that apply to this claim
5. **Note Exclusions**: Identify any exclusions that might apply
6. **Provide Reasoning**: Explain your analysis with specific references to policy language

**Response Format:**
Provide your analysis in the following structured format:

## Coverage Determination: [COVERED/NOT COVERED/PARTIALLY COVERED]

## Summary
[Brief 2-3 sentence summary of your determination]

## Applicable Coverages
[List specific coverages that apply, with form references and section numbers]

## Relevant Exclusions
[List any exclusions that might apply, with specific form references]

## Analysis Details
[Concise explanation of your reasoning, citing specific policy language and form sections]

## Recommendations
[Brief recommendations for claim handling or additional information needed]

**Important Guidelines:**
- Be concise and precise - avoid unnecessary elaboration
- Always cite specific form names, sections, and policy language when possible
- Reference the actual forms provided in your analysis (e.g., "Per Form CG0001, Section II...")
- If information is insufficient, clearly state what additional details are needed
- Consider both coverage grants and exclusions
- Pay attention to policy conditions, limits, and deductibles
- If multiple forms are provided, consider how they interact
- Be conservative in your analysis - when in doubt, note the uncertainty
- Keep responses focused and professional
`;

/**
 * Analyze a claim against selected forms using OpenAI
 * @param {string} claimDescription - Description of the claim scenario
 * @param {Array} formChunks - Array of form chunks with metadata
 * @param {Array} conversationHistory - Previous messages in the conversation
 * @returns {Promise<string>} - AI analysis response
 */
export async function analyzeClaimCoverage(claimDescription, formChunks, conversationHistory = []) {
  try {
    // Prepare context from form chunks
    const formsContext = formChunks.map(chunk => {
      return `=== FORM: ${chunk.formName} ===
Form Number: ${chunk.formNumber || 'Not specified'}
Category: ${chunk.category || 'Not specified'}
Section: Part ${chunk.chunkIndex + 1} of ${chunk.totalChunks}

FORM CONTENT:
${chunk.text}

---`;
    }).join('\n\n');

    // Create forms summary
    const uniqueForms = [...new Set(formChunks.map(chunk => chunk.formName))];
    const formsSummary = `FORMS BEING ANALYZED:
${uniqueForms.map(formName => {
  const formChunk = formChunks.find(chunk => chunk.formName === formName);
  return `- ${formName} (${formChunk.formNumber || 'No number'}) - ${formChunk.category || 'Unknown category'}`;
}).join('\n')}

TOTAL FORMS: ${uniqueForms.length}
TOTAL SECTIONS: ${formChunks.length}

`;

    // Build messages array
    const messages = [
      {
        role: 'system',
        content: CLAIMS_ANALYSIS_SYSTEM_PROMPT
      },
      {
        role: 'system',
        content: `${formsSummary}DETAILED POLICY FORMS CONTENT:\n\n${formsContext}`
      }
    ];

    // Add conversation history
    messages.push(...conversationHistory);

    // Add current claim question
    messages.push({
      role: 'user',
      content: `Please analyze the following claim scenario:\n\n${claimDescription}`
    });

    // Call Cloud Function (secure proxy to OpenAI)
    const analyzeClaim = httpsCallable(functions, 'analyzeClaim');
    const result = await Promise.race([
      analyzeClaim({
        messages: messages,
        model: 'gpt-4o-mini',
        maxTokens: 2000,
        temperature: 0.2
      }),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Claims analysis request timeout')), 60000)
      )
    ]);

    if (!result.data.success) {
      throw new Error('Failed to analyze claim');
    }

    const content = result.data.content?.trim();

    if (!content) {
      throw new Error('No analysis content received');
    }

    return content;

  } catch (error) {
    console.error('Error in claim analysis:', error);

    // Provide more specific error messages
    if (error.message.includes('timeout')) {
      throw new Error('Analysis request timed out. Please try again with fewer forms or a simpler question.');
    } else if (error.message.includes('API key')) {
      throw new Error('AI service configuration error. Please contact support.');
    } else if (error.message.includes('rate limit')) {
      throw new Error('Too many requests. Please wait a moment and try again.');
    } else {
      throw new Error(`Analysis failed: ${error.message}`);
    }
  }
}

interface ConversationMessage {
  role: string;
  content: string;
}

/**
 * Analyze claim with intelligent chunking for multiple documents
 * @param {string} claimDescription - Description of the claim scenario
 * @param {Array} formChunks - Array of form chunks
 * @param {Array} conversationHistory - Previous conversation
 * @returns {Promise<string>} - Combined analysis response
 */
export async function analyzeClaimWithChunking(
  claimDescription: string,
  formChunks: FormChunk[],
  conversationHistory: ConversationMessage[] = []
): Promise<string> {
  console.log(`Starting analysis with ${formChunks.length} form chunks`);

  // Filter out error chunks for initial processing
  const validChunks = formChunks.filter(chunk => !chunk.error);
  const errorChunks = formChunks.filter(chunk => chunk.error);

  if (validChunks.length === 0) {
    throw new Error('No valid form content available for analysis. Please check that the selected forms are accessible and contain readable text.');
  }

  // Group chunks by form to ensure complete form analysis
  const chunksByForm = validChunks.reduce((acc, chunk) => {
    const formKey = `${chunk.formId}-${chunk.formName}`;
    if (!acc[formKey]) {
      acc[formKey] = [];
    }
    acc[formKey].push(chunk);
    return acc;
  }, {});

  const formGroups = Object.values(chunksByForm);
  console.log(`Organized into ${formGroups.length} form groups`);

  // If we have few forms or small total content, process all together
  if (formGroups.length <= 3 && validChunks.length <= 8) {
    console.log('Processing all forms together (small dataset)');
    return await analyzeClaimCoverage(claimDescription, validChunks, conversationHistory);
  }

  // For larger datasets, process by form groups and synthesize
  const analyses = [];

  for (let i = 0; i < formGroups.length; i++) {
    const formGroup = formGroups[i];
    const formName = formGroup[0].formName;

    try {
      console.log(`Analyzing form group ${i + 1}/${formGroups.length}: ${formName}`);
      const analysis = await analyzeClaimCoverage(claimDescription, formGroup, conversationHistory);
      analyses.push({
        analysis,
        formName,
        formNumber: formGroup[0].formNumber,
        category: formGroup[0].category,
        chunkCount: formGroup.length
      });
    } catch (error) {
      console.error(`Failed to analyze form ${formName}:`, error);
      analyses.push({
        analysis: `**Error analyzing ${formName}**: ${error.message}`,
        formName,
        formNumber: formGroup[0].formNumber,
        category: formGroup[0].category,
        chunkCount: formGroup.length,
        error: true
      });
    }

    // Small delay between form analyses to prevent rate limiting
    if (i < formGroups.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }

  // Add information about any error chunks
  if (errorChunks.length > 0) {
    const errorSummary = errorChunks.map(chunk =>
      `- ${chunk.formName}: ${chunk.text.replace('[Error: ', '').replace(']', '')}`
    ).join('\n');

    analyses.push({
      analysis: `**Forms with Processing Errors:**\n${errorSummary}\n\nThese forms could not be analyzed due to processing errors.`,
      formName: 'Processing Errors',
      error: true
    });
  }

  // Synthesize all analyses into a final response
  console.log(`Synthesizing ${analyses.length} form analyses`);
  return await synthesizeAnalyses(claimDescription, analyses);
}

/**
 * Synthesize multiple form analyses into a coherent final response
 * @param {string} claimDescription - Original claim description
 * @param {Array} analyses - Array of analysis objects with formName, analysis, etc.
 * @returns {Promise<string>} - Synthesized response
 */
async function synthesizeAnalyses(claimDescription, analyses) {
  // Separate successful analyses from errors
  const successfulAnalyses = analyses.filter(a => !a.error);
  const errorAnalyses = analyses.filter(a => a.error);

  // Create a comprehensive prompt for synthesis
  const formsAnalyzed = successfulAnalyses.map(a =>
    `${a.formName} (${a.formNumber || 'No number'}) - ${a.category || 'Unknown category'}`
  ).join('\n');

  const synthesisPrompt = `
You are synthesizing multiple insurance form analyses into a comprehensive final claim determination.

**CLAIM SCENARIO:**
${claimDescription}

**FORMS ANALYZED:**
${formsAnalyzed}

**INDIVIDUAL FORM ANALYSES:**
${successfulAnalyses.map((analysis) => `
=== ${analysis.formName} ===
Form Number: ${analysis.formNumber || 'Not specified'}
Category: ${analysis.category || 'Unknown'}
Chunks Analyzed: ${analysis.chunkCount || 1}

ANALYSIS:
${analysis.analysis}
`).join('\n\n')}

${errorAnalyses.length > 0 ? `
**FORMS WITH ERRORS:**
${errorAnalyses.map(a => a.analysis).join('\n')}
` : ''}

**SYNTHESIS INSTRUCTIONS:**
Provide a comprehensive final analysis that:
1. **Reconciles** any conflicting determinations between forms
2. **Determines** overall coverage (COVERED/NOT COVERED/PARTIALLY COVERED)
3. **Consolidates** all applicable coverages found across forms
4. **Identifies** all relevant exclusions that apply
5. **Prioritizes** primary vs. excess coverages appropriately
6. **Addresses** any gaps or conflicts between forms
7. **Provides** clear, actionable recommendations

Use the standard structured format with clear sections and specific form references.
`;

  try {
    // Call Cloud Function (secure proxy to OpenAI)
    const analyzeClaim = httpsCallable(functions, 'analyzeClaim');
    const result = await Promise.race([
      analyzeClaim({
        messages: [
          {
            role: 'system',
            content: 'You are an expert insurance claims analyst with deep knowledge of policy interactions and coverage determinations. Synthesize multiple form analyses into a definitive final determination.'
          },
          {
            role: 'user',
            content: synthesisPrompt
          }
        ],
        model: 'gpt-4o-mini',
        maxTokens: 3000,
        temperature: 0.1
      }),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Synthesis timeout')), 60000)
      )
    ]);

    if (!result.data.success) {
      throw new Error('Failed to synthesize analyses');
    }

    const content = result.data.content?.trim();

    if (!content) {
      throw new Error('No synthesis content received');
    }

    return content;

  } catch (error) {
    console.error('Error synthesizing analyses:', error);

    // Return a structured fallback synthesis
    return `## Coverage Analysis Summary

**Claim:** ${claimDescription}

**Forms Analyzed:** ${successfulAnalyses.length} form(s)

### Individual Form Findings

${successfulAnalyses.map((analysis) => `
#### ${analysis.formName}
${analysis.analysis}
`).join('\n')}

${errorAnalyses.length > 0 ? `
### Processing Issues
${errorAnalyses.map(a => a.analysis).join('\n')}
` : ''}

### Final Determination
**Status:** Requires manual review due to synthesis error: ${error.message}

**Recommendation:** Please review the individual form analyses above and consult with a senior claims examiner for final determination.

*Note: This is a compilation of individual analyses due to a technical issue with the synthesis process.*`;
  }
}
```

---

## src/services/coverageSearch.ts

**Path:** `src/services/coverageSearch.ts`

```typescript
/**
 * Coverage Search Service
 * 
 * Intelligent fuzzy search for coverage names using Fuse.js
 * Features:
 * - Typo tolerance
 * - Abbreviation expansion
 * - Synonym matching
 * - Line of business filtering
 * - Relevance scoring
 */

import Fuse from 'fuse.js';
import { COVERAGE_DATABASE, CoverageEntry } from '../data/coverageDatabase';

export interface SearchResult {
  name: string;
  score: number; // 0-100, higher is better
  matchType: 'exact' | 'abbreviation' | 'alias' | 'keyword' | 'fuzzy';
  category: string;
  description?: string;
  commonlyPairedWith?: string[];
}

// Configure Fuse.js for optimal fuzzy matching
const fuseOptions: Fuse.IFuseOptions<CoverageEntry> = {
  // Keys to search with weights
  keys: [
    { name: 'name', weight: 1.0 },           // Primary name - highest weight
    { name: 'abbreviations', weight: 0.9 },   // Abbreviations - very high
    { name: 'aliases', weight: 0.85 },        // Alternative names - high
    { name: 'keywords', weight: 0.6 },        // Related keywords - medium
    { name: 'description', weight: 0.3 },     // Description - lower
  ],
  
  // Fuzzy matching settings
  threshold: 0.4,        // 0 = exact, 1 = match anything (0.4 is balanced)
  distance: 100,         // How far to search for matches
  minMatchCharLength: 2, // Minimum characters to trigger search
  
  // Include score and match info
  includeScore: true,
  includeMatches: true,
  
  // Use extended search for advanced patterns
  useExtendedSearch: true,
  
  // Ignore field length normalization for better short-term matching
  ignoreFieldNorm: false,
  fieldNormWeight: 1,
};

// Create Fuse instance
const fuse = new Fuse(COVERAGE_DATABASE, fuseOptions);

/**
 * Search for coverages matching the query
 */
export function searchCoverages(
  query: string,
  options: {
    lineOfBusiness?: string;
    maxResults?: number;
    includeRelated?: boolean;
  } = {}
): SearchResult[] {
  const { lineOfBusiness, maxResults = 10, includeRelated = true } = options;
  
  if (!query || query.length < 1) {
    // Return popular coverages when no query
    return getPopularCoverages(lineOfBusiness, maxResults);
  }

  const normalizedQuery = query.trim().toUpperCase();
  
  // Check for exact abbreviation match first
  const exactAbbrevMatch = COVERAGE_DATABASE.find(c => 
    c.abbreviations?.some(abbr => abbr.toUpperCase() === normalizedQuery)
  );
  
  if (exactAbbrevMatch) {
    // Return abbreviation match first, then fuzzy results
    const results: SearchResult[] = [{
      name: exactAbbrevMatch.name,
      score: 100,
      matchType: 'abbreviation',
      category: exactAbbrevMatch.category,
      description: exactAbbrevMatch.description,
      commonlyPairedWith: exactAbbrevMatch.commonlyPairedWith,
    }];
    
    // Add related coverages if requested
    if (includeRelated && exactAbbrevMatch.commonlyPairedWith) {
      exactAbbrevMatch.commonlyPairedWith.forEach(related => {
        const relatedCoverage = COVERAGE_DATABASE.find(c => c.name === related);
        if (relatedCoverage) {
          results.push({
            name: relatedCoverage.name,
            score: 75,
            matchType: 'keyword',
            category: relatedCoverage.category,
            description: relatedCoverage.description,
          });
        }
      });
    }
    
    return results.slice(0, maxResults);
  }

  // Perform fuzzy search
  const fuseResults = fuse.search(query);
  
  // Filter by line of business if specified
  let filtered = fuseResults;
  if (lineOfBusiness) {
    const lobLower = lineOfBusiness.toLowerCase();
    filtered = fuseResults.filter(r => 
      r.item.lineOfBusiness.some(lob => 
        lob.toLowerCase().includes(lobLower) || lobLower.includes(lob.toLowerCase())
      )
    );
    
    // If filtering removes too many, add some back
    if (filtered.length < 3) {
      filtered = [...filtered, ...fuseResults.filter(r => !filtered.includes(r)).slice(0, 5)];
    }
  }

  // Convert to SearchResult format
  const results: SearchResult[] = filtered.slice(0, maxResults).map(result => {
    const fuseScore = result.score || 0;
    // Convert Fuse score (0 = perfect, 1 = worst) to our score (100 = perfect, 0 = worst)
    const score = Math.round((1 - fuseScore) * 100);
    
    // Determine match type based on which field matched
    let matchType: SearchResult['matchType'] = 'fuzzy';
    if (result.matches) {
      const matchedKey = result.matches[0]?.key;
      if (matchedKey === 'name') matchType = score > 90 ? 'exact' : 'fuzzy';
      else if (matchedKey === 'abbreviations') matchType = 'abbreviation';
      else if (matchedKey === 'aliases') matchType = 'alias';
      else if (matchedKey === 'keywords') matchType = 'keyword';
    }

    return {
      name: result.item.name,
      score,
      matchType,
      category: result.item.category,
      description: result.item.description,
      commonlyPairedWith: result.item.commonlyPairedWith,
    };
  });

  return results;
}

/**
 * Get popular coverages for a line of business
 */
export function getPopularCoverages(
  lineOfBusiness?: string,
  maxResults: number = 8
): SearchResult[] {
  let coverages = COVERAGE_DATABASE;

  if (lineOfBusiness) {
    const lobLower = lineOfBusiness.toLowerCase();
    coverages = COVERAGE_DATABASE.filter(c =>
      c.lineOfBusiness.some(lob =>
        lob.toLowerCase().includes(lobLower) || lobLower.includes(lob.toLowerCase())
      )
    );
  }

  // Return top coverages by category diversity
  const seen = new Set<string>();
  const results: SearchResult[] = [];

  for (const coverage of coverages) {
    if (!seen.has(coverage.category)) {
      results.push({
        name: coverage.name,
        score: 80,
        matchType: 'keyword',
        category: coverage.category,
        description: coverage.description,
        commonlyPairedWith: coverage.commonlyPairedWith,
      });
      seen.add(coverage.category);
    }
    if (results.length >= maxResults) break;
  }

  // Fill remaining slots with more coverages
  if (results.length < maxResults) {
    for (const coverage of coverages) {
      if (!results.some(r => r.name === coverage.name)) {
        results.push({
          name: coverage.name,
          score: 70,
          matchType: 'keyword',
          category: coverage.category,
          description: coverage.description,
        });
      }
      if (results.length >= maxResults) break;
    }
  }

  return results;
}

/**
 * Get coverages commonly paired with a given coverage
 */
export function getRelatedCoverages(
  coverageName: string,
  maxResults: number = 5
): SearchResult[] {
  const coverage = COVERAGE_DATABASE.find(
    c => c.name.toLowerCase() === coverageName.toLowerCase()
  );

  if (!coverage?.commonlyPairedWith) return [];

  return coverage.commonlyPairedWith
    .map(related => {
      const relatedCoverage = COVERAGE_DATABASE.find(c => c.name === related);
      if (!relatedCoverage) return null;

      return {
        name: relatedCoverage.name,
        score: 85,
        matchType: 'keyword' as const,
        category: relatedCoverage.category,
        description: relatedCoverage.description,
      };
    })
    .filter((r): r is SearchResult => r !== null)
    .slice(0, maxResults);
}

/**
 * Suggest coverages that might be missing based on existing coverages
 */
export function suggestMissingCoverages(
  existingCoverageNames: string[],
  lineOfBusiness?: string,
  maxResults: number = 5
): SearchResult[] {
  const existing = new Set(existingCoverageNames.map(n => n.toLowerCase()));
  const suggestions: SearchResult[] = [];
  const seen = new Set<string>();

  // Find coverages commonly paired with existing ones
  for (const existingName of existingCoverageNames) {
    const related = getRelatedCoverages(existingName, 10);
    for (const r of related) {
      if (!existing.has(r.name.toLowerCase()) && !seen.has(r.name)) {
        suggestions.push({
          ...r,
          score: 90, // High score for gap-filling suggestions
          matchType: 'keyword',
        });
        seen.add(r.name);
      }
    }
  }

  // Filter by line of business if specified
  let filtered = suggestions;
  if (lineOfBusiness) {
    const lobLower = lineOfBusiness.toLowerCase();
    filtered = suggestions.filter(s => {
      const coverage = COVERAGE_DATABASE.find(c => c.name === s.name);
      return coverage?.lineOfBusiness.some(lob =>
        lob.toLowerCase().includes(lobLower)
      );
    });
  }

  return filtered.slice(0, maxResults);
}

/**
 * Get all unique categories
 */
export function getCategories(): string[] {
  return [...new Set(COVERAGE_DATABASE.map(c => c.category))].sort();
}

/**
 * Get coverages by category
 */
export function getCoveragesByCategory(category: string): CoverageEntry[] {
  return COVERAGE_DATABASE.filter(c => c.category === category);
}

```

---

## src/services/dataDictionaryService.ts

**Path:** `src/services/dataDictionaryService.ts`

```typescript
/**
 * Data Dictionary Service
 * Manages rating input field definitions and validation
 */

import {
  collection,
  doc,
  addDoc,
  updateDoc,
  getDocs,
  getDoc,
  query,
  where,
  serverTimestamp,
  writeBatch
} from 'firebase/firestore';
import { db } from '../firebase';
import { DataDictionaryField, RatingInput } from '../types/pricing';
import logger, { LOG_CATEGORIES } from '../utils/logger';

class DataDictionaryService {
  /**
   * Get all data dictionary fields for a product
   */
  async getProductFields(productId: string): Promise<DataDictionaryField[]> {
    try {
      const q = query(
        collection(db, `products/${productId}/dataDictionary`),
        where('productId', '==', productId)
      );
      const snapshot = await getDocs(q);
      return snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      } as DataDictionaryField));
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Failed to fetch data dictionary fields', 
        { productId }, error as Error);
      throw error;
    }
  }

  /**
   * Create a new data dictionary field
   */
  async createField(productId: string, field: Omit<DataDictionaryField, 'id' | 'productId' | 'createdAt' | 'updatedAt'>): Promise<DataDictionaryField> {
    try {
      const fieldData = {
        ...field,
        productId,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      };

      const ref = await addDoc(
        collection(db, `products/${productId}/dataDictionary`),
        fieldData
      );

      return {
        id: ref.id,
        ...fieldData
      } as DataDictionaryField;
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Failed to create data dictionary field', 
        { productId, fieldName: field.name }, error as Error);
      throw error;
    }
  }

  /**
   * Validate rating inputs against data dictionary
   */
  async validateInputs(productId: string, inputs: RatingInput): Promise<{ isValid: boolean; errors: string[] }> {
    try {
      const fields = await this.getProductFields(productId);
      const errors: string[] = [];

      for (const field of fields) {
        if (field.required && (inputs[field.name] === undefined || inputs[field.name] === null)) {
          errors.push(`${field.label} is required`);
          continue;
        }

        const value = inputs[field.name];
        if (value === undefined || value === null) continue;

        // Type validation
        if (field.type === 'number' && typeof value !== 'number') {
          errors.push(`${field.label} must be a number`);
        }
        if (field.type === 'boolean' && typeof value !== 'boolean') {
          errors.push(`${field.label} must be a boolean`);
        }

        // Range validation
        if (field.type === 'number' && typeof value === 'number') {
          if (field.min !== undefined && value < field.min) {
            errors.push(`${field.label} must be at least ${field.min}`);
          }
          if (field.max !== undefined && value > field.max) {
            errors.push(`${field.label} must be at most ${field.max}`);
          }
        }

        // Enum validation
        if (field.type === 'enum' && field.enumOptions && !field.enumOptions.includes(String(value))) {
          errors.push(`${field.label} must be one of: ${field.enumOptions.join(', ')}`);
        }
      }

      return {
        isValid: errors.length === 0,
        errors
      };
    } catch (error) {
      logger.error(LOG_CATEGORIES.ERROR, 'Failed to validate inputs', 
        { productId }, error as Error);
      throw error;
    }
  }

  /**
   * Coerce input values to correct types
   */
  coerceInputs(fields: DataDictionaryField[], inputs: RatingInput): RatingInput {
    const coerced: RatingInput = {};

    for (const field of fields) {
      const value = inputs[field.name];
      if (value === undefined || value === null) continue;

      if (field.type === 'number') {
        coerced[field.name] = Number(value);
      } else if (field.type === 'boolean') {
        coerced[field.name] = value === true || value === 'true';
      } else {
        coerced[field.name] = value;
      }
    }

    return coerced;
  }
}

export default new DataDictionaryService();

```

---

## src/services/firebaseConnectionMonitor.ts

**Path:** `src/services/firebaseConnectionMonitor.ts`

```typescript
// src/services/firebaseConnectionMonitor.js
/**
 * Firebase Connection Monitor Service
 * Monitors Firebase connection state and provides reconnection logic
 */

import { onSnapshot, doc } from 'firebase/firestore';
import { db } from '../firebase';
import logger, { LOG_CATEGORIES } from '../utils/logger';

class FirebaseConnectionMonitor {
  constructor() {
    this.isConnected = true;
    this.listeners = new Set();
    this.connectionCheckInterval = null;
    this.unsubscribeConnectionListener = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 2000; // Start with 2 seconds
    this.maxReconnectDelay = 30000; // Max 30 seconds
    this.networkListenersAdded = false;
  }

  /**
   * Start monitoring Firebase connection
   */
  startMonitoring() {
    if (this.unsubscribeConnectionListener) {
      // Connection monitor already running (reduced logging noise)
      return;
    }

    // Starting Firebase connection monitor (reduced logging noise)

    // Firestore doesn't have a .info/connected path like Realtime Database
    // Instead, we'll use network events and onSnapshot error handling
    // to detect connection state

    // Setup network monitoring as primary detection method
    this.setupNetworkMonitoring();

    // Also use a dummy snapshot listener to detect Firestore connectivity
    // This will fail gracefully if there's no connection
    try {
      // Create a minimal listener that will error if disconnected
      const dummyRef = doc(db, '_connection_test_', 'status');

      this.unsubscribeConnectionListener = onSnapshot(
        dummyRef,
        () => {
          // Successfully listening means we're connected
          if (!this.isConnected) {
            this.handleConnectionChange(true);
          }
        },
        (error) => {
          // Snapshot error might indicate connection issues
          // But don't treat all errors as disconnection
          // Suppress permission errors - they're expected for guest users
          if (error.code !== 'permission-denied') {
            logger.warn(
              LOG_CATEGORIES.FIREBASE,
              'Firestore snapshot listener error (may indicate connection issue)',
              { error: error.message }
            );
          }
        }
      );
    } catch (error) {
      logger.warn(
        LOG_CATEGORIES.FIREBASE,
        'Could not setup Firestore connection listener, using network events only',
        { error: error.message }
      );
    }
  }

  /**
   * Setup network event monitoring as fallback
   */
  setupNetworkMonitoring() {
    if (typeof window === 'undefined') return;

    // Only add listeners once
    if (this.networkListenersAdded) return;
    this.networkListenersAdded = true;

    window.addEventListener('online', () => {
      // Network online event detected (reduced logging noise)
      this.handleConnectionChange(true);
    });

    window.addEventListener('offline', () => {
      // Network offline event detected (reduced logging noise)
      this.handleConnectionChange(false);
    });

    // Initial check - assume connected unless proven otherwise
    // This prevents false "disconnected" warnings on page load
    const initialState = navigator.onLine !== false; // Default to true if undefined
    if (initialState) {
      this.isConnected = true;
      this.notifyListeners('connected');
    }
  }

  /**
   * Handle connection state change
   */
  handleConnectionChange(connected) {
    const wasConnected = this.isConnected;
    this.isConnected = connected;

    if (connected && !wasConnected) {
      // Connection restored - only log if there were previous reconnect attempts
      if (this.reconnectAttempts > 0) {
        logger.info(LOG_CATEGORIES.FIREBASE, 'âœ… Firebase connection restored');
      }
      this.reconnectAttempts = 0;
      this.reconnectDelay = 2000; // Reset delay
      this.notifyListeners('connected');
    } else if (!connected && wasConnected) {
      // Connection lost - only log warning
      logger.warn(LOG_CATEGORIES.FIREBASE, 'âš ï¸ Firebase connection lost');
      this.notifyListeners('disconnected');
      this.attemptReconnect();
    }
  }

  /**
   * Attempt to reconnect with exponential backoff
   */
  attemptReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      logger.error(
        LOG_CATEGORIES.FIREBASE,
        'Max reconnection attempts reached',
        { attempts: this.reconnectAttempts }
      );
      this.notifyListeners('reconnect-failed');
      return;
    }

    this.reconnectAttempts++;
    const delay = Math.min(
      this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),
      this.maxReconnectDelay
    );

    // Attempting reconnection (reduced logging noise - only log on errors)

    setTimeout(() => {
      if (!this.isConnected) {
        this.notifyListeners('reconnecting');
        // The actual reconnection is handled by Firebase SDK
        // We just need to check if we're back online
        if (navigator.onLine) {
          this.handleConnectionChange(true);
        } else {
          this.attemptReconnect();
        }
      }
    }, delay);
  }

  /**
   * Add connection state listener
   */
  addListener(callback) {
    if (typeof callback !== 'function') {
      logger.error(LOG_CATEGORIES.FIREBASE, 'Connection listener must be a function');
      return () => {};
    }

    this.listeners.add(callback);

    // Immediately notify of current state
    callback({
      state: this.isConnected ? 'connected' : 'disconnected',
      isConnected: this.isConnected,
      reconnectAttempts: this.reconnectAttempts
    });

    // Return unsubscribe function
    return () => {
      this.listeners.delete(callback);
    };
  }

  /**
   * Notify all listeners of connection state change
   */
  notifyListeners(state) {
    const eventData = {
      state,
      isConnected: this.isConnected,
      reconnectAttempts: this.reconnectAttempts,
      timestamp: new Date().toISOString()
    };

    this.listeners.forEach(listener => {
      try {
        listener(eventData);
      } catch (error) {
        logger.error(
          LOG_CATEGORIES.FIREBASE,
          'Error in connection listener',
          {},
          error
        );
      }
    });
  }

  /**
   * Stop monitoring
   */
  stopMonitoring() {
    // Stopping Firebase connection monitor (reduced logging noise)

    if (this.unsubscribeConnectionListener) {
      this.unsubscribeConnectionListener();
      this.unsubscribeConnectionListener = null;
    }

    if (this.connectionCheckInterval) {
      clearInterval(this.connectionCheckInterval);
      this.connectionCheckInterval = null;
    }

    this.listeners.clear();
  }

  /**
   * Get current connection state
   */
  getConnectionState() {
    return {
      isConnected: this.isConnected,
      reconnectAttempts: this.reconnectAttempts,
      hasListeners: this.listeners.size > 0
    };
  }

  /**
   * Force reconnection attempt
   */
  forceReconnect() {
    // Forcing reconnection attempt (reduced logging noise)
    this.reconnectAttempts = 0;
    this.attemptReconnect();
  }
}

// Create singleton instance
const connectionMonitor = new FirebaseConnectionMonitor();

// Auto-start monitoring in browser environment
if (typeof window !== 'undefined') {
  connectionMonitor.startMonitoring();
}

export default connectionMonitor;

```

---

## src/services/firebaseOptimized.ts

**Path:** `src/services/firebaseOptimized.ts`

```typescript
/**
 * Optimized Firebase Service
 *
 * Enhancements:
 * - Intelligent caching with TTL management
 * - Exponential backoff retry logic
 * - Query queue management for concurrency control
 * - Batch operations with automatic flushing
 * - Fallback to cached data on errors
 * - Performance monitoring and logging
 */

import {
  collection,
  collectionGroup,
  doc,
  getDocs,
  getDoc,
  onSnapshot,
  query,
  where,
  orderBy,
  limit,
  writeBatch,
  enableNetwork,
  disableNetwork,
  QueryConstraint
} from 'firebase/firestore';
import { db } from '../firebase';
import logger, { LOG_CATEGORIES } from '../utils/logger';
import { CACHE } from '../config/constants';

/**
 * Simple cache entry for Firebase data
 * Note: This is intentionally different from CacheService's CacheEntry
 * which has additional metadata (ttl, hits, size) for advanced caching
 */
interface FirebaseCacheEntry<T> {
  data: T;
  timestamp: number;
}

interface RetryOptions {
  maxRetries?: number;
  initialDelayMs?: number;
  maxDelayMs?: number;
}

class FirebaseOptimizedService {
  private cache: Map<string, FirebaseCacheEntry<any>>;
  private subscribers: Map<string, any>;
  private batchQueue: any[];
  private batchTimeout: NodeJS.Timeout | null;
  private queryCache: Map<string, FirebaseCacheEntry<any>>;
  private indexHints: Map<string, any>;
  private activeQueries: number;
  private queryQueue: Array<() => Promise<any>>;

  // Configuration constants - uses centralized CACHE config from constants.ts
  private readonly CACHE_TTL = CACHE.TTL_PRODUCTS; // Default TTL from centralized config
  private readonly BATCH_SIZE = 500;
  private readonly BATCH_DELAY = 100; // 100ms
  private readonly MAX_CONCURRENT_QUERIES = 3;
  private readonly MAX_RETRIES = 3;
  private readonly INITIAL_RETRY_DELAY = 100; // ms
  private readonly MAX_RETRY_DELAY = 5000; // ms

  constructor() {
    this.cache = new Map();
    this.subscribers = new Map();
    this.batchQueue = [];
    this.batchTimeout = null;
    this.queryCache = new Map();
    this.indexHints = new Map();
    this.activeQueries = 0;
    this.queryQueue = [];
  }

  /**
   * Optimized: Get cached data with TTL validation
   */
  private getCachedData<T>(key: string): T | null {
    const cached = this.cache.get(key);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > this.CACHE_TTL) {
      this.cache.delete(key);
      return null;
    }

    return cached.data as T;
  }

  /**
   * Optimized: Set cached data with timestamp
   */
  private setCachedData<T>(key: string, data: T): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  /**
   * Optimized: Exponential backoff retry logic
   */
  private async retryWithBackoff<T>(
    fn: () => Promise<T>,
    options: RetryOptions = {}
  ): Promise<T> {
    const {
      maxRetries = this.MAX_RETRIES,
      initialDelayMs = this.INITIAL_RETRY_DELAY,
      maxDelayMs = this.MAX_RETRY_DELAY
    } = options;

    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));

        if (attempt < maxRetries) {
          // Exponential backoff: delay = initialDelay * 2^attempt, capped at maxDelay
          const delay = Math.min(
            initialDelayMs * Math.pow(2, attempt),
            maxDelayMs
          );

          logger.debug(LOG_CATEGORIES.DATA, `Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`, {
            error: lastError.message
          });

          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }

  /**
   * Optimized: Execute query with concurrency control and retry logic
   */
  private async executeQuery<T>(
    queryFn: () => Promise<T>,
    cacheKey?: string
  ): Promise<T> {
    return new Promise((resolve, reject) => {
      const queryTask = async () => {
        this.activeQueries++;
        try {
          // Optimized: Retry with exponential backoff
          const result = await this.retryWithBackoff(() => queryFn());
          resolve(result);
        } catch (error) {
          // Fallback: Try to use cached data if available
          if (cacheKey) {
            const cached = this.getCachedData<T>(cacheKey);
            if (cached) {
              logger.warn(LOG_CATEGORIES.DATA, 'Query failed, using cached data', {
                cacheKey,
                error: error instanceof Error ? error.message : String(error)
              });
              resolve(cached);
              return;
            }
          }
          reject(error);
        } finally {
          this.activeQueries--;
          this.processQueryQueue();
        }
      };

      if (this.activeQueries < this.MAX_CONCURRENT_QUERIES) {
        queryTask();
      } else {
        this.queryQueue.push(queryTask);
      }
    });
  }

  /**
   * Optimized: Process queued queries when slots become available
   */
  private processQueryQueue(): void {
    if (this.queryQueue.length > 0 && this.activeQueries < this.MAX_CONCURRENT_QUERIES) {
      const nextQuery = this.queryQueue.shift();
      if (nextQuery) {
        nextQuery();
      }
    }
  }

  // Optimized collection fetching with enhanced caching and query optimization
  async getCollection(collectionName, options = {}) {
    const startTime = Date.now();
    const {
      useCache = true,
      orderByField = null,
      orderDirection = 'asc',
      limitCount = null,
      whereConditions = [],
      enableQueryOptimization = true
    } = options;

    const cacheKey = `${collectionName}_${JSON.stringify(options)}`;

    // Silently track Firebase operation (batched logging in logger)
    logger.logFirebaseOperation('getCollection', collectionName);

    // Check cache first
    if (useCache) {
      const cached = this.getCachedData(cacheKey);
      if (cached) {
        return cached;
      }
    }

    // Check query cache for similar queries
    if (useCache && this.queryCache.has(cacheKey)) {
      const cachedQuery = this.queryCache.get(cacheKey);
      if (Date.now() - cachedQuery.timestamp < this.CACHE_TTL) {
        return cachedQuery.data;
      }
    }

    const queryFn = async () => {
      try {
        const queryStartTime = Date.now();
        let q = collection(db, collectionName);

        // Optimize query order for better performance
        if (enableQueryOptimization && whereConditions.length > 0) {
          // Sort where conditions by selectivity (most selective first)
          const optimizedConditions = this.optimizeWhereConditions(whereConditions, collectionName);
          optimizedConditions.forEach(([field, operator, value]) => {
            q = query(q, where(field, operator, value));
          });
        } else {
          whereConditions.forEach(([field, operator, value]) => {
            q = query(q, where(field, operator, value));
          });
        }

        // Apply ordering
        if (orderByField) {
          q = query(q, orderBy(orderByField, orderDirection));
        }

        // Apply limit (always use limit for performance)
        const effectiveLimit = limitCount || 1000; // Default limit
        q = query(q, limit(effectiveLimit));

        const snapshot = await getDocs(q);

        const data = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));

        const queryTime = Date.now() - queryStartTime;

        // Cache the result
        if (useCache) {
          this.setCachedData(cacheKey, data);
          this.queryCache.set(cacheKey, {
            data,
            timestamp: Date.now(),
            queryTime,
            resultCount: data.length
          });
        }

        return data;
      } catch (error) {
        // Only log errors, not successful fetches
        logger.error(LOG_CATEGORIES.FIREBASE, `Error fetching ${collectionName}`, { collectionName }, error as Error);

        // Provide index optimization hints
        if (error.code === 'failed-precondition' && error.message.includes('index')) {
          this.suggestIndexOptimization(collectionName, options, error);
        }

        throw error;
      }
    };

    return this.executeQuery(queryFn, cacheKey);
  }

  // Collection group query for subcollections (e.g., all coverages across all products)
  async getCollectionGroup(collectionName, options = {}) {
    const { useCache = true } = options;
    const cacheKey = `collectionGroup_${collectionName}_${JSON.stringify(options)}`;

    logger.logFirebaseOperation('getCollectionGroup', collectionName);

    // Check cache first
    if (useCache) {
      const cached = this.getCachedData(cacheKey);
      if (cached) {
        return cached;
      }
    }

    const queryFn = async () => {
      try {
        const groupQuery = collectionGroup(db, collectionName);
        const snapshot = await getDocs(groupQuery);

        const data = snapshot.docs.map(docSnap => ({
          id: docSnap.id,
          ...docSnap.data(),
          // Include parent path info for context
          _parentPath: docSnap.ref.parent.parent?.path || null,
          _productId: docSnap.ref.parent.parent?.id || null
        }));

        if (useCache) {
          this.setCachedData(cacheKey, data);
        }

        return data;
      } catch (error) {
        logger.error(LOG_CATEGORIES.FIREBASE, `Error fetching collection group ${collectionName}`, { collectionName }, error as Error);
        throw error;
      }
    };

    return this.executeQuery(queryFn, cacheKey);
  }

  // Optimize where conditions based on field selectivity
  optimizeWhereConditions(conditions, collectionName) {
    const hints = this.indexHints.get(collectionName) || {};

    return [...conditions].sort((a, b) => {
      const [fieldA] = a;
      const [fieldB] = b;

      // Prioritize fields with known high selectivity
      const selectivityA = hints[fieldA]?.selectivity || 0.5;
      const selectivityB = hints[fieldB]?.selectivity || 0.5;

      return selectivityB - selectivityA; // Higher selectivity first
    });
  }



  // Suggest index optimizations
  suggestIndexOptimization(collectionName, options, error) {
    const indexMatch = error.message.match(/https:\/\/console\.firebase\.google\.com[^\s]+/);
    logger.warn(LOG_CATEGORIES.FIREBASE, 'Index optimization needed', {
      collectionName,
      options,
      error: error.message,
      indexUrl: indexMatch ? indexMatch[0] : null
    });
  }

  // Optimized document fetching
  async getDocument(collectionName, docId, useCache = true) {
    const cacheKey = `${collectionName}_${docId}`;

    // Silently track Firebase operation (batched logging in logger)
    logger.logFirebaseOperation('getDocument', collectionName, docId);

    if (useCache) {
      const cached = this.getCachedData(cacheKey);
      if (cached) {
        return cached;
      }
    }

    try {
      const docRef = doc(db, collectionName, docId);
      const docSnap = await getDoc(docRef);

      if (!docSnap.exists()) {
        return null;
      }

      const data = { id: docSnap.id, ...docSnap.data() };

      if (useCache) {
        this.setCachedData(cacheKey, data);
      }

      return data;
    } catch (error) {
      logger.error(LOG_CATEGORIES.FIREBASE, `Error fetching document ${docId}`, {
        collectionName,
        docId
      }, error);
      throw error;
    }
  }

  // Optimized real-time subscription with cleanup
  subscribeToCollection(collectionName, callback, options = {}) {
    const { 
      orderByField = null, 
      orderDirection = 'asc',
      limitCount = null,
      whereConditions = []
    } = options;

    const subscriptionKey = `${collectionName}_${JSON.stringify(options)}`;
    
    // Clean up existing subscription
    if (this.subscribers.has(subscriptionKey)) {
      this.subscribers.get(subscriptionKey)();
    }

    try {
      let q = collection(db, collectionName);
      
      // Apply conditions
      whereConditions.forEach(([field, operator, value]) => {
        q = query(q, where(field, operator, value));
      });
      
      if (orderByField) {
        q = query(q, orderBy(orderByField, orderDirection));
      }
      
      if (limitCount) {
        q = query(q, limit(limitCount));
      }

      const unsubscribe = onSnapshot(q, 
        (snapshot) => {
          const data = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));
          
          // Update cache
          const cacheKey = `${collectionName}_${JSON.stringify(options)}`;
          this.setCachedData(cacheKey, data);
          
          callback(data, null);
        },
        (error) => {
          logger.error(LOG_CATEGORIES.FIREBASE, `Subscription error for ${collectionName}`, { collectionName }, error as Error);
          callback(null, error);
        }
      );

      this.subscribers.set(subscriptionKey, unsubscribe);
      return unsubscribe;
    } catch (error) {
      logger.error(LOG_CATEGORIES.FIREBASE, `Error setting up subscription for ${collectionName}`, { collectionName }, error as Error);
      callback(null, error);
    }
  }

  // Batch write operations for better performance
  addToBatch(operation) {
    this.batchQueue.push(operation);
    
    // Auto-execute batch when it reaches size limit
    if (this.batchQueue.length >= this.BATCH_SIZE) {
      this.executeBatch();
    } else {
      // Schedule batch execution
      if (this.batchTimeout) {
        clearTimeout(this.batchTimeout);
      }
      
      this.batchTimeout = setTimeout(() => {
        this.executeBatch();
      }, this.BATCH_DELAY);
    }
  }

  async executeBatch() {
    if (this.batchQueue.length === 0) return;
    
    const batch = writeBatch(db);
    const operations = [...this.batchQueue];
    this.batchQueue = [];
    
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }

    try {
      operations.forEach(operation => {
        const { type, ref, data } = operation;
        
        switch (type) {
          case 'set':
            batch.set(ref, data);
            break;
          case 'update':
            batch.update(ref, data);
            break;
          case 'delete':
            batch.delete(ref);
            break;
          default:
            logger.warn(LOG_CATEGORIES.FIREBASE, 'Unknown batch operation type', { type });
        }
      });

      await batch.commit();

      // Clear related cache entries
      operations.forEach(operation => {
        const { ref } = operation;
        const collectionName = ref.parent.id;
        this.clearCacheByPattern(collectionName);
      });

    } catch (error) {
      logger.error(LOG_CATEGORIES.FIREBASE, 'Batch execution failed', {}, error as Error);
      throw error;
    }
  }

  // Clear cache by pattern
  clearCacheByPattern(pattern) {
    const keysToDelete = [];

    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        keysToDelete.push(key);
      }
    }

    keysToDelete.forEach(key => this.cache.delete(key));
  }

  // Network status management
  async goOffline() {
    try {
      await disableNetwork(db);
    } catch (error) {
      logger.error(LOG_CATEGORIES.FIREBASE, 'Error enabling offline mode', {}, error as Error);
    }
  }

  async goOnline() {
    try {
      await enableNetwork(db);
    } catch (error) {
      logger.error(LOG_CATEGORIES.FIREBASE, 'Error enabling online mode', {}, error as Error);
    }
  }

  // Cleanup all subscriptions and cache
  cleanup() {
    // Unsubscribe from all active subscriptions
    this.subscribers.forEach(unsubscribe => unsubscribe());
    this.subscribers.clear();

    // Clear cache
    this.cache.clear();

    // Clear batch timeout
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }

    // Execute any pending batch operations
    if (this.batchQueue.length > 0) {
      this.executeBatch();
    }
  }

  // Get cache statistics
  getCacheStats() {
    const totalEntries = this.cache.size;
    const totalSize = JSON.stringify([...this.cache.values()]).length;
    
    return {
      entries: totalEntries,
      estimatedSize: `${(totalSize / 1024).toFixed(2)} KB`,
      subscribers: this.subscribers.size,
      batchQueueSize: this.batchQueue.length
    };
  }
}

// Create singleton instance
const firebaseOptimized = new FirebaseOptimizedService();

// Cleanup on page unload
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => {
    firebaseOptimized.cleanup();
  });
}

export default firebaseOptimized;
```

---

## src/services/index.ts

**Path:** `src/services/index.ts`

```typescript
/**
 * Services Index
 * Centralized exports for all service modules
 * 
 * Organization:
 * - AI Services: RAG, prompt optimization, response formatting, claims analysis
 * - Data Services: Firebase optimized queries, caching, data dictionary
 * - Validation Services: Product, coverage, form, rule validation
 * - Monitoring: Connection monitoring, audit logging
 */

// ============================================================================
// AI Services
// ============================================================================

export {
  advancedRAGService,
  default as ragService,
  type DocumentChunk,
  type ChunkMetadata,
  type SummaryRequest,
  type SummaryResult
} from './advancedRAGService';

export {
  aiPromptOptimizer,
  default as promptOptimizer,
  MODEL_CONFIGS,
  TOKEN_BUDGETS,
  type QueryType,
  type ModelTier,
  type ModelConfig
} from './aiPromptOptimizer';

export {
  responseFormatter,
  default as formatter,
  type ResponseMetadata,
  type FormattedResponse,
  type ResponseSection
} from './responseFormatter';

export {
  analyzeClaimCoverage,
  analyzeClaimWithChunking
} from './claimsAnalysisService';

// ============================================================================
// Data Services
// ============================================================================

export { default as firebaseOptimized } from './firebaseOptimized';

export {
  cacheServices,
  type CacheStats
} from './cacheService';

export { default as dataDictionaryService } from './dataDictionaryService';

export {
  getProduct360Summary,
  invalidateProduct360Cache,
  getProductStats,
  getCoverageSummary,
  getFormSummary,
  type Product360Summary
} from './product360ReadModel';

// ============================================================================
// Validation Services
// ============================================================================

export {
  // Validation functions
  validateProduct,
  validateCoverage,
  validateCoverageBasic,
  calculateCoverageCompleteness,
  validateForm,
  validatePricingStep,
  validateRule,
  validateBatch,
  validateProductIntegrity,
  validateCoverageLimit,
  validateCoverageDeductible,
  validateStateCode,
  validateStateSubset,
  validateStateApplicability,
  // Referential integrity
  checkReferentialIntegrity,
  // Rule validation
  isValidRuleType,
  isValidRuleCategory,
  isValidRuleStatus,
  sanitizeRule,
  checkRuleConflicts,
  validateRuleDeletion,
  // Utilities
  formatValidationResult,
  // Types
  type ValidationResult,
  type ValidationError,
  type ValidationWarning,
  type ReferentialIntegrityReport,
  type CoverageValidationOptions,
  type CoverageValidationResult
} from './validationService';

// ============================================================================
// Monitoring & Audit Services
// ============================================================================

export { default as connectionMonitor } from './firebaseConnectionMonitor';

export {
  logAuditEvent,
  getAuditHistory,
  getProductAuditActivity,
  getUserActivity,
  detectChanges,
  formatAuditEntry,
  type AuditAction,
  type AuditEntity,
  type AuditChange,
  type AuditLogEntry
} from './auditService';

```

---

## src/services/product360ReadModel.ts

**Path:** `src/services/product360ReadModel.ts`

```typescript
/**
 * Product360 Read Model
 * Optimized read model for Product360 overview page
 * Aggregates data from multiple sources for efficient rendering
 */

import {
  collection,
  doc,
  getDoc,
  getDocs,
  query,
  where,
  collectionGroup
} from 'firebase/firestore';
import { db } from '@/firebase';
import { Product, Coverage, Form } from '@types/index';
import logger, { LOG_CATEGORIES } from '@utils/logger';
import { performanceMonitor } from '@utils/performanceMonitor';
import { cacheServices } from '@services/cacheService';

/**
 * Product360 summary data
 */
export interface Product360Summary {
  product: Product;
  stats: {
    totalCoverages: number;
    totalForms: number;
    totalLimits: number;
    totalDeductibles: number;
    totalRules: number;
    totalPricingRules: number;
    totalVersions: number;
    totalStates: number;
  };
  coverages: Coverage[];
  forms: Form[];
  recentActivity: Array<{
    type: string;
    description: string;
    timestamp: number;
  }>;
  migrationStatus: {
    total: number;
    migrated: number;
    percentage: number;
  };
}

/**
 * Get Product360 summary
 */
export async function getProduct360Summary(productId: string): Promise<Product360Summary | null> {
  const timerId = performanceMonitor.start('getProduct360Summary');

  try {
    // Check cache first
    const cached = cacheServices.products.get(`product360-${productId}`);
    if (cached) {
      logger.debug(LOG_CATEGORIES.CACHE, 'Product360 summary from cache', { productId });
      performanceMonitor.end(timerId, 'getProduct360Summary', 'CACHE');
      return cached as Product360Summary;
    }

    // Get product
    const productRef = doc(db, 'products', productId);
    const productSnap = await getDoc(productRef);

    if (!productSnap.exists()) {
      logger.warn(LOG_CATEGORIES.DATA, 'Product not found', { productId });
      performanceMonitor.end(timerId, 'getProduct360Summary', 'DATA');
      return null;
    }

    const product = { id: productSnap.id, ...productSnap.data() } as Product;

    // Get coverages
    const coveragesRef = collection(db, `products/${productId}/coverages`);
    const coveragesSnap = await getDocs(coveragesRef);
    const coverages = coveragesSnap.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as Coverage[];

    // Get forms
    const formsRef = collection(db, 'forms');
    const formsQuery = query(formsRef, where('productId', '==', productId));
    const formsSnap = await getDocs(formsQuery);
    const forms = formsSnap.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as Form[];

    // Count limits and deductibles
    let totalLimits = 0;
    let totalDeductibles = 0;

    for (const coverage of coverages) {
      const limitsRef = collection(db, `products/${productId}/coverages/${coverage.id}/limits`);
      const deductiblesRef = collection(db, `products/${productId}/coverages/${coverage.id}/deductibles`);

      const [limitsSnap, deductiblesSnap] = await Promise.all([
        getDocs(limitsRef),
        getDocs(deductiblesRef)
      ]);

      totalLimits += limitsSnap.size;
      totalDeductibles += deductiblesSnap.size;
    }

    // Count rules
    const rulesRef = collection(db, `products/${productId}/rules`);
    const rulesSnap = await getDocs(rulesRef);
    const totalRules = rulesSnap.size;

    // Count pricing rules
    const pricingRulesRef = collection(db, `products/${productId}/pricingRules`);
    const pricingRulesSnap = await getDocs(pricingRulesRef);
    const totalPricingRules = pricingRulesSnap.size;

    // Count versions
    const versionsRef = collection(db, `products/${productId}/versions`);
    const versionsSnap = await getDocs(versionsRef);
    const totalVersions = versionsSnap.size;

    // Count states
    const statesRef = collection(db, `products/${productId}/states`);
    const statesSnap = await getDocs(statesRef);
    const totalStates = statesSnap.size;

    // Build summary
    const summary: Product360Summary = {
      product,
      stats: {
        totalCoverages: coverages.length,
        totalForms: forms.length,
        totalLimits,
        totalDeductibles,
        totalRules,
        totalPricingRules,
        totalVersions,
        totalStates
      },
      coverages,
      forms,
      recentActivity: [],
      migrationStatus: {
        total: coverages.length,
        migrated: coverages.filter(c => c.migrated).length,
        percentage: coverages.length > 0
          ? Math.round((coverages.filter(c => c.migrated).length / coverages.length) * 100)
          : 0
      }
    };

    // Cache result
    cacheServices.products.set(`product360-${productId}`, summary, 10 * 60 * 1000);

    performanceMonitor.end(timerId, 'getProduct360Summary', 'DATA');

    logger.info(LOG_CATEGORIES.DATA, 'Product360 summary loaded', {
      productId,
      stats: summary.stats
    });

    return summary;
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to get Product360 summary', {}, error as Error);
    performanceMonitor.end(timerId, 'getProduct360Summary', 'ERROR');
    throw error;
  }
}

/**
 * Invalidate Product360 cache
 */
export function invalidateProduct360Cache(productId: string): void {
  cacheServices.products.delete(`product360-${productId}`);
  logger.debug(LOG_CATEGORIES.CACHE, 'Product360 cache invalidated', { productId });
}

/**
 * Get product statistics
 */
export async function getProductStats(productId: string): Promise<Record<string, number>> {
  const summary = await getProduct360Summary(productId);
  if (!summary) {
    return {};
  }

  return summary.stats;
}

/**
 * Get coverage summary for product
 */
export async function getCoverageSummary(
  productId: string
): Promise<Array<{ id: string; name: string; type: string; formCount: number }>> {
  try {
    const coveragesRef = collection(db, `products/${productId}/coverages`);
    const coveragesSnap = await getDocs(coveragesRef);

    const summaries = await Promise.all(
      coveragesSnap.docs.map(async (coverageDoc) => {
        const coverage = coverageDoc.data() as Coverage;

        // Count forms for this coverage
        const formCoveragesRef = collectionGroup(db, 'formCoverages');
        const formCoveragesQuery = query(
          formCoveragesRef,
          where('productId', '==', productId),
          where('coverageId', '==', coverageDoc.id)
        );
        const formCoveragesSnap = await getDocs(formCoveragesQuery);

        return {
          id: coverageDoc.id,
          name: coverage.name || coverage.coverageName || 'Unnamed',
          type: coverage.type || coverage.coverageType || 'Unknown',
          formCount: formCoveragesSnap.size
        };
      })
    );

    return summaries;
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to get coverage summary', {}, error as Error);
    return [];
  }
}

/**
 * Get form summary for product
 */
export async function getFormSummary(
  productId: string
): Promise<Array<{ id: string; name: string; number: string; coverageCount: number }>> {
  try {
    const formsRef = collection(db, 'forms');
    const formsQuery = query(formsRef, where('productId', '==', productId));
    const formsSnap = await getDocs(formsQuery);

    const summaries = await Promise.all(
      formsSnap.docs.map(async (formDoc) => {
        const form = formDoc.data() as Form;

        // Count coverages for this form
        const formCoveragesRef = collectionGroup(db, 'formCoverages');
        const formCoveragesQuery = query(
          formCoveragesRef,
          where('productId', '==', productId),
          where('formId', '==', formDoc.id)
        );
        const formCoveragesSnap = await getDocs(formCoveragesQuery);

        return {
          id: formDoc.id,
          name: form.name || form.formName || 'Unnamed',
          number: form.number || form.formNumber || 'N/A',
          coverageCount: formCoveragesSnap.size
        };
      })
    );

    return summaries;
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to get form summary', {}, error as Error);
    return [];
  }
}

```

---

## src/services/responseFormatter.ts

**Path:** `src/services/responseFormatter.ts`

```typescript
/**
 * Response Formatter Service
 * 
 * Formats AI responses for optimal readability and user experience.
 * Handles markdown, structured data, and metadata presentation.
 */

import logger, { LOG_CATEGORIES } from '../utils/logger';

export interface ResponseMetadata {
  queryType?: string;
  confidence?: number;
  tokensUsed?: number;
  processingTime?: number;
  sources?: string[];
  timestamp?: number;
}

export interface FormattedResponse {
  content: string;
  metadata: ResponseMetadata;
  isStructured: boolean;
  sections: ResponseSection[];
}

export interface ResponseSection {
  title: string;
  content: string;
  type: 'text' | 'list' | 'table' | 'code' | 'insight';
}

class ResponseFormatter {
  /**
   * Parse response into sections
   */
  parseIntoSections(content: string): ResponseSection[] {
    const sections: ResponseSection[] = [];
    const lines = content.split('\n');
    let currentSection: ResponseSection | null = null;
    let currentContent: string[] = [];

    for (const line of lines) {
      // Detect section headers (## or ###)
      if (line.match(/^#{2,3}\s+/)) {
        if (currentSection) {
          currentSection.content = currentContent.join('\n').trim();
          sections.push(currentSection);
        }

        const title = line.replace(/^#{2,3}\s+/, '').trim();
        currentSection = {
          title,
          content: '',
          type: this.detectSectionType(title, content)
        };
        currentContent = [];
      } else if (currentSection) {
        currentContent.push(line);
      }
    }

    // Add final section
    if (currentSection) {
      currentSection.content = currentContent.join('\n').trim();
      sections.push(currentSection);
    }

    return sections.length > 0 ? sections : [
      {
        title: 'Response',
        content: content.trim(),
        type: 'text'
      }
    ];
  }

  /**
   * Detect section type from content
   */
  private detectSectionType(title: string, _content: string): ResponseSection['type'] {
    const lowerTitle = title.toLowerCase();

    if (lowerTitle.includes('insight') || lowerTitle.includes('recommendation')) {
      return 'insight';
    }
    if (lowerTitle.includes('list') || lowerTitle.includes('items')) {
      return 'list';
    }
    if (lowerTitle.includes('table') || lowerTitle.includes('comparison')) {
      return 'table';
    }
    if (lowerTitle.includes('code') || lowerTitle.includes('example')) {
      return 'code';
    }

    return 'text';
  }

  /**
   * Enhance markdown formatting
   */
  enhanceMarkdown(content: string): string {
    let enhanced = content;

    // Add emphasis to key terms
    enhanced = enhanced.replace(
      /\b(important|critical|urgent|note|warning|success|error)\b/gi,
      '**$1**'
    );

    // Format lists consistently
    enhanced = enhanced.replace(/^\s*[-â€¢]\s+/gm, 'â€¢ ');

    // Format numbered lists
    enhanced = enhanced.replace(/^\s*\d+\.\s+/gm, (match) => match);

    // Add spacing around headers
    enhanced = enhanced.replace(/^(#{1,6}\s+.+)$/gm, '\n$1\n');

    return enhanced.trim();
  }

  /**
   * Extract key metrics from response
   */
  extractMetrics(content: string): Record<string, any> {
    const metrics: Record<string, any> = {};

    // Extract numbers and percentages
    const numberMatches = content.match(/(\d+(?:\.\d+)?)\s*(%|products?|coverages?|forms?|states?|tasks?)/gi);
    if (numberMatches) {
      metrics.numbers = numberMatches.slice(0, 5);
    }

    // Extract action items
    const actionMatches = content.match(/(?:recommend|suggest|should|must|need to)\s+([^.!?]+)/gi);
    if (actionMatches) {
      metrics.actions = actionMatches.slice(0, 3);
    }

    return metrics;
  }

  /**
   * Format response with metadata
   */
  formatWithMetadata(
    content: string,
    metadata: ResponseMetadata
  ): FormattedResponse {
    const enhanced = this.enhanceMarkdown(content);
    const sections = this.parseIntoSections(enhanced);
    const metrics = this.extractMetrics(content);

    logger.debug(LOG_CATEGORIES.AI, 'Response formatted', {
      sections: sections.length,
      hasMetadata: !!metadata,
      metrics: Object.keys(metrics)
    });

    return {
      content: enhanced,
      metadata: {
        ...metadata,
        timestamp: Date.now()
      },
      isStructured: sections.length > 1,
      sections
    };
  }

  /**
   * Generate summary from response
   */
  generateSummary(content: string, maxLength: number = 150): string {
    const sentences = content.match(/[^.!?]+[.!?]+/g) || [];
    let summary = '';

    for (const sentence of sentences) {
      if ((summary + sentence).length <= maxLength) {
        summary += sentence;
      } else {
        break;
      }
    }

    return summary.trim() || content.substring(0, maxLength) + '...';
  }

  /**
   * Format for display with proper escaping
   */
  formatForDisplay(content: string): string {
    // Escape HTML special characters
    let formatted = content
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');

    // Restore markdown formatting
    formatted = formatted
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/`(.+?)`/g, '<code>$1</code>');

    return formatted;
  }

  /**
   * Calculate response quality score
   */
  calculateQualityScore(
    content: string,
    metadata: ResponseMetadata
  ): number {
    let score = 50; // Base score

    // Length bonus (200-2000 chars is ideal)
    if (content.length >= 200 && content.length <= 2000) {
      score += 15;
    }

    // Structure bonus
    if (content.includes('##') || content.includes('â€¢')) {
      score += 15;
    }

    // Specificity bonus
    if (content.match(/\d+/)) {
      score += 10;
    }

    // Confidence bonus
    if (metadata.confidence && metadata.confidence > 0.8) {
      score += 10;
    }

    return Math.min(score, 100);
  }
}

export const responseFormatter = new ResponseFormatter();
export default responseFormatter;

```

---

## src/services/validationService.ts

**Path:** `src/services/validationService.ts`

```typescript
/**
 * Consolidated Validation Service
 * Comprehensive validation for all insurance product data
 * Merged from: validationService.ts, dataValidationService.ts, coverageValidation.ts, ruleValidation.ts, stateValidation.ts
 */

import {
  collection,
  query,
  where,
  getDocs,
  doc,
  getDoc,
  Timestamp
} from 'firebase/firestore';
import { db } from '../firebase';
import { Product, Coverage, Form, PricingStep, Rule, StateApplicability } from '../types';
import logger, { LOG_CATEGORIES } from '../utils/logger';

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  metadata?: Record<string, unknown>;
}

export interface ValidationError {
  field: string;
  message: string;
  severity: 'error';
  code: string;
}

export interface ValidationWarning {
  field: string;
  message: string;
  severity: 'warning';
  code: string;
}

export interface ReferentialIntegrityReport {
  orphanedCoverages: string[];
  orphanedForms: string[];
  orphanedRules: string[];
  brokenFormMappings: string[];
  invalidStateReferences: string[];
  totalIssues: number;
}

// ============================================================================
// Product Validation
// ============================================================================

export function validateProduct(product: Partial<Product>): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  // Required fields
  if (!product.name || product.name.trim().length === 0) {
    errors.push({
      field: 'name',
      message: 'Product name is required',
      severity: 'error',
      code: 'PRODUCT_NAME_REQUIRED'
    });
  }

  // Name length validation
  if (product.name && product.name.length > 100) {
    errors.push({
      field: 'name',
      message: 'Product name must be 100 characters or less',
      severity: 'error',
      code: 'PRODUCT_NAME_TOO_LONG'
    });
  }

  // Status validation
  if (product.status && !['active', 'inactive', 'draft'].includes(product.status)) {
    errors.push({
      field: 'status',
      message: 'Invalid product status',
      severity: 'error',
      code: 'INVALID_PRODUCT_STATUS'
    });
  }

  // Category validation
  if (product.category && product.category.length > 50) {
    warnings.push({
      field: 'category',
      message: 'Category name is unusually long',
      severity: 'warning',
      code: 'CATEGORY_NAME_LONG'
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

// ============================================================================
// Coverage Validation
// ============================================================================

/**
 * Validation options for coverage
 */
export interface CoverageValidationOptions {
  mode: 'draft' | 'publish';
}

/**
 * Extended validation result with completeness scoring
 */
export interface CoverageValidationResult extends ValidationResult {
  completenessScore: number;
  missingRequiredFields: string[];
  readyToPublish: boolean;
}

/**
 * Required fields for publishing a coverage
 */
const COVERAGE_REQUIRED_FOR_PUBLISH = [
  'name',
  'coverageCode',
  'productId',
];

/**
 * Fields that contribute to completeness scoring
 */
const COVERAGE_COMPLETENESS_FIELDS: { field: string; weight: number; label: string }[] = [
  { field: 'name', weight: 15, label: 'Coverage Name' },
  { field: 'coverageCode', weight: 10, label: 'Coverage Code' },
  { field: 'description', weight: 10, label: 'Description' },
  { field: 'coverageKind', weight: 5, label: 'Coverage Kind' },
  { field: 'coverageCategory', weight: 5, label: 'Coverage Category' },
  { field: 'coverageTrigger', weight: 8, label: 'Coverage Trigger' },
  { field: 'valuationMethod', weight: 8, label: 'Valuation Method' },
  { field: 'coinsurancePercentage', weight: 7, label: 'Coinsurance' },
  { field: 'availabilityStates', weight: 10, label: 'Availability States' },
  { field: 'territoryType', weight: 5, label: 'Territory Type' },
  { field: 'claimsReportingPeriod', weight: 5, label: 'Claims Reporting Period' },
  { field: 'hasSubrogationRights', weight: 4, label: 'Subrogation Rights' },
  { field: 'eligibilityCriteria', weight: 4, label: 'Eligibility Criteria' },
  { field: 'scopeOfCoverage', weight: 4, label: 'Scope of Coverage' },
];

/**
 * Calculate completeness score for a coverage
 */
export function calculateCoverageCompleteness(coverage: Partial<Coverage>): {
  score: number;
  filledFields: string[];
  missingFields: string[];
} {
  let totalWeight = 0;
  let earnedWeight = 0;
  const filledFields: string[] = [];
  const missingFields: string[] = [];

  for (const { field, weight, label } of COVERAGE_COMPLETENESS_FIELDS) {
    totalWeight += weight;
    const value = (coverage as Record<string, unknown>)[field];

    const isFilled = value !== undefined && value !== null && value !== '' &&
      !(Array.isArray(value) && value.length === 0);

    if (isFilled) {
      earnedWeight += weight;
      filledFields.push(label);
    } else {
      missingFields.push(label);
    }
  }

  return {
    score: Math.round((earnedWeight / totalWeight) * 100),
    filledFields,
    missingFields
  };
}

/**
 * Validate coverage with draft/publish mode support
 */
export function validateCoverage(
  coverage: Partial<Coverage>,
  options: CoverageValidationOptions = { mode: 'publish' }
): CoverageValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];
  const missingRequiredFields: string[] = [];
  const { mode } = options;

  // Calculate completeness
  const completeness = calculateCoverageCompleteness(coverage);

  // Required fields (only enforced in publish mode)
  if (!coverage.name || coverage.name.trim().length === 0) {
    if (mode === 'publish') {
      errors.push({
        field: 'name',
        message: 'Coverage name is required',
        severity: 'error',
        code: 'COVERAGE_NAME_REQUIRED'
      });
    }
    missingRequiredFields.push('name');
  }

  if (!coverage.productId) {
    if (mode === 'publish') {
      errors.push({
        field: 'productId',
        message: 'Product ID is required',
        severity: 'error',
        code: 'PRODUCT_ID_REQUIRED'
      });
    }
    missingRequiredFields.push('productId');
  }

  // Coverage code - required for publish
  if (!coverage.coverageCode || coverage.coverageCode.trim().length === 0) {
    if (mode === 'publish') {
      errors.push({
        field: 'coverageCode',
        message: 'Coverage code is required for publishing',
        severity: 'error',
        code: 'COVERAGE_CODE_REQUIRED'
      });
    }
    missingRequiredFields.push('coverageCode');
  } else if (!/^[A-Z0-9-]+$/i.test(coverage.coverageCode)) {
    // Format validation (always applies)
    warnings.push({
      field: 'coverageCode',
      message: 'Coverage code should contain only letters, numbers, and hyphens',
      severity: 'warning',
      code: 'INVALID_COVERAGE_CODE_FORMAT'
    });
  }

  // Business rule validations (apply to both modes)
  if (coverage.coinsurancePercentage !== undefined) {
    if (coverage.coinsurancePercentage < 0 || coverage.coinsurancePercentage > 100) {
      errors.push({
        field: 'coinsurancePercentage',
        message: 'Coinsurance percentage must be between 0 and 100',
        severity: 'error',
        code: 'INVALID_COINSURANCE_PERCENTAGE'
      });
    }
  }

  if (coverage.waitingPeriod !== undefined && coverage.waitingPeriod < 0) {
    errors.push({
      field: 'waitingPeriod',
      message: 'Waiting period cannot be negative',
      severity: 'error',
      code: 'NEGATIVE_WAITING_PERIOD'
    });
  }

  if (coverage.claimsReportingPeriod !== undefined && coverage.claimsReportingPeriod < 0) {
    errors.push({
      field: 'claimsReportingPeriod',
      message: 'Claims reporting period cannot be negative',
      severity: 'error',
      code: 'NEGATIVE_CLAIMS_REPORTING_PERIOD'
    });
  }

  // Coverage kind validation
  const validKinds = ['coverage', 'endorsement', 'exclusion', 'notice', 'condition'];
  if (coverage.coverageKind && !validKinds.includes(coverage.coverageKind)) {
    errors.push({
      field: 'coverageKind',
      message: `Invalid coverage kind: ${coverage.coverageKind}`,
      severity: 'error',
      code: 'INVALID_COVERAGE_KIND'
    });
  }

  // Endorsement-specific validation
  if (coverage.coverageKind === 'endorsement' && !coverage.modifiesCoverageId) {
    warnings.push({
      field: 'modifiesCoverageId',
      message: 'Endorsements should specify which coverage they modify',
      severity: 'warning',
      code: 'ENDORSEMENT_MISSING_TARGET'
    });
  }

  // Claims-made specific validation
  if (coverage.coverageTrigger === 'claimsMade' && !coverage.claimsReportingPeriod) {
    warnings.push({
      field: 'claimsReportingPeriod',
      message: 'Claims-made coverage should specify a claims reporting period',
      severity: 'warning',
      code: 'CLAIMS_MADE_MISSING_REPORTING_PERIOD'
    });
  }

  // ACV specific validation
  if (coverage.valuationMethod === 'ACV' && !coverage.depreciationMethod) {
    warnings.push({
      field: 'depreciationMethod',
      message: 'ACV valuation should specify a depreciation method',
      severity: 'warning',
      code: 'ACV_MISSING_DEPRECIATION_METHOD'
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    completenessScore: completeness.score,
    missingRequiredFields,
    readyToPublish: errors.length === 0 && missingRequiredFields.length === 0
  };
}

/**
 * Legacy validateCoverage function signature for backward compatibility
 * @deprecated Use validateCoverage with options instead
 */
export function validateCoverageBasic(coverage: Partial<Coverage>): ValidationResult {
  const result = validateCoverage(coverage, { mode: 'publish' });
  return {
    isValid: result.isValid,
    errors: result.errors,
    warnings: result.warnings
  };
}

// ============================================================================
// Form Validation
// ============================================================================

export function validateForm(form: Partial<Form>): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  // Required fields
  if (!form.formName || form.formName.trim().length === 0) {
    errors.push({
      field: 'formName',
      message: 'Form name is required',
      severity: 'error',
      code: 'FORM_NAME_REQUIRED'
    });
  }

  if (!form.formNumber || form.formNumber.trim().length === 0) {
    errors.push({
      field: 'formNumber',
      message: 'Form number is required',
      severity: 'error',
      code: 'FORM_NUMBER_REQUIRED'
    });
  }

  // Form number format validation (ISO standard: XX XX XX)
  if (form.formNumber && !/^[A-Z]{2}\s?\d{2}\s?\d{2}/.test(form.formNumber)) {
    warnings.push({
      field: 'formNumber',
      message: 'Form number does not match ISO standard format (e.g., CP 00 10)',
      severity: 'warning',
      code: 'NON_STANDARD_FORM_NUMBER'
    });
  }

  // Edition date validation
  if (form.edition && !/^\d{2}\/\d{2}$/.test(form.edition)) {
    warnings.push({
      field: 'edition',
      message: 'Edition should be in MM/YY format (e.g., 05/16)',
      severity: 'warning',
      code: 'INVALID_EDITION_FORMAT'
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

// ============================================================================
// Pricing Step Validation
// ============================================================================

export function validatePricingStep(step: Partial<PricingStep>): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  // Step type validation
  if (!step.stepType || !['factor', 'operand'].includes(step.stepType)) {
    errors.push({
      field: 'stepType',
      message: 'Step type must be either "factor" or "operand"',
      severity: 'error',
      code: 'INVALID_STEP_TYPE'
    });
  }

  // Factor step validation
  if (step.stepType === 'factor') {
    if (!step.stepName || step.stepName.trim().length === 0) {
      errors.push({
        field: 'stepName',
        message: 'Step name is required for factor steps',
        severity: 'error',
        code: 'STEP_NAME_REQUIRED'
      });
    }

    if (!step.coverages || step.coverages.length === 0) {
      errors.push({
        field: 'coverages',
        message: 'At least one coverage must be selected',
        severity: 'error',
        code: 'NO_COVERAGES_SELECTED'
      });
    }

    if (step.value !== undefined && step.value < 0) {
      warnings.push({
        field: 'value',
        message: 'Negative pricing factor may produce unexpected results',
        severity: 'warning',
        code: 'NEGATIVE_PRICING_FACTOR'
      });
    }
  }

  // Operand step validation
  if (step.stepType === 'operand') {
    if (!step.operand || !['+', '-', '*', '/', '='].includes(step.operand)) {
      errors.push({
        field: 'operand',
        message: 'Operand must be one of: +, -, *, /, =',
        severity: 'error',
        code: 'INVALID_OPERAND'
      });
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

// ============================================================================
// Rule Validation
// ============================================================================

export function validateRule(rule: Partial<Rule>): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  // Required fields
  if (!rule.name || rule.name.trim().length === 0) {
    errors.push({
      field: 'name',
      message: 'Rule name is required',
      severity: 'error',
      code: 'RULE_NAME_REQUIRED'
    });
  }

  if (!rule.condition || rule.condition.trim().length === 0) {
    errors.push({
      field: 'condition',
      message: 'Rule condition is required',
      severity: 'error',
      code: 'RULE_CONDITION_REQUIRED'
    });
  }

  if (!rule.outcome || rule.outcome.trim().length === 0) {
    errors.push({
      field: 'outcome',
      message: 'Rule outcome is required',
      severity: 'error',
      code: 'RULE_OUTCOME_REQUIRED'
    });
  }

  if (!rule.ruleType) {
    errors.push({
      field: 'ruleType',
      message: 'Rule type is required',
      severity: 'error',
      code: 'RULE_TYPE_REQUIRED'
    });
  }

  // Priority validation
  if (rule.priority !== undefined && (rule.priority < 0 || rule.priority > 100)) {
    warnings.push({
      field: 'priority',
      message: 'Priority should typically be between 0 and 100',
      severity: 'warning',
      code: 'UNUSUAL_PRIORITY_VALUE'
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

// ============================================================================
// Batch Validation
// ============================================================================

export function validateBatch<T>(
  items: T[],
  validator: (item: T) => ValidationResult
): { valid: T[]; invalid: Array<{ item: T; result: ValidationResult }> } {
  const valid: T[] = [];
  const invalid: Array<{ item: T; result: ValidationResult }> = [];

  for (const item of items) {
    const result = validator(item);
    if (result.isValid) {
      valid.push(item);
    } else {
      invalid.push({ item, result });
    }
  }

  return { valid, invalid };
}

// ============================================================================
// Referential Integrity Validation (from dataValidationService)
// ============================================================================

/**
 * Validate a product and all its relationships
 */
export async function validateProductIntegrity(productId: string): Promise<ValidationResult> {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  try {
    // Check product exists
    const productDoc = await getDoc(doc(db, 'products', productId));
    if (!productDoc.exists()) {
      errors.push({
        field: 'productId',
        message: `Product ${productId} does not exist`,
        severity: 'error',
        code: 'PRODUCT_NOT_FOUND'
      });
      return { isValid: false, errors, warnings };
    }

    const product = productDoc.data() as Product;

    // Validate product fields
    if (!product.name || product.name.trim().length === 0) {
      errors.push({
        field: 'name',
        message: 'Product name is required and cannot be empty',
        severity: 'error',
        code: 'PRODUCT_NAME_EMPTY'
      });
    }

    if (product.effectiveDate && product.expirationDate) {
      const effectiveDate = product.effectiveDate instanceof Timestamp
        ? product.effectiveDate.toDate()
        : new Date(product.effectiveDate);
      const expirationDate = product.expirationDate instanceof Timestamp
        ? product.expirationDate.toDate()
        : new Date(product.expirationDate);

      if (effectiveDate >= expirationDate) {
        errors.push({
          field: 'dates',
          message: 'Product effective date must be before expiration date',
          severity: 'error',
          code: 'INVALID_DATE_RANGE'
        });
      }
    }

    // Validate coverages exist
    const coveragesSnap = await getDocs(
      collection(db, `products/${productId}/coverages`)
    );
    if (coveragesSnap.empty) {
      warnings.push({
        field: 'coverages',
        message: 'Product has no coverages defined',
        severity: 'warning',
        code: 'NO_COVERAGES'
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      metadata: { productId, coverageCount: coveragesSnap.size }
    };
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Product integrity validation failed',
      { productId }, error as Error);
    errors.push({
      field: 'validation',
      message: 'Failed to validate product integrity',
      severity: 'error',
      code: 'VALIDATION_ERROR'
    });
    return { isValid: false, errors, warnings };
  }
}

/**
 * Check referential integrity across all entities
 */
export async function checkReferentialIntegrity(productId: string): Promise<ReferentialIntegrityReport> {
  const report: ReferentialIntegrityReport = {
    orphanedCoverages: [],
    orphanedForms: [],
    orphanedRules: [],
    brokenFormMappings: [],
    invalidStateReferences: [],
    totalIssues: 0
  };

  try {
    // Check for orphaned coverages
    const coveragesSnap = await getDocs(
      collection(db, `products/${productId}/coverages`)
    );

    for (const coverageDoc of coveragesSnap.docs) {
      const coverage = coverageDoc.data() as Coverage;
      if (!coverage.name || !coverage.coverageType) {
        report.orphanedCoverages.push(coverageDoc.id);
      }
    }

    // Check for orphaned forms
    const formsSnap = await getDocs(
      query(collection(db, 'forms'), where('productId', '==', productId))
    );

    for (const formDoc of formsSnap.docs) {
      const form = formDoc.data() as Form;
      if (!form.formName || !form.formNumber) {
        report.orphanedForms.push(formDoc.id);
      }
    }

    // Check for orphaned rules
    const rulesSnap = await getDocs(
      query(collection(db, 'rules'), where('productId', '==', productId))
    );

    for (const ruleDoc of rulesSnap.docs) {
      const rule = ruleDoc.data() as Rule;
      if (!rule.name || !rule.condition) {
        report.orphanedRules.push(ruleDoc.id);
      }
    }

    report.totalIssues =
      report.orphanedCoverages.length +
      report.orphanedForms.length +
      report.orphanedRules.length +
      report.brokenFormMappings.length +
      report.invalidStateReferences.length;

    return report;
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Referential integrity check failed',
      { productId }, error as Error);
    return report;
  }
}

/**
 * Validate state code
 */
export function validateStateCode(state: string): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  const validStates = ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
                       'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
                       'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
                       'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
                       'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'];

  if (!state || state.trim().length === 0) {
    errors.push({
      field: 'state',
      message: 'State code is required',
      severity: 'error',
      code: 'STATE_REQUIRED'
    });
  } else if (!validStates.includes(state.toUpperCase())) {
    errors.push({
      field: 'state',
      message: `Invalid state code: ${state}`,
      severity: 'error',
      code: 'INVALID_STATE_CODE'
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Validate a coverage limit
 */
export function validateCoverageLimit(limit: Partial<CoverageLimit>): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  if (!limit.limitType) {
    errors.push({
      field: 'limitType',
      message: 'Limit type is required',
      severity: 'error'
    });
  }

  if (limit.amount === undefined || limit.amount === null) {
    errors.push({
      field: 'amount',
      message: 'Limit amount is required',
      severity: 'error'
    });
  } else if (typeof limit.amount === 'number' && limit.amount < 0) {
    errors.push({
      field: 'amount',
      message: 'Limit amount must be a positive number',
      severity: 'error'
    });
  }

  if (!limit.displayValue || limit.displayValue.trim() === '') {
    warnings.push({
      field: 'displayValue',
      message: 'Display value is recommended for better readability',
      severity: 'warning'
    });
  }

  // Min/max validation
  if (limit.minAmount !== undefined && limit.maxAmount !== undefined) {
    if (limit.minAmount > limit.maxAmount) {
      errors.push({
        field: 'minAmount',
        message: 'Minimum amount cannot be greater than maximum amount',
        severity: 'error'
      });
    }
  }

  if (limit.amount !== undefined && limit.minAmount !== undefined && limit.amount < limit.minAmount) {
    errors.push({
      field: 'amount',
      message: 'Amount cannot be less than minimum amount',
      severity: 'error'
    });
  }

  if (limit.amount !== undefined && limit.maxAmount !== undefined && limit.amount > limit.maxAmount) {
    errors.push({
      field: 'amount',
      message: 'Amount cannot be greater than maximum amount',
      severity: 'error'
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Validate a coverage deductible
 */
export function validateCoverageDeductible(deductible: Partial<CoverageDeductible>): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  if (!deductible.deductibleType) {
    errors.push({
      field: 'deductibleType',
      message: 'Deductible type is required',
      severity: 'error'
    });
  }

  if (deductible.amount === undefined || deductible.amount === null) {
    errors.push({
      field: 'amount',
      message: 'Deductible amount is required',
      severity: 'error'
    });
  } else if (typeof deductible.amount === 'number' && deductible.amount < 0) {
    errors.push({
      field: 'amount',
      message: 'Deductible amount must be a positive number',
      severity: 'error'
    });
  }

  // Percentage validation
  if (deductible.deductibleType === 'percentage' && deductible.amount !== undefined) {
    if (typeof deductible.amount === 'number' && (deductible.amount < 0 || deductible.amount > 100)) {
      errors.push({
        field: 'amount',
        message: 'Percentage must be between 0 and 100',
        severity: 'error'
      });
    }
    if (typeof deductible.amount === 'number' && deductible.amount > 50) {
      warnings.push({
        field: 'amount',
        message: 'Percentage deductible above 50% is unusual',
        severity: 'warning'
      });
    }
  }

  if (!deductible.displayValue || deductible.displayValue.trim() === '') {
    warnings.push({
      field: 'displayValue',
      message: 'Display value is recommended for better readability',
      severity: 'warning'
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Format validation result into a readable string
 */
export function formatValidationResult(result: ValidationResult): string {
  const messages: string[] = [];

  if (result.errors.length > 0) {
    messages.push('Errors:');
    result.errors.forEach(error => {
      messages.push(`  â€¢ ${error.message}`);
    });
  }

  if (result.warnings.length > 0) {
    if (messages.length > 0) messages.push('');
    messages.push('Warnings:');
    result.warnings.forEach(warning => {
      messages.push(`  â€¢ ${warning.message}`);
    });
  }

  return messages.join('\n');
}

// ============================================================================
// Rule Helper Functions (from ruleValidation.ts)
// ============================================================================

/**
 * Validate rule type
 */
export function isValidRuleType(ruleType: string): boolean {
  return ['Product', 'Coverage', 'Forms', 'Pricing'].includes(ruleType);
}

/**
 * Validate rule category
 */
export function isValidRuleCategory(category: string): boolean {
  return ['Eligibility', 'Pricing', 'Compliance', 'Coverage', 'Forms'].includes(category);
}

/**
 * Validate rule status
 */
export function isValidRuleStatus(status: string): boolean {
  return ['Active', 'Inactive', 'Draft', 'Under Review', 'Archived'].includes(status);
}

/**
 * Sanitize rule data before saving
 */
export function sanitizeRule(rule: Partial<Rule>): Partial<Rule> {
  const sanitized: Partial<Rule> = { ...rule };

  // Trim string fields
  if (sanitized.name) sanitized.name = sanitized.name.trim();
  if (sanitized.condition) sanitized.condition = sanitized.condition.trim();
  if (sanitized.outcome) sanitized.outcome = sanitized.outcome.trim();
  if (sanitized.reference) sanitized.reference = sanitized.reference.trim();
  if (sanitized.productId) sanitized.productId = sanitized.productId.trim();
  if (sanitized.targetId) sanitized.targetId = sanitized.targetId.trim();

  // Remove targetId if rule type is Product
  if (sanitized.ruleType === 'Product') {
    delete sanitized.targetId;
  }

  // Set default values
  if (sanitized.proprietary === undefined) sanitized.proprietary = false;
  if (sanitized.status === undefined) sanitized.status = 'Draft';

  return sanitized;
}

/**
 * Check if a rule conflicts with existing rules
 */
export function checkRuleConflicts(
  newRule: Partial<Rule>,
  existingRules: Rule[]
): { hasConflict: boolean; conflicts: string[] } {
  const conflicts: string[] = [];

  // Check for duplicate names in same product
  const duplicateName = existingRules.find(
    rule =>
      rule.productId === newRule.productId &&
      rule.name.toLowerCase() === newRule.name?.toLowerCase() &&
      rule.id !== newRule.id
  );

  if (duplicateName) {
    conflicts.push(`A rule with the name "${newRule.name}" already exists for this product`);
  }

  // Check for identical conditions and outcomes
  const identicalRule = existingRules.find(
    rule =>
      rule.productId === newRule.productId &&
      rule.ruleType === newRule.ruleType &&
      rule.targetId === newRule.targetId &&
      rule.condition === newRule.condition &&
      rule.outcome === newRule.outcome &&
      rule.id !== newRule.id
  );

  if (identicalRule) {
    conflicts.push(`An identical rule already exists: "${identicalRule.name}"`);
  }

  return {
    hasConflict: conflicts.length > 0,
    conflicts
  };
}

/**
 * Validate rule before deletion
 */
export function validateRuleDeletion(rule: Rule): { canDelete: boolean; warnings: string[] } {
  const warnings: string[] = [];

  if (rule.status === 'Active') {
    warnings.push('This is an active rule. Deleting it may affect product behavior.');
  }

  if (rule.proprietary) {
    warnings.push('This is a proprietary rule. Make sure you have a backup.');
  }

  if (rule.priority !== undefined && rule.priority >= 80) {
    warnings.push('This is a high-priority rule. Verify it is safe to delete.');
  }

  return {
    canDelete: true,
    warnings
  };
}

// ============================================================================
// State Applicability Validation
// ============================================================================

/**
 * Validate that child entity states are a subset of parent entity states
 * Used for hierarchical state applicability (e.g., coverage states must be subset of product states)
 */
export function validateStateSubset(
  childStates: string[] | undefined,
  parentStates: string[] | undefined,
  entityName: string = 'Entity'
): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  // If child has no states, it's valid (inherits parent)
  if (!childStates || childStates.length === 0) {
    return { isValid: true, errors, warnings };
  }

  // If parent has no states, child can't have states
  if (!parentStates || parentStates.length === 0) {
    errors.push({
      field: 'states',
      message: `${entityName} cannot have state restrictions when parent has no state restrictions`,
      severity: 'error',
      code: 'STATE_SUBSET_INVALID'
    });
    return { isValid: false, errors, warnings };
  }

  // Check if all child states are in parent states
  const invalidStates = childStates.filter(state => !parentStates.includes(state));

  if (invalidStates.length > 0) {
    errors.push({
      field: 'states',
      message: `${entityName} states must be a subset of parent states. Invalid states: ${invalidStates.join(', ')}`,
      severity: 'error',
      code: 'STATE_SUBSET_MISMATCH'
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Validate state applicability record
 */
export function validateStateApplicability(stateApp: Partial<StateApplicability>): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  // Required fields
  if (!stateApp.state || stateApp.state.trim().length === 0) {
    errors.push({
      field: 'state',
      message: 'State code is required',
      severity: 'error',
      code: 'STATE_CODE_REQUIRED'
    });
  }

  if (!stateApp.entityId || stateApp.entityId.trim().length === 0) {
    errors.push({
      field: 'entityId',
      message: 'Entity ID is required',
      severity: 'error',
      code: 'ENTITY_ID_REQUIRED'
    });
  }

  if (!stateApp.entityType) {
    errors.push({
      field: 'entityType',
      message: 'Entity type is required',
      severity: 'error',
      code: 'ENTITY_TYPE_REQUIRED'
    });
  }

  // Validate state code format (2-letter US state code)
  if (stateApp.state && !/^[A-Z]{2}$/.test(stateApp.state)) {
    errors.push({
      field: 'state',
      message: 'State code must be a 2-letter US state abbreviation',
      severity: 'error',
      code: 'INVALID_STATE_CODE_FORMAT'
    });
  }

  // Validate subset if parent states are provided
  if (stateApp.isSubsetOf && stateApp.isSubsetOf.length > 0 && stateApp.state) {
    if (!stateApp.isSubsetOf.includes(stateApp.state)) {
      errors.push({
        field: 'state',
        message: `State ${stateApp.state} is not in the allowed parent states`,
        severity: 'error',
        code: 'STATE_NOT_IN_PARENT_SET'
      });
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

export default {
  validateProduct,
  validateCoverage,
  validateForm,
  validatePricingStep,
  validateRule,
  validateBatch,
  validateProductIntegrity,
  checkReferentialIntegrity,
  validateStateCode,
  validateCoverageLimit,
  validateCoverageDeductible,
  formatValidationResult,
  isValidRuleType,
  isValidRuleCategory,
  isValidRuleStatus,
  sanitizeRule,
  checkRuleConflicts,
  validateRuleDeletion,
  validateStateSubset,
  validateStateApplicability
};

```

---

## src/styled.d.ts

**Path:** `src/styled.d.ts`

```typescript
import 'styled-components';
import { theme } from './styles/theme';

type ThemeType = typeof theme;

declare module 'styled-components' {
  export interface DefaultTheme extends ThemeType {
    // Ensure all theme properties are available
    colours: ThemeType['colours'];
    colors: ThemeType['colors'];
    fontFamily?: string;
    radiusSm: string;
    radiusLg: string;
    shadowXl: string;
  }
}

```

---

## src/styles/GlobalStyle.ts

**Path:** `src/styles/GlobalStyle.ts`

```typescript
import { createGlobalStyle, keyframes } from 'styled-components';

/* -------- Gentle background pulse animation -------- */
const backgroundPulse = keyframes`
  0%   { transform: scale(1);   opacity: 0.6; filter: blur(60px); }
  50%  { transform: scale(1.35); opacity: 0.45; filter: blur(80px); }
  100% { transform: scale(1);   opacity: 0.6; filter: blur(60px); }
`;

/* gentle diagonal wave scroll - optimized */
const waveScroll = keyframes`
  from { background-position: 0 0; }
  to   { background-position: 400px 0; }
`;

/* subtle shimmer for loading states */
const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

export const GlobalStyle = createGlobalStyle`
  /* ---------- Reset & Base Styles ---------- */
  *,*::before,*::after { box-sizing:border-box; }

  html {
    scroll-behavior: smooth;
    text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;
    /* Apple-style font feature settings for elegant typography */
    font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1, 'cv01' 1, 'cv02' 1;
    font-optical-sizing: auto;
  }

  body {
    margin: 0;
    /* Apple-inspired system font stack */
    font-family: ${({ theme }) => theme.font};
    font-size: ${({ theme }) => theme.typography.body.size};
    line-height: ${({ theme }) => theme.typography.body.lineHeight};
    letter-spacing: ${({ theme }) => theme.typography.body.letterSpacing};
    font-weight: 400;
    background: linear-gradient(145deg, #f8fafc 0%, #f1f5f9 50%, #f8fafc 100%);
    color: ${({ theme }) => theme.colours.text};
    /* Apple-style font rendering for crisp, elegant text */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
    font-feature-settings: 'kern' 1, 'liga' 1, 'calt' 1;
    overflow-x: hidden;
    min-height: 100vh;
  }

  /* ---------- Focus States - Enhanced Accessibility (WCAG 2.1 AA) ---------- */
  /* Only hide outline for mouse users, preserve for keyboard navigation */
  :focus:not(:focus-visible) {
    outline: none;
  }

  /* Show clear focus indicator for keyboard users */
  :focus-visible {
    outline: 2px solid ${({ theme }) => theme.colours.primary};
    outline-offset: 3px;
    border-radius: 6px;
    transition: outline-offset 0.15s ease;
  }

  /* Enhanced interactive element focus with brand colors */
  button:focus-visible,
  a:focus-visible,
  [role="button"]:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colours.focusRing};
    border-color: ${({ theme }) => theme.colours.primary};
  }

  input:focus-visible,
  select:focus-visible,
  textarea:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colours.focusRing};
    border-color: ${({ theme }) => theme.colours.primary};
  }

  /* Skip link for keyboard navigation */
  .skip-link {
    position: absolute;
    top: -100px;
    left: 16px;
    z-index: 10000;
    padding: 12px 24px;
    background: ${({ theme }) => theme.colours.primary};
    color: white;
    font-weight: 600;
    border-radius: ${({ theme }) => theme.radiusMd};
    text-decoration: none;
    transition: top 0.2s ease;

    &:focus {
      top: 16px;
    }
  }

  /* Screen reader only utility */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* ---------- Selection Styles - Enhanced ---------- */
  ::selection {
    background: ${({ theme }) => theme.colours.primary};
    color: white;
    text-shadow: none;
  }

  ::-moz-selection {
    background: ${({ theme }) => theme.colours.primary};
    color: white;
    text-shadow: none;
  }

  /* ---------- Scrollbar Styling - Refined ---------- */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  ::-webkit-scrollbar-track {
    background: transparent;
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb {
    background: rgba(148, 163, 184, 0.4);
    border-radius: 4px;
    border: 2px solid transparent;
    background-clip: content-box;
    transition: background 0.2s ease;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: rgba(148, 163, 184, 0.6);
    background-clip: content-box;
  }

  ::-webkit-scrollbar-thumb:active {
    background: rgba(99, 102, 241, 0.5);
    background-clip: content-box;
  }

  /* Scrollbar corner */
  ::-webkit-scrollbar-corner {
    background: transparent;
  }

  /* Firefox scrollbar */
  * {
    scrollbar-width: thin;
    scrollbar-color: rgba(148, 163, 184, 0.4) transparent;
  }

  /* ---------- Typography Reset - Apple-Inspired ---------- */
  h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-family: ${({ theme }) => theme.fontDisplay};
    font-weight: 600;
    line-height: 1.2;
    color: ${({ theme }) => theme.colours.text};
    letter-spacing: -0.022em;
  }

  h1 {
    font-size: ${({ theme }) => theme.typography.h1.size};
    font-weight: ${({ theme }) => theme.typography.h1.weight};
    line-height: ${({ theme }) => theme.typography.h1.lineHeight};
    letter-spacing: ${({ theme }) => theme.typography.h1.letterSpacing};
  }

  h2 {
    font-size: ${({ theme }) => theme.typography.h2.size};
    font-weight: ${({ theme }) => theme.typography.h2.weight};
    line-height: ${({ theme }) => theme.typography.h2.lineHeight};
    letter-spacing: ${({ theme }) => theme.typography.h2.letterSpacing};
  }

  h3 {
    font-size: ${({ theme }) => theme.typography.h3.size};
    font-weight: ${({ theme }) => theme.typography.h3.weight};
    line-height: ${({ theme }) => theme.typography.h3.lineHeight};
    letter-spacing: ${({ theme }) => theme.typography.h3.letterSpacing};
  }

  h4 {
    font-size: ${({ theme }) => theme.typography.h4.size};
    font-weight: ${({ theme }) => theme.typography.h4.weight};
    line-height: ${({ theme }) => theme.typography.h4.lineHeight};
    letter-spacing: ${({ theme }) => theme.typography.h4.letterSpacing};
  }

  h5 {
    font-size: ${({ theme }) => theme.typography.h5.size};
    font-weight: ${({ theme }) => theme.typography.h5.weight};
    line-height: ${({ theme }) => theme.typography.h5.lineHeight};
    letter-spacing: ${({ theme }) => theme.typography.h5.letterSpacing};
  }

  p {
    margin: 0;
    color: ${({ theme }) => theme.colours.textSecondary};
    font-size: ${({ theme }) => theme.typography.body.size};
    line-height: ${({ theme }) => theme.typography.body.lineHeight};
  }

  /* Small/caption text */
  small {
    font-size: ${({ theme }) => theme.typography.small.size};
    line-height: ${({ theme }) => theme.typography.small.lineHeight};
    letter-spacing: ${({ theme }) => theme.typography.small.letterSpacing};
  }

  /* ---------- Links - Enhanced ---------- */
  a {
    color: inherit;
    text-decoration: none;
    transition: color ${({ theme }) => theme.transitions.fast},
                opacity ${({ theme }) => theme.transitions.fast};
  }

  a:hover {
    color: ${({ theme }) => theme.colours.primary};
  }

  /* ---------- Buttons & Inputs - Enhanced ---------- */
  button {
    font-family: inherit;
    font-size: inherit;
    cursor: pointer;
    border: none;
    background: none;
    padding: 0;
    transition: transform 0.15s ease, opacity 0.15s ease;
  }

  button:disabled {
    cursor: not-allowed;
    opacity: 0.5;
  }

  button:active:not(:disabled) {
    transform: scale(0.98);
  }

  input, textarea, select {
    font-family: inherit;
    font-size: inherit;
    color: ${({ theme }) => theme.colours.text};
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  /* Placeholder styling */
  input::placeholder,
  textarea::placeholder {
    color: ${({ theme }) => theme.colours.textMuted};
    opacity: 1;
  }

  /* ---------- Images ---------- */
  img, svg {
    display: block;
    max-width: 100%;
    height: auto;
  }

  /* SVG icon defaults */
  svg {
    flex-shrink: 0;
  }

  /* ---------- Lists ---------- */
  ul, ol {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  /* ---------- Tables - Enhanced ---------- */
  table {
    border-collapse: collapse;
    border-spacing: 0;
    width: 100%;
  }

  th, td {
    text-align: left;
    vertical-align: middle;
  }

  /* ---------- Reduced Motion ---------- */
  @media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }

  /* ---------- Subtle animated radial glow - Refined ---------- */
  body::before {
    content: '';
    position: fixed;
    top: -15vmax;
    left: -15vmax;
    width: 55vmax;
    height: 55vmax;
    z-index: -1;
    pointer-events: none;
    opacity: 0.8;

    background:
      radial-gradient(
        ellipse at 25% 25%,
        ${({ theme }) => theme.colours.primary}18 0%,
        ${({ theme }) => theme.colours.primary}08 35%,
        transparent 65%
      ),
      radial-gradient(
        ellipse at 75% 75%,
        ${({ theme }) => theme.colours.primaryDark}12 0%,
        transparent 50%
      );

    animation: ${backgroundPulse} 8s ease-in-out infinite alternate;
    will-change: transform, opacity;
  }

  /* ---------- Diagonal grid wave - Refined ---------- */
  body::after {
    content: '';
    position: fixed;
    top: -20vmax;
    left: -20vmax;
    width: 60vmax;
    height: 60vmax;
    z-index: -2;
    pointer-events: none;
    opacity: 0.6;

    background:
      repeating-linear-gradient(
        135deg,
        ${({ theme }) => theme.colours.primaryDark}06 0px,
        ${({ theme }) => theme.colours.primaryDark}06 1px,
        transparent 1px,
        transparent 16px
      );

    animation: ${waveScroll} 25s linear infinite;
    mix-blend-mode: multiply;
    will-change: background-position;
  }

  /* ---------- Utility Classes - Extended ---------- */
  .truncate {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .line-clamp-3 {
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  /* Fade in animation utility */
  .fade-in {
    animation: fadeIn 0.3s ease forwards;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Shimmer loading effect */
  .shimmer {
    background: linear-gradient(
      90deg,
      ${({ theme }) => theme.colours.backgroundAlt} 0%,
      ${({ theme }) => theme.colours.background} 50%,
      ${({ theme }) => theme.colours.backgroundAlt} 100%
    );
    background-size: 200% 100%;
    animation: ${shimmer} 1.5s ease-in-out infinite;
  }

  /* Glass effect utility */
  .glass {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(20px) saturate(180%);
    -webkit-backdrop-filter: blur(20px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  /* Hover lift effect */
  .hover-lift {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .hover-lift:hover {
    transform: translateY(-2px);
  }

  /* Interactive card base */
  .interactive-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    cursor: pointer;
  }

  .interactive-card:hover {
    transform: translateY(-2px);
    box-shadow: ${({ theme }) => theme.shadowCardHover};
  }

  .interactive-card:active {
    transform: translateY(0);
  }

  /* ---------- Wizard Animations ---------- */
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  @keyframes slideUp {
    from { transform: translateY(100%); }
    to { transform: translateY(0); }
  }

  @keyframes slideInRight {
    from { opacity: 0; transform: translateX(20px); }
    to { opacity: 1; transform: translateX(0); }
  }

  .animate-fade-in {
    animation: fadeIn 0.3s ease-out forwards;
  }

  .animate-slide-up {
    animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  .animate-slide-in-right {
    animation: slideInRight 0.2s ease-out forwards;
  }
`;
```

---

## src/styles/animations.ts

**Path:** `src/styles/animations.ts`

```typescript
/**
 * Centralized Animation Library
 * 
 * All reusable keyframe animations for the application.
 * Import from '@/styles/animations' to use.
 */

import { keyframes, css } from 'styled-components';

// ============ Fade Animations ============
export const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

export const fadeOut = keyframes`
  from { opacity: 1; }
  to { opacity: 0; }
`;

export const fadeInUp = keyframes`
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
`;

export const fadeInDown = keyframes`
  from { opacity: 0; transform: translateY(-8px); }
  to { opacity: 1; transform: translateY(0); }
`;

export const fadeInLeft = keyframes`
  from { opacity: 0; transform: translateX(-8px); }
  to { opacity: 1; transform: translateX(0); }
`;

export const fadeInRight = keyframes`
  from { opacity: 0; transform: translateX(8px); }
  to { opacity: 1; transform: translateX(0); }
`;

// ============ Scale Animations ============
export const scaleIn = keyframes`
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
`;

export const scaleOut = keyframes`
  from { opacity: 1; transform: scale(1); }
  to { opacity: 0; transform: scale(0.95); }
`;

export const successPop = keyframes`
  0% { transform: scale(0.8); opacity: 0; }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); opacity: 1; }
`;

// ============ Slide Animations ============
export const slideUp = keyframes`
  from { opacity: 0; transform: translateY(16px); }
  to { opacity: 1; transform: translateY(0); }
`;

export const slideDown = keyframes`
  from { opacity: 0; transform: translateY(-16px); }
  to { opacity: 1; transform: translateY(0); }
`;

export const slideInLeft = keyframes`
  from { transform: translateX(-100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
`;

export const slideInRight = keyframes`
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
`;

export const slideOutRight = keyframes`
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
`;

// ============ Loading Animations ============
export const spin = keyframes`
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
`;

export const pulse = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
`;

export const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

export const bounce = keyframes`
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
`;

// ============ Feedback Animations ============
export const shake = keyframes`
  0%, 100% { transform: translateX(0); }
  20%, 60% { transform: translateX(-4px); }
  40%, 80% { transform: translateX(4px); }
`;

export const highlight = keyframes`
  0% { background-color: rgba(99, 102, 241, 0.2); }
  100% { background-color: transparent; }
`;

export const ripple = keyframes`
  0% { transform: scale(0); opacity: 1; }
  100% { transform: scale(4); opacity: 0; }
`;

// ============ Float/Hover Animations ============
export const float = keyframes`
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-8px); }
`;

export const breathe = keyframes`
  0%, 100% { opacity: 0.95; }
  50% { opacity: 1; }
`;

export const glowPulse = keyframes`
  0%, 100% { opacity: 0.4; }
  50% { opacity: 0.8; }
`;

// ============ Progress Animations ============
export const progressIndeterminate = keyframes`
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
`;

export const progressStripe = keyframes`
  0% { background-position: 0 0; }
  100% { background-position: 40px 0; }
`;

// ============ Gradient Animations ============
export const gradientShift = keyframes`
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
`;

export const gradientFlow = keyframes`
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
`;

// ============ Animation CSS Mixins ============
export const hoverLiftEffect = css`
  transition: transform 0.2s ease, box-shadow 0.2s ease;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  &:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
`;

export const pressEffect = css`
  transition: transform 0.1s ease;

  &:active {
    transform: scale(0.98);
  }
`;

export const focusRingEffect = css`
  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.25);
  }
`;

/**
 * Animation Timing Presets
 * NOTE: For complete timing/easing definitions, use theme.transitions from @/styles/theme.ts
 * These are simplified re-exports for animation-specific use cases.
 */
export const timings = {
  instant: '100ms',
  fast: '150ms',
  normal: '220ms',
  slow: '300ms',
  slower: '400ms',
} as const;

export const easings = {
  ease: 'ease',
  easeIn: 'ease-in',
  easeOut: 'ease-out',
  easeInOut: 'ease-in-out',
  spring: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
  springSubtle: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
  bounce: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
  smooth: 'cubic-bezier(0.4, 0, 0.2, 1)',
} as const;

// ============ Advanced Animations ============

/** Staggered reveal for list items - use with animation-delay */
export const staggerReveal = keyframes`
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
`;

/** Morphing shape animation */
export const morphShape = keyframes`
  0%, 100% {
    border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%;
  }
  25% {
    border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%;
  }
  50% {
    border-radius: 50% 60% 30% 60% / 30% 50% 70% 40%;
  }
  75% {
    border-radius: 60% 40% 60% 40% / 70% 30% 50% 60%;
  }
`;

/** AI-inspired neural pulse */
export const neuralPulse = keyframes`
  0%, 100% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 0.8;
    transform: scale(1.05);
  }
`;

/** Elegant typing cursor */
export const typingCursor = keyframes`
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
`;

/** Smooth content reveal (clip-path based) */
export const clipReveal = keyframes`
  from {
    clip-path: polygon(0 0, 0 0, 0 100%, 0 100%);
  }
  to {
    clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
  }
`;

/** Circular reveal animation */
export const circleReveal = keyframes`
  from {
    clip-path: circle(0% at 50% 50%);
  }
  to {
    clip-path: circle(100% at 50% 50%);
  }
`;

/** Elastic bounce for attention */
export const elasticBounce = keyframes`
  0% { transform: scale(1); }
  30% { transform: scale(1.15); }
  50% { transform: scale(0.95); }
  70% { transform: scale(1.05); }
  100% { transform: scale(1); }
`;

/** Subtle attention wobble */
export const wobble = keyframes`
  0%, 100% { transform: rotate(0deg); }
  25% { transform: rotate(-3deg); }
  75% { transform: rotate(3deg); }
`;

/** Smooth slide and fade for modals */
export const modalEnter = keyframes`
  from {
    opacity: 0;
    transform: translateY(-20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
`;

export const modalExit = keyframes`
  from {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
  to {
    opacity: 0;
    transform: translateY(10px) scale(0.98);
  }
`;

/** Overlay fade for modals/dialogs */
export const overlayEnter = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

export const overlayExit = keyframes`
  from { opacity: 1; }
  to { opacity: 0; }
`;

/** Progress bar animation */
export const progressLoad = keyframes`
  0% { width: 0%; }
  100% { width: 100%; }
`;

/** Indeterminate progress animation */
export const indeterminateProgress = keyframes`
  0% { transform: translateX(-100%); }
  100% { transform: translateX(400%); }
`;

/** Check mark draw animation */
export const drawCheck = keyframes`
  0% { stroke-dashoffset: 100; }
  100% { stroke-dashoffset: 0; }
`;

/** Content skeleton shimmer */
export const skeletonShimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

/** Notification badge pop */
export const badgePop = keyframes`
  0% { transform: scale(0); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
`;

/** Gentle breathing for AI elements */
export const aiBreathing = keyframes`
  0%, 100% {
    opacity: 0.7;
    transform: scale(1);
    filter: blur(20px);
  }
  50% {
    opacity: 1;
    transform: scale(1.02);
    filter: blur(25px);
  }
`;

/** Data flow animation for charts/graphs */
export const dataFlow = keyframes`
  0% {
    stroke-dashoffset: 1000;
    opacity: 0;
  }
  50% { opacity: 1; }
  100% {
    stroke-dashoffset: 0;
    opacity: 1;
  }
`;

// ============ Animation Helper CSS Mixins ============

/** Staggered children animation mixin */
export const staggeredChildren = css`
  & > * {
    animation: ${staggerReveal} 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
  }
  ${Array.from({ length: 12 }, (_, i) => `
    & > *:nth-child(${i + 1}) {
      animation-delay: ${i * 50}ms;
    }
  `).join('')}
`;

/** Glass hover effect mixin */
export const glassHoverEffect = css`
  transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
              box-shadow 0.3s ease,
              background 0.3s ease;

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1),
                0 8px 16px rgba(0, 0, 0, 0.05);
    background: rgba(255, 255, 255, 0.95);
  }

  &:active {
    transform: translateY(-2px);
    transition: transform 0.1s ease;
  }
`;

/** Card interaction effect */
export const cardInteractionEffect = css`
  transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1),
              box-shadow 0.25s ease,
              border-color 0.25s ease;
  cursor: pointer;

  &:hover {
    transform: translateY(-6px) scale(1.01);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.12),
                0 8px 16px rgba(0, 0, 0, 0.06);
    border-color: rgba(99, 102, 241, 0.3);
  }

  &:active {
    transform: translateY(-2px) scale(0.99);
    transition: transform 0.1s ease;
  }
`;

/** AI glow effect for special elements */
export const aiGlowEffect = css`
  position: relative;

  &::before {
    content: '';
    position: absolute;
    inset: -2px;
    background: linear-gradient(135deg, #6366f1, #8b5cf6, #06b6d4);
    border-radius: inherit;
    opacity: 0;
    z-index: -1;
    filter: blur(12px);
    transition: opacity 0.3s ease;
  }

  &:hover::before {
    opacity: 0.5;
  }
`;
```

---

## src/styles/copilotAnimations.ts

**Path:** `src/styles/copilotAnimations.ts`

```typescript
/**
 * Premium Copilot Animations
 * Sophisticated micro-interactions for AI-assisted coverage creation
 */

import { keyframes, css } from 'styled-components';

// AI Field Update - Purple glow pulse when AI populates a field
export const aiFieldUpdate = keyframes`
  0% { 
    box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
    background-color: transparent;
  }
  15% { 
    box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
    background-color: rgba(139, 92, 246, 0.08);
  }
  100% { 
    box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
    background-color: transparent;
  }
`;

// Sparkle rotation for AI indicator
export const aiSparkle = keyframes`
  0%, 100% { 
    opacity: 1; 
    transform: scale(1) rotate(0deg);
  }
  25% { 
    opacity: 0.9; 
    transform: scale(1.15) rotate(90deg);
  }
  50% { 
    opacity: 0.8; 
    transform: scale(1.1) rotate(180deg);
  }
  75% { 
    opacity: 0.9; 
    transform: scale(1.15) rotate(270deg);
  }
`;

// Gentle pulse for active AI processing
export const aiPulse = keyframes`
  0%, 100% { 
    opacity: 1;
    transform: scale(1);
  }
  50% { 
    opacity: 0.7;
    transform: scale(1.05);
  }
`;

// Shimmer effect for loading states
export const shimmer = keyframes`
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
`;

// Slide in from right
export const slideInRight = keyframes`
  from { 
    opacity: 0; 
    transform: translateX(20px);
  }
  to { 
    opacity: 1; 
    transform: translateX(0);
  }
`;

// Slide in from bottom
export const slideInUp = keyframes`
  from { 
    opacity: 0; 
    transform: translateY(12px);
  }
  to { 
    opacity: 1; 
    transform: translateY(0);
  }
`;

// Fade in with scale
export const fadeInScale = keyframes`
  from { 
    opacity: 0; 
    transform: scale(0.95);
  }
  to { 
    opacity: 1; 
    transform: scale(1);
  }
`;

// Success check animation
export const successCheck = keyframes`
  0% { 
    stroke-dashoffset: 24;
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% { 
    stroke-dashoffset: 0;
    opacity: 1;
  }
`;

// Confetti burst for completion
export const confettiBurst = keyframes`
  0% { 
    opacity: 1;
    transform: translateY(0) rotate(0deg) scale(1);
  }
  100% { 
    opacity: 0;
    transform: translateY(-80px) rotate(720deg) scale(0);
  }
`;

// Progress fill animation
export const progressFill = keyframes`
  from { width: 0%; }
  to { width: var(--progress-width, 100%); }
`;

// Glow pulse for active elements
export const glowPulse = keyframes`
  0%, 100% { 
    box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4);
  }
  50% { 
    box-shadow: 0 0 20px 4px rgba(99, 102, 241, 0.2);
  }
`;

// CSS mixins for common animation patterns
export const aiFieldHighlight = css`
  animation: ${aiFieldUpdate} 1.5s ease-out;
`;

export const aiProcessingIndicator = css`
  animation: ${aiPulse} 1.5s ease-in-out infinite;
`;

export const shimmerLoading = css`
  background: linear-gradient(
    90deg,
    rgba(139, 92, 246, 0.05) 0%,
    rgba(139, 92, 246, 0.15) 50%,
    rgba(139, 92, 246, 0.05) 100%
  );
  background-size: 200% 100%;
  animation: ${shimmer} 1.5s ease-in-out infinite;
`;

export const staggeredFadeIn = (index: number, baseDelay = 50) => css`
  animation: ${fadeInScale} 0.3s ease-out;
  animation-delay: ${index * baseDelay}ms;
  animation-fill-mode: both;
`;

```

---

## src/styles/theme.ts

**Path:** `src/styles/theme.ts`

```typescript
/**
 * Global theme object for the application
 * NOTE: Components reference `theme.colours.*` (British spelling).
 * We keep an identical `colors` alias so either spelling works.
 *
 * Enhanced with modern design tokens for micro-interactions,
 * refined shadows, and improved visual hierarchy.
 */

// Color palette - base colors with enhanced semantic variations
const palette = {
  /** brand - refined indigo spectrum */
  primary:        '#6366f1',
  primaryDark:    '#4f46e5',
  primaryDarker:  '#4338ca',
  primaryLight:   '#eef2ff',
  primaryLighter: '#f5f7ff',
  primaryHover:   '#5b5bf6',
  primaryActive:  '#4f46e5',
  primaryGlow:    'rgba(99, 102, 241, 0.5)',
  focusRing:      'rgba(99, 102, 241, 0.25)',

  /** greys / text - improved contrast (WCAG AA compliant) */
  text:           '#0f172a',
  textSecondary:  '#475569',
  textMuted:      '#64748b', // Changed from #94a3b8 for 4.5:1 contrast ratio
  textInverse:    '#ffffff',
  secondaryText:  '#1e293b',

  /** backgrounds & borders - subtle layering */
  background:     '#ffffff',
  backgroundAlt:  '#f8fafc',
  backgroundSubtle: '#f1f5f9',
  backgroundElevated: '#ffffff',
  tableHeader:    '#f8fafc',
  border:         '#e2e8f0',
  borderLight:    '#f1f5f9',
  borderFocus:    '#6366f1',
  hover:          '#f1f5f9',
  hoverSubtle:    'rgba(99, 102, 241, 0.04)',

  /** semantic colors - refined palette */
  success:        '#10b981',
  successLight:   '#d1fae5',
  successLighter: '#ecfdf5',
  successDark:    '#059669',
  warning:        '#f59e0b',
  warningLight:   '#fef3c7',
  warningLighter: '#fffbeb',
  warningDark:    '#d97706',
  error:          '#ef4444',
  errorLight:     '#fee2e2',
  errorLighter:   '#fef2f2',
  errorDark:      '#dc2626',
  info:           '#3b82f6',
  infoLight:      '#dbeafe',
  infoLighter:    '#eff6ff',
  infoDark:       '#2563eb',

  /** accents - modern gradients */
  gradient:       'linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%)',
  gradientSubtle: 'linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%)',
  gradientVibrant: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 35%, #06b6d4 100%)',
  danger:         '#dc2626',
  dangerHover:    '#b91c1c',
  secondaryLight: '#f1f5f9',
  buttonBackground: '#ffffff',

  /** interactive states - refined opacity levels */
  focusRingSubtle: 'rgba(99, 102, 241, 0.2)',
  overlay:        'rgba(15, 23, 42, 0.6)',
  overlayLight:   'rgba(15, 23, 42, 0.4)',
  overlaySubtle:  'rgba(15, 23, 42, 0.2)',
  shimmer:        'rgba(255, 255, 255, 0.6)',
};

// Application theme with enhanced design tokens
export const theme = {
  /** main colour map (preferred British spelling) */
  colours: palette,

  /** alias for components that imported `theme.colors` */
  colors: palette,

  /** shared primitives - refined radius scale */
  radius: '10px',
  radiusXs: '4px',
  radiusSm: '6px',
  radiusMd: '12px',
  radiusLg: '16px',
  radiusXl: '20px',
  radiusXxl: '24px',
  radiusFull: '9999px',

  /** shadows - refined elevation scale with colored shadows */
  shadow: '0 1px 3px rgba(0,0,0,0.04), 0 2px 8px rgba(0,0,0,0.04)',
  shadowSm: '0 1px 2px rgba(0,0,0,0.04)',
  shadowMd: '0 4px 12px rgba(0,0,0,0.06), 0 2px 4px rgba(0,0,0,0.04)',
  shadowLg: '0 8px 24px rgba(0,0,0,0.08), 0 4px 8px rgba(0,0,0,0.04)',
  shadowXl: '0 16px 48px rgba(0,0,0,0.12), 0 8px 16px rgba(0,0,0,0.06)',
  shadowInner: 'inset 0 2px 4px rgba(0,0,0,0.04)',
  shadowFocus: '0 0 0 3px rgba(99, 102, 241, 0.2)',
  shadowElevated: '0 20px 60px rgba(0,0,0,0.1), 0 8px 24px rgba(0,0,0,0.06)',
  shadowCard: '0 2px 8px rgba(0,0,0,0.04), 0 4px 16px rgba(0,0,0,0.04)',
  shadowCardHover: '0 8px 24px rgba(0,0,0,0.08), 0 4px 12px rgba(0,0,0,0.04)',
  shadowPrimary: '0 4px 16px rgba(99, 102, 241, 0.25)',
  shadowPrimaryHover: '0 8px 24px rgba(99, 102, 241, 0.35)',

  /**
   * Apple-inspired font stack
   * SF Pro Display for headings, SF Pro Text for body
   * Falls back to system fonts for cross-platform consistency
   */
  font: `-apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', 'Segoe UI', Roboto, system-ui, sans-serif`,
  fontDisplay: `-apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', 'Segoe UI', system-ui, sans-serif`,
  fontText: `-apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', 'Segoe UI', system-ui, sans-serif`,
  fontMono: `'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace`,

  /** spacing scale (multiples of 4px) - extended */
  spacing: {
    xxs: '2px',
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
    xxl: '48px',
    xxxl: '64px',
    '4xl': '80px',
  },

  /**
   * Apple-inspired typography scale
   * Clean, elegant sizing with refined letter-spacing
   * Based on Apple's Human Interface Guidelines
   */
  typography: {
    // Large titles - bold and impactful
    h1: { size: '34px', weight: '700', lineHeight: '1.18', letterSpacing: '-0.022em' },
    h2: { size: '28px', weight: '600', lineHeight: '1.21', letterSpacing: '-0.018em' },
    h3: { size: '22px', weight: '600', lineHeight: '1.27', letterSpacing: '-0.014em' },
    h4: { size: '18px', weight: '600', lineHeight: '1.33', letterSpacing: '-0.01em' },
    h5: { size: '16px', weight: '600', lineHeight: '1.38', letterSpacing: '-0.006em' },
    // Body text - optimized for readability
    body: { size: '15px', weight: '400', lineHeight: '1.53', letterSpacing: '-0.009em' },
    bodySmall: { size: '14px', weight: '400', lineHeight: '1.43', letterSpacing: '-0.006em' },
    small: { size: '13px', weight: '400', lineHeight: '1.38', letterSpacing: '-0.003em' },
    caption: { size: '12px', weight: '500', lineHeight: '1.33', letterSpacing: '0' },
    label: { size: '14px', weight: '500', lineHeight: '1.36', letterSpacing: '-0.003em' },
    overline: { size: '11px', weight: '600', lineHeight: '1.45', letterSpacing: '0.06em' },
    // Navigation specific
    nav: { size: '14px', weight: '500', lineHeight: '1.29', letterSpacing: '-0.006em' },
  },

  /** animation timing - enhanced with micro-interaction curves */
  transitions: {
    instant: '100ms ease',
    fast: '150ms ease',
    normal: '220ms ease',
    slow: '300ms ease',
    slower: '400ms ease',
    spring: '300ms cubic-bezier(0.34, 1.56, 0.64, 1)',
    springSubtle: '250ms cubic-bezier(0.25, 0.46, 0.45, 0.94)',
    bounce: '500ms cubic-bezier(0.68, -0.55, 0.265, 1.55)',
    smooth: '300ms cubic-bezier(0.4, 0, 0.2, 1)',
    enter: '220ms cubic-bezier(0, 0, 0.2, 1)',
    exit: '180ms cubic-bezier(0.4, 0, 1, 1)',
    expand: '250ms cubic-bezier(0.4, 0, 0.2, 1)',
  },

  /** z-index scale - extended */
  zIndex: {
    base: 0,
    raised: 10,
    dropdown: 100,
    sticky: 200,
    fixed: 250,
    overlay: 300,
    modal: 400,
    popover: 500,
    tooltip: 600,
    toast: 700,
    max: 9999,
  },

  /** breakpoints - extended */
  breakpoints: {
    xs: '480px',
    sm: '640px',
    md: '768px',
    lg: '1024px',
    xl: '1280px',
    xxl: '1536px',
    '3xl': '1920px',
  },

  /** glass morphism styles - refined */
  glass: {
    background: 'rgba(255, 255, 255, 0.92)',
    backgroundSubtle: 'rgba(255, 255, 255, 0.75)',
    backgroundStrong: 'rgba(255, 255, 255, 0.98)',
    backdropFilter: 'blur(24px) saturate(180%)',
    backdropFilterSubtle: 'blur(12px) saturate(150%)',
    border: '1px solid rgba(255, 255, 255, 0.3)',
    borderSubtle: '1px solid rgba(226, 232, 240, 0.5)',
  },

  /** page background gradient - refined */
  pageBackground: 'linear-gradient(145deg, #f8fafc 0%, #eef2f6 50%, #f1f5f9 100%)',

  /** overlay gradient - enhanced */
  overlayGradient: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 45%, #06b6d4 100%)',

  /** focus ring styles - improved accessibility */
  focusRing: `
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.25);
    border-color: #6366f1;
  `,
  focusRingSubtle: `
    outline: none;
    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.15);
  `,

  /** micro-interaction helpers */
  microInteractions: {
    hoverLift: 'translateY(-2px)',
    hoverLiftSubtle: 'translateY(-1px)',
    pressDown: 'translateY(1px)',
    scaleUp: 'scale(1.02)',
    scaleDown: 'scale(0.98)',
    iconBounce: 'translateY(-1px) scale(1.05)',
  },

  /** input styles - consistent form elements */
  input: {
    height: '44px',
    heightSm: '36px',
    heightLg: '52px',
    padding: '12px 16px',
    paddingSm: '8px 12px',
    paddingLg: '16px 20px',
    borderWidth: '1.5px',
    focusRingWidth: '3px',
  },

  /** AI-themed accent colors for intelligent UI elements */
  ai: {
    primary: '#6366f1',
    secondary: '#8b5cf6',
    tertiary: '#06b6d4',
    glow: 'rgba(99, 102, 241, 0.4)',
    glowStrong: 'rgba(99, 102, 241, 0.6)',
    gradient: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #06b6d4 100%)',
    gradientSubtle: 'linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 50%, rgba(6, 182, 212, 0.1) 100%)',
    pulse: 'rgba(99, 102, 241, 0.15)',
    spark: '#a855f7',
  },

  /** Glassmorphism 2.0 - Enhanced glass effects */
  glass2: {
    background: 'rgba(255, 255, 255, 0.85)',
    backgroundDark: 'rgba(15, 23, 42, 0.85)',
    backgroundSubtle: 'rgba(255, 255, 255, 0.6)',
    backgroundFrosted: 'rgba(248, 250, 252, 0.92)',
    backdropFilter: 'blur(20px) saturate(180%)',
    backdropFilterStrong: 'blur(40px) saturate(200%)',
    backdropFilterSubtle: 'blur(8px) saturate(150%)',
    border: '1px solid rgba(255, 255, 255, 0.25)',
    borderSubtle: '1px solid rgba(255, 255, 255, 0.12)',
    borderGlow: '1px solid rgba(99, 102, 241, 0.25)',
    shadow: '0 8px 32px rgba(0, 0, 0, 0.08), 0 4px 16px rgba(0, 0, 0, 0.04)',
    shadowElevated: '0 24px 64px rgba(0, 0, 0, 0.12), 0 8px 24px rgba(0, 0, 0, 0.06)',
    innerGlow: 'inset 0 1px 0 rgba(255, 255, 255, 0.5)',
    innerGlowSubtle: 'inset 0 1px 0 rgba(255, 255, 255, 0.2)',
  },

  /** Motion design tokens for sophisticated animations */
  motion: {
    /** Duration presets */
    duration: {
      instant: '50ms',
      fast: '100ms',
      normal: '200ms',
      slow: '300ms',
      slower: '500ms',
      slowest: '800ms',
    },
    /** Easing curves */
    easing: {
      linear: 'linear',
      ease: 'ease',
      easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
      easeOut: 'cubic-bezier(0, 0, 0.2, 1)',
      easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
      spring: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
      springGentle: 'cubic-bezier(0.25, 0.8, 0.25, 1)',
      springBouncy: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
      springSmooth: 'cubic-bezier(0.22, 1, 0.36, 1)',
      anticipate: 'cubic-bezier(0.38, -0.4, 0.88, 0.65)',
      overshoot: 'cubic-bezier(0.64, -0.2, 0.36, 1.2)',
    },
    /** Stagger delays for list/grid animations */
    stagger: {
      fast: '30ms',
      normal: '50ms',
      slow: '80ms',
    },
  },

  /** Enhanced card styles */
  card: {
    background: 'rgba(255, 255, 255, 0.95)',
    backgroundHover: 'rgba(255, 255, 255, 1)',
    border: '1px solid rgba(226, 232, 240, 0.8)',
    borderHover: '1px solid rgba(99, 102, 241, 0.3)',
    borderRadius: '16px',
    borderRadiusSm: '12px',
    borderRadiusLg: '20px',
    shadow: '0 4px 16px rgba(0, 0, 0, 0.04), 0 2px 8px rgba(0, 0, 0, 0.02)',
    shadowHover: '0 12px 32px rgba(0, 0, 0, 0.08), 0 4px 16px rgba(0, 0, 0, 0.04)',
    shadowActive: '0 6px 20px rgba(0, 0, 0, 0.06), 0 2px 8px rgba(0, 0, 0, 0.03)',
    padding: '24px',
    paddingSm: '16px',
    paddingLg: '32px',
  },

  /** Skeleton loading styles */
  skeleton: {
    background: 'linear-gradient(90deg, #f1f5f9 0%, #e2e8f0 50%, #f1f5f9 100%)',
    backgroundSize: '200% 100%',
    animationDuration: '1.5s',
    borderRadius: '8px',
  },

  /** Notification/Status indicator colors */
  status: {
    online: '#22c55e',
    offline: '#94a3b8',
    busy: '#f59e0b',
    away: '#fb923c',
    error: '#ef4444',
  },

  /** Dark mode preparation - color mappings */
  darkMode: {
    background: '#0f172a',
    backgroundAlt: '#1e293b',
    backgroundElevated: '#334155',
    text: '#f1f5f9',
    textSecondary: '#94a3b8',
    textMuted: '#64748b',
    border: '#334155',
    borderLight: '#475569',
  },
};
```

---

## src/types/index.ts

**Path:** `src/types/index.ts`

```typescript
/**
 * Core Type Definitions for Insurance Product Hub
 * Centralized type definitions for the entire application
 *
 * Enhancements:
 * - Normalized data structures with relational mappings
 * - Strong typing with required fields and generics
 * - Comprehensive audit trails and versioning
 */

import { Timestamp } from 'firebase/firestore';

// ============================================================================
// Product Types
// ============================================================================

export interface Product {
  id: string;
  /** Product code for internal reference (e.g., 'CP-001') */
  productCode?: string;
  name: string;
  description?: string;
  /** Product category (e.g., 'Commercial Property', 'BOP', 'Auto') */
  category?: string;
  status?: 'active' | 'inactive' | 'draft';
  /** Whether this product is archived (soft delete) */
  archived?: boolean;

  // State Availability
  states?: string[];                // State codes where product is available (e.g., ['CA', 'NY', 'TX'])
  excludedStates?: string[];        // State codes where product is NOT available
  availableStates?: string[];       // Alias for states (for consistency)

  // Versioning & Effective Dates
  version?: number;                 // Version number for tracking changes
  effectiveDate?: Timestamp | Date;  // When this product becomes effective
  expirationDate?: Timestamp | Date; // When this product expires

  // Denormalized Statistics (maintained by CF triggers)
  /** Count of coverages in this product */
  coverageCount?: number;
  /** Count of forms linked to this product */
  formCount?: number;
  /** Count of rules for this product */
  ruleCount?: number;
  /** Count of packages for this product */
  packageCount?: number;

  // Relational mappings (normalized for scalability)
  coverageIds?: string[];           // Array of coverage IDs linked to this product
  formIds?: string[];               // Array of form IDs linked to this product
  ruleIds?: string[];               // Array of rule IDs linked to this product
  packageIds?: string[];            // Array of package IDs linked to this product

  // Audit Trail
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;               // User who created this product
  updatedBy?: string;               // User who last updated this product
  changeReason?: string;            // Reason for last change

  metadata?: Record<string, unknown>;
}

export interface ProductFormData {
  name: string;
  description?: string;
  category?: string;
  status?: 'active' | 'inactive' | 'draft';
}

// ============================================================================
// Coverage Types
// ============================================================================

// Limit Types
export type LimitType =
  | 'perOccurrence'      // Per occurrence/per claim limit
  | 'aggregate'          // Annual aggregate limit
  | 'perPerson'          // Per person limit (liability)
  | 'perLocation'        // Per location limit (property)
  | 'sublimit'           // Sublimit for specific perils/property
  | 'combined'           // Combined single limit
  | 'split';             // Split limits (e.g., 100/300/100)

// Deductible Types
export type DeductibleType =
  | 'flat'               // Fixed dollar amount
  | 'percentage'         // Percentage of insured value or loss
  | 'franchise'          // Nothing if loss < deductible, full if >
  | 'disappearing'       // Reduces as loss increases
  | 'perOccurrence'      // Applied per claim
  | 'aggregate'          // Annual aggregate deductible
  | 'waiting';           // Waiting period (time deductible)



// Coverage Trigger Types
export type CoverageTrigger =
  | 'occurrence'      // Standard occurrence-based trigger
  | 'claimsMade'      // Claims-made trigger
  | 'hybrid'          // Combination of occurrence and claims-made
  | 'manifestation'   // Coverage triggered when injury/damage manifests
  | 'exposure'        // Coverage triggered when exposure to cause occurs
  | 'continuous'      // Coverage triggered over continuous period
  | 'injuryInFact';   // Coverage triggered when actual injury occurs

// Valuation Methods
export type ValuationMethod = 'ACV' | 'RC' | 'agreedValue' | 'marketValue' | 'functionalRC' | 'statedAmount';

// Depreciation Methods
export type DepreciationMethod = 'straightLine' | 'decliningBalance' | 'none';

// Territory Types
export type TerritoryType = 'worldwide' | 'USA' | 'stateSpecific' | 'custom';

// Endorsement Types
export type EndorsementType = 'broadening' | 'restrictive' | 'clarifying' | 'additional';

// Premium Basis
export type PremiumBasis = 'flat' | 'perUnit' | 'rated' | 'manual';

// ========== NEW: Coverage Kind & Draft Types ==========

/**
 * CoverageKind distinguishes the nature of the coverage item
 * - coverage: Standard insurance coverage providing protection
 * - endorsement: Modifies or extends an existing coverage
 * - exclusion: Specifically excludes certain risks
 * - notice: Informational notice or disclosure
 * - condition: Policy condition affecting coverage
 */
export type CoverageKind = 'coverage' | 'endorsement' | 'exclusion' | 'notice' | 'condition';

/**
 * Draft status for coverage creation workflow
 */
export type CoverageDraftStatus = 'draft' | 'published';

/**
 * Source of coverage creation
 */
export type CoverageDraftSource = 'manual' | 'ai' | 'template' | 'clone' | 'form_import';

/**
 * Coverage draft stored in products/{productId}/coverageDrafts/{draftId}
 */
export interface CoverageDraft {
  id: string;
  productId: string;

  // Draft state
  draft: Partial<Coverage>;
  status: CoverageDraftStatus;
  source: CoverageDraftSource;

  // Template/clone reference
  sourceTemplateId?: string;
  sourceCloneId?: string;
  sourceFormId?: string;

  // Completeness tracking
  completenessScore?: number;
  missingRequiredFields?: string[];
  validationWarnings?: string[];

  // Last AI interaction
  lastAIPatchAt?: Timestamp | Date;
  aiPatchHistory?: Array<{
    patchedAt: Timestamp | Date;
    fieldsChanged: string[];
    messageId?: string;
  }>;

  // Metadata
  createdAt: Timestamp | Date;
  updatedAt: Timestamp | Date;
  createdBy?: string;
  updatedBy?: string;
}

/**
 * Conversation message for coverage copilot
 * Stored in products/{productId}/coverageDrafts/{draftId}/messages/{messageId}
 */
export interface CoverageCopilotMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  createdAt: Timestamp | Date;

  // AI response metadata
  patch?: Partial<Coverage>;
  questions?: Array<{
    id: string;
    text: string;
    fieldHints?: string[];
  }>;
  suggestions?: string[];
  warnings?: string[];
}

/**
 * AI response from coverageAssistant cloud function
 */
export interface CoverageCopilotResponse {
  assistant_message: string;
  patch: Partial<Coverage>;
  questions: Array<{
    id: string;
    text: string;
    fieldHints?: string[];
  }>;
  missing_required_for_publish: string[];
  suggested_template_ids?: string[];
  near_matches?: Array<{
    coverageId: string;
    name: string;
    similarity: number;
    why: string;
  }>;
  warnings?: string[];
}

/**
 * Coverage similarity match for duplicate detection
 */
export interface CoverageSimilarityMatch {
  coverageId: string;
  name: string;
  coverageCode?: string;
  similarity: number;
  why: string;
  matchedFields: string[];
}

/**
 * CoverageLimit represents a structured limit for a coverage
 * Stored in subcollection: products/{productId}/coverages/{coverageId}/limits/{limitId}
 */
export interface CoverageLimit {
  id: string;
  coverageId: string;
  productId: string;

  // Limit Details
  limitType: LimitType;
  amount: number;
  displayValue: string;  // '$1,000,000' or '100/300/100'

  // Applicability
  appliesTo?: string[];  // Specific perils, property types, or situations
  description?: string;
  states?: string[];    // State-specific applicability

  // Behavior
  isDefault?: boolean;
  isRequired?: boolean;
  minAmount?: number;
  maxAmount?: number;

  // Relationships
  parentLimitId?: string;  // For sublimits that reduce from parent

  // Versioning & Effective Dates
  version?: number;
  effectiveDate?: Timestamp | Date;
  expirationDate?: Timestamp | Date;
  displayOrder?: number;

  // Metadata
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;
  updatedBy?: string;
}

/**
 * CoverageDeductible represents a structured deductible for a coverage
 * Stored in subcollection: products/{productId}/coverages/{coverageId}/deductibles/{deductibleId}
 */
export interface CoverageDeductible {
  id: string;
  coverageId: string;
  productId: string;

  // Deductible Details
  deductibleType: DeductibleType;
  amount?: number;           // For flat deductibles
  percentage?: number;       // For percentage deductibles (e.g., 2 for 2%)
  displayValue: string;      // '$1,000' or '2%' or '30 days'

  // Applicability
  appliesTo?: string[];      // Specific perils or situations
  description?: string;
  states?: string[];         // State-specific applicability

  // Behavior
  isDefault?: boolean;
  isRequired?: boolean;
  minAmount?: number;
  maxAmount?: number;

  // Special Rules for Percentage Deductibles
  minimumRetained?: number;  // Minimum dollar amount retained
  maximumRetained?: number;  // Maximum dollar amount retained

  // Special Rules for Disappearing Deductibles
  disappearingSchedule?: {
    lossAmount: number;
    deductibleAmount: number;
  }[];

  // Versioning & Effective Dates
  version?: number;
  effectiveDate?: Timestamp | Date;
  expirationDate?: Timestamp | Date;
  displayOrder?: number;

  // Metadata
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;
  updatedBy?: string;
}



/**
 * Coverage represents an insurance coverage that can be part of a product.
 * Coverages can be hierarchical - a coverage with parentCoverageId is a sub-coverage.
 *
 * Database Structure:
 * - Stored in: products/{productId}/coverages/{coverageId}
 * - Sub-coverages use parentCoverageId to reference their parent
 * - Forms are linked via formCoverages junction table (not stored here)
 * - Limits stored in subcollection: limits/{limitId}
 * - Deductibles stored in subcollection: deductibles/{deductibleId}
 */
export interface Coverage {
  // ========== Identity & Hierarchy ==========
  id: string;
  productId: string;
  name: string;
  description?: string;
  coverageCode?: string;

  // Hierarchical structure - if set, this is a sub-coverage
  parentCoverageId?: string;

  // ========== Classification ==========
  type?: string;
  isOptional?: boolean;

  /**
   * Kind of coverage item - distinguishes standard coverages from endorsements, exclusions, etc.
   * Default: 'coverage'
   */
  coverageKind?: CoverageKind;

  // ========== Coverage Scope ==========
  scopeOfCoverage?: string;
  perilsCovered?: string[];
  exclusions?: string[];           // Specific exclusions for this coverage
  insurableObjects?: string[];     // Types of property/objects covered (e.g., 'buildings', 'contents', 'equipment')
  excludedObjects?: string[];      // Types of property/objects NOT covered

  // ========== Financial Structure ==========
  /**
   * @deprecated Use Limits subcollection instead
   * Kept for backward compatibility during migration
   */
  limits?: string[];

  /**
   * @deprecated Use Deductibles subcollection instead
   * Kept for backward compatibility during migration
   */
  deductibles?: string[];

  // Premium Structure
  premiumBasis?: PremiumBasis;
  ratePerUnit?: number;
  minimumPremium?: number;
  premium?: number;

  // ========== Coinsurance & Participation ==========
  coinsurancePercentage?: number;  // Legacy single value - 80, 90, 100
  coinsuranceOptions?: number[];   // Available coinsurance percentages (e.g., [80, 90, 100])
  coinsuranceMinimum?: number;     // Minimum coinsurance percentage allowed
  coinsuranceMaximum?: number;     // Maximum coinsurance percentage allowed
  hasCoinsurancePenalty?: boolean;
  insuredParticipation?: number;   // Percentage insured pays (copay)
  coinsuranceWaiver?: boolean;     // Whether coinsurance can be waived

  // ========== Coverage Triggers & Periods ==========
  coverageTrigger?: CoverageTrigger;
  waitingPeriod?: number;
  waitingPeriodUnit?: 'days' | 'months';
  allowRetroactiveDate?: boolean;
  extendedReportingPeriod?: number;  // Months

  // ========== Valuation ==========
  valuationMethod?: ValuationMethod;
  depreciationMethod?: DepreciationMethod;
  valuationMethods?: ValuationMethod[];  // Multiple valuation methods allowed
  agreedValueAmount?: number;      // For agreed value valuation

  // ========== Territory ==========
  territoryType?: TerritoryType;
  /**
   * @deprecated Use availabilityStates for product availability.
   * states field maintained for backward compatibility.
   * For policy territory clauses, use territoryType + includedTerritories/excludedTerritories.
   */
  states?: string[];
  excludedTerritories?: string[];
  includedTerritories?: string[];

  /**
   * Product availability by state - which states this coverage is available for sale
   * Preferred over legacy 'states' field for new coverages.
   */
  availabilityStates?: string[];

  // ========== Endorsement Metadata ==========
  modifiesCoverageId?: string;      // Which coverage this endorsement modifies
  endorsementType?: EndorsementType;
  supersedes?: string[];            // Coverage IDs this replaces

  // ========== Underwriting ==========
  /**
   * Underwriter approval requirement:
   * - 'yes' = Always requires underwriter approval
   * - 'no' = Auto-approved, no underwriter review needed
   * - 'conditional' = Requires approval based on eligibility criteria
   * @deprecated Use underwriterApprovalType instead (kept for backward compatibility)
   */
  requiresUnderwriterApproval?: boolean;

  /**
   * Underwriter approval type (preferred over requiresUnderwriterApproval):
   * - 'yes' = Always requires underwriter approval
   * - 'no' = Auto-approved, no underwriter review needed
   * - 'conditional' = Requires approval based on eligibility criteria
   */
  underwriterApprovalType?: 'yes' | 'no' | 'conditional';
  eligibilityCriteria?: string[];
  prohibitedClasses?: string[];     // Business classes that can't buy this

  /**
   * @deprecated Use requiredCoverageIds for ID-based references
   * Kept for backward compatibility - contains coverage names
   */
  requiredCoverages?: string[];

  /**
   * @deprecated Use incompatibleCoverageIds for ID-based references
   * Kept for backward compatibility - contains coverage names
   */
  incompatibleCoverages?: string[];

  /**
   * Coverage IDs that must be purchased with this coverage (preferred over requiredCoverages)
   */
  requiredCoverageIds?: string[];

  /**
   * Coverage IDs that cannot be purchased with this coverage (preferred over incompatibleCoverages)
   */
  incompatibleCoverageIds?: string[];

  // ========== Claims ==========
  claimsReportingPeriod?: number;   // Days to report claim
  proofOfLossDeadline?: number;     // Days to submit proof
  hasSubrogationRights?: boolean;
  hasSalvageRights?: boolean;

  // ========== Versioning & Effective Dates ==========
  version?: number;                 // Version number for tracking changes
  effectiveDate?: Timestamp | Date;  // When this coverage becomes effective
  expirationDate?: Timestamp | Date; // When this coverage expires
  displayOrder?: number;            // Order for UI display

  // ========== Coverage Metadata & Classification ==========
  coverageCategory?: 'Liability' | 'Property' | 'Medical' | 'Other';
  lineOfBusiness?: string;          // e.g., "Commercial Auto", "Homeowners"
  dependsOnCoverageId?: string[];   // Coverage IDs this depends on

  // ========== Relationships & Counts (Normalized) ==========
  // Relational mappings for scalability
  formIds?: string[];               // Linked form IDs (denormalized for quick access)
  limitIds?: string[];              // Array of limit IDs in this coverage
  deductibleIds?: string[];         // Array of deductible IDs in this coverage
  subCoverageIds?: string[];        // Array of sub-coverage IDs under this coverage
  ruleIds?: string[];               // Array of rule IDs for this coverage

  // Cached counts (computed by Cloud Functions)
  ruleCount?: number;               // Cached count of rules for this coverage (computed)
  limitCount?: number;              // Count of limits in this coverage (computed)
  deductibleCount?: number;         // Count of deductibles in this coverage (computed)
  subCoverageCount?: number;        // Count of sub-coverages under this coverage (computed)
  formMappingCount?: number;        // Count of form mappings for this coverage (computed)

  // ========== Metadata ==========
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;               // User who created this coverage
  updatedBy?: string;               // User who last updated this coverage
  changeReason?: string;            // Reason for last change
  metadata?: Record<string, unknown>;

  // ========== Audit Trail (subcollection: auditLogs) ==========
  // Audit logs are stored in: products/{productId}/coverages/{coverageId}/auditLogs/{logId}
  // This field is for reference only; actual logs are in subcollection
  lastAuditLogId?: string;          // Reference to most recent audit log
}



export interface CoverageFormData {
  productId: string;
  name: string;
  description?: string;
  type?: string;
  parentCoverageId?: string;
  limits?: string[];
  deductibles?: string[];
  premium?: number;
  isOptional?: boolean;
  states?: string[];
}

/**
 * CoverageVersion represents a version of a coverage for regulatory compliance
 * Stored in subcollection: products/{productId}/coverages/{coverageId}/versions/{versionId}
 */
export interface CoverageVersion {
  id: string;
  coverageId: string;
  productId: string;

  // Version Info
  versionNumber: string;        // '1.0', '2.0', etc.
  effectiveDate: Date | Timestamp;
  expirationDate?: Date | Timestamp;

  // Change Tracking
  changes: string;              // Description of what changed
  changedBy?: string;           // User who made the change
  approvedBy?: string;          // Underwriter/manager who approved

  // Regulatory
  regulatoryFilingNumber?: string;
  stateApprovals?: {
    state: string;
    approvalDate: Date;
    filingNumber: string;
  }[];

  // Snapshot
  snapshot: Coverage;           // Full coverage data at this version

  // Metadata
  createdAt: Timestamp | Date;
}

/**
 * PackageType for coverage packages
 */
export type PackageType = 'required' | 'recommended' | 'popular' | 'custom';

/**
 * CoveragePackage represents a bundle of coverages
 * Stored in: products/{productId}/packages/{packageId}
 */
export interface CoveragePackage {
  id: string;
  productId: string;

  // Package Info
  name: string;
  description?: string;
  packageType: PackageType;

  // Coverages
  coverageIds: string[];

  // Pricing
  discountPercentage?: number;  // Package discount
  packagePremium?: number;      // Override individual premiums

  // Metadata
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
}

// ============================================================================
// Pricing Types
// ============================================================================

export interface PricingRule {
  id: string;
  productId: string;
  coverageId?: string;
  name: string;
  description?: string;
  ruleType: 'base' | 'modifier' | 'discount' | 'surcharge';
  value: number;
  valueType: 'percentage' | 'fixed';
  conditions?: PricingCondition[];
  priority?: number;
  isActive?: boolean;

  // Versioning & Effective Dates
  version?: number;
  effectiveDate?: Timestamp | Date;
  expirationDate?: Timestamp | Date;

  // State Applicability
  states?: string[];  // State-specific pricing rules
  dependsOnRuleId?: string[];  // Rule dependencies

  // Audit Trail
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;
  updatedBy?: string;
  changeReason?: string;
}

export interface PricingCondition {
  field: string;
  operator: 'equals' | 'greaterThan' | 'lessThan' | 'contains' | 'between';
  value: string | number | boolean | [number, number];
}

/**
 * PricingRuleRef represents a reference to a pricing rule within a pricing step
 */
export interface PricingRuleRef {
  /** ID of the pricing rule */
  ruleId: string;
  /** Optional weight/priority for this rule in the step */
  weight?: number;
}

/**
 * PricingStep represents a step in the pricing calculation process
 * Stored in: products/{productId}/pricingSteps/{stepId}
 */
export interface PricingStep {
  id: string;
  productId: string;

  // Step Identification
  /** Name of the pricing step (e.g., "Base Rate", "Territory Factor", "Protection Class") */
  name: string;
  /** Alternative name field for backward compatibility */
  stepName?: string;
  description?: string;

  // Step Type & Execution
  /** Type of pricing step: 'factor' applies a multiplier, 'operand' performs an operation */
  stepType?: 'factor' | 'operand';
  /** Order in which this step executes (0, 1, 2, ...) */
  order: number;
  /** Scope of this step: 'product' applies to all coverages, 'coverage' applies to specific coverage */
  scope: 'product' | 'coverage';
  /** Coverage ID when scope='coverage' */
  targetId?: string;

  // Factor Step Properties
  /** Coverages this step applies to (for factor steps) */
  coverages?: string[];
  /** Numeric value for the step (e.g., factor multiplier) */
  value?: number;

  // Operand Step Properties
  /** Mathematical operand for operand steps */
  operand?: '+' | '-' | '*' | '/' | '=';

  // Rules
  /** Ordered list of pricing rule references */
  rules: PricingRuleRef[];

  // Versioning & Effective Dates
  version?: string;
  effectiveDate?: Timestamp | Date;
  expirationDate?: Timestamp | Date;
  isActive?: boolean;

  // Audit Trail
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;
  updatedBy?: string;
}

/**
 * PremiumBreakdown represents the result of pricing calculation
 */
export interface PremiumBreakdown {
  /** Premium amount for each step */
  stepBreakdown: Record<string, number>;
  /** Total premium before adjustments */
  subtotal: number;
  /** Total adjustments (discounts/surcharges) */
  adjustments: number;
  /** Final premium */
  total: number;
  /** Metadata about the calculation */
  metadata?: Record<string, unknown>;
}

// ============================================================================
// Form Types
// ============================================================================

export interface FormField {
  id: string;
  name: string;
  label: string;
  type: 'text' | 'number' | 'select' | 'checkbox' | 'radio' | 'date' | 'textarea';
  required?: boolean;
  placeholder?: string;
  defaultValue?: string | number | boolean;
  options?: FormFieldOption[];
  validation?: FormFieldValidation;
  dependsOn?: string;
  metadata?: Record<string, unknown>;
}

export interface FormFieldOption {
  label: string;
  value: string | number;
}

export interface FormFieldValidation {
  min?: number;
  max?: number;
  pattern?: string;
  message?: string;
}

/**
 * FormTemplate represents an insurance form (policy form, endorsement, etc.)
 *
 * Database Structure:
 * - Stored in: forms/{formId}
 * - Linked to coverages via formCoverages junction table
 * - Do NOT store coverageIds or productIds arrays here (use formCoverages instead)
 */
export interface FormTemplate {
  id: string;

  // Form identification
  formNumber: string;
  formName?: string;
  formEditionDate?: string;

  // Primary product association (optional, for organizational purposes)
  productId?: string;

  // Form metadata
  name?: string;  // Deprecated: use formName instead
  description?: string;
  type?: string;  // e.g., 'coverage', 'endorsement', 'exclusion', 'notice'
  category?: string;

  // Form fields (for dynamic forms)
  fields?: FormField[];

  // Versioning & Effective Dates
  version?: string;
  effectiveDate?: string | Timestamp | Date;
  expirationDate?: string | Timestamp | Date;  // When this form version expires

  // State availability (informational - actual coverage availability via formCoverages)
  states?: string[];

  // File storage
  filePath?: string;
  downloadUrl?: string;

  // Status
  isActive?: boolean;

  // Audit Trail
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;               // User who created this form
  updatedBy?: string;               // User who last updated this form
  changeReason?: string;            // Reason for last change
}

/** @deprecated Use FormTemplate instead. Alias for backward compatibility. */
export type Form = FormTemplate;

/**
 * FormCoverageMapping represents the many-to-many relationship between forms and coverages.
 * This is the SINGLE SOURCE OF TRUTH for form-coverage relationships.
 *
 * Database Structure:
 * - Stored in: formCoverages/{mappingId}
 */
export interface FormCoverageMapping {
  id: string;
  formId: string;
  coverageId: string;
  productId: string;  // Denormalized for efficient querying

  // Mapping Metadata
  isPrimary?: boolean;  // Indicates primary form for coverage
  displayOrder?: number;  // Order for UI display
  notes?: string;  // Mapping-specific notes

  // State Applicability
  states?: string[];  // State-specific form-coverage mappings

  // Applicability Conditions
  applicabilityConditions?: {
    field: string;
    operator: 'equals' | 'greaterThan' | 'lessThan' | 'contains' | 'between';
    value: string | number | boolean | [number, number];
  }[];

  // Versioning & Effective Dates
  version?: number;
  effectiveDate?: Timestamp | Date;
  expirationDate?: Timestamp | Date;

  // Audit Trail
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;
  updatedBy?: string;
}

// ============================================================================
// State/Geography Types
// ============================================================================

export interface StateAvailability {
  id: string;
  productId: string;
  stateCode: string;
  stateName: string;
  isAvailable: boolean;
  effectiveDate?: Date | Timestamp;
  expirationDate?: Date | Timestamp;
  restrictions?: string[];
  metadata?: Record<string, unknown>;
}

// ============================================================================
// Rules Types
// ============================================================================

/**
 * Rule Type - defines what the rule applies to
 */
export type RuleType = 'Product' | 'Coverage' | 'Forms' | 'Pricing';

/**
 * Rule Category - defines the functional category of the rule
 */
export type RuleCategory = 'Eligibility' | 'Pricing' | 'Compliance' | 'Coverage' | 'Forms';

/**
 * Rule Status - defines the current state of the rule
 */
export type RuleStatus = 'Active' | 'Inactive' | 'Draft' | 'Under Review' | 'Archived';

/**
 * Rule represents a business rule in the insurance product system.
 * Rules can apply to products, coverages, forms, or pricing.
 *
 * Database Structure:
 * - Stored in: rules/{ruleId}
 * - Linked to products via productId
 * - Linked to specific entities via targetId (when ruleType is not 'Product')
 */
export interface Rule {
  id: string;
  productId: string;

  // Rule Classification
  ruleType: RuleType;
  ruleCategory: RuleCategory;

  // Target Entity (optional - only for Coverage, Forms, Pricing rules)
  targetId?: string;  // coverageId, formId, or pricingStepId depending on ruleType

  // Rule Content
  name: string;
  condition: string;      // The condition that triggers the rule
  outcome: string;        // The result when the condition is met
  reference?: string;     // Reference to policy language, form section, etc.

  // Rule Properties
  proprietary?: boolean;  // Is this a proprietary/custom rule?
  status: RuleStatus;
  priority?: number;      // For rule execution order

  // Versioning & Effective Dates
  version?: number;
  effectiveDate?: Timestamp | Date;
  expirationDate?: Timestamp | Date;

  // State Applicability
  states?: string[];  // State-specific rules
  dependsOnRuleId?: string[];  // Rule dependencies

  // Metadata
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;
  updatedBy?: string;
  changeReason?: string;
}



/**
 * Rule Template for quick rule creation
 */
export interface RuleTemplate {
  id: string;
  name: string;
  description: string;
  ruleType: RuleType;
  ruleCategory: RuleCategory;
  conditionTemplate: string;
  outcomeTemplate: string;
  isBuiltIn?: boolean;
  createdAt?: Timestamp | Date;
}

/**
 * Rule Validation Result
 */
export interface RuleValidationResult {
  isValid: boolean;
  errors: string[];
  warnings?: string[];
}

// ============================================================================
// Cache Types
// ============================================================================

export interface CacheEntry<T = unknown> {
  data: T;
  timestamp: number;
  expiresAt?: number;
  metadata?: Record<string, unknown>;
}

export interface CacheOptions {
  ttl?: number;
  priority?: 'low' | 'medium' | 'high';
  tags?: string[];
}

// ============================================================================
// Comprehensive State Applicability Types
// ============================================================================

/**
 * StateApplicability represents comprehensive state-specific information for products, coverages, and forms.
 * This is the SINGLE SOURCE OF TRUTH for state-specific data.
 *
 * Database Structure:
 * - Stored in: stateApplicability/{applicabilityId}
 * - Linked to products, coverages, or forms via entityId and entityType
 */
export interface StateApplicability {
  id: string;
  entityId: string;  // productId, coverageId, or formId
  entityType: 'product' | 'coverage' | 'form';
  productId: string;  // Denormalized for efficient querying

  // State Information
  state: string;  // State code (e.g., 'CA', 'NY')
  stateName: string;  // Full state name

  // Filing & Approval Status
  filingStatus?: 'pending' | 'filed' | 'approved' | 'rejected' | 'withdrawn';
  rateApprovalStatus?: 'pending' | 'approved' | 'denied' | 'conditional';
  complianceStatus?: 'compliant' | 'non-compliant' | 'under-review';

  // Effective Dates
  effectiveDate?: Timestamp | Date;
  expirationDate?: Timestamp | Date;

  // State-Specific Rules
  stateSpecificRules?: string[];  // Rule IDs that apply to this state
  stateSpecificForms?: string[];  // Form IDs specific to this state
  stateSpecificLimits?: string[];  // Limit IDs specific to this state
  stateSpecificDeductibles?: string[];  // Deductible IDs specific to this state

  // Regulatory Information
  regulatoryNotes?: string;
  filingNumber?: string;
  approvalDate?: Timestamp | Date;
  regulatoryAgency?: string;

  // Restrictions & Conditions
  restrictions?: string[];  // Any state-specific restrictions
  conditions?: string[];  // Any state-specific conditions

  // Subset Validation (for hierarchical entities)
  // When a coverage is state-specific, it must be a subset of product's states
  parentEntityId?: string;  // Reference to parent entity (e.g., productId for coverage state)
  isSubsetOf?: string[];    // State codes this must be a subset of
  validationStatus?: 'valid' | 'invalid' | 'pending-review';
  validationErrors?: string[];  // Errors if subset validation fails

  // Metadata
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
  createdBy?: string;
  updatedBy?: string;
}

// ============================================================================
// API Response Types
// ============================================================================

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: ApiError;
  metadata?: {
    timestamp: number;
    requestId?: string;
    cached?: boolean;
  };
}

export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  stack?: string;
}

// ============================================================================
// UI Component Types
// ============================================================================

export interface TableColumn<T = unknown> {
  key: keyof T | string;
  label: string;
  sortable?: boolean;
  filterable?: boolean;
  render?: (value: unknown, row: T) => React.ReactNode;
  width?: string | number;
}

export interface PaginationOptions {
  page: number;
  pageSize: number;
  total: number;
}

export interface SortOptions {
  field: string;
  direction: 'asc' | 'desc';
}

export interface FilterOptions {
  field: string;
  value: unknown;
  operator?: 'equals' | 'contains' | 'greaterThan' | 'lessThan';
}

// ============================================================================
// Utility Types
// ============================================================================

export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

export type Nullable<T> = T | null;

export type Optional<T> = T | undefined;

export type AsyncResult<T, E = Error> = Promise<{ data: T; error: null } | { data: null; error: E }>;

// ============================================================================
// Re-export Domain-Specific Types
// ============================================================================

// Pricing Types
export * from './pricing';
```

---

## src/types/pricing.ts

**Path:** `src/types/pricing.ts`

```typescript
/**
 * Pricing Engine Types
 * Defines types for pricing steps, rules, and calculations
 */

import { Timestamp } from 'firebase/firestore';

/**
 * DataDictionaryField represents a field used in pricing inputs and calculations
 * Stored in: products/{productId}/dataDictionary/{fieldId}
 */
export interface DataDictionaryField {
  id: string;
  productId: string;
  
  // Field Identification
  /** Unique field name (e.g., 'buildingSquareFootage', 'protectionClass') */
  name: string;
  /** Display label for UI (e.g., 'Building Square Footage') */
  label: string;
  /** Field description */
  description?: string;
  
  // Type & Validation
  /** Field data type */
  type: 'number' | 'string' | 'boolean' | 'enum' | 'date';
  /** Enum options if type='enum' */
  enumOptions?: string[];
  /** Minimum value for numeric fields */
  min?: number;
  /** Maximum value for numeric fields */
  max?: number;
  /** Whether field is required */
  required?: boolean;
  /** Default value */
  defaultValue?: string | number | boolean;
  
  // Display & Organization
  /** Category for grouping in UI (e.g., 'Building', 'Operations', 'Claims') */
  category?: string;
  /** Display order within category */
  displayOrder?: number;
  
  // Metadata
  createdAt?: Timestamp | Date;
  updatedAt?: Timestamp | Date;
}

/**
 * RatingInput represents user-provided input for rating calculation
 */
export interface RatingInput {
  [fieldName: string]: string | number | boolean | undefined;
}

/**
 * RatingResult represents the result of a rating calculation
 */
export interface RatingResult {
  /** Premium breakdown by step */
  stepBreakdown: Record<string, number>;
  /** Total premium */
  total: number;
  /** Calculation metadata */
  metadata?: {
    calculatedAt?: Date;
    productId?: string;
    coverageId?: string;
    inputsUsed?: RatingInput;
  };
}

```

---

## src/utils/aiTimeout.ts

**Path:** `src/utils/aiTimeout.ts`

```typescript
/**
 * AI Timeout Utilities
 * Handles timeouts for AI API calls with Promise.race and graceful degradation
 */

import logger, { LOG_CATEGORIES } from './logger';

/**
 * Timeout error
 */
export class TimeoutError extends Error {
  constructor(message: string = 'Operation timed out') {
    super(message);
    this.name = 'TimeoutError';
  }
}

/**
 * Create a timeout promise that rejects after specified duration
 */
export function createTimeoutPromise<T>(
  timeoutMs: number,
  timeoutMessage: string = 'Operation timed out'
): Promise<T> {
  return new Promise((_, reject) => {
    setTimeout(() => {
      reject(new TimeoutError(timeoutMessage));
    }, timeoutMs);
  });
}

/**
 * Execute promise with timeout
 */
export async function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  operationName: string = 'Operation'
): Promise<T> {
  try {
    return await Promise.race([
      promise,
      createTimeoutPromise<T>(
        timeoutMs,
        `${operationName} timed out after ${timeoutMs}ms`
      )
    ]);
  } catch (error) {
    if (error instanceof TimeoutError) {
      logger.warn(LOG_CATEGORIES.AI, `${operationName} timeout`, {
        timeoutMs,
        operationName
      });
    }
    throw error;
  }
}

/**
 * Execute promise with timeout and fallback
 */
export async function withTimeoutAndFallback<T>(
  promise: Promise<T>,
  timeoutMs: number,
  fallbackValue: T,
  operationName: string = 'Operation'
): Promise<T> {
  try {
    return await withTimeout(promise, timeoutMs, operationName);
  } catch (error) {
    if (error instanceof TimeoutError) {
      logger.warn(LOG_CATEGORIES.AI, `${operationName} timeout, using fallback`, {
        timeoutMs,
        operationName
      });
      return fallbackValue;
    }
    throw error;
  }
}

/**
 * Retry promise with timeout
 */
export interface RetryOptions {
  maxAttempts: number;
  delayMs: number;
  backoffMultiplier: number;
  timeoutMs: number;
}

export async function withTimeoutAndRetry<T>(
  promiseFn: () => Promise<T>,
  options: RetryOptions,
  operationName: string = 'Operation'
): Promise<T> {
  let lastError: Error | null = null;
  let delay = options.delayMs;

  for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {
    try {
      logger.debug(LOG_CATEGORIES.AI, `${operationName} attempt ${attempt}/${options.maxAttempts}`, {
        operationName,
        attempt
      });

      return await withTimeout(
        promiseFn(),
        options.timeoutMs,
        `${operationName} (attempt ${attempt})`
      );
    } catch (error) {
      lastError = error as Error;

      if (attempt < options.maxAttempts) {
        logger.warn(LOG_CATEGORIES.AI, `${operationName} attempt ${attempt} failed, retrying`, {
          operationName,
          attempt,
          error: (error as Error).message,
          nextRetryIn: delay
        });

        await new Promise(resolve => setTimeout(resolve, delay));
        delay *= options.backoffMultiplier;
      }
    }
  }

  logger.error(LOG_CATEGORIES.ERROR, `${operationName} failed after ${options.maxAttempts} attempts`, {}, lastError || new Error('Unknown error'));
  throw lastError || new Error(`${operationName} failed after ${options.maxAttempts} attempts`);
}

/**
 * Abort controller wrapper for fetch-based timeouts
 */
export function createAbortController(timeoutMs: number): AbortController {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  // Store timeout ID for cleanup
  (controller as any).__timeoutId = timeoutId;

  return controller;
}

/**
 * Clean up abort controller
 */
export function cleanupAbortController(controller: AbortController): void {
  const timeoutId = (controller as any).__timeoutId;
  if (timeoutId) {
    clearTimeout(timeoutId);
  }
}

/**
 * Fetch with timeout
 */
export async function fetchWithTimeout(
  url: string,
  options: RequestInit & { timeout?: number } = {}
): Promise<Response> {
  const { timeout = 30000, ...fetchOptions } = options;
  const controller = createAbortController(timeout);

  try {
    const response = await fetch(url, {
      ...fetchOptions,
      signal: controller.signal
    });
    cleanupAbortController(controller);
    return response;
  } catch (error) {
    cleanupAbortController(controller);
    if ((error as Error).name === 'AbortError') {
      throw new TimeoutError(`Fetch request timed out after ${timeout}ms`);
    }
    throw error;
  }
}

/**
 * Default retry options for AI operations
 */
export const DEFAULT_AI_RETRY_OPTIONS: RetryOptions = {
  maxAttempts: 3,
  delayMs: 1000,
  backoffMultiplier: 2,
  timeoutMs: 45000
};

/**
 * Aggressive retry options for critical operations
 */
export const AGGRESSIVE_RETRY_OPTIONS: RetryOptions = {
  maxAttempts: 5,
  delayMs: 500,
  backoffMultiplier: 1.5,
  timeoutMs: 60000
};

/**
 * Quick retry options for fast operations
 */
export const QUICK_RETRY_OPTIONS: RetryOptions = {
  maxAttempts: 2,
  delayMs: 500,
  backoffMultiplier: 1,
  timeoutMs: 15000
};

```

---

## src/utils/bundleOptimization.tsx

**Path:** `src/utils/bundleOptimization.tsx`

```tsx
/**
 * Bundle optimization utilities for the Product Hub App
 * Handles code splitting, lazy loading, and resource optimization
 */

import React, { lazy, Suspense, ComponentType, ReactNode } from 'react';
import logger, { LOG_CATEGORIES } from './logger';

interface LazyComponentOptions {
  fallback?: ReactNode;
  chunkName?: string;
}

// Simplified lazy loading using Vite's native support
export const createOptimizedLazyComponent = <P extends object = Record<string, never>>(
  importFn: () => Promise<{ default: ComponentType<P> }>,
  options: LazyComponentOptions = {}
): React.FC<P> => {
  const { fallback = null, chunkName = 'unknown' } = options;

  const LazyComponent = lazy(() =>
    importFn().catch(error => {
      logger.error(LOG_CATEGORIES.ERROR, `Failed to load chunk: ${chunkName}`, {}, error as Error);
      throw error;
    })
  );

  return (props: P) => (
    <Suspense fallback={fallback}>
      <LazyComponent {...props} />
    </Suspense>
  );
};

// Simplified resource hints for better loading performance
export const addResourceHints = () => {
  try {
    const head = document.head;
    const resourceHintExists = (rel: string, href: string) =>
      document.querySelector(`link[rel="${rel}"][href="${href}"]`) !== null;

    // DNS prefetch for external resources
    const dnsPrefetchUrls = [
      'https://fonts.googleapis.com',
      'https://firestore.googleapis.com',
      'https://firebase.googleapis.com'
    ];

    dnsPrefetchUrls.forEach(url => {
      if (!resourceHintExists('dns-prefetch', url)) {
        const link = document.createElement('link');
        link.rel = 'dns-prefetch';
        link.href = url;
        head.appendChild(link);
      }
    });

    // Preconnect to critical origins
    const preconnectUrls = [
      'https://fonts.gstatic.com',
      'https://firestore.googleapis.com'
    ];

    preconnectUrls.forEach(url => {
      if (!resourceHintExists('preconnect', url)) {
        const link = document.createElement('link');
        link.rel = 'preconnect';
        link.href = url;
        link.crossOrigin = 'anonymous';
        head.appendChild(link);
      }
    });
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to add resource hints', {}, error as Error);
  }
};


// Initialize bundle optimizations
export const initBundleOptimizations = () => {
  if (typeof window === 'undefined') return;

  try {
    addResourceHints();
    logger.debug(LOG_CATEGORIES.DATA, 'Bundle optimizations initialized');
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Bundle optimizations failed', {}, error as Error);
  }
};
```

---

## src/utils/core/index.ts

**Path:** `src/utils/core/index.ts`

```typescript
/**
 * Core Utilities Index
 * Centralized exports for core system utilities
 */

// Logging (includes performance monitoring and audit trail)
export * from '../logger';

// AI timeout utilities
export * from '../aiTimeout';

// PDF chunking
export * from '../pdfChunking';

// Performance monitoring
export * from '../performanceMonitor';

// Parallel processing
export * from '../parallelProcessor';
```

---

## src/utils/data/index.ts

**Path:** `src/utils/data/index.ts`

```typescript
/**
 * Data Utilities Index
 * Centralized exports for all data-related utilities
 */

// Firestore helpers
export * from '../firestoreHelpers';

// Storage utilities
export * from '../storage';

// Product cloning
export * from '../productClone';

// Format utilities
export * from '../format';

```

---

## src/utils/firestoreHelpers.ts

**Path:** `src/utils/firestoreHelpers.ts`

```typescript
/**
 * Firestore Helper Utilities
 * 
 * Utilities for working with Firestore data types, including
 * Timestamp conversion and data normalization.
 */

import { Timestamp } from 'firebase/firestore';

type TimestampLike = Timestamp | Date | string | null | undefined;

/**
 * Check if a value is a Firestore Timestamp
 */
export const isFirestoreTimestamp = (value: unknown): value is Timestamp => {
  return Boolean(value && typeof value === 'object' && 'seconds' in value && 'nanoseconds' in value);
};

/**
 * Convert Firestore Timestamp to Date object
 */
export const timestampToDate = (timestamp: TimestampLike): Date | null => {
  if (!timestamp) return null;

  if (isFirestoreTimestamp(timestamp)) {
    return timestamp.toDate();
  }

  if (timestamp instanceof Date) {
    return timestamp;
  }

  if (typeof timestamp === 'string') {
    const date = new Date(timestamp);
    return isNaN(date.getTime()) ? null : date;
  }

  return null;
};

type DateFormat = 'MM/DD/YYYY' | 'DD/MM/YYYY' | 'YYYY-MM-DD' | 'MMM DD, YYYY' | 'MMMM DD, YYYY';

/**
 * Convert Firestore Timestamp to formatted date string
 *
 * @param timestamp - Firestore Timestamp or Date
 * @param format - Format string (default: 'MM/DD/YYYY')
 * @returns Formatted date string or empty string if invalid
 */
export const formatFirestoreDate = (timestamp: TimestampLike, format: DateFormat = 'MM/DD/YYYY'): string => {
  const date = timestampToDate(timestamp);
  if (!date) return '';

  const day = String(date.getDate()).padStart(2, '0');
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const year = date.getFullYear();

  switch (format) {
    case 'MM/DD/YYYY':
      return `${month}/${day}/${year}`;
    case 'DD/MM/YYYY':
      return `${day}/${month}/${year}`;
    case 'YYYY-MM-DD':
      return `${year}-${month}-${day}`;
    case 'MMM DD, YYYY':
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    case 'MMMM DD, YYYY':
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    default:
      return `${month}/${day}/${year}`;
  }
};

/**
 * Normalize Firestore document data by converting all Timestamps to dates
 */
export const normalizeFirestoreData = <T extends Record<string, unknown>>(data: unknown): T | unknown => {
  if (!data || typeof data !== 'object') {
    return data;
  }

  if (Array.isArray(data)) {
    return data.map(item => normalizeFirestoreData(item));
  }

  if (isFirestoreTimestamp(data)) {
    return data.toDate();
  }

  const normalized: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(data)) {
    if (isFirestoreTimestamp(value)) {
      normalized[key] = value.toDate();
    } else if (Array.isArray(value)) {
      normalized[key] = value.map(item => normalizeFirestoreData(item));
    } else if (value && typeof value === 'object') {
      normalized[key] = normalizeFirestoreData(value);
    } else {
      normalized[key] = value;
    }
  }

  return normalized as T;
};

/**
 * Get relative time string (e.g., "2 hours ago", "3 days ago")
 */
export const getRelativeTime = (timestamp: TimestampLike): string => {
  const date = timestampToDate(timestamp);
  if (!date) return '';

  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffSecs = Math.floor(diffMs / 1000);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffSecs < 60) return 'just now';
  if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
  if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
  if (diffDays < 30) {
    const weeks = Math.floor(diffDays / 7);
    return `${weeks} week${weeks > 1 ? 's' : ''} ago`;
  }
  if (diffDays < 365) {
    const months = Math.floor(diffDays / 30);
    return `${months} month${months > 1 ? 's' : ''} ago`;
  }

  const years = Math.floor(diffDays / 365);
  return `${years} year${years > 1 ? 's' : ''} ago`;
};

/**
 * Convert date to Firestore Timestamp format
 */
export const dateToTimestamp = (date: Date | string | null): Timestamp | null => {
  if (!date) return null;
  
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  
  if (isNaN(dateObj.getTime())) {
    return null;
  }
  
  return Timestamp.fromDate(dateObj);
};

```

---

## src/utils/format.ts

**Path:** `src/utils/format.ts`

```typescript
/**
 * Format Utilities
 * Centralized formatting functions for display and presentation
 */

import type { FormTemplate } from '../types';

/**
 * Get display name for a form
 * Prefers formName, falls back to formNumber, then name
 */
export function getFormDisplayName(form: Partial<FormTemplate>): string {
  if (form.formName && form.formName.trim()) {
    return form.formName;
  }
  if (form.formNumber && form.formNumber.trim()) {
    return form.formNumber;
  }
  if (form.name && form.name.trim()) {
    return form.name;
  }
  return 'Unnamed Form';
}



/**
 * Format a percentage value
 */
export function formatPercentage(value: number | undefined, decimals: number = 0): string {
  if (value === undefined || value === null) {
    return '0%';
  }
  return `${value.toFixed(decimals)}%`;
}

/**
 * Format a date
 */
export function formatDate(date: Date | string | undefined): string {
  if (!date) {
    return 'N/A';
  }
  const d = typeof date === 'string' ? new Date(date) : date;
  return d.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });
}



```

---

## src/utils/index.ts

**Path:** `src/utils/index.ts`

```typescript
/**
 * Utilities Index
 * Centralized exports for all utility modules
 * 
 * Organization:
 * - core/: System utilities (logging, timeouts, PDF processing)
 * - data/: Data manipulation (Firestore, storage, cloning, versioning)
 * - ui/: UI utilities (performance, markdown, state guards)
 * - validation/: Validation logic (moved to services/validationService)
 */

// Core utilities
export * from './core';

// Data utilities
export * from './data';

// UI utilities
export * from './ui';
```

---

## src/utils/logger.ts

**Path:** `src/utils/logger.ts`

```typescript
/**
 * Comprehensive Logging System for Product Hub App
 * Provides structured logging for all user actions, API calls, data operations, and system events
 *
 * Features:
 * - Structured logging with categories and levels
 * - Session storage for debugging
 * - Global error handlers
 */

// Log levels
export const LOG_LEVELS = {
  ERROR: 'ERROR',
  WARN: 'WARN', 
  INFO: 'INFO',
  DEBUG: 'DEBUG',
  TRACE: 'TRACE'
} as const;

export type LogLevel = typeof LOG_LEVELS[keyof typeof LOG_LEVELS];

// Log categories for better organization
export const LOG_CATEGORIES = {
  AUTH: 'AUTH',
  API: 'API',
  FIREBASE: 'FIREBASE',
  USER_ACTION: 'USER_ACTION',
  NAVIGATION: 'NAVIGATION',
  FORM: 'FORM',
  DATA: 'DATA',
  ERROR: 'ERROR',
  AI: 'AI',
  UPLOAD: 'UPLOAD',
  EXPORT: 'EXPORT',
  IMPORT: 'IMPORT',
  CACHE: 'CACHE',
  NEWS: 'NEWS',
  EARNINGS: 'EARNINGS',
  CLAIMS: 'CLAIMS',
  PERFORMANCE: 'PERFORMANCE',
  SECURITY: 'SECURITY'
} as const;

export type LogCategory = typeof LOG_CATEGORIES[keyof typeof LOG_CATEGORIES];

interface LogEntry {
  timestamp: string;
  sessionId: string;
  userId: string | null;
  sessionDuration: number;
  level: LogLevel;
  category: LogCategory;
  message: string;
  data: Record<string, unknown>;
  url: string;
  userAgent: string;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

class Logger {
  private isEnabled: boolean;
  private logLevel: LogLevel;
  private sessionId: string;
  private userId: string | null;
  private startTime: number;
  private firebaseOpCounts: Map<string, number>;
  private lastFirebaseLogTime: number;

  constructor() {
    this.isEnabled = true;
    // In production, only show WARN and above; in dev, show INFO and above (not DEBUG for cleaner console)
    this.logLevel = process.env.NODE_ENV === 'production' ? LOG_LEVELS.WARN : LOG_LEVELS.INFO;
    this.sessionId = this.generateSessionId();
    this.userId = null;
    this.startTime = Date.now();
    this.firebaseOpCounts = new Map();
    this.lastFirebaseLogTime = 0;
  }

  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  setUserId(userId: string): void {
    this.userId = userId;
    this.log(LOG_LEVELS.INFO, LOG_CATEGORIES.AUTH, 'User ID set', { userId });
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = Object.values(LOG_LEVELS);
    return levels.indexOf(level) <= levels.indexOf(this.logLevel);
  }

  private formatLogEntry(
    level: LogLevel,
    category: LogCategory,
    message: string,
    data: Record<string, unknown> = {},
    error: Error | null = null
  ): LogEntry {
    const timestamp = new Date().toISOString();
    const sessionDuration = Date.now() - this.startTime;
    
    const logEntry: LogEntry = {
      timestamp,
      sessionId: this.sessionId,
      userId: this.userId,
      sessionDuration,
      level,
      category,
      message,
      data: this.sanitizeData(data),
      url: window.location.href,
      userAgent: navigator.userAgent,
    };

    if (error) {
      logEntry.error = {
        name: error.name,
        message: error.message,
        ...(error.stack !== undefined && { stack: error.stack })
      };
    }

    return logEntry;
  }

  private sanitizeData(data: Record<string, unknown>): Record<string, unknown> {
    // Remove sensitive information from logs
    if (!data || typeof data !== 'object') return data;
    
    const sanitized = { ...data };
    const sensitiveKeys = ['password', 'token', 'apiKey', 'secret', 'auth'];
    
    Object.keys(sanitized).forEach(key => {
      if (sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {
        sanitized[key] = '[REDACTED]';
      }
    });
    
    return sanitized;
  }

  log(
    level: LogLevel,
    category: LogCategory,
    message: string,
    data: Record<string, unknown> = {},
    error: Error | null = null
  ): void {
    if (!this.isEnabled || !this.shouldLog(level)) return;

    const logEntry = this.formatLogEntry(level, category, message, data, error);
    const prefix = `[${level}][${category}]`;
    
    // Console output with appropriate styling
    switch (level) {
      case LOG_LEVELS.ERROR:
        console.error(`ðŸ”´ ${prefix}`, message, logEntry);
        break;
      case LOG_LEVELS.WARN:
        console.warn(`ðŸŸ¡ ${prefix}`, message, logEntry);
        break;
      case LOG_LEVELS.INFO:
        console.info(`ðŸ”µ ${prefix}`, message, logEntry);
        break;
      case LOG_LEVELS.DEBUG:
        console.debug(`ðŸŸ¢ ${prefix}`, message, logEntry);
        break;
      case LOG_LEVELS.TRACE:
        console.trace(`âšª ${prefix}`, message, logEntry);
        break;
      default:
        console.log(`${prefix}`, message, logEntry);
    }

    // Store in session storage for debugging (keep last 100 entries)
    this.storeLogEntry(logEntry);
  }

  private storeLogEntry(logEntry: LogEntry): void {
    try {
      const stored = JSON.parse(sessionStorage.getItem('ph_logs') || '[]') as LogEntry[];
      stored.push(logEntry);
      
      // Keep only last 100 entries
      if (stored.length > 100) {
        stored.splice(0, stored.length - 100);
      }
      
      sessionStorage.setItem('ph_logs', JSON.stringify(stored));
    } catch (error) {
      console.warn('Failed to store log entry:', error);
    }
  }

  // Convenience methods for different log levels
  error(category: LogCategory, message: string, data: Record<string, unknown> = {}, error: Error | null = null): void {
    this.log(LOG_LEVELS.ERROR, category, message, data, error);
  }

  warn(category: LogCategory, message: string, data: Record<string, unknown> = {}): void {
    this.log(LOG_LEVELS.WARN, category, message, data);
  }

  info(category: LogCategory, message: string, data: Record<string, unknown> = {}): void {
    this.log(LOG_LEVELS.INFO, category, message, data);
  }

  debug(category: LogCategory, message: string, data: Record<string, unknown> = {}): void {
    this.log(LOG_LEVELS.DEBUG, category, message, data);
  }

  trace(category: LogCategory, message: string, data: Record<string, unknown> = {}): void {
    this.log(LOG_LEVELS.TRACE, category, message, data);
  }

  // Specialized logging methods for common operations
  logUserAction(action: string, details: Record<string, unknown> = {}): void {
    this.info(LOG_CATEGORIES.USER_ACTION, `User action: ${action}`, details);
  }

  logApiCall(
    method: string,
    url: string,
    payload: Record<string, unknown> = {},
    response: unknown = {},
    duration = 0
  ): void {
    this.info(LOG_CATEGORIES.API, `API ${method} ${url}`, {
      method,
      url,
      payload: this.sanitizeData(payload),
      response: typeof response === 'object' && response !== null ? { ...(response as Record<string, unknown>), data: '[TRUNCATED]' } : response,
      duration,
      status: (response as { status?: string })?.status || 'unknown'
    });
  }

  logFirebaseOperation(
    operation: string,
    collection: string,
    _docId: string | null = null,
    _data: Record<string, unknown> = {}
  ): void {
    // Batch similar Firebase operations to reduce console noise
    const key = `${operation}_${collection}`;
    const count = (this.firebaseOpCounts.get(key) || 0) + 1;
    this.firebaseOpCounts.set(key, count);

    const now = Date.now();
    // Only log aggregated counts every 2 seconds or on first call
    if (count === 1 || now - this.lastFirebaseLogTime > 2000) {
      this.lastFirebaseLogTime = now;

      // Log summary of all operations
      if (this.firebaseOpCounts.size > 0) {
        const summary: Record<string, number> = {};
        this.firebaseOpCounts.forEach((v, k) => { summary[k] = v; });
        this.debug(LOG_CATEGORIES.FIREBASE, 'Firebase operations', { operations: summary });
        this.firebaseOpCounts.clear();
      }
    }
  }

  logFormSubmission(
    formName: string,
    formData: Record<string, unknown> = {},
    validationErrors: string[] = []
  ): void {
    this.info(LOG_CATEGORIES.FORM, `Form submission: ${formName}`, {
      formName,
      formData: this.sanitizeData(formData),
      validationErrors,
      isValid: validationErrors.length === 0
    });
  }

  logNavigation(from: string, to: string, params: Record<string, unknown> = {}): void {
    this.info(LOG_CATEGORIES.NAVIGATION, `Navigation: ${from} â†’ ${to}`, {
      from,
      to,
      params
    });
  }



  logAIOperation(
    operation: string,
    model: string,
    prompt: string,
    response: string,
    duration = 0
  ): void {
    this.info(LOG_CATEGORIES.AI, `AI ${operation}`, {
      operation,
      model,
      prompt: prompt?.substring(0, 100) + '...',
      response: response?.substring(0, 100) + '...',
      duration
    });
  }

  // Get stored logs for debugging
  getLogs(): LogEntry[] {
    try {
      return JSON.parse(sessionStorage.getItem('ph_logs') || '[]') as LogEntry[];
    } catch {
      return [];
    }
  }

  // Clear stored logs
  clearLogs(): void {
    sessionStorage.removeItem('ph_logs');
    this.info(LOG_CATEGORIES.DATA, 'Logs cleared');
  }

  // Export logs for debugging
  exportLogs(): void {
    const logs = this.getLogs();
    const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `product-hub-logs-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.info(LOG_CATEGORIES.EXPORT, 'Logs exported');
  }
}

// Create singleton instance
const logger = new Logger();

// Add global error handler
if (typeof window !== 'undefined') {
  window.addEventListener('error', (event) => {
    logger.error(LOG_CATEGORIES.ERROR, 'Global error caught', {
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno
    }, event.error);
  });

  // Add unhandled promise rejection handler
  window.addEventListener('unhandledrejection', (event) => {
    logger.error(LOG_CATEGORIES.ERROR, 'Unhandled promise rejection', {
      reason: event.reason
    });
  });
}

export default logger;

```

---

## src/utils/markdownParser.tsx

**Path:** `src/utils/markdownParser.tsx`

```tsx
// Simple markdown parser for AI responses
// Handles basic formatting like **bold**, *italic*, bullet points, etc.

import React, { ReactNode, ReactElement } from 'react';
import styled from 'styled-components';

const FormattedText = styled.div`
  line-height: 1.6;
  color: #374151;

  strong {
    font-weight: 600;
    color: #1f2937;
  }

  em {
    font-style: italic;
    color: #4b5563;
  }

  ul {
    margin: 12px 0;
    padding-left: 20px;
  }

  li {
    margin: 4px 0;
  }

  p {
    margin: 12px 0;
    
    &:first-child {
      margin-top: 0;
    }
    
    &:last-child {
      margin-bottom: 0;
    }
  }

  h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    color: #1f2937;
    margin: 16px 0 8px 0;
    
    &:first-child {
      margin-top: 0;
    }
  }

  h1 { font-size: 1.5em; }
  h2 { font-size: 1.3em; }
  h3 { font-size: 1.1em; }
  h4, h5, h6 { font-size: 1em; }

  code {
    background: #f3f4f6;
    padding: 2px 4px;
    border-radius: 4px;
    font-family: 'SF Mono', ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Monaco, Consolas, monospace;
    font-size: 0.9em;
    color: #6366f1;
  }

  blockquote {
    border-left: 3px solid #e5e7eb;
    padding-left: 16px;
    margin: 12px 0;
    color: #6b7280;
    font-style: italic;
  }
`;

// Parse markdown-like text and return React elements
export function parseMarkdown(text: string): ReactNode[] | null {
  if (!text) return null;

  // Split text into lines for processing
  const lines = text.split('\n');
  const elements: ReactNode[] = [];
  let currentParagraph: string[] = [];
  let inList = false;
  let listItems: string[] = [];

  const flushParagraph = () => {
    if (currentParagraph.length > 0) {
      const paragraphText = currentParagraph.join(' ').trim();
      if (paragraphText) {
        elements.push(
          <p key={elements.length}>
            {parseInlineFormatting(paragraphText)}
          </p>
        );
      }
      currentParagraph = [];
    }
  };

  const flushList = () => {
    if (listItems.length > 0) {
      elements.push(
        <ul key={elements.length}>
          {listItems.map((item, index) => (
            <li key={index}>{parseInlineFormatting(item)}</li>
          ))}
        </ul>
      );
      listItems = [];
      inList = false;
    }
  };

  lines.forEach((line) => {
    const trimmedLine = line.trim();

    // Empty line
    if (!trimmedLine) {
      flushParagraph();
      flushList();
      return;
    }

    // Headers
    const headerMatch = trimmedLine.match(/^(#{1,6})\s+(.+)$/);
    if (headerMatch && headerMatch[1] && headerMatch[2]) {
      flushParagraph();
      flushList();
      const level = headerMatch[1].length;
      const HeaderTag = `h${level}` as 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
      elements.push(
        React.createElement(
          HeaderTag,
          { key: elements.length },
          parseInlineFormatting(headerMatch[2])
        )
      );
      return;
    }

    // List items
    const listMatch = trimmedLine.match(/^[-*+]\s+(.+)$/);
    if (listMatch && listMatch[1]) {
      flushParagraph();
      if (!inList) {
        inList = true;
      }
      listItems.push(listMatch[1]);
      return;
    }

    // Blockquote
    if (trimmedLine.startsWith('>')) {
      flushParagraph();
      flushList();
      const quoteText = trimmedLine.replace(/^>\s*/, '');
      elements.push(
        <blockquote key={elements.length}>
          {parseInlineFormatting(quoteText)}
        </blockquote>
      );
      return;
    }

    // Regular paragraph text
    if (inList) {
      flushList();
    }
    currentParagraph.push(trimmedLine);
  });

  // Flush any remaining content
  flushParagraph();
  flushList();

  return elements;
}

// Parse inline formatting like **bold**, *italic*, `code`
function parseInlineFormatting(text: string): ReactNode | ReactNode[] {
  if (!text) return text;

  const parts: ReactNode[] = [];
  let currentIndex = 0;

  // Regex to match **bold**, *italic*, and `code`
  const formatRegex = /(\*\*([^*]+)\*\*|\*([^*]+)\*|`([^`]+)`)/g;
  let match: RegExpExecArray | null;

  while ((match = formatRegex.exec(text)) !== null) {
    // Add text before the match
    if (match.index > currentIndex) {
      parts.push(text.slice(currentIndex, match.index));
    }

    // Add the formatted element
    if (match[2]) {
      // **bold**
      parts.push(<strong key={parts.length}>{match[2]}</strong>);
    } else if (match[3]) {
      // *italic*
      parts.push(<em key={parts.length}>{match[3]}</em>);
    } else if (match[4]) {
      // `code`
      parts.push(<code key={parts.length}>{match[4]}</code>);
    }

    currentIndex = match.index + match[0].length;
  }

  // Add remaining text
  if (currentIndex < text.length) {
    parts.push(text.slice(currentIndex));
  }

  return parts.length > 1 ? parts : text;
}

// Main component to render parsed markdown
interface MarkdownRendererProps {
  children: string;
  [key: string]: any;
}

export function MarkdownRenderer({ children, ...props }: MarkdownRendererProps): ReactElement {
  const parsedContent = parseMarkdown(children);
  
  return (
    <FormattedText {...props}>
      {parsedContent}
    </FormattedText>
  );
}

export default MarkdownRenderer;

```

---

## src/utils/markdownSanitizer.ts

**Path:** `src/utils/markdownSanitizer.ts`

```typescript
/**
 * Markdown Sanitizer
 * Sanitizes markdown content to prevent XSS attacks while preserving formatting
 */

/**
 * Dangerous patterns that could lead to XSS
 */
const DANGEROUS_PATTERNS = [
  /<script[^>]*>[\s\S]*?<\/script>/gi,
  /<iframe[^>]*>[\s\S]*?<\/iframe>/gi,
  /on\w+\s*=\s*["'][^"']*["']/gi,
  /javascript:/gi,
  /data:text\/html/gi,
  /<embed[^>]*>/gi,
  /<object[^>]*>/gi,
  /<link[^>]*>/gi,
  /<style[^>]*>[\s\S]*?<\/style>/gi,
  /<!--[\s\S]*?-->/g
];

/**
 * Sanitize markdown content
 * Removes potentially dangerous HTML/JavaScript while preserving markdown formatting
 */
export function sanitizeMarkdown(content: string): string {
  if (!content || typeof content !== 'string') {
    return '';
  }

  let sanitized = content;

  // Remove dangerous patterns
  DANGEROUS_PATTERNS.forEach(pattern => {
    sanitized = sanitized.replace(pattern, '');
  });

  // Remove any remaining HTML tags except markdown-safe ones
  sanitized = sanitized.replace(/<(?!br\s*\/?|hr\s*\/?|p\s*\/?|\/p>|div\s*\/?|\/div>)[^>]+>/g, '');

  // Escape special characters that could be interpreted as HTML
  sanitized = sanitized
    .replace(/&(?!amp;|lt;|gt;|quot;|#)/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // Unescape markdown-safe content
  sanitized = sanitized
    .replace(/&lt;br\s*\/?&gt;/g, '<br />')
    .replace(/&lt;hr\s*\/?&gt;/g, '<hr />')
    .replace(/&lt;p&gt;/g, '<p>')
    .replace(/&lt;\/p&gt;/g, '</p>')
    .replace(/&lt;div&gt;/g, '<div>')
    .replace(/&lt;\/div&gt;/g, '</div>');

  return sanitized.trim();
}

/**
 * Sanitize markdown with length limit
 */
export function sanitizeMarkdownWithLimit(
  content: string,
  maxLength: number = 10000
): string {
  const sanitized = sanitizeMarkdown(content);
  
  if (sanitized.length > maxLength) {
    return sanitized.substring(0, maxLength) + '...';
  }
  
  return sanitized;
}

/**
 * Extract plain text from markdown
 */
export function extractPlainText(markdown: string): string {
  let text = markdown;

  // Remove markdown formatting
  text = text.replace(/\*\*(.+?)\*\*/g, '$1');  // Bold
  text = text.replace(/\*(.+?)\*/g, '$1');      // Italic
  text = text.replace(/`(.+?)`/g, '$1');        // Code
  text = text.replace(/\[(.+?)\]\(.+?\)/g, '$1'); // Links
  text = text.replace(/#+\s+/g, '');            // Headers
  text = text.replace(/[-*]\s+/g, '');          // Lists
  text = text.replace(/\n\n+/g, '\n');          // Multiple newlines

  return text.trim();
}

/**
 * Validate markdown structure
 */
export interface MarkdownValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export function validateMarkdown(content: string): MarkdownValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  if (!content || typeof content !== 'string') {
    errors.push('Content must be a non-empty string');
    return { isValid: false, errors, warnings };
  }

  // Check for unmatched brackets
  const openBrackets = (content.match(/\[/g) || []).length;
  const closeBrackets = (content.match(/\]/g) || []).length;
  if (openBrackets !== closeBrackets) {
    warnings.push('Unmatched square brackets detected');
  }

  // Check for unmatched parentheses
  const openParens = (content.match(/\(/g) || []).length;
  const closeParens = (content.match(/\)/g) || []).length;
  if (openParens !== closeParens) {
    warnings.push('Unmatched parentheses detected');
  }

  // Check for unmatched asterisks (bold/italic)
  const asterisks = (content.match(/\*/g) || []).length;
  if (asterisks % 2 !== 0) {
    warnings.push('Unmatched asterisks detected');
  }

  // Check for unmatched backticks
  const backticks = (content.match(/`/g) || []).length;
  if (backticks % 2 !== 0) {
    warnings.push('Unmatched backticks detected');
  }

  // Check for suspicious patterns
  if (/<script|javascript:|on\w+\s*=/i.test(content)) {
    errors.push('Suspicious patterns detected');
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Compact markdown by removing excessive whitespace
 */
export function compactMarkdown(content: string): string {
  let compacted = content;

  // Remove leading/trailing whitespace from lines
  compacted = compacted
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0)
    .join('\n');

  // Reduce multiple newlines to max 2
  compacted = compacted.replace(/\n{3,}/g, '\n\n');

  return compacted;
}

/**
 * Truncate markdown at word boundary
 */
export function truncateMarkdown(
  content: string,
  maxLength: number = 500
): string {
  if (content.length <= maxLength) {
    return content;
  }

  const truncated = content.substring(0, maxLength);
  const lastSpace = truncated.lastIndexOf(' ');
  
  if (lastSpace > maxLength * 0.8) {
    return truncated.substring(0, lastSpace) + '...';
  }

  return truncated + '...';
}

```

---

## src/utils/parallelProcessor.ts

**Path:** `src/utils/parallelProcessor.ts`

```typescript
/**
 * Parallel Processing Utility
 *
 * Provides robust parallel batch processing with:
 * - Rate limiting to avoid API throttling
 * - Exponential backoff retry logic
 * - Error handling with partial success support
 * - Progress tracking and cancellation
 * - Configurable concurrency limits
 */

import logger, { LOG_CATEGORIES } from './logger';

// ============================================================================
// Types
// ============================================================================

export interface BatchProcessorOptions {
  /** Maximum concurrent operations (default: 5) */
  concurrency?: number;
  /** Delay between batches in ms (default: 100) */
  batchDelay?: number;
  /** Maximum retries per item (default: 3) */
  maxRetries?: number;
  /** Initial retry delay in ms (default: 100) */
  initialRetryDelay?: number;
  /** Maximum retry delay in ms (default: 5000) */
  maxRetryDelay?: number;
  /** Whether to continue on errors (default: true) */
  continueOnError?: boolean;
  /** Progress callback */
  onProgress?: (completed: number, total: number, errors: number) => void;
  /** Abort signal for cancellation */
  signal?: AbortSignal;
}

export interface BatchResult<T> {
  results: T[];
  errors: BatchError[];
  totalProcessed: number;
  successCount: number;
  errorCount: number;
  durationMs: number;
}

export interface BatchError {
  index: number;
  error: Error;
  item: unknown;
}

// ============================================================================
// Default Configuration
// ============================================================================

const DEFAULT_OPTIONS: Required<Omit<BatchProcessorOptions, 'onProgress' | 'signal'>> = {
  concurrency: 5,
  batchDelay: 100,
  maxRetries: 3,
  initialRetryDelay: 100,
  maxRetryDelay: 5000,
  continueOnError: true
};

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Sleep for specified milliseconds
 */
const sleep = (ms: number): Promise<void> => 
  new Promise(resolve => setTimeout(resolve, ms));

/**
 * Calculate exponential backoff delay
 */
const getBackoffDelay = (
  attempt: number, 
  initialDelay: number, 
  maxDelay: number
): number => {
  const delay = initialDelay * Math.pow(2, attempt);
  return Math.min(delay, maxDelay);
};

// ============================================================================
// Main Processor Functions
// ============================================================================

/**
 * Process items in parallel batches with rate limiting and error handling
 * 
 * @param items - Array of items to process
 * @param processor - Async function to process each item
 * @param options - Processing options
 * @returns BatchResult with results and error information
 */
export async function processBatchWithRetry<T, R>(
  items: T[],
  processor: (item: T, index: number) => Promise<R>,
  options: BatchProcessorOptions = {}
): Promise<BatchResult<R>> {
  const startTime = Date.now();
  const opts = { ...DEFAULT_OPTIONS, ...options };
  
  const results: R[] = [];
  const errors: BatchError[] = [];
  let completed = 0;

  logger.debug(LOG_CATEGORIES.AI, 'Starting batch processing', {
    totalItems: items.length,
    concurrency: opts.concurrency,
    batchDelay: opts.batchDelay
  });

  // Process in batches
  for (let i = 0; i < items.length; i += opts.concurrency) {
    // Check for cancellation
    if (opts.signal?.aborted) {
      logger.warn(LOG_CATEGORIES.AI, 'Batch processing cancelled');
      break;
    }

    const batch = items.slice(i, i + opts.concurrency);
    const batchPromises = batch.map(async (item, batchIndex) => {
      const globalIndex = i + batchIndex;
      return processItemWithRetry(item, globalIndex, processor, opts);
    });

    const batchResults = await Promise.allSettled(batchPromises);

    // Process batch results
    batchResults.forEach((result, batchIndex) => {
      const globalIndex = i + batchIndex;
      completed++;

      if (result.status === 'fulfilled') {
        results[globalIndex] = result.value;
      } else {
        const error: BatchError = {
          index: globalIndex,
          error: result.reason instanceof Error ? result.reason : new Error(String(result.reason)),
          item: items[globalIndex]
        };
        errors.push(error);

        if (!opts.continueOnError) {
          throw error.error;
        }
      }
    });

    // Report progress
    opts.onProgress?.(completed, items.length, errors.length);

    // Add delay between batches (except for last batch)
    if (i + opts.concurrency < items.length) {
      await sleep(opts.batchDelay);
    }
  }

  const durationMs = Date.now() - startTime;

  logger.info(LOG_CATEGORIES.AI, 'Batch processing completed', {
    totalProcessed: completed,
    successCount: completed - errors.length,
    errorCount: errors.length,
    durationMs
  });

  return {
    results: results.filter(r => r !== undefined),
    errors,
    totalProcessed: completed,
    successCount: completed - errors.length,
    errorCount: errors.length,
    durationMs
  };
}

/**
 * Process a single item with retry logic
 */
async function processItemWithRetry<T, R>(
  item: T,
  index: number,
  processor: (item: T, index: number) => Promise<R>,
  opts: Required<Omit<BatchProcessorOptions, 'onProgress' | 'signal'>>
): Promise<R> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= opts.maxRetries; attempt++) {
    try {
      return await processor(item, index);
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (attempt < opts.maxRetries) {
        const delay = getBackoffDelay(attempt, opts.initialRetryDelay, opts.maxRetryDelay);
        logger.debug(LOG_CATEGORIES.AI, `Retry ${attempt + 1}/${opts.maxRetries} for item ${index}`, {
          delay,
          error: lastError.message
        });
        await sleep(delay);
      }
    }
  }

  throw lastError;
}

/**
 * Simple parallel batch processor (no retry, for backward compatibility)
 * This matches the signature used in advancedRAGService.ts
 */
export async function processBatch<T, R>(
  items: T[],
  processor: (item: T) => Promise<R>,
  batchSize: number = 5,
  delayMs: number = 100
): Promise<R[]> {
  const results: R[] = [];

  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(batch.map(processor));
    results.push(...batchResults);

    // Add delay between batches to avoid rate limiting
    if (i + batchSize < items.length) {
      await sleep(delayMs);
    }
  }

  return results;
}

/**
 * Rate-limited processor for API calls
 * Ensures minimum delay between each call
 */
export async function processWithRateLimit<T, R>(
  items: T[],
  processor: (item: T) => Promise<R>,
  minDelayMs: number = 200
): Promise<R[]> {
  const results: R[] = [];

  for (const item of items) {
    const startTime = Date.now();
    const result = await processor(item);
    results.push(result);

    // Ensure minimum delay between calls
    const elapsed = Date.now() - startTime;
    if (elapsed < minDelayMs) {
      await sleep(minDelayMs - elapsed);
    }
  }

  return results;
}

/**
 * Chunked processor for large datasets
 * Processes items in chunks with optional progress reporting
 */
export async function processInChunks<T, R>(
  items: T[],
  processor: (chunk: T[]) => Promise<R[]>,
  chunkSize: number = 10,
  onChunkComplete?: (chunkIndex: number, totalChunks: number) => void
): Promise<R[]> {
  const results: R[] = [];
  const totalChunks = Math.ceil(items.length / chunkSize);

  for (let i = 0; i < items.length; i += chunkSize) {
    const chunk = items.slice(i, i + chunkSize);
    const chunkResults = await processor(chunk);
    results.push(...chunkResults);

    const chunkIndex = Math.floor(i / chunkSize);
    onChunkComplete?.(chunkIndex + 1, totalChunks);
  }

  return results;
}

/**
 * Concurrent map with limit
 * Like Promise.all but with concurrency control
 */
export async function mapConcurrent<T, R>(
  items: T[],
  processor: (item: T) => Promise<R>,
  concurrency: number = 5
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let currentIndex = 0;

  const workers = Array.from({ length: Math.min(concurrency, items.length) }, async () => {
    while (currentIndex < items.length) {
      const index = currentIndex++;
      const item = items[index];
      if (item !== undefined) {
        results[index] = await processor(item);
      }
    }
  });

  await Promise.all(workers);
  return results;
}

// Export default for convenience
export default {
  processBatchWithRetry,
  processBatch,
  processWithRateLimit,
  processInChunks,
  mapConcurrent
};

```

---

## src/utils/pdfChunking.ts

**Path:** `src/utils/pdfChunking.ts`

```typescript
// src/utils/pdfChunking.ts
/**
 * PDF Chunking Utility - Insurance-Aware Document Processing
 *
 * OPTIMIZED VERSION - Enhanced for P&C Insurance Forms:
 * - Insurance-specific section detection (coverages, exclusions, conditions)
 * - Hierarchical document understanding
 * - Semantic boundary preservation
 * - Metadata extraction for better context
 * - Parallel processing with rate limiting
 */

import { getDownloadURL, ref } from 'firebase/storage';
import { storage } from '../firebase';
import { CACHE } from '../config/constants';
import logger, { LOG_CATEGORIES } from './logger';

// ============================================================================
// Types
// ============================================================================

export interface ChunkMetadata {
  formId: string;
  formName: string;
  formNumber?: string;
  category?: string;
  chunkIndex: number;
  totalChunks: number;
  sectionType?: InsuranceSectionType;
  importance?: 'critical' | 'high' | 'medium' | 'low';
  originalLength?: number;
  warning?: boolean;
  error?: boolean;
}

export interface FormChunk extends ChunkMetadata {
  text: string;
}

export type InsuranceSectionType =
  | 'declarations'
  | 'insuring_agreement'
  | 'definitions'
  | 'exclusions'
  | 'conditions'
  | 'endorsement'
  | 'coverage'
  | 'limits'
  | 'deductibles'
  | 'general';

// ============================================================================
// Configuration
// ============================================================================

// PDF processing cache to avoid reprocessing (uses centralized CACHE config)
const pdfCache = new Map();
const CACHE_TTL = CACHE.TTL_FORMS; // 10 minutes - same as forms TTL
const MAX_CACHE_SIZE = CACHE.MAX_CACHE_SIZE; // Maximum number of cached PDFs

// Insurance-specific section patterns with importance levels
const INSURANCE_SECTION_PATTERNS: Array<{
  pattern: RegExp;
  type: InsuranceSectionType;
  importance: 'critical' | 'high' | 'medium' | 'low';
}> = [
  // Critical sections - affect coverage determination
  { pattern: /^(INSURING\s+AGREEMENT|COVERAGE\s+AGREEMENT)/i, type: 'insuring_agreement', importance: 'critical' },
  { pattern: /^EXCLUSIONS?(\s|$)/i, type: 'exclusions', importance: 'critical' },
  { pattern: /^(COVERAGE\s+[A-Z]|SECTION\s+[IVX]+\s*[-â€“]\s*COVERAGE)/i, type: 'coverage', importance: 'critical' },

  // High importance - affect policy terms
  { pattern: /^CONDITIONS?(\s|$)/i, type: 'conditions', importance: 'high' },
  { pattern: /^DEFINITIONS?(\s|$)/i, type: 'definitions', importance: 'high' },
  { pattern: /^(LIMITS?\s+OF\s+(LIABILITY|INSURANCE)|COVERAGE\s+LIMITS?)/i, type: 'limits', importance: 'high' },
  { pattern: /^DEDUCTIBLES?(\s|$)/i, type: 'deductibles', importance: 'high' },

  // Medium importance - endorsements and modifications
  { pattern: /^ENDORSEMENT(\s|$)/i, type: 'endorsement', importance: 'medium' },
  { pattern: /^(THIS\s+ENDORSEMENT\s+MODIFIES|POLICY\s+CHANGE)/i, type: 'endorsement', importance: 'medium' },

  // Lower importance - declarations and general
  { pattern: /^DECLARATIONS?(\s|$)/i, type: 'declarations', importance: 'medium' },
  { pattern: /^(SECTION|PART)\s+[A-Z0-9]/i, type: 'general', importance: 'low' }
];

// Lazy load pdfjs to avoid bundle bloat
let pdfjsLib = null;
const loadPdfJs = async () => {
  if (pdfjsLib) return pdfjsLib;

  try {
    pdfjsLib = await import(/* webpackChunkName: "pdfjs" */ 'pdfjs-dist');

    // Set worker source with fallback - using .mjs for pdfjs-dist v5.4+
    if (typeof window !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc = `${window.location.origin}/pdf.worker.min.mjs`;
    } else {
      pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdf.worker.min.mjs';
    }

    // PDF.js loaded successfully (removed console.log to reduce noise)
    return pdfjsLib;
  } catch (error) {
    console.error('Failed to load PDF.js:', error);
    throw new Error('PDF processing is not available');
  }
};

// Cache management
const cleanupCache = () => {
  const now = Date.now();
  const entries = Array.from(pdfCache.entries());

  // Remove expired entries
  entries.forEach(([key, value]) => {
    if (now - value.timestamp > CACHE_TTL) {
      pdfCache.delete(key);
    }
  });

  // Remove oldest entries if cache is too large
  if (pdfCache.size > MAX_CACHE_SIZE) {
    const sortedEntries = entries
      .sort((a, b) => a[1].timestamp - b[1].timestamp)
      .slice(0, pdfCache.size - MAX_CACHE_SIZE);

    sortedEntries.forEach(([key]) => pdfCache.delete(key));
  }
};

/**
 * Extract text from a PDF file (either from Firebase Storage or File object)
 * @param {string|File} source - Firebase storage path or File object
 * @param {number} timeout - Timeout in milliseconds (default: 30000)
 * @returns {Promise<string>} - Extracted text
 */
export async function extractPdfText(source, timeout = 30000) {
  const cacheKey = typeof source === 'string' ? source : `file_${source.name}_${source.size}`;

  console.log('ðŸ” extractPdfText called with:', {
    sourceType: typeof source,
    isString: typeof source === 'string',
    source: typeof source === 'string' ? source.substring(0, 100) : 'File object',
    cacheKey: cacheKey.substring(0, 100)
  });

  // Check cache first
  const cached = pdfCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    console.log('âœ… PDF cache hit, returning cached text');
    return cached.text;
  }

  // Clean up cache periodically
  cleanupCache();

  let pdf = null;
  try {
    await loadPdfJs();

    let pdfData;
    const urlTimeout = Math.min(timeout * 0.3, 10000); // 30% of timeout or 10s max
    const fetchTimeout = Math.min(timeout * 0.5, 15000); // 50% of timeout or 15s max

    if (typeof source === 'string') {
      let url = source;

      // Check if source is a Firebase Storage path or already a download URL
      if (!source.startsWith('http://') && !source.startsWith('https://')) {
        console.log('ðŸ“ Source is a Firebase Storage path, getting download URL...');
        // It's a Firebase Storage path, get the download URL
        url = await Promise.race([
          getDownloadURL(ref(storage, source)),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Firebase URL fetch timeout')), urlTimeout)
          )
        ]);
        console.log('âœ… Got download URL:', url.substring(0, 100));
      } else {
        console.log('ðŸŒ Source is already a URL, using directly');
      }

      console.log('â¬‡ï¸ Fetching PDF from URL...');
      const response = await Promise.race([
        fetch(url),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('PDF fetch timeout')), fetchTimeout)
        )
      ]);

      console.log('ðŸ“¦ Fetch response:', {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        contentType: response.headers.get('content-type')
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch PDF: ${response.status} ${response.statusText}`);
      }

      console.log('ðŸ“¥ Downloading PDF data...');
      pdfData = await Promise.race([
        response.arrayBuffer(),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('PDF download timeout')), fetchTimeout)
        )
      ]);
      console.log('âœ… PDF data downloaded:', pdfData.byteLength, 'bytes');
    } else {
      // File object
      pdfData = await source.arrayBuffer();
    }

    console.log('ðŸ“– Parsing PDF document...');
    pdf = await Promise.race([
      pdfjsLib.getDocument({
        data: new Uint8Array(pdfData),
        // Optimize memory usage
        disableFontFace: true,
        disableRange: false,
        disableStream: false
      }).promise,
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('PDF parsing timeout')), 10000)
      )
    ]);

    console.log('âœ… PDF parsed successfully:', {
      numPages: pdf.numPages,
      fingerprint: pdf.fingerprints?.[0]?.substring(0, 20)
    });

    let text = '';
    const maxPages = Math.min(pdf.numPages, 50); // Limit to 50 pages to prevent memory issues
    const pages = [];

    console.log(`ðŸ“„ Extracting text from ${maxPages} pages...`);

    // Process pages in batches to manage memory
    const batchSize = 5;
    for (let batchStart = 1; batchStart <= maxPages; batchStart += batchSize) {
      const batchEnd = Math.min(batchStart + batchSize - 1, maxPages);

      for (let i = batchStart; i <= batchEnd; i++) {
        try {
          const page = await Promise.race([
            pdf.getPage(i),
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error(`Page ${i} timeout`)), 5000)
            )
          ]);

          const content = await Promise.race([
            page.getTextContent(),
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error(`Page ${i} content timeout`)), 5000)
            )
          ]);

          const pageText = content.items.map(item => item.str).join(' ');
          text += pageText + '\n\n';

          // Clean up page resources immediately
          page.cleanup();
          pages.push(page);
        } catch (pageError) {
          console.warn(`Failed to extract text from page ${i}:`, pageError);
          text += `[Error extracting page ${i}: ${pageError.message}]\n\n`;
        }
      }

      // Force garbage collection hint between batches
      if (batchEnd < maxPages && typeof window !== 'undefined' && window.gc) {
        window.gc();
      }
    }

    if (pdf.numPages > maxPages) {
      text += `\n[Note: PDF has ${pdf.numPages} pages, but only first ${maxPages} were processed]\n`;
    }

    const finalText = text.trim();

    console.log('âœ… Text extraction complete:', {
      textLength: finalText.length,
      firstChars: finalText.substring(0, 100),
      isEmpty: finalText.length === 0
    });

    // Cache the result
    pdfCache.set(cacheKey, {
      text: finalText,
      timestamp: Date.now()
    });

    return finalText;
  } catch (error) {
    console.error('PDF text extraction failed:', error);
    throw new Error(`PDF text extraction failed: ${error.message}`);
  } finally {
    // Cleanup PDF document
    if (pdf) {
      try {
        pdf.destroy();
      } catch (cleanupError) {
        console.warn('PDF cleanup error:', cleanupError);
      }
    }
  }
}

/**
 * Split text into chunks suitable for AI processing
 * @param {string} text - Text to chunk
 * @param {number} maxTokens - Maximum tokens per chunk (approximate)
 * @param {number} overlap - Number of words to overlap between chunks
 * @returns {Array<string>} - Array of text chunks
 */
export function chunkText(text, maxTokens = 3000, overlap = 200) {
  // Rough approximation: 1 token â‰ˆ 0.75 words
  const maxWords = Math.floor(maxTokens * 0.75);
  const words = text.split(/\s+/);

  if (words.length <= maxWords) {
    return [text];
  }

  const chunks = [];
  let startIndex = 0;

  while (startIndex < words.length) {
    const endIndex = Math.min(startIndex + maxWords, words.length);
    const chunk = words.slice(startIndex, endIndex).join(' ');
    chunks.push(chunk);

    // Move start index forward, accounting for overlap
    startIndex = endIndex - overlap;

    // Prevent infinite loop if overlap is too large
    if (startIndex <= (chunks.length > 1 ? startIndex - overlap : 0)) {
      startIndex = endIndex;
    }
  }

  return chunks;
}

/**
 * Detect insurance section type from text
 */
function detectSectionType(text: string): { type: InsuranceSectionType; importance: 'critical' | 'high' | 'medium' | 'low' } | null {
  const firstLine = text.split('\n')[0]?.trim() || '';

  for (const { pattern, type, importance } of INSURANCE_SECTION_PATTERNS) {
    if (pattern.test(firstLine)) {
      return { type, importance };
    }
  }

  return null;
}

/**
 * Extract key insurance terms from text for metadata
 */
function extractKeyTerms(text: string): string[] {
  const terms: string[] = [];
  const lowerText = text.toLowerCase();

  // Coverage-related terms
  if (lowerText.includes('bodily injury')) terms.push('bodily_injury');
  if (lowerText.includes('property damage')) terms.push('property_damage');
  if (lowerText.includes('personal injury')) terms.push('personal_injury');
  if (lowerText.includes('medical payments')) terms.push('medical_payments');
  if (lowerText.includes('uninsured motorist')) terms.push('uninsured_motorist');
  if (lowerText.includes('comprehensive')) terms.push('comprehensive');
  if (lowerText.includes('collision')) terms.push('collision');

  // Limit-related terms
  if (/\$[\d,]+/.test(text)) terms.push('has_limits');
  if (lowerText.includes('per occurrence')) terms.push('per_occurrence');
  if (lowerText.includes('aggregate')) terms.push('aggregate');

  // Exclusion indicators
  if (lowerText.includes('does not apply')) terms.push('exclusion_indicator');
  if (lowerText.includes('we will not')) terms.push('exclusion_indicator');
  if (lowerText.includes('not covered')) terms.push('exclusion_indicator');

  return terms;
}

/**
 * Intelligently chunk insurance form text based on structure and content
 * OPTIMIZED: Uses insurance-specific patterns for better semantic chunking
 *
 * @param text - Insurance form text to chunk
 * @param form - Form metadata for context
 * @returns Array of intelligently chunked text with metadata
 */
export function chunkInsuranceFormText(text: string, form: { formName?: string; id?: string } = {}): string[] {
  // For shorter forms, return as single chunk
  if (text.length < 8000) {
    return [text];
  }

  const chunks: string[] = [];
  let currentChunk = '';
  let currentSectionType: InsuranceSectionType = 'general';
  const lines = text.split('\n');

  for (const line of lines) {
    // Check if this line starts a new insurance section
    const sectionInfo = detectSectionType(line);
    const isNewSection = sectionInfo !== null;

    // If we hit a new section and current chunk is substantial, start new chunk
    if (isNewSection && currentChunk.length > 1500) {
      if (currentChunk.trim()) {
        chunks.push(currentChunk.trim());
      }
      currentChunk = line + '\n';
      currentSectionType = sectionInfo?.type || 'general';
    } else {
      currentChunk += line + '\n';
    }

    // If current chunk gets too large, force a split at a sentence boundary
    if (currentChunk.length > 10000) {
      // Try to find a good split point (end of sentence)
      const splitPoint = findSentenceBoundary(currentChunk, 8000);
      if (splitPoint > 0) {
        chunks.push(currentChunk.substring(0, splitPoint).trim());
        currentChunk = currentChunk.substring(splitPoint);
      } else {
        chunks.push(currentChunk.trim());
        currentChunk = '';
      }
    }
  }

  // Add remaining content
  if (currentChunk.trim()) {
    chunks.push(currentChunk.trim());
  }

  // If we didn't get good natural splits, fall back to word-based chunking
  if (chunks.length === 1 && chunks[0].length > 12000) {
    logger.debug(LOG_CATEGORIES.AI, `Falling back to word-based chunking for form ${form.formName || form.id}`);
    return chunkText(text, 4000, 300);
  }

  // Ensure no chunk is too large
  const finalChunks: string[] = [];
  for (const chunk of chunks) {
    if (chunk.length > 15000) {
      const subChunks = chunkText(chunk, 4000, 300);
      finalChunks.push(...subChunks);
    } else {
      finalChunks.push(chunk);
    }
  }

  return finalChunks.length > 0 ? finalChunks : [text];
}

/**
 * Find a sentence boundary near the target position
 */
function findSentenceBoundary(text: string, targetPos: number): number {
  // Look for sentence endings near the target position
  const searchStart = Math.max(0, targetPos - 500);
  const searchEnd = Math.min(text.length, targetPos + 500);
  const searchText = text.substring(searchStart, searchEnd);

  // Find sentence endings (. ! ?) followed by space or newline
  const sentenceEndPattern = /[.!?]\s+/g;
  let lastMatch = -1;
  let match;

  while ((match = sentenceEndPattern.exec(searchText)) !== null) {
    const absolutePos = searchStart + match.index + match[0].length;
    if (absolutePos <= targetPos + 200) {
      lastMatch = absolutePos;
    }
  }

  return lastMatch;
}

/**
 * Enhanced chunking with metadata for insurance forms
 * Returns chunks with section type and importance information
 */
export function chunkInsuranceFormWithMetadata(
  text: string,
  form: { formName?: string; id?: string; formNumber?: string; category?: string }
): FormChunk[] {
  const textChunks = chunkInsuranceFormText(text, form);

  return textChunks.map((chunk, index) => {
    const sectionInfo = detectSectionType(chunk);
    const keyTerms = extractKeyTerms(chunk);

    return {
      text: chunk,
      formId: form.id || 'unknown',
      formName: form.formName || form.formNumber || 'Unnamed Form',
      formNumber: form.formNumber,
      category: form.category,
      chunkIndex: index,
      totalChunks: textChunks.length,
      sectionType: sectionInfo?.type || 'general',
      importance: sectionInfo?.importance || 'medium',
      originalLength: text.length
    };
  });
}

/**
 * Process multiple forms and create chunks with metadata
 * OPTIMIZED: Uses parallel processor with rate limiting and better error handling
 *
 * @param forms - Array of form objects with filePath or downloadUrl
 * @param maxConcurrent - Maximum concurrent PDF processing (default: 3)
 * @param onProgress - Optional progress callback
 * @returns Promise<Array> - Array of chunks with form metadata
 */
export async function processFormsForAnalysis(
  forms: Array<{ id: string; formName?: string; formNumber?: string; category?: string; filePath?: string; downloadUrl?: string }>,
  maxConcurrent = 3,
  onProgress?: (completed: number, total: number) => void
): Promise<FormChunk[]> {
  if (!Array.isArray(forms) || forms.length === 0) {
    logger.warn(LOG_CATEGORIES.AI, 'No forms provided for analysis');
    return [];
  }

  const allChunks: FormChunk[] = [];
  logger.info(LOG_CATEGORIES.AI, `Processing ${forms.length} forms for analysis`);

  // Process a single form
  const processForm = async (form: typeof forms[0]): Promise<FormChunk[] | null> => {
    if (!form || !form.id) {
      logger.warn(LOG_CATEGORIES.AI, 'Invalid form object', { form });
      return null;
    }

    try {
      // Determine the source for PDF extraction
      const source = form.filePath || form.downloadUrl;
      if (!source) {
        logger.warn(LOG_CATEGORIES.AI, `Form ${form.id} has no filePath or downloadUrl`);
        return null;
      }

      // Extract text with enhanced error handling
      const text = await extractPdfText(source, 30000);

      // Validate extracted text
      if (!text || text.trim().length < 50) {
        logger.warn(LOG_CATEGORIES.AI, `Insufficient text extracted from form ${form.id}`, {
          length: text?.length || 0
        });
        return [{
          text: `[Warning: Form ${form.formName || form.id} contains minimal text content. This may indicate a scanned document.]`,
          formId: form.id,
          formName: form.formName || form.formNumber || 'Unnamed Form',
          formNumber: form.formNumber,
          category: form.category,
          chunkIndex: 0,
          totalChunks: 1,
          sectionType: 'general',
          importance: 'low',
          warning: true
        }];
      }

      // Use enhanced chunking with metadata
      return chunkInsuranceFormWithMetadata(text, form);
    } catch (error) {
      logger.error(LOG_CATEGORIES.AI, `Failed to process form ${form.id}`, { error });
      return [{
        text: `[Error: Could not process form ${form.formName || form.id}: ${error instanceof Error ? error.message : 'Unknown error'}]`,
        formId: form.id,
        formName: form.formName || form.formNumber || 'Unnamed Form',
        formNumber: form.formNumber,
        category: form.category,
        chunkIndex: 0,
        totalChunks: 1,
        sectionType: 'general',
        importance: 'low',
        error: true
      }];
    }
  };

  // Process forms in batches
  let completed = 0;
  const batches: typeof forms[] = [];
  for (let i = 0; i < forms.length; i += maxConcurrent) {
    batches.push(forms.slice(i, i + maxConcurrent));
  }

  for (const batch of batches) {
    const batchResults = await Promise.allSettled(batch.map(processForm));

    batchResults.forEach((result) => {
      completed++;
      if (result.status === 'fulfilled' && result.value) {
        allChunks.push(...result.value);
      }
      onProgress?.(completed, forms.length);
    });

    // Small delay between batches
    if (completed < forms.length) {
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }

  logger.info(LOG_CATEGORIES.AI, `Total chunks created: ${allChunks.length}`);
  return allChunks;
}

/**
 * Create a summary of all forms for context
 * @param {Array} forms - Array of form objects
 * @returns {string} - Summary text for AI context
 */
export function createFormsSummary(forms) {
  const summary = forms.map(form => {
    return `Form: ${form.formName || form.formNumber || 'Unnamed'}
Number: ${form.formNumber || 'N/A'}
Category: ${form.category || 'Unknown'}
Type: ${form.type || 'Unknown'}`;
  }).join('\n\n');
  
  return `Available Forms for Analysis:\n\n${summary}`;
}

/**
 * Estimate token count for text (rough approximation)
 * @param {string} text - Text to estimate
 * @returns {number} - Estimated token count
 */
export function estimateTokenCount(text) {
  // Rough approximation: 1 token â‰ˆ 0.75 words
  const words = text.split(/\s+/).length;
  return Math.ceil(words / 0.75);
}
```

---

## src/utils/performance.ts

**Path:** `src/utils/performance.ts`

```typescript
/**
 * Performance Utilities
 * Debounce and throttle functions for performance optimization
 */

/**
 * Debounce function - delays execution until after wait time has elapsed
 */
export const debounce = <T extends (...args: unknown[]) => unknown>(
  func: T,
  wait: number,
  immediate: boolean = false
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout | null = null;

  return function executedFunction(...args: Parameters<T>): void {
    const later = (): void => {
      timeout = null;
      if (!immediate) func(...args);
    };

    const callNow = immediate && !timeout;

    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) func(...args);
  };
};

/**
 * Throttle function - ensures function is called at most once per wait period
 */
export const throttle = <T extends (...args: unknown[]) => unknown>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle = false;

  return function executedFunction(...args: Parameters<T>): void {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => {
        inThrottle = false;
      }, wait);
    }
  };
};
```

---

## src/utils/performanceMonitor.ts

**Path:** `src/utils/performanceMonitor.ts`

```typescript
/**
 * Performance Monitor
 * Tracks operation timing, metrics, and performance bottlenecks
 */

import logger, { LOG_CATEGORIES } from './logger';

/**
 * Performance metric
 */
export interface PerformanceMetric {
  name: string;
  duration: number;
  startTime: number;
  endTime: number;
  category: string;
  metadata?: Record<string, any>;
}

/**
 * Performance statistics
 */
export interface PerformanceStats {
  name: string;
  count: number;
  totalDuration: number;
  avgDuration: number;
  minDuration: number;
  maxDuration: number;
  p95Duration: number;
  p99Duration: number;
}

/**
 * Performance monitor for tracking operation timing
 */
export class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric[]> = new Map();
  private activeTimers: Map<string, number> = new Map();
  private maxMetricsPerName: number = 1000;

  /**
   * Start timing an operation
   */
  start(name: string): string {
    const timerId = `${name}-${Date.now()}-${Math.random()}`;
    this.activeTimers.set(timerId, Date.now());
    return timerId;
  }

  /**
   * End timing an operation
   */
  end(
    timerId: string,
    name: string,
    category: string = 'GENERAL',
    metadata?: Record<string, any>
  ): PerformanceMetric | null {
    const startTime = this.activeTimers.get(timerId);
    if (!startTime) {
      logger.warn(LOG_CATEGORIES.PERFORMANCE, 'Timer not found', { timerId, name });
      return null;
    }

    this.activeTimers.delete(timerId);
    const endTime = Date.now();
    const duration = endTime - startTime;

    const metric: PerformanceMetric = {
      name,
      duration,
      startTime,
      endTime,
      category,
      ...(metadata !== undefined && { metadata })
    };

    // Store metric
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const metrics = this.metrics.get(name)!;
    metrics.push(metric);

    // Keep only recent metrics to avoid memory bloat
    if (metrics.length > this.maxMetricsPerName) {
      metrics.shift();
    }

    // Log slow operations
    if (duration > 1000) {
      logger.warn(LOG_CATEGORIES.PERFORMANCE, `Slow operation: ${name}`, {
        duration,
        category,
        metadata
      });
    }

    return metric;
  }

  /**
   * Measure operation with automatic timing
   */
  async measure<T>(
    name: string,
    fn: () => Promise<T>,
    category: string = 'GENERAL',
    metadata?: Record<string, any>
  ): Promise<T> {
    const timerId = this.start(name);
    try {
      const result = await fn();
      this.end(timerId, name, category, metadata);
      return result;
    } catch (error) {
      this.end(timerId, name, category, { ...metadata, error: true });
      throw error;
    }
  }

  /**
   * Measure synchronous operation
   */
  measureSync<T>(
    name: string,
    fn: () => T,
    category: string = 'GENERAL',
    metadata?: Record<string, any>
  ): T {
    const timerId = this.start(name);
    try {
      const result = fn();
      this.end(timerId, name, category, metadata);
      return result;
    } catch (error) {
      this.end(timerId, name, category, { ...metadata, error: true });
      throw error;
    }
  }

  /**
   * Get statistics for a metric name
   */
  getStats(name: string): PerformanceStats | null {
    const metrics = this.metrics.get(name);
    if (!metrics || metrics.length === 0) {
      return null;
    }

    const durations = metrics.map(m => m.duration).sort((a, b) => a - b);
    const totalDuration = durations.reduce((a, b) => a + b, 0);

    return {
      name,
      count: metrics.length,
      totalDuration,
      avgDuration: totalDuration / metrics.length,
      minDuration: durations[0] ?? 0,
      maxDuration: durations[durations.length - 1] ?? 0,
      p95Duration: durations[Math.floor(durations.length * 0.95)] ?? 0,
      p99Duration: durations[Math.floor(durations.length * 0.99)] ?? 0
    };
  }

  /**
   * Get all statistics
   */
  getAllStats(): PerformanceStats[] {
    const stats: PerformanceStats[] = [];
    this.metrics.forEach((_, name) => {
      const stat = this.getStats(name);
      if (stat) {
        stats.push(stat);
      }
    });
    return stats;
  }

  /**
   * Clear metrics
   */
  clear(): void {
    this.metrics.clear();
    this.activeTimers.clear();
  }

  /**
   * Get all metrics
   */
  getMetrics(name?: string): PerformanceMetric[] {
    if (name) {
      return this.metrics.get(name) || [];
    }

    const allMetrics: PerformanceMetric[] = [];
    this.metrics.forEach(metrics => {
      allMetrics.push(...metrics);
    });
    return allMetrics;
  }

  /**
   * Log performance report
   */
  logReport(): void {
    const stats = this.getAllStats();
    logger.info(LOG_CATEGORIES.PERFORMANCE, 'Performance Report', {
      metricsCount: stats.length,
      stats: stats.map(s => ({
        name: s.name,
        count: s.count,
        avgDuration: Math.round(s.avgDuration),
        maxDuration: s.maxDuration,
        p95Duration: Math.round(s.p95Duration)
      }))
    });
  }
}

/**
 * Global performance monitor instance
 */
export const performanceMonitor = new PerformanceMonitor();

/**
 * Decorator for measuring function performance
 */
export function Measure(category: string = 'GENERAL') {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const name = `${target.constructor.name}.${propertyKey}`;
      return performanceMonitor.measure(name, () => originalMethod.apply(this, args), category);
    };

    return descriptor;
  };
}

```

---

## src/utils/productClone.ts

**Path:** `src/utils/productClone.ts`

```typescript
/**
 * Product Clone Utility
 * Transactional deep-clone with rollback support
 */

import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  deleteDoc,
  writeBatch,
  query,
  where,
  Timestamp,
} from 'firebase/firestore';
import { db } from '@/firebase';
import type { Product, Coverage } from '../types';
import logger, { LOG_CATEGORIES } from './logger';

interface CloneResult {
  success: boolean;
  newProductId?: string;
  error?: string;
  createdIds?: {
    product: string;
    coverages: string[];
    forms: string[];
  };
}

/**
 * Clone a product with all related data (coverages, limits, deductibles, forms, rules, pricing)
 * Includes rollback on failure
 */
export async function cloneProduct(sourceProductId: string): Promise<CloneResult> {
  const createdIds = {
    product: '',
    coverages: [] as string[],
    forms: [] as string[],
  };

  try {
    logger.info(LOG_CATEGORIES.DATA, 'Starting product clone', { sourceProductId });

    // 1. Fetch source product
    const srcProdSnap = await getDoc(doc(db, 'products', sourceProductId));
    if (!srcProdSnap.exists()) {
      throw new Error('Source product not found');
    }
    const srcData = srcProdSnap.data() as Product;

    // 2. Create new product
    const newProdRef = await addDoc(collection(db, 'products'), {
      ...srcData,
      name: `${srcData.name} â€“ Copy`,
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });
    const newProductId = newProdRef.id;
    createdIds.product = newProductId;

    logger.info(LOG_CATEGORIES.DATA, 'Created new product', { newProductId });

    // 3. Clone coverages with ID mapping (batched)
    const coverageIdMap: Record<string, string> = {};
    const covSnap = await getDocs(collection(db, `products/${sourceProductId}/coverages`));

    if (covSnap.docs.length > 0) {
      const batch = writeBatch(db);
      covSnap.docs.forEach(covDoc => {
        const covData = covDoc.data() as Coverage;
        const newCovRef = doc(collection(db, `products/${newProductId}/coverages`));
        batch.set(newCovRef, {
          ...covData,
          createdAt: Timestamp.now(),
          updatedAt: Timestamp.now(),
        });
        coverageIdMap[covDoc.id] = newCovRef.id;
        createdIds.coverages.push(newCovRef.id);
      });
      await batch.commit();
    }

    logger.info(LOG_CATEGORIES.DATA, 'Cloned coverages', {
      count: Object.keys(coverageIdMap).length,
    });

    // 4. Clone limits and deductibles for each coverage (consolidated batching)
    let limitsDeductiblesBatch = writeBatch(db);
    let batchOperationCount = 0;
    const BATCH_SIZE = 450; // Leave room for other operations

    for (const [oldCovId, newCovId] of Object.entries(coverageIdMap)) {
      // Clone limits
      const limitsSnap = await getDocs(
        collection(db, `products/${sourceProductId}/coverages/${oldCovId}/limits`)
      );
      limitsSnap.docs.forEach(limitDoc => {
        if (batchOperationCount >= BATCH_SIZE) {
          // Commit current batch and start new one
          limitsDeductiblesBatch.commit();
          limitsDeductiblesBatch = writeBatch(db);
          batchOperationCount = 0;
        }
        const limitRef = doc(
          collection(db, `products/${newProductId}/coverages/${newCovId}/limits`)
        );
        limitsDeductiblesBatch.set(limitRef, {
          ...limitDoc.data(),
          createdAt: Timestamp.now(),
          updatedAt: Timestamp.now(),
        });
        batchOperationCount++;
      });

      // Clone deductibles
      const deductiblesSnap = await getDocs(
        collection(db, `products/${sourceProductId}/coverages/${oldCovId}/deductibles`)
      );
      deductiblesSnap.docs.forEach(deductibleDoc => {
        if (batchOperationCount >= BATCH_SIZE) {
          // Commit current batch and start new one
          limitsDeductiblesBatch.commit();
          limitsDeductiblesBatch = writeBatch(db);
          batchOperationCount = 0;
        }
        const deductibleRef = doc(
          collection(db, `products/${newProductId}/coverages/${newCovId}/deductibles`)
        );
        limitsDeductiblesBatch.set(deductibleRef, {
          ...deductibleDoc.data(),
          createdAt: Timestamp.now(),
          updatedAt: Timestamp.now(),
        });
        batchOperationCount++;
      });
    }

    // Commit final batch if there are pending operations
    if (batchOperationCount > 0) {
      await limitsDeductiblesBatch.commit();
    }

    logger.info(LOG_CATEGORIES.DATA, 'Cloned limits and deductibles');

    // 5. Clone forms and recreate junction table (batched)
    const formSnap = await getDocs(
      query(collection(db, 'forms'), where('productId', '==', sourceProductId))
    );

    let formsBatch = writeBatch(db);
    let formBatchCount = 0;
    const FORM_BATCH_SIZE = 450;

    for (const formDoc of formSnap.docs) {
      const formData = formDoc.data();
      const oldCoverageIds = formData.coverageIds || [];
      const newCoverageIds = oldCoverageIds
        .map((cid: string) => coverageIdMap[cid])
        .filter(Boolean);

      // Create new form
      const newFormRef = doc(collection(db, 'forms'));
      formsBatch.set(newFormRef, {
        ...formData,
        productId: newProductId,
        coverageIds: newCoverageIds,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now(),
      });
      createdIds.forms.push(newFormRef.id);
      formBatchCount++;

      // Add junction table entries
      for (const newCovId of newCoverageIds) {
        if (formBatchCount >= FORM_BATCH_SIZE) {
          await formsBatch.commit();
          formsBatch = writeBatch(db);
          formBatchCount = 0;
        }
        const junctionRef = doc(collection(db, 'formCoverages'));
        formsBatch.set(junctionRef, {
          formId: newFormRef.id,
          coverageId: newCovId,
          productId: newProductId,
          createdAt: Timestamp.now(),
        });
        formBatchCount++;
      }
    }

    // Commit final batch if there are pending operations
    if (formBatchCount > 0) {
      await formsBatch.commit();
    }

    logger.info(LOG_CATEGORIES.DATA, 'Cloned forms and junction table', {
      formCount: createdIds.forms.length,
    });

    // 6. Clone pricing steps (batched)
    const pricingSnap = await getDocs(
      collection(db, `products/${sourceProductId}/steps`)
    );
    if (pricingSnap.docs.length > 0) {
      let pricingBatch = writeBatch(db);
      let pricingBatchCount = 0;
      const PRICING_BATCH_SIZE = 450;

      pricingSnap.docs.forEach(pricingDoc => {
        if (pricingBatchCount >= PRICING_BATCH_SIZE) {
          pricingBatch.commit();
          pricingBatch = writeBatch(db);
          pricingBatchCount = 0;
        }
        const pricingRef = doc(collection(db, `products/${newProductId}/steps`));
        pricingBatch.set(pricingRef, {
          ...pricingDoc.data(),
          createdAt: Timestamp.now(),
          updatedAt: Timestamp.now(),
        });
        pricingBatchCount++;
      });

      if (pricingBatchCount > 0) {
        await pricingBatch.commit();
      }
    }

    logger.info(LOG_CATEGORIES.DATA, 'Product clone completed successfully', {
      newProductId,
      coverageCount: createdIds.coverages.length,
      formCount: createdIds.forms.length,
    });

    return {
      success: true,
      newProductId,
      createdIds,
    };
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Product clone failed, initiating rollback', {
      sourceProductId,
      createdIds,
    }, error as Error);

    // Rollback: Delete all created documents
    try {
      await rollbackClone(createdIds);
    } catch (rollbackError) {
      logger.error(LOG_CATEGORIES.ERROR, 'Rollback failed', {}, rollbackError as Error);
    }

    return {
      success: false,
      error: (error as Error).message || 'Unknown error during clone',
    };
  }
}

/**
 * Rollback a failed clone operation
 */
async function rollbackClone(createdIds: {
  product: string;
  coverages: string[];
  forms: string[];
}): Promise<void> {
  logger.info(LOG_CATEGORIES.DATA, 'Rolling back clone operation', { createdIds });

  // Delete forms first (they reference coverages)
  for (const formId of createdIds.forms) {
    try {
      await deleteDoc(doc(db, 'forms', formId));
    } catch (err) {
      logger.warn(LOG_CATEGORIES.ERROR, 'Failed to delete form during rollback', {
        formId,
      });
    }
  }

  // Delete coverages (they reference product)
  if (createdIds.product) {
    for (const covId of createdIds.coverages) {
      try {
        await deleteDoc(doc(db, `products/${createdIds.product}/coverages`, covId));
      } catch (err) {
        logger.warn(LOG_CATEGORIES.ERROR, 'Failed to delete coverage during rollback', {
          covId,
        });
      }
    }

    // Delete product
    try {
      await deleteDoc(doc(db, 'products', createdIds.product));
    } catch (err) {
      logger.warn(LOG_CATEGORIES.ERROR, 'Failed to delete product during rollback', {
        productId: createdIds.product,
      });
    }
  }

  logger.info(LOG_CATEGORIES.DATA, 'Rollback completed');
}

```

---

## src/utils/stateGuards.ts

**Path:** `src/utils/stateGuards.ts`

```typescript
/**
 * State Guards & Save Protection
 * Handles dirty state tracking, unsaved changes detection, and save confirmations
 */

/**
 * Dirty state tracker for form changes
 */
export interface DirtyState {
  isDirty: boolean;
  originalValue: any;
  currentValue: any;
  changedFields: string[];
}

/**
 * Create initial dirty state
 */
export function createDirtyState(initialValue: any): DirtyState {
  return {
    isDirty: false,
    originalValue: JSON.parse(JSON.stringify(initialValue)),
    currentValue: JSON.parse(JSON.stringify(initialValue)),
    changedFields: []
  };
}

/**
 * Update dirty state when value changes
 */
export function updateDirtyState(
  state: DirtyState,
  newValue: any,
  fieldName?: string
): DirtyState {
  const isDirty = JSON.stringify(state.originalValue) !== JSON.stringify(newValue);
  const changedFields = fieldName && isDirty && !state.changedFields.includes(fieldName)
    ? [...state.changedFields, fieldName]
    : state.changedFields;

  return {
    isDirty,
    originalValue: state.originalValue,
    currentValue: newValue,
    changedFields
  };
}

/**
 * Reset dirty state
 */
export function resetDirtyState(state: DirtyState): DirtyState {
  return {
    isDirty: false,
    originalValue: JSON.parse(JSON.stringify(state.currentValue)),
    currentValue: JSON.parse(JSON.stringify(state.currentValue)),
    changedFields: []
  };
}

/**
 * Get change summary
 */
export interface ChangeSummary {
  added: string[];
  removed: string[];
  unchanged: string[];
  total: number;
}

export function getChangeSummary(
  originalStates: string[],
  currentStates: string[]
): ChangeSummary {
  const added = currentStates.filter(s => !originalStates.includes(s));
  const removed = originalStates.filter(s => !currentStates.includes(s));
  const unchanged = currentStates.filter(s => originalStates.includes(s));

  return {
    added,
    removed,
    unchanged,
    total: currentStates.length
  };
}

/**
 * Format change summary for display
 */
export function formatChangeSummary(summary: ChangeSummary): string {
  const lines: string[] = [];

  if (summary.added.length > 0) {
    lines.push(`Added: ${summary.added.join(', ')}`);
  }

  if (summary.removed.length > 0) {
    lines.push(`Removed: ${summary.removed.join(', ')}`);
  }

  if (summary.unchanged.length > 0) {
    lines.push(`Unchanged: ${summary.unchanged.length} state(s)`);
  }

  return lines.join('\n');
}

/**
 * Build save confirmation message
 */
export function buildSaveConfirmation(
  originalStates: string[],
  currentStates: string[],
  entityName: string = 'Coverage'
): string {
  const summary = getChangeSummary(originalStates, currentStates);

  let message = `Save changes to ${entityName}?\n\n`;

  if (summary.added.length > 0) {
    message += `âœ“ Add ${summary.added.length} state(s): ${summary.added.join(', ')}\n`;
  }

  if (summary.removed.length > 0) {
    message += `âœ— Remove ${summary.removed.length} state(s): ${summary.removed.join(', ')}\n`;
  }

  if (summary.added.length === 0 && summary.removed.length === 0) {
    message += 'No changes detected.';
  }

  return message;
}

/**
 * Validate state subset relationship
 */
export interface SubsetValidationResult {
  isValid: boolean;
  isSubset: boolean;
  invalidStates: string[];
  message: string;
}

export function validateStateSubset(
  childStates: string[],
  parentStates: string[],
  childName: string = 'Child',
  parentName: string = 'Parent'
): SubsetValidationResult {
  const invalidStates = childStates.filter(s => !parentStates.includes(s));

  if (invalidStates.length > 0) {
    return {
      isValid: false,
      isSubset: false,
      invalidStates,
      message: `${childName} includes states not available in ${parentName}: ${invalidStates.join(', ')}`
    };
  }

  return {
    isValid: true,
    isSubset: true,
    invalidStates: [],
    message: `${childName} is a valid subset of ${parentName}`
  };
}

/**
 * Validate state coverage (at least one state selected)
 */
export interface CoverageValidationResult {
  isValid: boolean;
  hasCoverage: boolean;
  message: string;
}

export function validateStateCoverage(
  selectedStates: string[],
  minRequired: number = 1
): CoverageValidationResult {
  if (selectedStates.length < minRequired) {
    return {
      isValid: false,
      hasCoverage: false,
      message: `At least ${minRequired} state(s) must be selected`
    };
  }

  return {
    isValid: true,
    hasCoverage: true,
    message: `${selectedStates.length} state(s) selected`
  };
}

/**
 * Validate state consistency across related entities
 */
export interface ConsistencyValidationResult {
  isValid: boolean;
  inconsistencies: Array<{
    entity: string;
    issue: string;
  }>;
  message: string;
}

export function validateStateConsistency(
  productStates: string[],
  coverageStates: string[],
  formStates: string[]
): ConsistencyValidationResult {
  const inconsistencies: ConsistencyValidationResult['inconsistencies'] = [];

  // Check coverage is subset of product
  const invalidCoverageStates = coverageStates.filter(s => !productStates.includes(s));
  if (invalidCoverageStates.length > 0) {
    inconsistencies.push({
      entity: 'Coverage',
      issue: `Includes states not in product: ${invalidCoverageStates.join(', ')}`
    });
  }

  // Check form is subset of product
  const invalidFormStates = formStates.filter(s => !productStates.includes(s));
  if (invalidFormStates.length > 0) {
    inconsistencies.push({
      entity: 'Form',
      issue: `Includes states not in product: ${invalidFormStates.join(', ')}`
    });
  }

  // Check form-coverage overlap
  const formCoverageOverlap = formStates.filter(s => coverageStates.includes(s));
  if (formStates.length > 0 && coverageStates.length > 0 && formCoverageOverlap.length === 0) {
    inconsistencies.push({
      entity: 'Form-Coverage',
      issue: 'No overlapping states between form and coverage'
    });
  }

  return {
    isValid: inconsistencies.length === 0,
    inconsistencies,
    message: inconsistencies.length === 0
      ? 'All state relationships are consistent'
      : `Found ${inconsistencies.length} inconsistency(ies)`
  };
}

/**
 * Build unsaved changes warning
 */
export function buildUnsavedChangesWarning(
  isDirty: boolean,
  entityName: string = 'this page'
): string {
  if (!isDirty) return '';
  return `You have unsaved changes on ${entityName}. Are you sure you want to leave?`;
}

```

---

## src/utils/storage.ts

**Path:** `src/utils/storage.ts`

```typescript
/**
 * Storage Utilities
 * Centralized Firebase Storage operations for forms and documents
 */

import { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';
import { storage } from '@/firebase';
import logger, { LOG_CATEGORIES } from './logger';

/**
 * Sanitize filename for safe storage
 */
function sanitizeFilename(filename: string): string {
  return filename
    .toLowerCase()
    .replace(/[^a-z0-9._-]/g, '_')
    .replace(/_{2,}/g, '_')
    .substring(0, 100);
}

/**
 * Upload a form PDF to Firebase Storage
 * 
 * @param file - File to upload
 * @param productId - Product ID for organization
 * @returns Object with filePath and downloadUrl
 */
export async function uploadFormPdf(
  file: File,
  productId?: string
): Promise<{ filePath: string; downloadUrl: string }> {
  try {
    if (!file.type.includes('pdf')) {
      throw new Error('Only PDF files are supported');
    }

    if (file.size > 50 * 1024 * 1024) {
      throw new Error('File size must not exceed 50MB');
    }

    // Create timestamped filename
    const timestamp = Date.now();
    const sanitized = sanitizeFilename(file.name);
    const filename = `${timestamp}_${sanitized}`;

    // Organize by product if provided
    const pathPrefix = productId ? `forms/${productId}` : 'forms';
    const filePath = `${pathPrefix}/${filename}`;

    logger.info(LOG_CATEGORIES.DATA, 'Uploading form PDF', {
      filename,
      size: file.size,
      productId,
    });

    // Upload to Firebase Storage
    const storageRef = ref(storage, filePath);
    await uploadBytes(storageRef, file, {
      contentType: 'application/pdf',
      customMetadata: {
        uploadedAt: new Date().toISOString(),
        productId: productId || 'unknown',
      },
    });

    // Get download URL
    const downloadUrl = await getDownloadURL(storageRef);

    logger.info(LOG_CATEGORIES.DATA, 'Form PDF uploaded successfully', {
      filePath,
      size: file.size,
    });

    return { filePath, downloadUrl };
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to upload form PDF', {
      filename: file.name,
      size: file.size,
    }, error as Error);
    throw error;
  }
}

/**
 * Delete a form PDF from Firebase Storage
 * 
 * @param filePath - Path to the file in storage
 */
export async function deleteFormPdf(filePath: string): Promise<void> {
  try {
    logger.info(LOG_CATEGORIES.DATA, 'Deleting form PDF', { filePath });

    const storageRef = ref(storage, filePath);
    await deleteObject(storageRef);

    logger.info(LOG_CATEGORIES.DATA, 'Form PDF deleted successfully', { filePath });
  } catch (error) {
    logger.error(LOG_CATEGORIES.ERROR, 'Failed to delete form PDF', {
      filePath,
    }, error as Error);
    throw error;
  }
}



```

---

## src/utils/ui/index.ts

**Path:** `src/utils/ui/index.ts`

```typescript
/**
 * UI Utilities Index
 * Centralized exports for all UI-related utilities
 */

// Performance utilities (debounce, throttle)
export * from '../performance';

// Markdown utilities
export * from '../markdownParser';
export * from '../markdownSanitizer';

// Bundle optimization
export * from '../bundleOptimization';

// State guards
export * from '../stateGuards';

```

---

## src/vite-env.d.ts

**Path:** `src/vite-env.d.ts`

```typescript
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_FIREBASE_API_KEY: string;
  readonly VITE_FIREBASE_AUTH_DOMAIN: string;
  readonly VITE_FIREBASE_PROJECT_ID: string;
  readonly VITE_FIREBASE_STORAGE_BUCKET: string;
  readonly VITE_FIREBASE_MESSAGING_SENDER_ID: string;
  readonly VITE_FIREBASE_APP_ID: string;
  readonly VITE_FIREBASE_MEASUREMENT_ID?: string;
  readonly VITE_USE_FIREBASE_EMULATORS?: string;
  readonly VITE_OPENAI_API_KEY?: string;
  readonly VITE_ANTHROPIC_API_KEY?: string;
  readonly VITE_ENABLE_AI_FEATURES?: string;
  readonly VITE_LOG_LEVEL?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}

```

---

