/**
 * AI Plan Types
 *
 * Structured schema for AI Builder proposals. The AI generates a plan
 * describing which artifacts to create/modify, with rationales and
 * confidence scores. The user reviews diffs, then applies the plan
 * which creates draft versions inside an active Change Set.
 *
 * GUARDRAIL: AI never writes directly to published artifacts.
 *
 * Data model:
 *   orgs/{orgId}/aiSuggestions/{suggestionId}
 */

import { Timestamp } from 'firebase/firestore';
import type { VersionedEntityType } from './versioning';
import type { ChangeSetItemAction } from './changeSet';

// ============================================================================
// Proposed Artifact — a single item in the plan
// ============================================================================

/**
 * The entity types an AI plan can propose.
 * Maps to VersionedEntityType + formUse (junction, not versioned).
 */
export type PlanArtifactType =
  | 'product'
  | 'coverage'
  | 'rule'
  | 'rateProgram'
  | 'table'
  | 'formUse';

export const PLAN_ARTIFACT_TYPE_LABELS: Record<PlanArtifactType, string> = {
  product: 'Product Version',
  coverage: 'Coverage Version',
  rule: 'Rule Version',
  rateProgram: 'Rate Program Version',
  table: 'Rating Table Version',
  formUse: 'Form Usage',
};

/** Confidence level for a proposal */
export type ConfidenceLevel = 'high' | 'medium' | 'low';

export const CONFIDENCE_CONFIG: Record<ConfidenceLevel, { label: string; color: string }> = {
  high: { label: 'High Confidence', color: '#059669' },
  medium: { label: 'Medium Confidence', color: '#f59e0b' },
  low: { label: 'Low Confidence', color: '#ef4444' },
};

/**
 * A single proposed artifact within a plan.
 */
export interface ProposedArtifact {
  /** Client-side key for tracking (not persisted as a doc ID) */
  key: string;
  /** What kind of artifact */
  artifactType: PlanArtifactType;
  /** Action: create a new entity or modify an existing one */
  action: 'create' | 'modify';
  /** Human-readable name for the artifact */
  name: string;
  /** If modifying, the existing entity ID */
  existingEntityId?: string;
  /** If modifying, the existing parent entity ID (e.g. productId for coverage) */
  parentEntityId?: string;
  /** The proposed data payload (shape varies by artifactType) */
  proposedData: Record<string, unknown>;
  /** AI-generated rationale for this proposal */
  rationale: string;
  /** Confidence in this proposal */
  confidence: ConfidenceLevel;
  /** Data sources the AI used for this proposal */
  dataSources: string[];
}

// ============================================================================
// Proposed Product Data shapes
// ============================================================================

export interface ProposedProductData {
  name: string;
  description?: string;
  category?: string;
  states?: string[];
  effectiveStart?: string;
  effectiveEnd?: string;
}

export interface ProposedCoverageData {
  name: string;
  description?: string;
  coverageCode?: string;
  category?: string;
  isOptional?: boolean;
  limits?: Array<{ label: string; amount: number }>;
  deductibles?: Array<{ label: string; amount: number }>;
}

export interface ProposedRuleData {
  name: string;
  type: 'eligibility' | 'referral' | 'validation';
  description?: string;
  conditions?: Record<string, unknown>;
  outcome?: Record<string, unknown>;
}

export interface ProposedRateProgramData {
  name: string;
  description?: string;
  lineOfBusiness?: string;
  steps?: Array<{ name: string; type: string; description?: string }>;
}

export interface ProposedTableData {
  name: string;
  description?: string;
  dimensions?: Array<{ name: string; values: string[] }>;
}

export interface ProposedFormUseData {
  formId: string;
  formVersionId: string;
  formNumber?: string;
  formTitle?: string;
  useType: 'base' | 'endorsement' | 'notice' | 'condition';
  stateCode?: string;
}

// ============================================================================
// AI Plan — the full structured proposal
// ============================================================================

/**
 * A structured plan generated by the AI Builder.
 */
export interface AIPlan {
  /** Human-readable title for the plan */
  title: string;
  /** Brief description of what the plan achieves */
  description: string;
  /** Ordered list of proposed artifacts */
  artifacts: ProposedArtifact[];
  /** Overall rationale */
  overallRationale: string;
  /** Data / context the AI used */
  dataUsed: string[];
  /** Potential risks or caveats */
  caveats: string[];
}

// ============================================================================
// Impact Summary — preview what will happen
// ============================================================================

export interface PlanImpactSummary {
  /** Counts by action */
  creations: number;
  modifications: number;
  /** Counts by artifact type */
  byType: Record<PlanArtifactType, number>;
  /** Affected existing entity IDs */
  affectedEntityIds: string[];
  /** Required approval roles (derived from APPROVAL_RULES) */
  requiredApprovalRoles: string[];
  /** Warnings (e.g. low-confidence items) */
  warnings: string[];
}

// ============================================================================
// Diff Entry — show before/after for modifications
// ============================================================================

export interface PlanDiffEntry {
  /** Reference to the ProposedArtifact key */
  artifactKey: string;
  artifactName: string;
  artifactType: PlanArtifactType;
  action: 'create' | 'modify';
  /** For 'create': all fields shown as additions */
  /** For 'modify': field-level diffs */
  fields: PlanFieldDiff[];
}

export interface PlanFieldDiff {
  fieldPath: string;
  label: string;
  oldValue?: unknown;
  newValue: unknown;
  type: 'added' | 'changed' | 'removed';
}

// ============================================================================
// Apply Result — what was created during apply
// ============================================================================

export interface PlanApplyResult {
  /** Whether the apply completed successfully */
  success: boolean;
  /** Items created in the Change Set */
  appliedItems: AppliedItem[];
  /** The Change Set the items were added to */
  changeSetId: string;
  /** Any errors during apply */
  errors: string[];
  /** The stored suggestion ID */
  suggestionId: string;
}

export interface AppliedItem {
  artifactKey: string;
  artifactType: PlanArtifactType;
  action: 'create' | 'modify';
  /** The Firestore document ID of the created/modified entity */
  entityId: string;
  /** The Firestore document ID of the created draft version */
  versionId: string;
  /** Name for display */
  name: string;
}

// ============================================================================
// Stored Suggestion Record
// ============================================================================

/** Accept/reject status for a stored AI suggestion */
export type SuggestionOutcome = 'pending' | 'accepted' | 'rejected' | 'partially_accepted';

/**
 * Persisted at orgs/{orgId}/aiSuggestions/{suggestionId}.
 * Records the AI proposal and the user's decision.
 */
export interface AISuggestion {
  id: string;
  orgId: string;
  /** The original user prompt */
  userPrompt: string;
  /** The full AI plan */
  plan: AIPlan;
  /** User's decision */
  outcome: SuggestionOutcome;
  /** If accepted, which artifacts were applied */
  appliedArtifactKeys?: string[];
  /** If accepted, the Change Set ID */
  changeSetId?: string;
  /** Reason if rejected */
  rejectionReason?: string;
  /** AI model used */
  modelId: string;
  /** Request traceability */
  requestId: string;
  /** Latency in ms */
  latencyMs: number;
  /** Token usage */
  tokenUsage?: { prompt: number; completion: number; total: number };
  /** Audit */
  createdAt: Timestamp;
  createdBy: string;
  resolvedAt?: Timestamp;
  resolvedBy?: string;
}

// ============================================================================
// Validators
// ============================================================================

/**
 * Validate a ProposedArtifact for required fields.
 */
export function validateProposedArtifact(artifact: ProposedArtifact): string[] {
  const errors: string[] = [];

  if (!artifact.key) errors.push('Artifact key is required');
  if (!artifact.name || artifact.name.trim().length === 0) errors.push('Artifact name is required');
  if (!artifact.artifactType) errors.push('Artifact type is required');
  if (!['create', 'modify'].includes(artifact.action)) errors.push('Action must be "create" or "modify"');
  if (artifact.action === 'modify' && !artifact.existingEntityId) {
    errors.push(`Modify action requires existingEntityId for "${artifact.name}"`);
  }
  if (!artifact.rationale || artifact.rationale.trim().length === 0) {
    errors.push(`Rationale is required for "${artifact.name}"`);
  }
  if (!['high', 'medium', 'low'].includes(artifact.confidence)) {
    errors.push(`Invalid confidence level for "${artifact.name}"`);
  }

  // Type-specific validation
  const d = artifact.proposedData;
  switch (artifact.artifactType) {
    case 'product':
      if (!d.name) errors.push(`Product name is required in "${artifact.name}"`);
      break;
    case 'coverage':
      if (!d.name) errors.push(`Coverage name is required in "${artifact.name}"`);
      break;
    case 'rule':
      if (!d.name) errors.push(`Rule name is required in "${artifact.name}"`);
      if (!d.type) errors.push(`Rule type is required in "${artifact.name}"`);
      break;
    case 'rateProgram':
      if (!d.name) errors.push(`Rate program name is required in "${artifact.name}"`);
      break;
    case 'table':
      if (!d.name) errors.push(`Table name is required in "${artifact.name}"`);
      break;
    case 'formUse':
      if (!d.formId) errors.push(`Form ID is required for formUse in "${artifact.name}"`);
      if (!d.useType) errors.push(`Use type is required for formUse in "${artifact.name}"`);
      break;
  }

  return errors;
}

/**
 * Validate a full AIPlan.
 */
export function validateAIPlan(plan: AIPlan): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!plan.title || plan.title.trim().length === 0) errors.push('Plan title is required');
  if (!plan.description) errors.push('Plan description is required');
  if (!plan.artifacts || plan.artifacts.length === 0) errors.push('Plan must contain at least one artifact');
  if (!plan.overallRationale) errors.push('Overall rationale is required');

  // Check for duplicate keys
  const keys = new Set<string>();
  for (const a of plan.artifacts) {
    if (keys.has(a.key)) errors.push(`Duplicate artifact key: "${a.key}"`);
    keys.add(a.key);
    errors.push(...validateProposedArtifact(a));
  }

  return { valid: errors.length === 0, errors };
}

/**
 * Compute an impact summary from a plan.
 */
export function computeImpactSummary(plan: AIPlan): PlanImpactSummary {
  const byType: Record<PlanArtifactType, number> = {
    product: 0,
    coverage: 0,
    rule: 0,
    rateProgram: 0,
    table: 0,
    formUse: 0,
  };

  let creations = 0;
  let modifications = 0;
  const affectedEntityIds: string[] = [];
  const warnings: string[] = [];
  const approvalRoleSet = new Set<string>();

  // Approval rules by artifact type
  const APPROVAL_MAP: Record<string, string[]> = {
    product: ['product_manager'],
    coverage: ['product_manager'],
    rule: ['underwriter', 'compliance'],
    rateProgram: ['actuary'],
    table: ['actuary'],
    formUse: ['compliance'],
  };

  for (const a of plan.artifacts) {
    byType[a.artifactType] = (byType[a.artifactType] || 0) + 1;

    if (a.action === 'create') creations++;
    else modifications++;

    if (a.existingEntityId) affectedEntityIds.push(a.existingEntityId);

    if (a.confidence === 'low') {
      warnings.push(`"${a.name}" has low confidence — review carefully.`);
    }

    const roles = APPROVAL_MAP[a.artifactType] || [];
    roles.forEach(r => approvalRoleSet.add(r));
  }

  return {
    creations,
    modifications,
    byType,
    affectedEntityIds,
    requiredApprovalRoles: Array.from(approvalRoleSet),
    warnings,
  };
}

/**
 * Generate diff entries for a plan (for the preview UI).
 * For 'create' actions, all proposed fields are shown as additions.
 * For 'modify' actions, compares proposed data against current state.
 */
export function generatePlanDiffs(
  plan: AIPlan,
  currentStates?: Map<string, Record<string, unknown>>,
): PlanDiffEntry[] {
  return plan.artifacts.map(a => {
    const fields: PlanFieldDiff[] = [];

    if (a.action === 'create') {
      // Show all proposed fields as additions
      for (const [key, value] of Object.entries(a.proposedData)) {
        if (value !== undefined && value !== null && value !== '') {
          fields.push({
            fieldPath: key,
            label: humanizeFieldName(key),
            newValue: value,
            type: 'added',
          });
        }
      }
    } else {
      // Compare against current state
      const current = currentStates?.get(a.existingEntityId || '');
      for (const [key, newVal] of Object.entries(a.proposedData)) {
        const oldVal = current?.[key];
        if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
          fields.push({
            fieldPath: key,
            label: humanizeFieldName(key),
            oldValue: oldVal,
            newValue: newVal,
            type: oldVal === undefined ? 'added' : 'changed',
          });
        }
      }
    }

    return {
      artifactKey: a.key,
      artifactName: a.name,
      artifactType: a.artifactType,
      action: a.action,
      fields,
    };
  });
}

/** Convert camelCase/snake_case to human-readable label */
function humanizeFieldName(name: string): string {
  return name
    .replace(/([A-Z])/g, ' $1')
    .replace(/_/g, ' ')
    .replace(/^\s/, '')
    .replace(/\b\w/g, l => l.toUpperCase());
}
